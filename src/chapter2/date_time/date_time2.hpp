#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wmacro-redefined"
#pragma clang diagnostic pop
typedef __char16_t char16_t;
typedef __char32_t char32_t;
namespace std
{
    inline namespace __1
    {
    }
}
extern "C" void abort();
namespace std
{
    inline namespace __1
    {
        inline void __libcpp_verbose_abort(const char *, ...)
        {
            ::abort();
            __builtin_unreachable();
        }
    }
}

typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;
typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
typedef int __darwin_ct_rune_t;
typedef union
{
    char __mbstate8[128];
    long long _mbstateL;
} __mbstate_t;
typedef __mbstate_t __darwin_mbstate_t;
typedef long int __darwin_ptrdiff_t;
typedef long unsigned int __darwin_size_t;
typedef __builtin_va_list __darwin_va_list;
typedef int __darwin_wchar_t;
typedef __darwin_wchar_t __darwin_rune_t;
typedef int __darwin_wint_t;
typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;
typedef __darwin_ino64_t __darwin_ino_t;
typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];
struct __darwin_pthread_handler_rec
{
    void (*__routine)(void *);
    void *__arg;
    struct __darwin_pthread_handler_rec *__next;
};
struct _opaque_pthread_attr_t
{
    long __sig;
    char __opaque[56];
};
struct _opaque_pthread_cond_t
{
    long __sig;
    char __opaque[40];
};
struct _opaque_pthread_condattr_t
{
    long __sig;
    char __opaque[8];
};
struct _opaque_pthread_mutex_t
{
    long __sig;
    char __opaque[56];
};
struct _opaque_pthread_mutexattr_t
{
    long __sig;
    char __opaque[8];
};
struct _opaque_pthread_once_t
{
    long __sig;
    char __opaque[8];
};
struct _opaque_pthread_rwlock_t
{
    long __sig;
    char __opaque[192];
};
struct _opaque_pthread_rwlockattr_t
{
    long __sig;
    char __opaque[16];
};
struct _opaque_pthread_t
{
    long __sig;
    struct __darwin_pthread_handler_rec *__cleanup_stack;
    char __opaque[8176];
};
typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t *__darwin_pthread_t;
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;
typedef __uint32_t __darwin_wctype_t;

typedef enum
{
    P_ALL,
    P_PID,
    P_PGID
} idtype_t;
typedef __darwin_pid_t pid_t;
typedef __darwin_id_t id_t;
typedef int sig_atomic_t;
typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long long int64_t;

typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned int u_int32_t;
typedef unsigned long long u_int64_t;
typedef int64_t register_t;

typedef __darwin_intptr_t intptr_t;
typedef unsigned long uintptr_t;
typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;
typedef u_int64_t syscall_arg_t;
struct __darwin_arm_exception_state
{
    __uint32_t __exception;
    __uint32_t __fsr;
    __uint32_t __far;
};
struct __darwin_arm_exception_state64
{
    __uint64_t __far;
    __uint32_t __esr;
    __uint32_t __exception;
};
struct __darwin_arm_thread_state
{
    __uint32_t __r[13];
    __uint32_t __sp;
    __uint32_t __lr;
    __uint32_t __pc;
    __uint32_t __cpsr;
};
struct __darwin_arm_thread_state64
{
    __uint64_t __x[29];
    __uint64_t __fp;
    __uint64_t __lr;
    __uint64_t __sp;
    __uint64_t __pc;
    __uint32_t __cpsr;
    __uint32_t __pad;
};
struct __darwin_arm_vfp_state
{
    __uint32_t __r[64];
    __uint32_t __fpscr;
};
struct __darwin_arm_neon_state64
{
    __uint128_t __v[32];
    __uint32_t __fpsr;
    __uint32_t __fpcr;
};
struct __darwin_arm_neon_state
{
    __uint128_t __v[16];
    __uint32_t __fpsr;
    __uint32_t __fpcr;
};
struct __arm_pagein_state
{
    int __pagein_error;
};
struct __arm_legacy_debug_state
{
    __uint32_t __bvr[16];
    __uint32_t __bcr[16];
    __uint32_t __wvr[16];
    __uint32_t __wcr[16];
};
struct __darwin_arm_debug_state32
{
    __uint32_t __bvr[16];
    __uint32_t __bcr[16];
    __uint32_t __wvr[16];
    __uint32_t __wcr[16];
    __uint64_t __mdscr_el1;
};
struct __darwin_arm_debug_state64
{
    __uint64_t __bvr[16];
    __uint64_t __bcr[16];
    __uint64_t __wvr[16];
    __uint64_t __wcr[16];
    __uint64_t __mdscr_el1;
};
struct __darwin_arm_cpmu_state64
{
    __uint64_t __ctrs[16];
};
struct __darwin_mcontext32
{
    struct __darwin_arm_exception_state __es;
    struct __darwin_arm_thread_state __ss;
    struct __darwin_arm_vfp_state __fs;
};
struct __darwin_mcontext64
{
    struct __darwin_arm_exception_state64 __es;
    struct __darwin_arm_thread_state64 __ss;
    struct __darwin_arm_neon_state64 __ns;
};
typedef struct __darwin_mcontext64 *mcontext_t;

typedef __darwin_pthread_attr_t pthread_attr_t;

struct __darwin_sigaltstack
{
    void *ss_sp;
    __darwin_size_t ss_size;
    int ss_flags;
};
typedef struct __darwin_sigaltstack stack_t;
struct __darwin_ucontext
{
    int uc_onstack;
    __darwin_sigset_t uc_sigmask;
    struct __darwin_sigaltstack uc_stack;
    struct __darwin_ucontext *uc_link;
    __darwin_size_t uc_mcsize;
    struct __darwin_mcontext64 *uc_mcontext;
};
typedef struct __darwin_ucontext ucontext_t;
typedef __darwin_sigset_t sigset_t;
typedef __darwin_size_t size_t;
typedef __darwin_uid_t uid_t;

union sigval
{
    int sival_int;
    void *sival_ptr;
};
struct sigevent
{
    int sigev_notify;
    int sigev_signo;
    union sigval sigev_value;
    void (*sigev_notify_function)(union sigval);
    pthread_attr_t *sigev_notify_attributes;
};
typedef struct __siginfo
{
    int si_signo;
    int si_errno;
    int si_code;
    pid_t si_pid;
    uid_t si_uid;
    int si_status;
    void *si_addr;
    union sigval si_value;
    long si_band;
    unsigned long __pad[7];
} siginfo_t;
union __sigaction_u
{
    void (*__sa_handler)(int);
    void (*__sa_sigaction)(int, struct __siginfo *,
                           void *);
};
struct __sigaction
{
    union __sigaction_u __sigaction_u;
    void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
    sigset_t sa_mask;
    int sa_flags;
};
struct sigaction
{
    union __sigaction_u __sigaction_u;
    sigset_t sa_mask;
    int sa_flags;
};
typedef void (*sig_t)(int);
struct sigvec
{
    void (*sv_handler)(int);
    int sv_mask;
    int sv_flags;
};
struct sigstack
{
    char *ss_sp;
    int ss_onstack;
};
extern "C"
{
    void (*signal(int, void (*)(int)))(int);
}
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;
typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;
typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;
typedef long int intmax_t;
typedef long unsigned int uintmax_t;
struct timeval
{
    __darwin_time_t tv_sec;
    __darwin_suseconds_t tv_usec;
};
typedef __uint64_t rlim_t;
struct rusage
{
    struct timeval ru_utime;
    struct timeval ru_stime;
    long ru_maxrss;
    long ru_ixrss;
    long ru_idrss;
    long ru_isrss;
    long ru_minflt;
    long ru_majflt;
    long ru_nswap;
    long ru_inblock;
    long ru_oublock;
    long ru_msgsnd;
    long ru_msgrcv;
    long ru_nsignals;
    long ru_nvcsw;
    long ru_nivcsw;
};
typedef void *rusage_info_t;
struct rusage_info_v0
{
    uint8_t ri_uuid[16];
    uint64_t ri_user_time;
    uint64_t ri_system_time;
    uint64_t ri_pkg_idle_wkups;
    uint64_t ri_interrupt_wkups;
    uint64_t ri_pageins;
    uint64_t ri_wired_size;
    uint64_t ri_resident_size;
    uint64_t ri_phys_footprint;
    uint64_t ri_proc_start_abstime;
    uint64_t ri_proc_exit_abstime;
};
struct rusage_info_v1
{
    uint8_t ri_uuid[16];
    uint64_t ri_user_time;
    uint64_t ri_system_time;
    uint64_t ri_pkg_idle_wkups;
    uint64_t ri_interrupt_wkups;
    uint64_t ri_pageins;
    uint64_t ri_wired_size;
    uint64_t ri_resident_size;
    uint64_t ri_phys_footprint;
    uint64_t ri_proc_start_abstime;
    uint64_t ri_proc_exit_abstime;
    uint64_t ri_child_user_time;
    uint64_t ri_child_system_time;
    uint64_t ri_child_pkg_idle_wkups;
    uint64_t ri_child_interrupt_wkups;
    uint64_t ri_child_pageins;
    uint64_t ri_child_elapsed_abstime;
};
struct rusage_info_v2
{
    uint8_t ri_uuid[16];
    uint64_t ri_user_time;
    uint64_t ri_system_time;
    uint64_t ri_pkg_idle_wkups;
    uint64_t ri_interrupt_wkups;
    uint64_t ri_pageins;
    uint64_t ri_wired_size;
    uint64_t ri_resident_size;
    uint64_t ri_phys_footprint;
    uint64_t ri_proc_start_abstime;
    uint64_t ri_proc_exit_abstime;
    uint64_t ri_child_user_time;
    uint64_t ri_child_system_time;
    uint64_t ri_child_pkg_idle_wkups;
    uint64_t ri_child_interrupt_wkups;
    uint64_t ri_child_pageins;
    uint64_t ri_child_elapsed_abstime;
    uint64_t ri_diskio_bytesread;
    uint64_t ri_diskio_byteswritten;
};
struct rusage_info_v3
{
    uint8_t ri_uuid[16];
    uint64_t ri_user_time;
    uint64_t ri_system_time;
    uint64_t ri_pkg_idle_wkups;
    uint64_t ri_interrupt_wkups;
    uint64_t ri_pageins;
    uint64_t ri_wired_size;
    uint64_t ri_resident_size;
    uint64_t ri_phys_footprint;
    uint64_t ri_proc_start_abstime;
    uint64_t ri_proc_exit_abstime;
    uint64_t ri_child_user_time;
    uint64_t ri_child_system_time;
    uint64_t ri_child_pkg_idle_wkups;
    uint64_t ri_child_interrupt_wkups;
    uint64_t ri_child_pageins;
    uint64_t ri_child_elapsed_abstime;
    uint64_t ri_diskio_bytesread;
    uint64_t ri_diskio_byteswritten;
    uint64_t ri_cpu_time_qos_default;
    uint64_t ri_cpu_time_qos_maintenance;
    uint64_t ri_cpu_time_qos_background;
    uint64_t ri_cpu_time_qos_utility;
    uint64_t ri_cpu_time_qos_legacy;
    uint64_t ri_cpu_time_qos_user_initiated;
    uint64_t ri_cpu_time_qos_user_interactive;
    uint64_t ri_billed_system_time;
    uint64_t ri_serviced_system_time;
};
struct rusage_info_v4
{
    uint8_t ri_uuid[16];
    uint64_t ri_user_time;
    uint64_t ri_system_time;
    uint64_t ri_pkg_idle_wkups;
    uint64_t ri_interrupt_wkups;
    uint64_t ri_pageins;
    uint64_t ri_wired_size;
    uint64_t ri_resident_size;
    uint64_t ri_phys_footprint;
    uint64_t ri_proc_start_abstime;
    uint64_t ri_proc_exit_abstime;
    uint64_t ri_child_user_time;
    uint64_t ri_child_system_time;
    uint64_t ri_child_pkg_idle_wkups;
    uint64_t ri_child_interrupt_wkups;
    uint64_t ri_child_pageins;
    uint64_t ri_child_elapsed_abstime;
    uint64_t ri_diskio_bytesread;
    uint64_t ri_diskio_byteswritten;
    uint64_t ri_cpu_time_qos_default;
    uint64_t ri_cpu_time_qos_maintenance;
    uint64_t ri_cpu_time_qos_background;
    uint64_t ri_cpu_time_qos_utility;
    uint64_t ri_cpu_time_qos_legacy;
    uint64_t ri_cpu_time_qos_user_initiated;
    uint64_t ri_cpu_time_qos_user_interactive;
    uint64_t ri_billed_system_time;
    uint64_t ri_serviced_system_time;
    uint64_t ri_logical_writes;
    uint64_t ri_lifetime_max_phys_footprint;
    uint64_t ri_instructions;
    uint64_t ri_cycles;
    uint64_t ri_billed_energy;
    uint64_t ri_serviced_energy;
    uint64_t ri_interval_max_phys_footprint;
    uint64_t ri_runnable_time;
};
struct rusage_info_v5
{
    uint8_t ri_uuid[16];
    uint64_t ri_user_time;
    uint64_t ri_system_time;
    uint64_t ri_pkg_idle_wkups;
    uint64_t ri_interrupt_wkups;
    uint64_t ri_pageins;
    uint64_t ri_wired_size;
    uint64_t ri_resident_size;
    uint64_t ri_phys_footprint;
    uint64_t ri_proc_start_abstime;
    uint64_t ri_proc_exit_abstime;
    uint64_t ri_child_user_time;
    uint64_t ri_child_system_time;
    uint64_t ri_child_pkg_idle_wkups;
    uint64_t ri_child_interrupt_wkups;
    uint64_t ri_child_pageins;
    uint64_t ri_child_elapsed_abstime;
    uint64_t ri_diskio_bytesread;
    uint64_t ri_diskio_byteswritten;
    uint64_t ri_cpu_time_qos_default;
    uint64_t ri_cpu_time_qos_maintenance;
    uint64_t ri_cpu_time_qos_background;
    uint64_t ri_cpu_time_qos_utility;
    uint64_t ri_cpu_time_qos_legacy;
    uint64_t ri_cpu_time_qos_user_initiated;
    uint64_t ri_cpu_time_qos_user_interactive;
    uint64_t ri_billed_system_time;
    uint64_t ri_serviced_system_time;
    uint64_t ri_logical_writes;
    uint64_t ri_lifetime_max_phys_footprint;
    uint64_t ri_instructions;
    uint64_t ri_cycles;
    uint64_t ri_billed_energy;
    uint64_t ri_serviced_energy;
    uint64_t ri_interval_max_phys_footprint;
    uint64_t ri_runnable_time;
    uint64_t ri_flags;
};
struct rusage_info_v6
{
    uint8_t ri_uuid[16];
    uint64_t ri_user_time;
    uint64_t ri_system_time;
    uint64_t ri_pkg_idle_wkups;
    uint64_t ri_interrupt_wkups;
    uint64_t ri_pageins;
    uint64_t ri_wired_size;
    uint64_t ri_resident_size;
    uint64_t ri_phys_footprint;
    uint64_t ri_proc_start_abstime;
    uint64_t ri_proc_exit_abstime;
    uint64_t ri_child_user_time;
    uint64_t ri_child_system_time;
    uint64_t ri_child_pkg_idle_wkups;
    uint64_t ri_child_interrupt_wkups;
    uint64_t ri_child_pageins;
    uint64_t ri_child_elapsed_abstime;
    uint64_t ri_diskio_bytesread;
    uint64_t ri_diskio_byteswritten;
    uint64_t ri_cpu_time_qos_default;
    uint64_t ri_cpu_time_qos_maintenance;
    uint64_t ri_cpu_time_qos_background;
    uint64_t ri_cpu_time_qos_utility;
    uint64_t ri_cpu_time_qos_legacy;
    uint64_t ri_cpu_time_qos_user_initiated;
    uint64_t ri_cpu_time_qos_user_interactive;
    uint64_t ri_billed_system_time;
    uint64_t ri_serviced_system_time;
    uint64_t ri_logical_writes;
    uint64_t ri_lifetime_max_phys_footprint;
    uint64_t ri_instructions;
    uint64_t ri_cycles;
    uint64_t ri_billed_energy;
    uint64_t ri_serviced_energy;
    uint64_t ri_interval_max_phys_footprint;
    uint64_t ri_runnable_time;
    uint64_t ri_flags;
    uint64_t ri_user_ptime;
    uint64_t ri_system_ptime;
    uint64_t ri_pinstructions;
    uint64_t ri_pcycles;
    uint64_t ri_energy_nj;
    uint64_t ri_penergy_nj;
    uint64_t ri_reserved[14];
};
typedef struct rusage_info_v6 rusage_info_current;
struct rlimit
{
    rlim_t rlim_cur;
    rlim_t rlim_max;
};
struct proc_rlimit_control_wakeupmon
{
    uint32_t wm_flags;
    int32_t wm_rate;
};
extern "C"
{
    int getpriority(int, id_t);
    int getiopolicy_np(int, int);
    int getrlimit(int, struct rlimit *) __asm("_"
                                              "getrlimit");
    int getrusage(int, struct rusage *);
    int setpriority(int, id_t, int);
    int setiopolicy_np(int, int, int);
    int setrlimit(int, const struct rlimit *) __asm("_"
                                                    "setrlimit");
}
static inline uint16_t
_OSSwapInt16(
    uint16_t _data)
{
    return (uint16_t)(_data << 8 | _data >> 8);
}
static inline uint32_t
_OSSwapInt32(
    uint32_t _data)
{
    _data = __builtin_bswap32(_data);
    return _data;
}
static inline uint64_t
_OSSwapInt64(
    uint64_t _data)
{
    return __builtin_bswap64(_data);
}
struct _OSUnalignedU16
{
    volatile uint16_t __val;
};
struct _OSUnalignedU32
{
    volatile uint32_t __val;
};
struct _OSUnalignedU64
{
    volatile uint64_t __val;
};
static inline uint16_t
OSReadSwapInt16(
    const volatile void *_base,
    uintptr_t _offset)
{
    return _OSSwapInt16(((struct _OSUnalignedU16 *)((uintptr_t)_base + _offset))->__val);
}
static inline uint32_t
OSReadSwapInt32(
    const volatile void *_base,
    uintptr_t _offset)
{
    return _OSSwapInt32(((struct _OSUnalignedU32 *)((uintptr_t)_base + _offset))->__val);
}
static inline uint64_t
OSReadSwapInt64(
    const volatile void *_base,
    uintptr_t _offset)
{
    return _OSSwapInt64(((struct _OSUnalignedU64 *)((uintptr_t)_base + _offset))->__val);
}
static inline void
OSWriteSwapInt16(
    volatile void *_base,
    uintptr_t _offset,
    uint16_t _data)
{
    ((struct _OSUnalignedU16 *)((uintptr_t)_base + _offset))->__val = _OSSwapInt16(_data);
}
static inline void
OSWriteSwapInt32(
    volatile void *_base,
    uintptr_t _offset,
    uint32_t _data)
{
    ((struct _OSUnalignedU32 *)((uintptr_t)_base + _offset))->__val = _OSSwapInt32(_data);
}
static inline void
OSWriteSwapInt64(
    volatile void *_base,
    uintptr_t _offset,
    uint64_t _data)
{
    ((struct _OSUnalignedU64 *)((uintptr_t)_base + _offset))->__val = _OSSwapInt64(_data);
}
union wait
{
    int w_status;
    struct
    {
        unsigned int w_Termsig : 7,
            w_Coredump : 1,
            w_Retcode : 8,
            w_Filler : 16;
    } w_T;
    struct
    {
        unsigned int w_Stopval : 8,
            w_Stopsig : 8,
            w_Filler : 16;
    } w_S;
};
extern "C"
{
    pid_t wait(int *) __asm("_"
                            "wait");
    pid_t waitpid(pid_t, int *, int) __asm("_"
                                           "waitpid");
    int waitid(idtype_t, id_t, siginfo_t *, int) __asm("_"
                                                       "waitid");
    pid_t wait3(int *, int, struct rusage *);
    pid_t wait4(pid_t, int *, int, struct rusage *);
}

extern "C"
{
    void *alloca(size_t);
}
typedef __darwin_ct_rune_t ct_rune_t;
typedef __darwin_rune_t rune_t;

typedef struct
{
    int quot;
    int rem;
} div_t;
typedef struct
{
    long quot;
    long rem;
} ldiv_t;
typedef struct
{
    long long quot;
    long long rem;
} lldiv_t;
extern int __mb_cur_max;
extern "C"
{
    void *malloc(size_t __size);
    void *calloc(size_t __count, size_t __size);
    void free(void *);
    void *realloc(void *__ptr, size_t __size);
    void *valloc(size_t);
    void *aligned_alloc(size_t __alignment, size_t __size);
    int posix_memalign(void **__memptr, size_t __alignment, size_t __size);
}

extern "C"
{
    void abort(void);
    int abs(int);
    int atexit(void (*_Nonnull)(void));
    double atof(const char *);
    int atoi(const char *);
    long atol(const char *);
    long long
    atoll(const char *);
    void *bsearch(const void *__key, const void *__base, size_t __nel,
                  size_t __width, int (*_Nonnull __compar)(const void *, const void *));
    div_t div(int, int);
    void exit(int);
    char *getenv(const char *);
    long labs(long);
    ldiv_t ldiv(long, long);
    long long
    llabs(long long);
    lldiv_t lldiv(long long, long long);
    int mblen(const char *__s, size_t __n);
    size_t mbstowcs(wchar_t *, const char *, size_t);
    int mbtowc(wchar_t *, const char *, size_t);
    void qsort(void *__base, size_t __nel, size_t __width,
               int (*_Nonnull __compar)(const void *, const void *));
    int rand(void);
    void srand(unsigned);
    double strtod(const char *, char **) __asm("_"
                                               "strtod");
    float strtof(const char *, char **) __asm("_"
                                              "strtof");
    long strtol(const char *__str, char **__endptr, int __base);
    long double
    strtold(const char *, char **);
    long long
    strtoll(const char *__str, char **__endptr, int __base);
    unsigned long
    strtoul(const char *__str, char **__endptr, int __base);
    unsigned long long
    strtoull(const char *__str, char **__endptr, int __base);

    int system(const char *) __asm("_"
                                   "system");
    size_t wcstombs(char *, const wchar_t *, size_t);
    int wctomb(char *, wchar_t);
    void _Exit(int);
    long a64l(const char *);
    double drand48(void);
    char *ecvt(double, int, int *, int *);
    double erand48(unsigned short[3]);
    char *fcvt(double, int, int *, int *);
    char *gcvt(double, int, char *);
    int getsubopt(char **, char *const *, char **);
    int grantpt(int);
    char *initstate(unsigned, char *, size_t);
    long jrand48(unsigned short[3]);
    char *l64a(long);
    void lcong48(unsigned short[7]);
    long lrand48(void);

    char *mktemp(char *);
    int mkstemp(char *);
    long mrand48(void);
    long nrand48(unsigned short[3]);
    int posix_openpt(int);
    char *ptsname(int);
    int ptsname_r(int fildes, char *buffer, size_t buflen);
    int putenv(char *) __asm("_"
                             "putenv");
    long random(void);
    int rand_r(unsigned *);
    char *realpath(const char *, char *) __asm("_"
                                               "realpath"
                                               "$DARWIN_EXTSN");
    unsigned short *seed48(unsigned short[3]);
    int setenv(const char *__name, const char *__value, int __overwrite) __asm("_"
                                                                               "setenv");
    void setkey(const char *) __asm("_"
                                    "setkey");
    char *setstate(const char *);
    void srand48(long);
    void srandom(unsigned);
    int unlockpt(int);
    int unsetenv(const char *) __asm("_"
                                     "unsetenv");
    typedef __darwin_dev_t dev_t;
    typedef __darwin_mode_t mode_t;
    uint32_t arc4random(void);
    void arc4random_addrandom(unsigned char *, int)

        ;
    void arc4random_buf(void *__buf, size_t __nbytes);
    void arc4random_stir(void);
    uint32_t
    arc4random_uniform(uint32_t __upper_bound);
    int atexit_b(void (^_Nonnull)(void));
void *bsearch_b(const void *__key, const void *__base, size_t __nel,
     size_t __width, int (^ _Nonnull __compar)(const void *, const void *) 
     ;
char *cgetcap(char *, const char *, int);
int cgetclose(void);
int cgetent(char **, char **, const char *);
int cgetfirst(char **, char **);
int cgetmatch(const char *, const char *);
int cgetnext(char **, char **);
int cgetnum(char *, const char *, long *);
int cgetset(const char *);
int cgetstr(char *, const char *, char **);
int cgetustr(char *, const char *, char **);
int daemon(int, int) __asm("_" "daemon" ) ;
char *devname(dev_t, mode_t);
char *devname_r(dev_t, mode_t, char *buf, int len);
char *getbsize(int *, long *);
int getloadavg(double [], int);
const char
 *getprogname(void);
void setprogname(const char *);
int heapsort(void *__base, size_t __nel, size_t __width,
     int (* _Nonnull __compar)(const void *, const void *));
int heapsort_b(void *__base, size_t __nel, size_t __width,
     int (^ _Nonnull __compar)(const void *, const void *) 
     ;
int mergesort(void *__base, size_t __nel, size_t __width,
     int (* _Nonnull __compar)(const void *, const void *));
int mergesort_b(void *__base, size_t __nel, size_t __width,
     int (^ _Nonnull __compar)(const void *, const void *) 
     ;
void psort(void *__base, size_t __nel, size_t __width,
     int (* _Nonnull __compar)(const void *, const void *))
     ;
void psort_b(void *__base, size_t __nel, size_t __width,
     int (^ _Nonnull __compar)(const void *, const void *) 
     ;
void psort_r(void *__base, size_t __nel, size_t __width, void *,
     int (* _Nonnull __compar)(void *, const void *, const void *))
     ;
void qsort_b(void *__base, size_t __nel, size_t __width,
     int (^ _Nonnull __compar)(const void *, const void *) 
     ;
void qsort_r(void *__base, size_t __nel, size_t __width, void *,
     int (* _Nonnull __compar)(void *, const void *, const void *));
int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table,
     unsigned __endbyte);
int rpmatch(const char *)
 ;
int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table,
     unsigned __endbyte);
void sranddev(void);
void srandomdev(void);
void *reallocf(void *__ptr, size_t __size) ;
long long
 strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
 ;
long long
  strtoq(const char *__str, char **__endptr, int __base);
unsigned long long
  strtouq(const char *__str, char **__endptr, int __base);
extern char *suboptarg;
}
extern "C++"
{
inline
{
    return __builtin_labs(__x);
}
inline
{
    return __builtin_llabs(__x);
}
inline
{
    return __builtin_fabsf(__lcpp_x);
}
inline
{
    return __builtin_fabs(__lcpp_x);
}
inline long double
abs(long double __lcpp_x) throw()
{
    return __builtin_fabsl(__lcpp_x);
}
inline
{
    return ::ldiv(__x, __y);
}
inline lldiv_t div(long long __x,
                   long long __y) throw()
{
    return ::lldiv(__x, __y);
}
}
namespace std
{
inline namespace __1
{
    using ::_Exit;
    using ::abort;
    using ::abs;
    using ::atexit;
    using ::atof;
    using ::atoi;
    using ::atol;
    using ::atoll;
    using ::bsearch;
    using ::calloc;
    using ::div;
    using ::div_t;
    using ::exit;
    using ::free;
    using ::getenv;
    using ::labs;
    using ::ldiv;
    using ::ldiv_t;
    using ::llabs;
    using ::lldiv;
    using ::lldiv_t;
    using ::malloc;
    using ::mblen;
    using ::mbstowcs;
    using ::mbtowc;
    using ::qsort;
    using ::rand;
    using ::realloc;
    using ::size_t;
    using ::srand;
    using ::strtod;
    using ::strtof;
    using ::strtol;
    using ::strtold;
    using ::strtoll;
    using ::strtoul;
    using ::strtoull;
    using ::system;
    using ::wcstombs;
    using ::wctomb;
}
}
struct accessx_descriptor
{
unsigned int ad_name_offset;
int ad_flags;
int ad_pad[2];
};
typedef __darwin_ssize_t ssize_t;
extern "C"
{
int getattrlistbulk(int, void *, void *, size_t, uint64_t);
int getattrlistat(int, const char *, void *, void *, size_t, unsigned long);
int setattrlistat(int, const char *, void *, void *, size_t, uint32_t);
ssize_t freadlink(int, char *, size_t);
}
typedef __darwin_gid_t gid_t;
extern "C"
{
int faccessat(int, const char *, int, int);
int fchownat(int, const char *, uid_t, gid_t, int);
int linkat(int, const char *, int, const char *, int);
ssize_t readlinkat(int, const char *, char *, size_t);
int symlinkat(const char *, int, const char *);
int unlinkat(int, const char *, int);
}
typedef __darwin_off_t off_t;
typedef __darwin_useconds_t useconds_t;
extern "C"
{
void _exit(int);
int access(const char *, int);
unsigned int
alarm(unsigned int);
int chdir(const char *);
int chown(const char *, uid_t, gid_t);
int close(int) __asm("_"
                     "close");
int dup(int);
int dup2(int, int);
int execl(const char *__path, const char *__arg0, ...);
int execle(const char *__path, const char *__arg0, ...);
int execlp(const char *__file, const char *__arg0, ...);
int execv(const char *__path, char *const *__argv);
int execve(const char *__file, char *const *__argv, char *const *__envp);
int execvp(const char *__file, char *const *__argv);
pid_t fork(void);
long fpathconf(int, int);
char *getcwd(char *, size_t);
gid_t getegid(void);
uid_t geteuid(void);
gid_t getgid(void);
int getgroups(int, gid_t[]);
char *getlogin(void);
pid_t getpgrp(void);
pid_t getpid(void);
pid_t getppid(void);
uid_t getuid(void);
int isatty(int);
int link(const char *, const char *);
off_t lseek(int, off_t, int);
long pathconf(const char *, int);
int pause(void) __asm("_"
                      "pause");
int pipe(int[2]);
ssize_t read(int, void *, size_t) __asm("_"
                                        "read");
int rmdir(const char *);
int setgid(gid_t);
int setpgid(pid_t, pid_t);
pid_t setsid(void);
int setuid(uid_t);
unsigned int
sleep(unsigned int) __asm("_"
                          "sleep");
long sysconf(int);
pid_t tcgetpgrp(int);
int tcsetpgrp(int, pid_t);
char *ttyname(int);
int ttyname_r(int, char *, size_t) __asm("_"
                                         "ttyname_r");
int unlink(const char *);
ssize_t write(int __fd, const void *__buf, size_t __nbyte) __asm("_"
                                                                 "write");
}
extern "C"
{
size_t confstr(int, char *, size_t) __asm("_"
                                          "confstr");
int getopt(int, char *const[], const char *) __asm("_"
                                                   "getopt");
extern char *optarg;
extern int optind, opterr, optopt;
}
extern "C"
{
char *ctermid(char *);
}
extern "C"
{

void *brk(const void *);
int chroot(const char *);
char *crypt(const char *, const char *);
void encrypt(char *, int) __asm("_"
                                "encrypt");
int fchdir(int);
long gethostid(void);
pid_t getpgid(pid_t);
pid_t getsid(pid_t);
int getdtablesize(void);
int getpagesize(void);
char *getpass(const char *);
char *getwd(char *);
int lchown(const char *, uid_t, gid_t) __asm("_"
                                             "lchown");
int lockf(int, int, off_t) __asm("_"
                                 "lockf");
int nice(int) __asm("_"
                    "nice");
ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t __offset) __asm("_"
                                                                           "pread");
ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t __offset) __asm("_"
                                                                                  "pwrite");

void *sbrk(int);
pid_t setpgrp(void) __asm("_"
                          "setpgrp");
int setregid(gid_t, gid_t) __asm("_"
                                 "setregid");
int setreuid(uid_t, uid_t) __asm("_"
                                 "setreuid");
void swab(const void *, void *, ssize_t);
void sync(void);
int truncate(const char *, off_t);
useconds_t ualarm(useconds_t, useconds_t);
int usleep(useconds_t) __asm("_"
                             "usleep");

pid_t vfork(void);
int fsync(int) __asm("_"
                     "fsync");
int ftruncate(int, off_t);
int getlogin_r(char *, size_t);
}
extern "C"
{
int fchown(int, uid_t, gid_t);
int gethostname(char *, size_t);
ssize_t readlink(const char *, char *, size_t);
int setegid(gid_t);
int seteuid(uid_t);
int symlink(const char *, const char *);
}
extern "C"
{
typedef struct fd_set
{
    __int32_t fds_bits[((((1024) % ((sizeof(__int32_t) * 8))) == 0) ? ((1024) / ((sizeof(__int32_t) * 8))) : (((1024) / ((sizeof(__int32_t) * 8))) + 1))];
} fd_set;
int __darwin_check_fd_set_overflow(int, const void *, int);
}
inline __attribute__((__always_inline__)) int
__darwin_check_fd_set(int _a, const void *_b)
{
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunguarded-availability-new"
if ((uintptr_t)&__darwin_check_fd_set_overflow != (uintptr_t)0)
{
    return __darwin_check_fd_set_overflow(_a, _b, 0);
}
else
{
    return 1;
}
#pragma clang diagnostic pop
}
inline __attribute__((__always_inline__)) int
__darwin_fd_isset(int _fd, const struct fd_set *_p)
{
if (__darwin_check_fd_set(_fd, (const void *)_p))
{
    return _p->fds_bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] & ((__int32_t)(((unsigned long)1) << ((unsigned long)_fd % (sizeof(__int32_t) * 8))));
}
return 0;
}
inline __attribute__((__always_inline__)) void
__darwin_fd_set(int _fd, struct fd_set *const _p)
{
if (__darwin_check_fd_set(_fd, (const void *)_p))
{
    (_p->fds_bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] |= ((__int32_t)(((unsigned long)1) << ((unsigned long)_fd % (sizeof(__int32_t) * 8)))));
}
}
inline __attribute__((__always_inline__)) void
__darwin_fd_clr(int _fd, struct fd_set *const _p)
{
if (__darwin_check_fd_set(_fd, (const void *)_p))
{
    (_p->fds_bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] &= ~((__int32_t)(((unsigned long)1) << ((unsigned long)_fd % (sizeof(__int32_t) * 8)))));
}
}
struct timespec
{
__darwin_time_t tv_sec;
long tv_nsec;
};
typedef __darwin_time_t time_t;
typedef __darwin_suseconds_t suseconds_t;
extern "C"
{
int pselect(int, fd_set *, fd_set *,
            fd_set *, const struct timespec *,
            const sigset_t *) __asm("_"
                                    "pselect");
int select(int, fd_set *, fd_set *,
           fd_set *, struct timeval *) __asm("_"
                                             "select");
}
typedef __darwin_uuid_t uuid_t;

extern "C"
{
void _Exit(int);
int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t);
int acct(const char *);
int add_profil(char *, size_t, unsigned long, unsigned int);
void endusershell(void);
int execvP(const char *__file, const char *__searchpath, char *const *__argv);
char *fflagstostr(unsigned long);
int getdomainname(char *, int);
int getgrouplist(const char *, int, int *, int *);
int gethostuuid(uuid_t, const struct timespec *);
mode_t getmode(const void *, mode_t);
int getpeereid(int, uid_t *, gid_t *);
int getsgroups_np(int *, uuid_t);
char *getusershell(void);
int getwgroups_np(int *, uuid_t);
int initgroups(const char *, int);
int issetugid(void);
char *mkdtemp(char *);
int mknod(const char *, mode_t, dev_t);
int mkpath_np(const char *path, mode_t omode);
int mkpathat_np(int dfd, const char *path, mode_t omode)

    ;
int mkstemp(char *);
int mkstemps(char *, int);
char *mktemp(char *);
int mkostemp(char *path, int oflags)

    ;
int mkostemps(char *path, int slen, int oflags)

    ;
int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)

    ;
char *mkdtempat_np(int dfd, char *path)

    ;
int mkstempsat_np(int dfd, char *path, int slen)

    ;
int mkostempsat_np(int dfd, char *path, int slen, int oflags)

    ;
int nfssvc(int, void *);
int profil(char *, size_t, unsigned long, unsigned int);

int pthread_setugid_np(uid_t, gid_t);
int pthread_getugid_np(uid_t *, gid_t *);
int reboot(int);
int revoke(const char *);
;
int rcmd_af(char **, int, const char *, const char *, const char *, int *,
            int);
;
;
;
;
;
int setdomainname(const char *, int);
int setgroups(int, const gid_t *);
void sethostid(long);
int sethostname(const char *, int);
void setkey(const char *) __asm("_"
                                "setkey");
int setlogin(const char *);
void *setmode(const char *) __asm("_"
                                  "setmode");
int setrgid(gid_t);
int setruid(uid_t);
int setsgroups_np(int, const uuid_t);
void setusershell(void);
int setwgroups_np(int, const uuid_t);
int strtofflags(char **, unsigned long *, unsigned long *);
int swapon(const char *);
int ttyslot(void);
int undelete(const char *);
int unwhiteout(const char *);
void *valloc(size_t);

int syscall(int, ...);
extern char *suboptarg;
int getsubopt(char **, char *const *, char **);
int fgetattrlist(int, void *, void *, size_t, unsigned int);
int fsetattrlist(int, void *, void *, size_t, unsigned int);
int getattrlist(const char *, void *, void *, size_t, unsigned int) __asm("_"
                                                                          "getattrlist");
int setattrlist(const char *, void *, void *, size_t, unsigned int) __asm("_"
                                                                          "setattrlist");
int exchangedata(const char *, const char *, unsigned int);
int getdirentriesattr(int, void *, void *, size_t, unsigned int *, unsigned int *, unsigned int *, unsigned int);
struct fssearchblock;
struct searchstate;
int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *);
int fsctl(const char *, unsigned long, void *, unsigned int);
int ffsctl(int, unsigned long, void *, unsigned int);
int fsync_volume_np(int, int);
int sync_volume_np(const char *, int);
extern int optreset;
}
namespace boost
{
__extension__ typedef long long long_long_type;
__extension__ typedef unsigned long long ulong_long_type;
}
namespace boost
{
__extension__ typedef __int128 int128_type;
__extension__ typedef unsigned __int128 uint128_type;
}
namespace boost
{
using ::int16_t;
using ::int32_t;
using ::int64_t;
using ::int8_t;
using ::int_fast16_t;
using ::int_fast32_t;
using ::int_fast64_t;
using ::int_fast8_t;
using ::int_least16_t;
using ::int_least32_t;
using ::int_least64_t;
using ::int_least8_t;
using ::intmax_t;
using ::uint16_t;
using ::uint32_t;
using ::uint64_t;
using ::uint8_t;
using ::uint_fast16_t;
using ::uint_fast32_t;
using ::uint_fast64_t;
using ::uint_fast8_t;
using ::uint_least16_t;
using ::uint_least32_t;
using ::uint_least64_t;
using ::uint_least8_t;
using ::uintmax_t;
}
namespace boost
{
using ::intptr_t;
using ::uintptr_t;
}
namespace std
{
inline namespace __1
{
    template <bool, class _Tp = void>
    struct enable_if
    {
    };
    template <class _Tp>
    struct enable_if<true, _Tp>
    {
        typedef _Tp type;
    };
    template <bool _Bp, class _Tp = void>
    using __enable_if_t = typename enable_if<_Bp, _Tp>::type;
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp, _Tp __v>
    struct integral_constant
    {
        static const _Tp value = __v;
        typedef _Tp value_type;
        typedef integral_constant type;

        operator value_type() const throw() { return value; }
    };
    template <class _Tp, _Tp __v>
    const _Tp integral_constant<_Tp, __v>::value;
    typedef integral_constant<bool, true> true_type;
    typedef integral_constant<bool, false> false_type;
    template <bool _Val>
    using _BoolConstant = integral_constant<bool, _Val>;
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp>
    struct remove_const
    {
        typedef _Tp type;
    };
    template <class _Tp>
    struct remove_const<const _Tp>
    {
        typedef _Tp type;
    };
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp>
    struct remove_volatile
    {
        typedef _Tp type;
    };
    template <class _Tp>
    struct remove_volatile<volatile _Tp>
    {
        typedef _Tp type;
    };
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp>
    struct remove_cv
    {
        typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;
    };
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp>
    struct __libcpp_is_integral
    {
        enum
        {
            value = 0
        };
    };
    template <>
    struct __libcpp_is_integral<bool>
    {
        enum
        {
            value = 1
        };
    };
    template <>
    struct __libcpp_is_integral<char>
    {
        enum
        {
            value = 1
        };
    };
    template <>
    struct __libcpp_is_integral<signed char>
    {
        enum
        {
            value = 1
        };
    };
    template <>
    struct __libcpp_is_integral<unsigned char>
    {
        enum
        {
            value = 1
        };
    };
    template <>
    struct __libcpp_is_integral<wchar_t>
    {
        enum
        {
            value = 1
        };
    };
    template <>
    struct __libcpp_is_integral<char16_t>
    {
        enum
        {
            value = 1
        };
    };
    template <>
    struct __libcpp_is_integral<char32_t>
    {
        enum
        {
            value = 1
        };
    };
    template <>
    struct __libcpp_is_integral<short>
    {
        enum
        {
            value = 1
        };
    };
    template <>
    struct __libcpp_is_integral<unsigned short>
    {
        enum
        {
            value = 1
        };
    };
    template <>
    struct __libcpp_is_integral<int>
    {
        enum
        {
            value = 1
        };
    };
    template <>
    struct __libcpp_is_integral<unsigned int>
    {
        enum
        {
            value = 1
        };
    };
    template <>
    struct __libcpp_is_integral<long>
    {
        enum
        {
            value = 1
        };
    };
    template <>
    struct __libcpp_is_integral<unsigned long>
    {
        enum
        {
            value = 1
        };
    };
    template <>
    struct __libcpp_is_integral<long long>
    {
        enum
        {
            value = 1
        };
    };
    template <>
    struct __libcpp_is_integral<unsigned long long>
    {
        enum
        {
            value = 1
        };
    };
    template <>
    struct __libcpp_is_integral<__int128_t>
    {
        enum
        {
            value = 1
        };
    };
    template <>
    struct __libcpp_is_integral<__uint128_t>
    {
        enum
        {
            value = 1
        };
    };
    template <class _Tp>
        struct > {};
}
}
typedef long int ptrdiff_t;
typedef long unsigned int rsize_t;
typedef __decltype(__nullptr) nullptr_t;
namespace std
{
inline namespace __1
{
    using ::nullptr_t;
    using ::ptrdiff_t;
    using ::size_t;
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp, class _Up>
        struct > {};
    template <class _Tp, class _Up>
    using _IsSame = _BoolConstant<__is_same(_Tp, _Up)>;
    template <class _Tp, class _Up>
    using _IsNotSame = _BoolConstant<!__is_same(_Tp, _Up)>;
}
}
namespace std
{
inline namespace __1
{
    struct __is_referenceable_impl
    {
        template <class _Tp>
        static _Tp &__test(int);
        template <class _Tp>
        static false_type __test(...);
    };
    template <class _Tp>
    struct __is_referenceable : integral_constant<bool,
                                                  _IsNotSame<__decltype(__is_referenceable_impl::__test<_Tp>(0)), false_type>::value>{};
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_impl
    {
        typedef _Tp type;
    };
    template <class _Tp>
    struct __add_lvalue_reference_impl<_Tp, true>
    {
        typedef _Tp &type;
    };
    template <class _Tp>
    struct add_lvalue_reference
    {
        typedef typename __add_lvalue_reference_impl<_Tp>::type type;
    };
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp>
        struct > {};
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp>
        struct > {};
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp>
    struct _Tp type;
};
template <class _Tp>
struct _Tp type;
};
template <class _Tp>
struct _Tp type;
}
;
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,
              bool = is_volatile<typename remove_reference<_Tp>::type>::value>
    struct __apply_cv
    {
        typedef _Up type;
    };
    template <class _Tp, class _Up>
    struct __apply_cv<_Tp, _Up, true, false>
    {
        typedef const _Up type;
    };
    template <class _Tp, class _Up>
    struct __apply_cv<_Tp, _Up, false, true>
    {
        typedef volatile _Up type;
    };
    template <class _Tp, class _Up>
    struct __apply_cv<_Tp, _Up, true, true>
    {
        typedef const volatile _Up type;
    };
    template <class _Tp, class _Up>
    struct __apply_cv<_Tp &, _Up, false, false>
    {
        typedef _Up &type;
    };
    template <class _Tp, class _Up>
    struct __apply_cv<_Tp &, _Up, true, false>
    {
        typedef const _Up &type;
    };
    template <class _Tp, class _Up>
    struct __apply_cv<_Tp &, _Up, false, true>
    {
        typedef volatile _Up &type;
    };
    template <class _Tp, class _Up>
    struct __apply_cv<_Tp &, _Up, true, true>
    {
        typedef const volatile _Up &type;
    };
}
}
namespace std
{
inline namespace __1
{
    template <bool>
    struct _IfImpl;
    template <>
    struct _IfImpl<true>
    {
        template <class _IfRes, class _ElseRes>
        using _Select = _IfRes;
    };
    template <>
    struct _IfImpl<false>
    {
        template <class _IfRes, class _ElseRes>
        using _Select = _ElseRes;
    };
    template <bool _Cond, class _IfRes, class _ElseRes>
    using _If = typename _IfImpl<_Cond>::template _Select<_IfRes, _ElseRes>;
    template <bool _Bp, class _If, class _Then>
    struct conditional
    {
        typedef _If type;
    };
    template <class _If, class _Then>
    struct conditional<false, _If, _Then>
    {
        typedef _Then type;
    };
    template <bool _Bp, class _If, class _Then>
    using __conditional_t = typename conditional<_Bp, _If, _Then>::type;
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp,
              bool = __is_referenceable<_Tp>::value ||
                     _IsSame<typename remove_cv<_Tp>::type, void>::value>
    struct __add_pointer_impl
    {
        typedef typename remove_reference<_Tp>::type *type;
    };
    template <class _Tp>
    struct __add_pointer_impl<_Tp, false>
    {
        typedef _Tp type;
    };
    template <class _Tp>
    struct add_pointer
    {
        typedef typename __add_pointer_impl<_Tp>::type type;
    };
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp>
    struct is_array
        : public false_type
    {
    };
    template <class _Tp>
    struct is_array<_Tp[]>
        : public true_type
    {
    };
    template <class _Tp, size_t _Np>
    struct is_array<_Tp[_Np]>
        : public true_type
    {
    };
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp>
        struct > {};
    template <class _Tp>
        struct > {};
    template <class _Tp>
        struct > {};
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp>
        struct > {};
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp>
    struct remove_extent
    {
        typedef _Tp type;
    };
    template <class _Tp>
    struct remove_extent<_Tp[]>
    {
        typedef _Tp type;
    };
    template <class _Tp, size_t _Np>
    struct remove_extent<_Tp[_Np]>
    {
        typedef _Tp type;
    };
}
}
namespace std
{
inline namespace __1
{
    template <class _Up, bool>
    struct __decay
    {
        typedef typename remove_cv<_Up>::type type;
    };
    template <class _Up>
    struct __decay<_Up, true>
    {
    public:
        typedef typename conditional<
            is_array<_Up>::value,
            typename remove_extent<_Up>::type *,
            typename conditional<
                is_function<_Up>::value,
                typename add_pointer<_Up>::type,
                typename remove_cv<_Up>::type>::type>::type type;
    };
    template <class _Tp>
    struct decay
    {
    private:
        typedef typename remove_reference<_Tp>::type _Up;

    public:
        typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type;
    };
}
}
namespace std
{
inline namespace __1
{
    template <class _Bp, class _Dp>
    struct is_base_of
        : public integral_constant<bool, __is_base_of(_Bp, _Dp)>
    {
    };
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp, class _Up, class = void>
    struct __is_core_convertible : public false_type
    {
    };
    template <class _Tp, class _Up>
    struct __is_core_convertible<_Tp, _Up, __decltype(static_cast<void (*)(_Up)>(0)(static_cast<_Tp (*)()>(0)()))> : public true_type
    {
    };
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp>
    struct __libcpp_is_member_pointer
    {
        enum
        {
            __is_member = false,
            __is_func = false,
            __is_obj = false
        };
    };
    template <class _Tp, class _Up>
    struct __libcpp_is_member_pointer<_Tp _Up::*>
    {
        enum
        {
            __is_member = true,
            __is_func = is_function<_Tp>::value,
            __is_obj = !__is_func,
        };
    };
    template <class _Tp>
    struct is_member_function_pointer
        : _BoolConstant<__is_member_function_pointer(_Tp)>
    {
    };
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp>
    struct is_member_object_pointer
        : _BoolConstant<__is_member_object_pointer(_Tp)>
    {
    };
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp>
    class reference_wrapper;
    template <class _Tp>
    struct __is_reference_wrapper_impl : public false_type
    {
    };
    template <class _Tp>
    struct __is_reference_wrapper_impl<reference_wrapper<_Tp>> : public true_type
    {
    };
    template <class _Tp>
    struct __is_reference_wrapper
        : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type>
    {
    };
}
}

namespace std
{
inline namespace __1
{
    template <class _Tp>
        struct > {};
}
}
namespace std
{
inline namespace __1
{
    struct __nat
    {
    };
}
}

namespace std
{
inline namespace __1
{
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    template <class _Tp>
    _Tp &&__declval(int);
    template <class _Tp>
    _Tp __declval(long);
#pragma GCC diagnostic pop
    template <class _Tp>
    __decltype(__declval<_Tp>(0)) declval() throw();
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp>
    inline _Tp &&
    forward(typename remove_reference<_Tp>::type &__t) throw()
    {
        return static_cast<_Tp &&>(__t);
    }
    template <class _Tp>
    inline _Tp &&
    forward(typename remove_reference<_Tp>::type &&__t) throw()
    {
        _Static_assert(!is_lvalue_reference<_Tp>::value, "cannot forward an rvalue as an lvalue");
        return static_cast<_Tp &&>(__t);
    }
}
}
namespace std
{
inline namespace __1
{
    struct __any
    {
        __any(...);
    };
    template <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>
    struct __member_pointer_traits_imp
    {
    };
    template <class _Rp, class _Class, class... _Param>
    struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>
    {
        typedef _Class _ClassType;
        typedef _Rp _ReturnType;
        typedef _Rp(_FnType)(_Param...);
    };
    template <class _Rp, class _Class, class... _Param>
    struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>
    {
        typedef _Class _ClassType;
        typedef _Rp _ReturnType;
        typedef _Rp(_FnType)(_Param..., ...);
    };
    template <class _Rp, class _Class, class... _Param>
    struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>
    {
        typedef _Class const _ClassType;
        typedef _Rp _ReturnType;
        typedef _Rp(_FnType)(_Param...);
    };
    template <class _Rp, class _Class, class... _Param>
    struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>
    {
        typedef _Class const _ClassType;
        typedef _Rp _ReturnType;
        typedef _Rp(_FnType)(_Param..., ...);
    };
    template <class _Rp, class _Class, class... _Param>
    struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>
    {
        typedef _Class volatile _ClassType;
        typedef _Rp _ReturnType;
        typedef _Rp(_FnType)(_Param...);
    };
    template <class _Rp, class _Class, class... _Param>
    struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>
    {
        typedef _Class volatile _ClassType;
        typedef _Rp _ReturnType;
        typedef _Rp(_FnType)(_Param..., ...);
    };
    template <class _Rp, class _Class, class... _Param>
    struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>
    {
        typedef _Class const volatile _ClassType;
        typedef _Rp _ReturnType;
        typedef _Rp(_FnType)(_Param...);
    };
    template <class _Rp, class _Class, class... _Param>
    struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>
    {
        typedef _Class const volatile _ClassType;
        typedef _Rp _ReturnType;
        typedef _Rp(_FnType)(_Param..., ...);
    };
    template <class _Rp, class _Class, class... _Param>
    struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>
    {
        typedef _Class &_ClassType;
        typedef _Rp _ReturnType;
        typedef _Rp(_FnType)(_Param...);
    };
    template <class _Rp, class _Class, class... _Param>
    struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>
    {
        typedef _Class &_ClassType;
        typedef _Rp _ReturnType;
        typedef _Rp(_FnType)(_Param..., ...);
    };
    template <class _Rp, class _Class, class... _Param>
    struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const &, true, false>
    {
        typedef _Class const &_ClassType;
        typedef _Rp _ReturnType;
        typedef _Rp(_FnType)(_Param...);
    };
    template <class _Rp, class _Class, class... _Param>
    struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const &, true, false>
    {
        typedef _Class const &_ClassType;
        typedef _Rp _ReturnType;
        typedef _Rp(_FnType)(_Param..., ...);
    };
    template <class _Rp, class _Class, class... _Param>
    struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile &, true, false>
    {
        typedef _Class volatile &_ClassType;
        typedef _Rp _ReturnType;
        typedef _Rp(_FnType)(_Param...);
    };
    template <class _Rp, class _Class, class... _Param>
    struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile &, true, false>
    {
        typedef _Class volatile &_ClassType;
        typedef _Rp _ReturnType;
        typedef _Rp(_FnType)(_Param..., ...);
    };
    template <class _Rp, class _Class, class... _Param>
    struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile &, true, false>
    {
        typedef _Class const volatile &_ClassType;
        typedef _Rp _ReturnType;
        typedef _Rp(_FnType)(_Param...);
    };
    template <class _Rp, class _Class, class... _Param>
    struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile &, true, false>
    {
        typedef _Class const volatile &_ClassType;
        typedef _Rp _ReturnType;
        typedef _Rp(_FnType)(_Param..., ...);
    };
    template <class _Rp, class _Class, class... _Param>
    struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>
    {
        typedef _Class &&_ClassType;
        typedef _Rp _ReturnType;
        typedef _Rp(_FnType)(_Param...);
    };
    template <class _Rp, class _Class, class... _Param>
    struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>
    {
        typedef _Class &&_ClassType;
        typedef _Rp _ReturnType;
        typedef _Rp(_FnType)(_Param..., ...);
    };
    template <class _Rp, class _Class, class... _Param>
    struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const &&, true, false>
    {
        typedef _Class const &&_ClassType;
        typedef _Rp _ReturnType;
        typedef _Rp(_FnType)(_Param...);
    };
    template <class _Rp, class _Class, class... _Param>
    struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const &&, true, false>
    {
        typedef _Class const &&_ClassType;
        typedef _Rp _ReturnType;
        typedef _Rp(_FnType)(_Param..., ...);
    };
    template <class _Rp, class _Class, class... _Param>
    struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile &&, true, false>
    {
        typedef _Class volatile &&_ClassType;
        typedef _Rp _ReturnType;
        typedef _Rp(_FnType)(_Param...);
    };
    template <class _Rp, class _Class, class... _Param>
    struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile &&, true, false>
    {
        typedef _Class volatile &&_ClassType;
        typedef _Rp _ReturnType;
        typedef _Rp(_FnType)(_Param..., ...);
    };
    template <class _Rp, class _Class, class... _Param>
    struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile &&, true, false>
    {
        typedef _Class const volatile &&_ClassType;
        typedef _Rp _ReturnType;
        typedef _Rp(_FnType)(_Param...);
    };
    template <class _Rp, class _Class, class... _Param>
    struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile &&, true, false>
    {
        typedef _Class const volatile &&_ClassType;
        typedef _Rp _ReturnType;
        typedef _Rp(_FnType)(_Param..., ...);
    };
    template <class _Rp, class _Class>
    struct __member_pointer_traits_imp<_Rp _Class::*, false, true>
    {
        typedef _Class _ClassType;
        typedef _Rp _ReturnType;
    };
    template <class _MP>
    struct __member_pointer_traits
        : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,
                                             is_member_function_pointer<_MP>::value,
                                             is_member_object_pointer<_MP>::value>
    {
    };
    template <class _DecayedFp>
    struct __member_pointer_class_type
    {
    };
    template <class _Ret, class _ClassType>
    struct __member_pointer_class_type<_Ret _ClassType::*>
    {
        typedef _ClassType type;
    };
    template <class _Fp, class _A0,
              class _DecayFp = typename decay<_Fp>::type,
              class _DecayA0 = typename decay<_A0>::type,
              class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
    using __enable_if_bullet1 = typename enable_if<
        is_member_function_pointer<_DecayFp>::value && is_base_of<_ClassT, _DecayA0>::value>::type;
    template <class _Fp, class _A0,
              class _DecayFp = typename decay<_Fp>::type,
              class _DecayA0 = typename decay<_A0>::type>
    using __enable_if_bullet2 = typename enable_if<
        is_member_function_pointer<_DecayFp>::value && __is_reference_wrapper<_DecayA0>::value>::type;
    template <class _Fp, class _A0,
              class _DecayFp = typename decay<_Fp>::type,
              class _DecayA0 = typename decay<_A0>::type,
              class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
    using __enable_if_bullet3 = typename enable_if<
        is_member_function_pointer<_DecayFp>::value && !is_base_of<_ClassT, _DecayA0>::value && !__is_reference_wrapper<_DecayA0>::value>::type;
    template <class _Fp, class _A0,
              class _DecayFp = typename decay<_Fp>::type,
              class _DecayA0 = typename decay<_A0>::type,
              class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
    using __enable_if_bullet4 = typename enable_if<
        is_member_object_pointer<_DecayFp>::value && is_base_of<_ClassT, _DecayA0>::value>::type;
    template <class _Fp, class _A0,
              class _DecayFp = typename decay<_Fp>::type,
              class _DecayA0 = typename decay<_A0>::type>
    using __enable_if_bullet5 = typename enable_if<
        is_member_object_pointer<_DecayFp>::value && __is_reference_wrapper<_DecayA0>::value>::type;
    template <class _Fp, class _A0,
              class _DecayFp = typename decay<_Fp>::type,
              class _DecayA0 = typename decay<_A0>::type,
              class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
    using __enable_if_bullet6 = typename enable_if<
        is_member_object_pointer<_DecayFp>::value && !is_base_of<_ClassT, _DecayA0>::value && !__is_reference_wrapper<_DecayA0>::value>::type;
    template <class... _Args>
    __nat __invoke(__any, _Args &&...__args);
    template <class _Fp, class _A0, class... _Args,
              class = __enable_if_bullet1<_Fp, _A0>>
    inline __decltype((std::declval<_A0>().*std::declval<_Fp>())(std::declval<_Args>()...))
    __invoke(_Fp &&__f, _A0 &&__a0, _Args &&...__args)
    {
        return (static_cast<_A0 &&>(__a0).*__f)(static_cast<_Args &&>(__args)...);
    }
    template <class _Fp, class _A0, class... _Args,
              class = __enable_if_bullet2<_Fp, _A0>>
    inline __decltype((std::declval<_A0>().get().*std::declval<_Fp>())(std::declval<_Args>()...))
    __invoke(_Fp &&__f, _A0 &&__a0, _Args &&...__args)
    {
        return (__a0.get().*__f)(static_cast<_Args &&>(__args)...);
    }
    template <class _Fp, class _A0, class... _Args,
              class = __enable_if_bullet3<_Fp, _A0>>
    inline __decltype(((*std::declval<_A0>()).*std::declval<_Fp>())(std::declval<_Args>()...))
    __invoke(_Fp &&__f, _A0 &&__a0, _Args &&...__args)
    {
        return ((*static_cast<_A0 &&>(__a0)).*__f)(static_cast<_Args &&>(__args)...);
    }
    template <class _Fp, class _A0,
              class = __enable_if_bullet4<_Fp, _A0>>
    inline __decltype(std::declval<_A0>().*std::declval<_Fp>())
    __invoke(_Fp &&__f, _A0 &&__a0)
    {
        return static_cast<_A0 &&>(__a0).*__f;
    }
    template <class _Fp, class _A0,
              class = __enable_if_bullet5<_Fp, _A0>>
    inline __decltype(std::declval<_A0>().get().*std::declval<_Fp>())
    __invoke(_Fp &&__f, _A0 &&__a0)
    {
        return __a0.get().*__f;
    }
    template <class _Fp, class _A0,
              class = __enable_if_bullet6<_Fp, _A0>>
    inline __decltype((*std::declval<_A0>()).*std::declval<_Fp>())
    __invoke(_Fp &&__f, _A0 &&__a0)
    {
        return (*static_cast<_A0 &&>(__a0)).*__f;
    }
    template <class _Fp, class... _Args>
    inline __decltype(std::declval<_Fp>()(std::declval<_Args>()...))
    __invoke(_Fp &&__f, _Args &&...__args)
    {
        return static_cast<_Fp &&>(__f)(static_cast<_Args &&>(__args)...);
    }
    template <class _Ret, class _Fp, class... _Args>
    struct __invokable_r
    {
        template <class _XFp, class... _XArgs>
        static __decltype(std::__invoke(declval<_XFp>(), declval<_XArgs>()...)) __try_call(int);
        template <class _XFp, class... _XArgs>
        static __nat __try_call(...);
        using _Result = __decltype(__try_call<_Fp, _Args...>(0));
        using type = typename conditional<
            _IsNotSame<_Result, __nat>::value,
            typename conditional<is_void<_Ret>::value, true_type, __is_core_convertible<_Result, _Ret>>::type,
            false_type>::type;
        static const bool value = type::value;
    };
    template <class _Fp, class... _Args>
    using __invokable = __invokable_r<void, _Fp, _Args...>;
    template <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class... _Args>
    struct __nothrow_invokable_r_imp
    {
        static const bool value = false;
    };
    template <class _Ret, class _Fp, class... _Args>
    struct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>
    {
        typedef __nothrow_invokable_r_imp _ThisT;
        template <class _Tp>
        static void __test_noexcept(_Tp) throw();
        static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(
            std::__invoke(declval<_Fp>(), declval<_Args>()...)));
    };
    template <class _Ret, class _Fp, class... _Args>
    struct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>
    {
        static const bool value = noexcept(
            std::__invoke(declval<_Fp>(), declval<_Args>()...));
    };
    template <class _Ret, class _Fp, class... _Args>
    using __nothrow_invokable_r =
        __nothrow_invokable_r_imp<
            __invokable_r<_Ret, _Fp, _Args...>::value,
            is_void<_Ret>::value,
            _Ret, _Fp, _Args...>;
    template <class _Fp, class... _Args>
    using __nothrow_invokable =
        __nothrow_invokable_r_imp<
            __invokable<_Fp, _Args...>::value,
            true, void, _Fp, _Args...>;
    template <class _Fp, class... _Args>
    struct __invoke_of
        : public enable_if<
              __invokable<_Fp, _Args...>::value,
              typename __invokable_r<void, _Fp, _Args...>::_Result>
    {
    };
    template <class _Ret, bool = is_void<_Ret>::value>
    struct __invoke_void_return_wrapper
    {
        template <class... _Args>
        static _Ret __call(_Args &&...__args)
        {
            return std::__invoke(std::forward<_Args>(__args)...);
        }
    };
    template <class _Ret>
    struct __invoke_void_return_wrapper<_Ret, true>
    {
        template <class... _Args>
        static void __call(_Args &&...__args)
        {
            std::__invoke(std::forward<_Args>(__args)...);
        }
    };
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp>
    struct add_const
    {
        typedef const _Tp type;
    };
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp>
    struct add_cv
    {
        typedef const volatile _Tp type;
    };
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_impl
    {
        typedef _Tp type;
    };
    template <class _Tp>
    struct __add_rvalue_reference_impl<_Tp, true>
    {
        typedef _Tp &&type;
    };
    template <class _Tp>
    struct add_rvalue_reference
    {
        typedef typename __add_rvalue_reference_impl<_Tp>::type type;
    };
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp>
    struct add_volatile
    {
        typedef volatile _Tp type;
    };
}
}
namespace std
{
inline namespace __1
{
    template <class _Hp, class _Tp>
    struct __type_list
    {
        typedef _Hp _Head;
        typedef _Tp _Tail;
    };
    template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)>
    struct __find_first;
    template <class _Hp, class _Tp, size_t _Size>
    struct __find_first<__type_list<_Hp, _Tp>, _Size, true>
    {
        typedef _Hp type;
    };
    template <class _Hp, class _Tp, size_t _Size>
    struct __find_first<__type_list<_Hp, _Tp>, _Size, false>
    {
        typedef typename __find_first<_Tp, _Size>::type type;
    };
}
}
namespace std
{
inline namespace __1
{
    template <class _Tp>
    struct __align_type
    {
        static const size_t value = __alignof(_Tp);
        typedef _Tp type;
    };
    struct __struct_double
    {
        long double __lx;
    };
    struct __struct_double4
    {
        double __lx[4];
    };
    typedef __type_list<__align_type<unsigned char>,
                        __type_list<__align_type<unsigned short>,
                                    __type_list<__align_type<unsigned int>,
                                                __type_list<__align_type<unsigned long>,
                                                            __type_list<__align_type<unsigned long long>,
                                                                        __type_list<__align_type<double>,
                                                                                    __type_list<__align_type<long double>,
                                                                                                __type_list<__align_type<__struct_double>,
                                                                                                            __type_list<__align_type<__struct_double4>,
                                                                                                                        __type_list<__align_type<int *>,
                                                                                                                                    __nat>>>>>>>>>>
        __all_types;
    template <size_t _Align>
    struct __fallback_overaligned
    {
    };
    template <class _TL, size_t _Align>
    struct __find_pod;
    template <class _Hp, size_t _Align>
    struct __find_pod<__type_list<_Hp, __nat>, _Align>
    {
        typedef typename conditional<
            _Align == _Hp::value,
            typename _Hp::type,
            __fallback_overaligned<_Align>>::type type;
    };
    template <class _Hp, class _Tp, size_t _Align>
    struct __find_pod<__type_list<_Hp, _Tp>, _Align>
    {
        typedef typename conditional<
            _Align == _Hp::value,
            typename _Hp::type,
            typename __find_pod<_Tp, _Align>::type>::type type;
    };
    template <class _TL, size_t _Len>
    struct __find_max_align;
    template <class _Hp, size_t _Len>
    struct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value>
    {
    };
    template <size_t _Len, size_t _A1, size_t _A2>
    struct __select_align
    {
    private:
        static const size_t __min = _A2 < _A1 ? _A2 : _A1;
        static const size_t __max = _A1 < _A2 ? _A2 : _A1;

    public:
        static const size_t value = _Len < __max ? __min : __max;
    };
    template <class _Hp, class _Tp, size_t _Len>
    struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
        : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value>
    {
    };
    template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
    struct aligned_storage
    {
        typedef typename __find_pod<__all_types, _Align>::type _Aligner;
        union type
        {
            _Aligner __align;
            unsigned char __data[(_Len + _Align - 1) / _Align * _Align];
        };
    };
template <size_t _Len>struct /0x1 * 0x1];
};
};
template <size_t _Len>struct /0x2 * 0x2];
}
;
}
;
template <size_t _Len>struct /0x4 * 0x4];
}
;
}
;
template <size_t _Len>struct /0x8 * 0x8];
}
;
}
;
template <size_t _Len>struct /0x10 * 0x10];
}
;
}
;
template <size_t _Len>struct /0x20 * 0x20];
}
;
}
;
template <size_t _Len>struct /0x40 * 0x40];
}
;
}
;
template <size_t _Len>struct /0x80 * 0x80];
}
;
}
;
template <size_t _Len>struct /0x100 * 0x100];
}
;
}
;
template <size_t _Len>struct /0x200 * 0x200];
}
;
}
;
template <size_t _Len>struct /0x400 * 0x400];
}
;
}
;
template <size_t _Len>struct /0x800 * 0x800];
}
;
}
;
template <size_t _Len>struct /0x1000 * 0x1000];
}
;
}
;
template <size_t _Len>struct /0x2000 * 0x2000];
}
;
}
;
template <size_t _Len>struct /0x4000 * 0x4000];
}
;
}
;
}
}
namespace std
{
inline namespace __1
{
template <size_t _I0, size_t... _In>
struct __static_max;
template <size_t _I0>
struct __static_max<_I0>
{
    static const size_t value = _I0;
};
template <size_t _I0, size_t _I1, size_t... _In>
struct __static_max<_I0, _I1, _In...>
{
    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value : __static_max<_I1, _In...>::value;
};
template <size_t _Len, class _Type0, class... _Types>
struct aligned_union
{
    static const size_t alignment_value = __static_max<__alignof(_Type0),
                                                       __alignof(_Types)...>::value;
    static const size_t __len = __static_max<_Len, sizeof(_Type0),
                                             sizeof(_Types)...>::value;
    typedef typename aligned_storage<__len, alignment_value>::type type;
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct alignment_of
    : public integral_constant<size_t, _Alignof(_Tp)>
{
};
}
}

namespace std
{
inline namespace __1
{
template <class _Tp>
using __uncvref_t = typename remove_cv<typename remove_reference<_Tp>::type>::type;
template <class _Tp, class _Up>
struct __is_same_uncvref : _IsSame<__uncvref_t<_Tp>, __uncvref_t<_Up>>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class>
struct __void_t
{
    typedef void type;
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp, class _Up, class = void>
struct __common_type2_imp
{
};
template <class _Tp, class _Up>
struct __common_type2_imp<_Tp, _Up,
                          typename __void_t<__decltype(true ? declval<_Tp>() : declval<_Up>())>::type>
{
    typedef > ::type type;
};
template <class, class = void>
struct __common_type_impl
{
};
template <class... _Tp>
struct __common_types;
template <class... _Tp>
struct common_type;
template <class _Tp, class _Up>
struct __common_type_impl<
    __common_types<_Tp, _Up>,
    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
{
    typedef typename common_type<_Tp, _Up>::type type;
};
template <class _Tp, class _Up, class _Vp, class... _Rest>
struct __common_type_impl<
    __common_types<_Tp, _Up, _Vp, _Rest...>,
    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
    : __common_type_impl<__common_types<typename common_type<_Tp, _Up>::type,
                                        _Vp, _Rest...>>
{
};
template <>
struct common_type<>
{
};
template <class _Tp>
struct common_type<_Tp>
    : public common_type<_Tp, _Tp>
{
};
template <class _Tp, class _Up>
struct common_type<_Tp, _Up>
    : conditional<
          _IsSame<_Tp, typename decay<_Tp>::type>::value && _IsSame<_Up, typename decay<_Up>::type>::value,
          __common_type2_imp<_Tp, _Up>,
          common_type<typename decay<_Tp>::type, typename decay<_Up>::type>>::type
{
};
template <class _Tp, class _Up, class _Vp, class... _Rest>
struct
    common_type<_Tp, _Up, _Vp, _Rest...>
    : __common_type_impl<
          __common_types<_Tp, _Up, _Vp, _Rest...>>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _From, class _To>
struct __copy_cv
{
    using type = _To;
};
template <class _From, class _To>
struct __copy_cv<const _From, _To>
{
    using type = typename add_const<_To>::type;
};
template <class _From, class _To>
struct __copy_cv<volatile _From, _To>
{
    using type = typename add_volatile<_To>::type;
};
template <class _From, class _To>
struct __copy_cv<const volatile _From, _To>
{
    using type = typename add_cv<_To>::type;
};
template <class _From, class _To>
using __copy_cv_t = typename __copy_cv<_From, _To>::type;
}
}
namespace std
{
inline namespace __1
{
template <class _From, class _To>
struct __copy_cvref
{
    using type = __copy_cv_t<_From, _To>;
};
template <class _From, class _To>
struct __copy_cvref<_From &, _To>
{
    using type = typename add_lvalue_reference<__copy_cv_t<_From, _To>>::type;
};
template <class _From, class _To>
struct __copy_cvref<_From &&, _To>
{
    using type = typename add_rvalue_reference<__copy_cv_t<_From, _To>>::type;
};
template <class _From, class _To>
using __copy_cvref_t = typename __copy_cvref<_From, _To>::type;
}
}
namespace std
{
inline namespace __1
{
template <class _T1, class _T2>
struct is_convertible
    : public integral_constant<bool, __is_convertible_to(_T1, _T2)>
{
};
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
template <class...>
using __expand_to_true = true_type;
template <class... _Pred>
__expand_to_true<__enable_if_t<_Pred::value>...> __and_helper(int);
template <class...>
false_type __and_helper(...);
template <class... _Pred>
using _And;
}
}

namespace std
{
inline namespace __1
{
template <bool>
struct _OrImpl;
template <>
struct _OrImpl<true>
{
    template <class _Res, class _First, class... _Rest>
    using _Result =
        typename _OrImpl<!bool(_First::value) && sizeof...(_Rest) != 0>::template _Result<_First, _Rest...>;
};
template <>
struct _OrImpl<false>
{
    template <class _Res, class...>
    using _Result = _Res;
};
template <class... _Args>
    using _Or != 0 > ::template _Result<false_type, _Args...>;
}
}

namespace std
{
inline namespace __1
{
template <class _Tp, size_t _Dim = 0>
struct extent
    : integral_constant<size_t, __array_extent(_Tp, _Dim)>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct remove_all_extents
{
    typedef _Tp type;
};
template <class _Tp>
struct remove_all_extents<_Tp[]>
{
    typedef typename remove_all_extents<_Tp>::type type;
};
template <class _Tp, size_t _Np>
struct remove_all_extents<_Tp[_Np]>
{
    typedef typename remove_all_extents<_Tp>::type type;
};
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
{
};
}
}

namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
{
};
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct __libcpp_is_floating_point : public false_type
{
};
template <>
struct __libcpp_is_floating_point<float> : public true_type
{
};
template <>
struct __libcpp_is_floating_point<double> : public true_type
{
};
template <>
struct __libcpp_is_floating_point<long double> : public true_type
{
};
template <class _Tp>
struct is_floating_point
    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_arithmetic
    : public integral_constant<bool, is_integral<_Tp>::value ||
                                         is_floating_point<_Tp>::value>
{
};
}
}

namespace std
{
inline namespace __1
{
template <typename, typename _Tp>
struct __select_2nd
{
    typedef _Tp type;
};
template <class _Tp, class _Up>
    struct > {};
}
}

namespace std
{
inline namespace __1
{
template <class>
struct __libcpp_is_bounded_array : false_type
{
};
template <class _Tp, size_t _Np>
struct __libcpp_is_bounded_array<_Tp[_Np]> : true_type
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Func, class... _Args, class = __decltype(std::declval<_Func>()(std::declval<_Args>()...))>
true_type __is_callable_helper(int);
template <class...>
false_type __is_callable_helper(...);
template <class _Func, class... _Args>
struct __is_callable : __decltype(__is_callable_helper<_Func, _Args...>(0))
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct __is_nullptr_t_impl : public false_type
{
};
template <>
struct __is_nullptr_t_impl<nullptr_t> : public true_type
{
};
template <class _Tp>
struct __is_nullptr_t
    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
    struct > {};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
    struct > {};
}
}

namespace std
{
inline namespace __1
{
inline bool __libcpp_is_constant_evaluated() throw() { return __builtin_is_constant_evaluated(); }
}
}
namespace std
{
inline namespace __1
{
template <class _Tp, class... _Args>
struct is_constructible
    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>
{
};
}
}

namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_copy_assignable
    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                           typename add_lvalue_reference<typename add_const<_Tp>::type>::type>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_copy_constructible
    : public is_constructible<_Tp,
                              typename add_lvalue_reference<typename add_const<_Tp>::type>::type>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_default_constructible
    : public is_constructible<_Tp>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class>
struct __is_destructible_apply
{
    typedef int type;
};
template <typename _Tp>
struct __is_destructor_wellformed
{
    template <typename _Tp1>
    static true_type __test(
        typename __is_destructible_apply<__decltype(declval<_Tp1 &>().~_Tp1())>::type);
    template <typename _Tp1>
    static false_type __test(...);
    static const bool value = __decltype(__test<_Tp>(12))::value;
};
template <class _Tp, bool>
struct __destructible_imp;
template <class _Tp>
struct __destructible_imp<_Tp, false>
    : public integral_constant<bool,
                               __is_destructor_wellformed<typename remove_all_extents<_Tp>::type>::value>
{
};
template <class _Tp>
struct __destructible_imp<_Tp, true>
    : public true_type
{
};
template <class _Tp, bool>
struct __destructible_false;
template <class _Tp>
struct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, is_reference<_Tp>::value>
{
};
template <class _Tp>
struct __destructible_false<_Tp, true> : public false_type
{
};
template <class _Tp>
struct is_destructible
    : public __destructible_false<_Tp, is_function<_Tp>::value>
{
};
template <class _Tp>
struct is_destructible<_Tp[]>
    : public false_type
{
};
template <>
struct is_destructible<void>
    : public false_type
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct
    __libcpp_is_final : public integral_constant<bool, __is_final(_Tp)>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
    struct > {};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_move_assignable
    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                           typename add_rvalue_reference<_Tp>::type>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_move_constructible
    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp, class _Arg>
struct is_nothrow_assignable
    : public integral_constant<bool, __is_nothrow_assignable(_Tp, _Arg)>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp, class... _Args>
struct is_nothrow_constructible
    : public integral_constant<bool, __is_nothrow_constructible(_Tp, _Args...)>
{
};
}
}
namespace std
{
inline namespace __1
{
template <template <class...> class _Func, class... _Args>
struct _Lazy : _Func<_Args...>
{
};
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_nothrow_copy_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
                                   typename add_lvalue_reference<typename add_const<_Tp>::type>::type>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_nothrow_copy_constructible
    : public is_nothrow_constructible<_Tp,
                                      typename add_lvalue_reference<typename add_const<_Tp>::type>::type>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_nothrow_default_constructible
    : public is_nothrow_constructible<_Tp>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
    struct > {};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
    struct > {};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct __libcpp_nothrow_destructor
    : public integral_constant<bool, is_scalar<_Tp>::value ||
                                         is_reference<_Tp>::value>
{
};
template <class _Tp>
struct is_nothrow_destructible
    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type>
{
};
template <class _Tp>
struct is_nothrow_destructible<_Tp[]>
    : public false_type
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_nothrow_move_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
                                   typename add_rvalue_reference<_Tp>::type>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_nothrow_move_constructible
    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
{
};
}
}

namespace std
{
inline namespace __1
{
template <class _Tp>
    struct > {};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
{
};
}
}

namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp, bool = is_enum<_Tp>::value>
struct __underlying_type_impl;
template <class _Tp>
struct __underlying_type_impl<_Tp, false>
{
};
template <class _Tp>
struct __underlying_type_impl<_Tp, true>
{
    typedef __underlying_type(_Tp) type;
};
template <class _Tp>
struct underlying_type : __underlying_type_impl<_Tp, is_enum<_Tp>::value>
{
};
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
    struct > {};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp, class _Arg>
struct is_trivially_assignable
    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp, class... _Args>
struct is_trivially_constructible
    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_trivially_copy_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
                                     typename add_lvalue_reference<typename add_const<_Tp>::type>::type>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_trivially_copy_constructible
    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_trivially_destructible
    : public integral_constant<bool, __is_trivially_destructible(_Tp)>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_trivially_move_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
                                     typename add_rvalue_reference<_Tp>::type>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_trivially_move_constructible
    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class>
struct __libcpp_is_unbounded_array : false_type
{
};
template <class _Tp>
struct __libcpp_is_unbounded_array<_Tp[]> : true_type
{
};
}
}

namespace std
{
inline namespace __1
{
template <class _Tp>
    struct > {};
}
}
namespace std
{
inline namespace __1
{
typedef __type_list<signed char,
                    __type_list<signed short,
                                __type_list<signed int,
                                            __type_list<signed long,
                                                        __type_list<signed long long,
                                                                    __type_list<__int128_t,
                                                                                __nat>>>>>>
    __signed_types;
template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_signed{};
template <class _Tp>
struct __make_signed<_Tp, true>
{
    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
};
template <>
struct __make_signed<bool, true>{};
template <>
struct __make_signed<signed short, true> { typedef short type; };
template <>
struct __make_signed<unsigned short, true> { typedef short type; };
template <>
struct __make_signed<signed int, true> { typedef int type; };
template <>
struct __make_signed<unsigned int, true> { typedef int type; };
template <>
struct __make_signed<signed long, true> { typedef long type; };
template <>
struct __make_signed<unsigned long, true> { typedef long type; };
template <>
struct __make_signed<signed long long, true> { typedef long long type; };
template <>
struct __make_signed<unsigned long long, true> { typedef long long type; };
template <>
struct __make_signed<__int128_t, true> { typedef __int128_t type; };
template <>
struct __make_signed<__uint128_t, true> { typedef __int128_t type; };
template <class _Tp>
struct make_signed
{
    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;
};
}
}
namespace std
{
inline namespace __1
{
typedef __type_list<unsigned char,
                    __type_list<unsigned short,
                                __type_list<unsigned int,
                                            __type_list<unsigned long,
                                                        __type_list<unsigned long long,
                                                                    __type_list<__uint128_t,
                                                                                __nat>>>>>>
    __unsigned_types;
template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_unsigned{};
template <class _Tp>
struct __make_unsigned<_Tp, true>
{
    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
};
template <>
struct __make_unsigned<bool, true>{};
template <>
struct __make_unsigned<signed short, true> { typedef unsigned short type; };
template <>
struct __make_unsigned<unsigned short, true> { typedef unsigned short type; };
template <>
struct __make_unsigned<signed int, true> { typedef unsigned int type; };
template <>
struct __make_unsigned<unsigned int, true> { typedef unsigned int type; };
template <>
struct __make_unsigned<signed long, true> { typedef unsigned long type; };
template <>
struct __make_unsigned<unsigned long, true> { typedef unsigned long type; };
template <>
struct __make_unsigned<signed long long, true> { typedef unsigned long long type; };
template <>
struct __make_unsigned<unsigned long long, true> { typedef unsigned long long type; };
template <>
struct __make_unsigned<__int128_t, true> { typedef __uint128_t type; };
template <>
struct __make_unsigned<__uint128_t, true> { typedef __uint128_t type; };
template <class _Tp>
struct make_unsigned
{
    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;
};
template <class _Tp, class _Up>
using __copy_unsigned_t = __conditional_t<is_unsigned<_Tp>::value, typename make_unsigned<_Up>::type, _Up>;
}
}
namespace std
{
inline namespace __1
{
template <class _Pred>
struct _Not : _BoolConstant<!_Pred::value>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct rank
    : public integral_constant<size_t, 0>
{
};
template <class _Tp>
struct rank<_Tp[]>
    : public integral_constant<size_t, rank<_Tp>::value + 1>
{
};
template <class _Tp, size_t _Np>
struct rank<_Tp[_Np]>
    : public integral_constant<size_t, rank<_Tp>::value + 1>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct _Tp type;
};
template <class _Tp>
struct _Tp type;
};
template <class _Tp>
struct _Tp type;
}
;
template <class _Tp>
struct _Tp type;
}
;
template <class _Tp>
struct _Tp type;
}
;
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct __type_identity
{
    typedef _Tp type;
};
template <class _Tp>
using __type_identity_t = typename __type_identity<_Tp>::type;
}
}
namespace std
{
inline namespace __1
{
using ::int16_t;
using ::int32_t;
using ::int64_t;
using ::int8_t;
using ::int_fast16_t;
using ::int_fast32_t;
using ::int_fast64_t;
using ::int_fast8_t;
using ::int_least16_t;
using ::int_least32_t;
using ::int_least64_t;
using ::int_least8_t;
using ::intmax_t;
using ::intptr_t;
using ::uint16_t;
using ::uint32_t;
using ::uint64_t;
using ::uint8_t;
using ::uint_fast16_t;
using ::uint_fast32_t;
using ::uint_fast64_t;
using ::uint_fast8_t;
using ::uint_least16_t;
using ::uint_least32_t;
using ::uint_least64_t;
using ::uint_least8_t;
using ::uintmax_t;
using ::uintptr_t;
}
}
namespace std
{
inline namespace __1
{
template <class _T1, class _T2>
struct pair;
template <class _Tp>
struct hash;
template <class _Tp, bool>
struct __dependent_type : public _Tp
{
};
template <class _Tp>
struct __unconstref
{
    typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;
};
template <class _Callable>
class result_of;
template <class _Fp, class... _Args>
    class >
    : public __invoke_of<_Fp, _Args...>{};
template <class _Tp>
struct __is_swappable;
template <class _Tp>
struct __is_nothrow_swappable;
template <class>
using __swap_result_t = void;
template <class _Tp>
inline __swap_result_t<_Tp>
swap(_Tp &__x, _Tp &__y);
template <class _Tp, size_t _Np>
inline
    typename enable_if<
        __is_swappable<_Tp>::value>::type
        swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]);
namespace __detail
{
    template <class _Tp, class _Up = _Tp,
              bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>
    struct __swappable_with
    {
        template <class _LHS, class _RHS>
        static __decltype(swap(declval<_LHS>(), declval<_RHS>()))
        __test_swap(int);
        template <class, class>
        static __nat __test_swap(long);
        typedef __decltype((__test_swap<_Tp, _Up>(0))) __swap1;
        typedef __decltype((__test_swap<_Up, _Tp>(0))) __swap2;
        static const bool value = _IsNotSame<__swap1, __nat>::value && _IsNotSame<__swap2, __nat>::value;
    };
    template <class _Tp, class _Up>
    struct __swappable_with<_Tp, _Up, false> : false_type
    {
    };
    template <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>
    struct __nothrow_swappable_with
    {
        static const bool value =
            false;
    };
    template <class _Tp, class _Up>
    struct __nothrow_swappable_with<_Tp, _Up, false> : false_type
    {
    };
}
template <class _Tp>
struct __is_swappable
    : public integral_constant<bool, __detail::__swappable_with<_Tp &>::value>
{
};
template <class _Tp>
struct __is_nothrow_swappable
    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp &>::value>
{
};
template <class _Tp, bool = is_enum<_Tp>::value>
struct __sfinae_underlying_type
{
    typedef typename underlying_type<_Tp>::type type;
    typedef __decltype(((type)1) + 0) __promoted_type;
};
template <class _Tp>
struct __sfinae_underlying_type<_Tp, false>
{
};
inline int __convert_to_integral(int __val) { return __val; }
inline unsigned __convert_to_integral(unsigned __val) { return __val; }
inline long __convert_to_integral(long __val) { return __val; }
inline unsigned long __convert_to_integral(unsigned long __val) { return __val; }
inline long long __convert_to_integral(long long __val) { return __val; }
inline unsigned long long __convert_to_integral(unsigned long long __val) { return __val; }
template <typename _Fp>
inline
    typename enable_if<is_floating_point<_Fp>::value, long long>::type
    __convert_to_integral(_Fp __val) { return __val; }
inline __int128_t __convert_to_integral(__int128_t __val) { return __val; }
inline __uint128_t __convert_to_integral(__uint128_t __val) { return __val; }
template <class _Tp>
inline
    typename __sfinae_underlying_type<_Tp>::__promoted_type
    __convert_to_integral(_Tp __val) { return __val; }
struct __extract_key_fail_tag
{
};
struct __extract_key_self_tag
{
};
struct __extract_key_first_tag
{
};
template <class _ValTy, class _Key,
          class _RawValTy = typename __unconstref<_ValTy>::type>
struct __can_extract_key
    : conditional<_IsSame<_RawValTy, _Key>::value, __extract_key_self_tag,
                  __extract_key_fail_tag>::type
{
};
template <class _Pair, class _Key, class _First, class _Second>
struct __can_extract_key<_Pair, _Key, pair<_First, _Second>>
    : conditional<_IsSame<typename remove_const<_First>::type, _Key>::value,
                  __extract_key_first_tag, __extract_key_fail_tag>::type
{
};
template <class _ValTy, class _Key, class _ContainerValueTy,
          class _RawValTy = typename __unconstref<_ValTy>::type>
struct __can_extract_map_key
    : integral_constant<bool, _IsSame<_RawValTy, _Key>::value>
{
};
template <class _ValTy, class _Key, class _RawValTy>
struct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>
    : false_type
{
};
template <class _CharT>
using _IsCharLikeType = _And<is_standard_layout<_CharT>, is_trivial<_CharT>>;
template <class _Tp>
using __make_const_lvalue_ref = const typename remove_reference<_Tp>::type &;
template <bool _Const, class _Tp>
using __maybe_const = typename conditional<_Const, const _Tp, _Tp>::type;
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
{
    (void)(__c);
}
template <class _Tp>
{
    (void)(__i);
}
template <class _Tp>
{
    (void)(__c);
}
template <class _Tp>
{
    (void)(__lhs);
    (void)(__rhs);
}
template <class _Tp>
{
    (void)(__c);
}
}
}
namespace std
{
inline namespace __1
{
template <class _Tp, size_t _Np>

_Tp *begin(_Tp (&__array)[_Np])
{
    return __array;
}
template <class _Tp, size_t _Np>

_Tp *end(_Tp (&__array)[_Np])
{
    return __array + _Np;
}
template <class _Cp>

typename _Cp::iterator
begin(_Cp &__c)
{
    return __c.begin();
}
template <class _Cp>

typename _Cp::const_iterator
begin(const _Cp &__c)
{
    return __c.begin();
}
template <class _Cp>

typename _Cp::iterator
end(_Cp &__c)
{
    return __c.end();
}
template <class _Cp>

typename _Cp::const_iterator
end(const _Cp &__c)
{
    return __c.end();
}
}
}
namespace std
{
inline namespace __1
{
template <template <class...> class _Templ, class... _Args, class = _Templ<_Args...>>
true_type __sfinae_test_impl(int);
template <template <class...> class, class...>
false_type __sfinae_test_impl(...);
template <template <class...> class _Templ, class... _Args>
using _IsValidExpansion;
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
using __test_for_primary_template = __enable_if_t<
    _IsSame<_Tp, typename _Tp::__primary_template>::value>;
template <class _Tp>
using __is_primary_template = _IsValidExpansion<
    __test_for_primary_template, _Tp>;
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct __libcpp_is_signed_integer : public false_type
{
};
template <>
struct __libcpp_is_signed_integer<signed char> : public true_type
{
};
template <>
struct __libcpp_is_signed_integer<signed short> : public true_type
{
};
template <>
struct __libcpp_is_signed_integer<signed int> : public true_type
{
};
template <>
struct __libcpp_is_signed_integer<signed long> : public true_type
{
};
template <>
struct __libcpp_is_signed_integer<signed long long> : public true_type
{
};
template <>
struct __libcpp_is_signed_integer<__int128_t> : public true_type
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct __libcpp_is_unsigned_integer : public false_type
{
};
template <>
struct __libcpp_is_unsigned_integer<unsigned char> : public true_type
{
};
template <>
struct __libcpp_is_unsigned_integer<unsigned short> : public true_type
{
};
template <>
struct __libcpp_is_unsigned_integer<unsigned int> : public true_type
{
};
template <>
struct __libcpp_is_unsigned_integer<unsigned long> : public true_type
{
};
template <>
struct __libcpp_is_unsigned_integer<unsigned long long> : public true_type
{
};
template <>
struct __libcpp_is_unsigned_integer<__uint128_t> : public true_type
{
};
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}

namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}

namespace std
{
inline namespace __1
{
template <class _Tp>
inline typename remove_reference<_Tp>::type &&
move(_Tp &&__t) throw()
{
    typedef typename remove_reference<_Tp>::type _Up;
    return static_cast<_Up &&>(__t);
}
template <class _Tp>
using __move_if_noexcept_result_t =
    typename conditional<!is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value, const _Tp &,
                         _Tp &&>::type;
template <class _Tp>
inline __move_if_noexcept_result_t<_Tp>
move_if_noexcept(_Tp &__x) throw()
{
    return std::move(__x);
}
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}

namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}

namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
template <class _Iter>
struct iterator_traits;
struct input_iterator_tag
{
};
struct output_iterator_tag
{
};
struct forward_iterator_tag : public input_iterator_tag
{
};
struct bidirectional_iterator_tag : public forward_iterator_tag
{
};
struct random_access_iterator_tag : public bidirectional_iterator_tag
{
};
template <class _Iter>
struct __iter_traits_cache
{
    using type = _If<
        __is_primary_template<iterator_traits<_Iter>>::value,
        _Iter,
        iterator_traits<_Iter>>;
};
template <class _Iter>
using _ITER_TRAITS = typename __iter_traits_cache<_Iter>::type;
struct __iter_concept_concept_test
{
    template <class _Iter>
    using _Apply = typename _ITER_TRAITS<_Iter>::iterator_concept;
};
struct __iter_concept_category_test
{
    template <class _Iter>
    using _Apply = typename _ITER_TRAITS<_Iter>::iterator_category;
};
struct __iter_concept_random_fallback
{
    template <class _Iter>
    using _Apply = __enable_if_t<
        __is_primary_template<iterator_traits<_Iter>>::value,
        random_access_iterator_tag>;
};
template <class _Iter, class _Tester>
struct __test_iter_concept
    : _IsValidExpansion<_Tester::template _Apply, _Iter>,
      _Tester
{
};
template <class _Iter>
struct __iter_concept_cache
{
    using type = _Or<
        __test_iter_concept<_Iter, __iter_concept_concept_test>,
        __test_iter_concept<_Iter, __iter_concept_category_test>,
        __test_iter_concept<_Iter, __iter_concept_random_fallback>>;
};
template <class _Iter>
using _ITER_CONCEPT = typename __iter_concept_cache<_Iter>::type::template _Apply<_Iter>;
template <class _Tp>
struct __has_iterator_typedefs
{
private:
    template <class _Up>
    static false_type __test(...);
    template <class _Up>
    static true_type __test(typename __void_t<typename _Up::iterator_category>::type * = 0,
                            typename __void_t<typename _Up::difference_type>::type * = 0,
                            typename __void_t<typename _Up::value_type>::type * = 0,
                            typename __void_t<typename _Up::reference>::type * = 0,
                            typename __void_t<typename _Up::pointer>::type * = 0);

public:
    static const bool value = __decltype(__test<_Tp>(0, 0, 0, 0, 0))::value;
};
template <class _Tp>
struct __has_iterator_category
{
private:
    template <class _Up>
    static false_type __test(...);
    template <class _Up>
    static true_type __test(typename _Up::iterator_category * = __nullptr);

public:
    static const bool value = __decltype(__test<_Tp>(__nullptr))::value;
};
template <class _Tp>
struct __has_iterator_concept
{
private:
    template <class _Up>
    static false_type __test(...);
    template <class _Up>
    static true_type __test(typename _Up::iterator_concept * = __nullptr);

public:
    static const bool value = __decltype(__test<_Tp>(__nullptr))::value;
};
template <class _Iter, bool>
struct __iterator_traits
{
};
template <class _Iter, bool>
struct __iterator_traits_impl
{
};
template <class _Iter>
struct __iterator_traits_impl<_Iter, true>
{
    typedef typename _Iter::difference_type difference_type;
    typedef typename _Iter::value_type value_type;
    typedef typename _Iter::pointer pointer;
    typedef typename _Iter::reference reference;
    typedef typename _Iter::iterator_category iterator_category;
};
template <class _Iter>
struct __iterator_traits<_Iter, true>
    : __iterator_traits_impl<
          _Iter,
          is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||
              is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value>
{
};
template <class _Iter>
struct iterator_traits
    : __iterator_traits<_Iter, __has_iterator_typedefs<_Iter>::value>
{
    using __primary_template = iterator_traits;
};
template <class _Tp>
struct iterator_traits<_Tp *>
{
    typedef ptrdiff_t difference_type;
    typedef typename remove_cv<_Tp>::type value_type;
    typedef _Tp *pointer;
    typedef _Tp &reference;
    typedef random_access_iterator_tag iterator_category;
};
template <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp>>::value>
struct __has_iterator_category_convertible_to
    : is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>
{
};
template <class _Tp, class _Up>
struct __has_iterator_category_convertible_to<_Tp, _Up, false> : false_type
{
};
template <class _Tp, class _Up, bool = __has_iterator_concept<_Tp>::value>
struct __has_iterator_concept_convertible_to
    : is_convertible<typename _Tp::iterator_concept, _Up>
{
};
template <class _Tp, class _Up>
struct __has_iterator_concept_convertible_to<_Tp, _Up, false> : false_type
{
};
template <class _Tp>
struct __is_cpp17_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag>
{
};
template <class _Tp>
struct __is_cpp17_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag>
{
};
template <class _Tp>
struct __is_cpp17_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag>
{
};
template <class _Tp>
struct __is_cpp17_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag>
{
};
template <class _Tp>
struct __is_cpp17_contiguous_iterator : false_type
{
};
template <class _Up>
struct __is_cpp17_contiguous_iterator<_Up *> : true_type
{
};
template <class _Iter>
class __wrap_iter;
template <class _Tp>
struct __is_exactly_cpp17_input_iterator
    : public integral_constant<bool,
                               __has_iterator_category_convertible_to<_Tp, input_iterator_tag>::value &&
                                   !__has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value>
{
};
template <class _Tp>
struct __is_exactly_cpp17_forward_iterator
    : public integral_constant<bool,
                               __has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value &&
                                   !__has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag>::value>
{
};
template <class _Tp>
struct __is_exactly_cpp17_bidirectional_iterator
    : public integral_constant<bool,
                               __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag>::value &&
                                   !__has_iterator_category_convertible_to<_Tp, random_access_iterator_tag>::value>
{
};
template <class _InputIterator>
using __iter_value_type = typename iterator_traits<_InputIterator>::value_type;
template <class _InputIterator>
using __iter_key_type = typename remove_const<typename iterator_traits<_InputIterator>::value_type::first_type>::type;
template <class _InputIterator>
using __iter_mapped_type = typename iterator_traits<_InputIterator>::value_type::second_type;
template <class _InputIterator>
using __iter_to_alloc_type = pair<
    typename add_const<typename iterator_traits<_InputIterator>::value_type::first_type>::type,
    typename iterator_traits<_InputIterator>::value_type::second_type>;
template <class _Iter>
using __iterator_category_type = typename iterator_traits<_Iter>::iterator_category;
template <class _Iter>
using __iterator_pointer_type = typename iterator_traits<_Iter>::pointer;
template <class _Iter>
using __iter_diff_t = typename iterator_traits<_Iter>::difference_type;
template <class _InputIterator>
using __iter_value_type = typename iterator_traits<_InputIterator>::value_type;
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
inline

    _Tp *
    addressof(_Tp &__x) throw()
{
    return __builtin_addressof(__x);
}
}
}
namespace std
{
inline namespace __1
{
template <class _Tp, class = void>
struct __has_element_type : false_type
{
};
template <class _Tp>
struct __has_element_type<_Tp,
                          typename __void_t<typename _Tp::element_type>::type> : true_type
{
};
template <class _Ptr, bool = __has_element_type<_Ptr>::value>
struct __pointer_traits_element_type;
template <class _Ptr>
struct __pointer_traits_element_type<_Ptr, true>
{
    typedef typename _Ptr::element_type type;
};
template <template <class, class...> class _Sp, class _Tp, class... _Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>
{
    typedef typename _Sp<_Tp, _Args...>::element_type type;
};
template <template <class, class...> class _Sp, class _Tp, class... _Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>
{
    typedef _Tp type;
};
template <class _Tp, class = void>
struct __has_difference_type : false_type
{
};
template <class _Tp>
struct __has_difference_type<_Tp,
                             typename __void_t<typename _Tp::difference_type>::type> : true_type
{
};
template <class _Ptr, bool = __has_difference_type<_Ptr>::value>
struct __pointer_traits_difference_type
{
    typedef ptrdiff_t type;
};
template <class _Ptr>
struct __pointer_traits_difference_type<_Ptr, true>
{
    typedef typename _Ptr::difference_type type;
};
template <class _Tp, class _Up>
struct __has_rebind
{
private:
    template <class _Xp>
    static false_type __test(...);
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    template <class _Xp>
    static true_type __test(typename _Xp::template rebind<_Up> * = 0);
#pragma GCC diagnostic pop
public:
    static const bool value = __decltype(__test<_Tp>(0))::value;
};
template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __pointer_traits_rebind
{
    typedef typename _Tp::template rebind<_Up>::other type;
};
template <template <class, class...> class _Sp, class _Tp, class... _Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>
{
    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;
};
template <template <class, class...> class _Sp, class _Tp, class... _Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>
{
    typedef _Sp<_Up, _Args...> type;
};
template <class _Ptr>
struct pointer_traits
{
    typedef _Ptr pointer;
    typedef typename __pointer_traits_element_type<pointer>::type element_type;
    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;
    template <class _Up>
    struct rebind
    {
        typedef typename __pointer_traits_rebind<pointer, _Up>::type other;
    };

private:
    struct __nat
    {
    };

public:
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                                   __nat, element_type>::type &__r)
    {
        return pointer::pointer_to(__r);
    }
};
template <class _Tp>
struct pointer_traits<_Tp *>
{
    typedef _Tp *pointer;
    typedef _Tp element_type;
    typedef ptrdiff_t difference_type;
    template <class _Up>
    struct rebind
    {
        typedef _Up *other;
    };

private:
    struct __nat
    {
    };

public:
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                                   __nat, element_type>::type &__r) throw()
    {
        return std::addressof(__r);
    }
};
template <class _From, class _To>
struct __rebind_pointer
{
    typedef typename pointer_traits<_From>::template rebind<_To>::other type;
};
template <class _Pointer, class = void>
struct __to_address_helper;
template <class _Tp>

_Tp *__to_address(_Tp *__p) throw()
{
    _Static_assert(!is_function<_Tp>::value, "_Tp is a function type");
    return __p;
}
template <class _Pointer, class = void>
struct _HasToAddress : false_type
{
};
template <class _Pointer>
struct _HasToAddress<_Pointer,
                     __decltype((void)pointer_traits<_Pointer>::to_address(declval<const _Pointer &>()))> : true_type
{
};
template <class _Pointer, class = void>
struct _HasArrow : false_type
{
};
template <class _Pointer>
struct _HasArrow<_Pointer,
                 __decltype((void)declval<const _Pointer &>().operator->())> : true_type
{
};
template <class _Pointer>
struct _IsFancyPointer
{
    static const bool value = _HasArrow<_Pointer>::value || _HasToAddress<_Pointer>::value;
};
template <class _Pointer, class = __enable_if_t<
                              _And<is_class<_Pointer>, _IsFancyPointer<_Pointer>>::value>>

typename decay<__decltype(__to_address_helper<_Pointer>::__call(declval<const _Pointer &>()))>::type
__to_address(const _Pointer &__p) throw()
{
    return __to_address_helper<_Pointer>::__call(__p);
}
template <class _Pointer, class>
struct __to_address_helper
{

    static __decltype(std::__to_address(declval<const _Pointer &>().operator->()))
        __call(const _Pointer &__p) throw()
    {
        return std::__to_address(__p.operator->());
    }
};
template <class _Pointer>
struct __to_address_helper<_Pointer, __decltype((void)pointer_traits<_Pointer>::to_address(declval<const _Pointer &>()))>
{

    static __decltype(pointer_traits<_Pointer>::to_address(declval<const _Pointer &>()))
    __call(const _Pointer &__p) throw()
    {
        return pointer_traits<_Pointer>::to_address(__p);
    }
};
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{

{
    __builtin_unreachable();
}
}
}
namespace std
{
inline namespace __1
{
enum float_round_style
{
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
};
enum float_denorm_style
{
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
};
template <class _Tp, bool = is_arithmetic<_Tp>::value>
class __libcpp_numeric_limits
{
protected:
    typedef _Tp type;
    static const bool is_specialized = false;
    ;
};
};
}
static const int digits = 0;
static const int digits10 = 0;
static const int max_digits10 = 0;
static const bool is_signed = false;
static const bool is_integer = false;
static const bool is_exact = false;
static const int radix = 0;
;
}
;
}
static const int min_exponent = 0;
static const int min_exponent10 = 0;
static const int max_exponent = 0;
static const int max_exponent10 = 0;
static const bool has_infinity = false;
static const bool has_quiet_NaN = false;
static const bool has_signaling_NaN = false;
static const float_denorm_style has_denorm = denorm_absent;
static const bool has_denorm_loss = false;
;
}
;
}
;
}
;
}
static const bool is_iec559 = false;
static const bool is_bounded = false;
static const bool is_modulo = false;
static const bool traps = false;
static const bool tinyness_before = false;
static const float_round_style round_style = round_toward_zero;
}
;
template <class _Tp, int __digits, bool _IsSigned>
struct __libcpp_compute_min
{
static const _Tp value = _Tp(_Tp(1) << __digits);
};
template <class _Tp, int __digits>
struct __libcpp_compute_min<_Tp, __digits, false>
{
static const _Tp value = _Tp(0);
};
template <class _Tp>
class __libcpp_numeric_limits<_Tp, true>
{
protected:
typedef _Tp type;
static const bool is_specialized = true;
static const bool is_signed = type(-1) < type(0);
static const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
static const int digits10 = digits * 3 / 10;
static const int max_digits10 = 0;
static const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
static const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
{
return __min;
}
{
return __max;
};
} static const bool is_integer = true;
static const bool is_exact = true;
static const int radix = 2;
;
}
;
}
static const int min_exponent = 0;
static const int min_exponent10 = 0;
static const int max_exponent = 0;
static const int max_exponent10 = 0;
static const bool has_infinity = false;
static const bool has_quiet_NaN = false;
static const bool has_signaling_NaN = false;
static const float_denorm_style has_denorm = denorm_absent;
static const bool has_denorm_loss = false;
;
}
;
}
;
}
;
}
static const bool is_iec559 = false;
static const bool is_bounded = true;
static const bool is_modulo = !std::is_signed<_Tp>::value;
static const bool traps = false;
static const bool tinyness_before = false;
static const float_round_style round_style = round_toward_zero;
}
;
template <>
class __libcpp_numeric_limits<bool, true>
{
protected:
typedef bool type;
static const bool is_specialized = true;
static const bool is_signed = false;
static const int digits = 1;
static const int digits10 = 0;
static const int max_digits10 = 0;
static const type __min = false;
static const type __max = true;
{
return __min;
}
{
return __max;
};
} static const bool is_integer = true;
static const bool is_exact = true;
static const int radix = 2;
;
}
;
}
static const int min_exponent = 0;
static const int min_exponent10 = 0;
static const int max_exponent = 0;
static const int max_exponent10 = 0;
static const bool has_infinity = false;
static const bool has_quiet_NaN = false;
static const bool has_signaling_NaN = false;
static const float_denorm_style has_denorm = denorm_absent;
static const bool has_denorm_loss = false;
;
}
;
}
;
}
;
}
static const bool is_iec559 = false;
static const bool is_bounded = true;
static const bool is_modulo = false;
static const bool traps = false;
static const bool tinyness_before = false;
static const float_round_style round_style = round_toward_zero;
}
;
template <>
class __libcpp_numeric_limits<float, true>
{
protected:
typedef float type;
static const bool is_specialized = true;
static const bool is_signed = true;
static const int digits = 24;
static const int digits10 = 6;
static const int max_digits10 = 2 + (digits * 30103l) / 100000l;
{
return 1.17549435e-38F;
}
{
return 3.40282347e+38F;
};
} static const bool is_integer = false;
static const bool is_exact = false;
static const int radix = 2;
{
return 1.19209290e-7F;
}
{
return 0.5F;
}
static const int min_exponent = (-125);
static const int min_exponent10 = (-37);
static const int max_exponent = 128;
static const int max_exponent10 = 38;
static const bool has_infinity = true;
static const bool has_quiet_NaN = true;
static const bool has_signaling_NaN = true;
static const float_denorm_style has_denorm = denorm_present;
static const bool has_denorm_loss = false;
;
}
;
}
;
}
{
return 1.40129846e-45F;
}
static const bool is_iec559 = true;
static const bool is_bounded = true;
static const bool is_modulo = false;
static const bool traps = false;
static const bool tinyness_before = true;
static const float_round_style round_style = round_to_nearest;
}
;
template <>
class __libcpp_numeric_limits<double, true>
{
protected:
typedef double type;
static const bool is_specialized = true;
static const bool is_signed = true;
static const int digits = 53;
static const int digits10 = 15;
static const int max_digits10 = 2 + (digits * 30103l) / 100000l;
{
return 2.2250738585072014e-308;
}
{
return 1.7976931348623157e+308;
};
} static const bool is_integer = false;
static const bool is_exact = false;
static const int radix = 2;
{
return 2.2204460492503131e-16;
}
{
return 0.5;
}
static const int min_exponent = (-1021);
static const int min_exponent10 = (-307);
static const int max_exponent = 1024;
static const int max_exponent10 = 308;
static const bool has_infinity = true;
static const bool has_quiet_NaN = true;
static const bool has_signaling_NaN = true;
static const float_denorm_style has_denorm = denorm_present;
static const bool has_denorm_loss = false;
;
}
;
}
;
}
{
return 4.9406564584124654e-324;
}
static const bool is_iec559 = true;
static const bool is_bounded = true;
static const bool is_modulo = false;
static const bool traps = false;
static const bool tinyness_before = true;
static const float_round_style round_style = round_to_nearest;
}
;
template <>
class __libcpp_numeric_limits<long double, true>
{
protected:
typedef long double type;
static const bool is_specialized = true;
static const bool is_signed = true;
static const int digits = 53;
static const int digits10 = 15;
static const int max_digits10 = 2 + (digits * 30103l) / 100000l;
{
return 2.2250738585072014e-308L;
}
{
return 1.7976931348623157e+308L;
};
} static const bool is_integer = false;
static const bool is_exact = false;
static const int radix = 2;
{
return 2.2204460492503131e-16L;
}
{
return 0.5L;
}
static const int min_exponent = (-1021);
static const int min_exponent10 = (-307);
static const int max_exponent = 1024;
static const int max_exponent10 = 308;
static const bool has_infinity = true;
static const bool has_quiet_NaN = true;
static const bool has_signaling_NaN = true;
static const float_denorm_style has_denorm = denorm_present;
static const bool has_denorm_loss = false;
;
}
;
}
;
}
{
return 4.9406564584124654e-324L;
}
static const bool is_iec559 = true;
static const bool is_bounded = true;
static const bool is_modulo = false;
static const bool traps = false;
static const bool tinyness_before = true;
static const float_round_style round_style = round_to_nearest;
}
;
template <class _Tp>
class numeric_limits
    : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type>
{
typedef __libcpp_numeric_limits<typename remove_cv<_Tp>::type> __base;
typedef typename __base::type type;

public:
static const bool is_specialized = __base::is_specialized;
;
};
}
;
}
static const int digits = __base::digits;
static const int digits10 = __base::digits10;
static const int max_digits10 = __base::max_digits10;
static const bool is_signed = __base::is_signed;
static const bool is_integer = __base::is_integer;
static const bool is_exact = __base::is_exact;
static const int radix = __base::radix;
;
}
;
}
static const int min_exponent = __base::min_exponent;
static const int min_exponent10 = __base::min_exponent10;
static const int max_exponent = __base::max_exponent;
static const int max_exponent10 = __base::max_exponent10;
static const bool has_infinity = __base::has_infinity;
static const bool has_quiet_NaN = __base::has_quiet_NaN;
static const bool has_signaling_NaN = __base::has_signaling_NaN;
static const float_denorm_style has_denorm = __base::has_denorm;
static const bool has_denorm_loss = __base::has_denorm_loss;
;
}
;
}
;
}
;
}
static const bool is_iec559 = __base::is_iec559;
static const bool is_bounded = __base::is_bounded;
static const bool is_modulo = __base::is_modulo;
static const bool traps = __base::traps;
static const bool tinyness_before = __base::tinyness_before;
static const float_round_style round_style = __base::round_style;
}
;
template <class _Tp>
const bool numeric_limits<_Tp>::is_specialized;
template <class _Tp>
const int numeric_limits<_Tp>::digits;
template <class _Tp>
const int numeric_limits<_Tp>::digits10;
template <class _Tp>
const int numeric_limits<_Tp>::max_digits10;
template <class _Tp>
const bool numeric_limits<_Tp>::is_signed;
template <class _Tp>
const bool numeric_limits<_Tp>::is_integer;
template <class _Tp>
const bool numeric_limits<_Tp>::is_exact;
template <class _Tp>
const int numeric_limits<_Tp>::radix;
template <class _Tp>
const int numeric_limits<_Tp>::min_exponent;
template <class _Tp>
const int numeric_limits<_Tp>::min_exponent10;
template <class _Tp>
const int numeric_limits<_Tp>::max_exponent;
template <class _Tp>
const int numeric_limits<_Tp>::max_exponent10;
template <class _Tp>
const bool numeric_limits<_Tp>::has_infinity;
template <class _Tp>
const bool numeric_limits<_Tp>::has_quiet_NaN;
template <class _Tp>
const bool numeric_limits<_Tp>::has_signaling_NaN;
template <class _Tp>
const float_denorm_style numeric_limits<_Tp>::has_denorm;
template <class _Tp>
const bool numeric_limits<_Tp>::has_denorm_loss;
template <class _Tp>
const bool numeric_limits<_Tp>::is_iec559;
template <class _Tp>
const bool numeric_limits<_Tp>::is_bounded;
template <class _Tp>
const bool numeric_limits<_Tp>::is_modulo;
template <class _Tp>
const bool numeric_limits<_Tp>::traps;
template <class _Tp>
const bool numeric_limits<_Tp>::tinyness_before;
template <class _Tp>
const float_round_style numeric_limits<_Tp>::round_style;
template <class _Tp>
class numeric_limits<const _Tp>
    : private numeric_limits<_Tp>
{
typedef numeric_limits<_Tp> __base;
typedef _Tp type;

public:
static const bool is_specialized = __base::is_specialized;
;
};
}
;
}
static const int digits = __base::digits;
static const int digits10 = __base::digits10;
static const int max_digits10 = __base::max_digits10;
static const bool is_signed = __base::is_signed;
static const bool is_integer = __base::is_integer;
static const bool is_exact = __base::is_exact;
static const int radix = __base::radix;
;
}
;
}
static const int min_exponent = __base::min_exponent;
static const int min_exponent10 = __base::min_exponent10;
static const int max_exponent = __base::max_exponent;
static const int max_exponent10 = __base::max_exponent10;
static const bool has_infinity = __base::has_infinity;
static const bool has_quiet_NaN = __base::has_quiet_NaN;
static const bool has_signaling_NaN = __base::has_signaling_NaN;
static const float_denorm_style has_denorm = __base::has_denorm;
static const bool has_denorm_loss = __base::has_denorm_loss;
;
}
;
}
;
}
;
}
static const bool is_iec559 = __base::is_iec559;
static const bool is_bounded = __base::is_bounded;
static const bool is_modulo = __base::is_modulo;
static const bool traps = __base::traps;
static const bool tinyness_before = __base::tinyness_before;
static const float_round_style round_style = __base::round_style;
}
;
template <class _Tp>
const bool numeric_limits<const _Tp>::is_specialized;
template <class _Tp>
const int numeric_limits<const _Tp>::digits;
template <class _Tp>
const int numeric_limits<const _Tp>::digits10;
template <class _Tp>
const int numeric_limits<const _Tp>::max_digits10;
template <class _Tp>
const bool numeric_limits<const _Tp>::is_signed;
template <class _Tp>
const bool numeric_limits<const _Tp>::is_integer;
template <class _Tp>
const bool numeric_limits<const _Tp>::is_exact;
template <class _Tp>
const int numeric_limits<const _Tp>::radix;
template <class _Tp>
const int numeric_limits<const _Tp>::min_exponent;
template <class _Tp>
const int numeric_limits<const _Tp>::min_exponent10;
template <class _Tp>
const int numeric_limits<const _Tp>::max_exponent;
template <class _Tp>
const int numeric_limits<const _Tp>::max_exponent10;
template <class _Tp>
const bool numeric_limits<const _Tp>::has_infinity;
template <class _Tp>
const bool numeric_limits<const _Tp>::has_quiet_NaN;
template <class _Tp>
const bool numeric_limits<const _Tp>::has_signaling_NaN;
template <class _Tp>
const float_denorm_style numeric_limits<const _Tp>::has_denorm;
template <class _Tp>
const bool numeric_limits<const _Tp>::has_denorm_loss;
template <class _Tp>
const bool numeric_limits<const _Tp>::is_iec559;
template <class _Tp>
const bool numeric_limits<const _Tp>::is_bounded;
template <class _Tp>
const bool numeric_limits<const _Tp>::is_modulo;
template <class _Tp>
const bool numeric_limits<const _Tp>::traps;
template <class _Tp>
const bool numeric_limits<const _Tp>::tinyness_before;
template <class _Tp>
const float_round_style numeric_limits<const _Tp>::round_style;
template <class _Tp>
class numeric_limits<volatile _Tp>
    : private numeric_limits<_Tp>
{
typedef numeric_limits<_Tp> __base;
typedef _Tp type;

public:
static const bool is_specialized = __base::is_specialized;
;
};
}
;
}
static const int digits = __base::digits;
static const int digits10 = __base::digits10;
static const int max_digits10 = __base::max_digits10;
static const bool is_signed = __base::is_signed;
static const bool is_integer = __base::is_integer;
static const bool is_exact = __base::is_exact;
static const int radix = __base::radix;
;
}
;
}
static const int min_exponent = __base::min_exponent;
static const int min_exponent10 = __base::min_exponent10;
static const int max_exponent = __base::max_exponent;
static const int max_exponent10 = __base::max_exponent10;
static const bool has_infinity = __base::has_infinity;
static const bool has_quiet_NaN = __base::has_quiet_NaN;
static const bool has_signaling_NaN = __base::has_signaling_NaN;
static const float_denorm_style has_denorm = __base::has_denorm;
static const bool has_denorm_loss = __base::has_denorm_loss;
;
}
;
}
;
}
;
}
static const bool is_iec559 = __base::is_iec559;
static const bool is_bounded = __base::is_bounded;
static const bool is_modulo = __base::is_modulo;
static const bool traps = __base::traps;
static const bool tinyness_before = __base::tinyness_before;
static const float_round_style round_style = __base::round_style;
}
;
template <class _Tp>
const bool numeric_limits<volatile _Tp>::is_specialized;
template <class _Tp>
const int numeric_limits<volatile _Tp>::digits;
template <class _Tp>
const int numeric_limits<volatile _Tp>::digits10;
template <class _Tp>
const int numeric_limits<volatile _Tp>::max_digits10;
template <class _Tp>
const bool numeric_limits<volatile _Tp>::is_signed;
template <class _Tp>
const bool numeric_limits<volatile _Tp>::is_integer;
template <class _Tp>
const bool numeric_limits<volatile _Tp>::is_exact;
template <class _Tp>
const int numeric_limits<volatile _Tp>::radix;
template <class _Tp>
const int numeric_limits<volatile _Tp>::min_exponent;
template <class _Tp>
const int numeric_limits<volatile _Tp>::min_exponent10;
template <class _Tp>
const int numeric_limits<volatile _Tp>::max_exponent;
template <class _Tp>
const int numeric_limits<volatile _Tp>::max_exponent10;
template <class _Tp>
const bool numeric_limits<volatile _Tp>::has_infinity;
template <class _Tp>
const bool numeric_limits<volatile _Tp>::has_quiet_NaN;
template <class _Tp>
const bool numeric_limits<volatile _Tp>::has_signaling_NaN;
template <class _Tp>
const float_denorm_style numeric_limits<volatile _Tp>::has_denorm;
template <class _Tp>
const bool numeric_limits<volatile _Tp>::has_denorm_loss;
template <class _Tp>
const bool numeric_limits<volatile _Tp>::is_iec559;
template <class _Tp>
const bool numeric_limits<volatile _Tp>::is_bounded;
template <class _Tp>
const bool numeric_limits<volatile _Tp>::is_modulo;
template <class _Tp>
const bool numeric_limits<volatile _Tp>::traps;
template <class _Tp>
const bool numeric_limits<volatile _Tp>::tinyness_before;
template <class _Tp>
const float_round_style numeric_limits<volatile _Tp>::round_style;
template <class _Tp>
class numeric_limits<const volatile _Tp>
    : private numeric_limits<_Tp>
{
typedef numeric_limits<_Tp> __base;
typedef _Tp type;

public:
static const bool is_specialized = __base::is_specialized;
;
};
}
;
}
static const int digits = __base::digits;
static const int digits10 = __base::digits10;
static const int max_digits10 = __base::max_digits10;
static const bool is_signed = __base::is_signed;
static const bool is_integer = __base::is_integer;
static const bool is_exact = __base::is_exact;
static const int radix = __base::radix;
;
}
;
}
static const int min_exponent = __base::min_exponent;
static const int min_exponent10 = __base::min_exponent10;
static const int max_exponent = __base::max_exponent;
static const int max_exponent10 = __base::max_exponent10;
static const bool has_infinity = __base::has_infinity;
static const bool has_quiet_NaN = __base::has_quiet_NaN;
static const bool has_signaling_NaN = __base::has_signaling_NaN;
static const float_denorm_style has_denorm = __base::has_denorm;
static const bool has_denorm_loss = __base::has_denorm_loss;
;
}
;
}
;
}
;
}
static const bool is_iec559 = __base::is_iec559;
static const bool is_bounded = __base::is_bounded;
static const bool is_modulo = __base::is_modulo;
static const bool traps = __base::traps;
static const bool tinyness_before = __base::tinyness_before;
static const float_round_style round_style = __base::round_style;
}
;
template <class _Tp>
const bool numeric_limits<const volatile _Tp>::is_specialized;
template <class _Tp>
const int numeric_limits<const volatile _Tp>::digits;
template <class _Tp>
const int numeric_limits<const volatile _Tp>::digits10;
template <class _Tp>
const int numeric_limits<const volatile _Tp>::max_digits10;
template <class _Tp>
const bool numeric_limits<const volatile _Tp>::is_signed;
template <class _Tp>
const bool numeric_limits<const volatile _Tp>::is_integer;
template <class _Tp>
const bool numeric_limits<const volatile _Tp>::is_exact;
template <class _Tp>
const int numeric_limits<const volatile _Tp>::radix;
template <class _Tp>
const int numeric_limits<const volatile _Tp>::min_exponent;
template <class _Tp>
const int numeric_limits<const volatile _Tp>::min_exponent10;
template <class _Tp>
const int numeric_limits<const volatile _Tp>::max_exponent;
template <class _Tp>
const int numeric_limits<const volatile _Tp>::max_exponent10;
template <class _Tp>
const bool numeric_limits<const volatile _Tp>::has_infinity;
template <class _Tp>
const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;
template <class _Tp>
const bool numeric_limits<const volatile _Tp>::has_signaling_NaN;
template <class _Tp>
const float_denorm_style numeric_limits<const volatile _Tp>::has_denorm;
template <class _Tp>
const bool numeric_limits<const volatile _Tp>::has_denorm_loss;
template <class _Tp>
const bool numeric_limits<const volatile _Tp>::is_iec559;
template <class _Tp>
const bool numeric_limits<const volatile _Tp>::is_bounded;
template <class _Tp>
const bool numeric_limits<const volatile _Tp>::is_modulo;
template <class _Tp>
const bool numeric_limits<const volatile _Tp>::traps;
template <class _Tp>
const bool numeric_limits<const volatile _Tp>::tinyness_before;
template <class _Tp>
const float_round_style numeric_limits<const volatile _Tp>::round_style;
}
}
namespace std
{
inline namespace __1
{
template <class _InputIter>

void __advance(_InputIter &__i, typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)
{
    for (; __n > 0; --__n)
        ++__i;
}
template <class _BiDirIter>

void __advance(_BiDirIter &__i, typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)
{
    if (__n >= 0)
        for (; __n > 0; --__n)
            ++__i;
    else
        for (; __n < 0; ++__n)
            --__i;
}
template <class _RandIter>

void __advance(_RandIter &__i, typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)
{
    __i += __n;
}
template <
    class _InputIter, class _Distance,
    class _IntegralDistance = __decltype(std::__convert_to_integral(declval<_Distance>())),
    class = __enable_if_t<is_integral<_IntegralDistance>::value>>

void advance(_InputIter &__i, _Distance __orig_n)
{
    typedef typename iterator_traits<_InputIter>::difference_type _Difference;
    _Difference __n = static_cast<_Difference>(std::__convert_to_integral(__orig_n));
    ((void)0);
    std::__advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());
}
}
}
namespace std
{
inline namespace __1
{
template <class _Category, class _Tp, class _Distance = ptrdiff_t,
          class _Pointer = _Tp *, class _Reference = _Tp &>
struct iterator
{
    typedef _Tp value_type;
    typedef _Distance difference_type;
    typedef _Pointer pointer;
    typedef _Reference reference;
    typedef _Category iterator_category;
};
}
}
namespace std
{
inline namespace __1
{
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Container>
class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
#pragma GCC diagnostic pop
protected:
    _Container *container;

public:
    typedef output_iterator_tag iterator_category;
    typedef void value_type;
    typedef void difference_type;
    typedef void pointer;
    typedef void reference;
    typedef _Container container_type;
    {}

    {
        container->push_back(__value);
        return *this;
    }
    {
        return *this;
    }
    {
        return *this;
    }
    {
        return *this;
    }
    const { return container; }
};
template <class _Container>
inline back_insert_iterator<_Container>
back_inserter(_Container &__x)
{
    return back_insert_iterator<_Container>(__x);
}
}
}
namespace std
{
inline namespace __1
{
template <class _Iterator, class = __enable_if_t<__is_cpp17_contiguous_iterator<_Iterator>::value>>
struct __bounded_iter
{
    using value_type = typename iterator_traits<_Iterator>::value_type;
    using difference_type = typename iterator_traits<_Iterator>::difference_type;
    using pointer = typename iterator_traits<_Iterator>::pointer;
    using reference = typename iterator_traits<_Iterator>::reference;
    using iterator_category = typename iterator_traits<_Iterator>::iterator_category;
    = default;
    = default;
    = default;
    template <class _OtherIterator, class = __enable_if_t<is_convertible<_OtherIterator, _Iterator>::value>>

        : __current_(__other.__current_),
          __begin_(__other.__begin_),
          __end_(__other.__end_){} = default;
    = default;

private:
    explicit __bounded_iter(
        _Iterator __current, _Iterator __begin, _Iterator __end)
        : __current_(__current), __begin_(__begin), __end_(__end)
    {
        ((void)0);
    }
    template <class _It>
    friend __bounded_iter<_It> __make_bounded_iter(_It, _It, _It);

public:
    {
        ((void)0);
        return *__current_;
    }
    {
        ((void)0);
        return std::__to_address(__current_);
    }
    {
        ((void)0);
        return __current_[__n];
    }
    {
        ++__current_;
        return *this;
    }
    {
        __bounded_iter __tmp(*this);
        ++*this;
        return __tmp;
    }
    {
        --__current_;
        return *this;
    }
    {
        __bounded_iter __tmp(*this);
        --*this;
        return __tmp;
    }
    {
        __current_ += __n;
        return *this;
    }
    friend __bounded_iter
    operator+(__bounded_iter const &__self, difference_type __n) throw()
    {
        __bounded_iter __tmp(__self);
        __tmp += __n;
        return __tmp;
    }
    friend __bounded_iter
    operator+(difference_type __n, __bounded_iter const &__self) throw()
    {
        __bounded_iter __tmp(__self);
        __tmp += __n;
        return __tmp;
    }
    {
        __current_ -= __n;
        return *this;
    }
    friend __bounded_iter
    operator-(__bounded_iter const &__self, difference_type __n) throw()
    {
        __bounded_iter __tmp(__self);
        __tmp -= __n;
        return __tmp;
    }
    friend difference_type
    operator-(__bounded_iter const &__x, __bounded_iter const &__y) throw()
    {
        return __x.__current_ - __y.__current_;
    }
    friend bool
    operator==(__bounded_iter const &__x, __bounded_iter const &__y) throw()
    {
        return __x.__current_ == __y.__current_;
    }
    friend bool
    operator!=(__bounded_iter const &__x, __bounded_iter const &__y) throw()
    {
        return __x.__current_ != __y.__current_;
    }
    friend bool
    operator<(__bounded_iter const &__x, __bounded_iter const &__y) throw()
    {
        return __x.__current_ < __y.__current_;
    }
    friend bool
    operator>(__bounded_iter const &__x, __bounded_iter const &__y) throw()
    {
        return __x.__current_ > __y.__current_;
    }
    friend bool
    operator<=(__bounded_iter const &__x, __bounded_iter const &__y) throw()
    {
        return __x.__current_ <= __y.__current_;
    }
    friend bool
    operator>=(__bounded_iter const &__x, __bounded_iter const &__y) throw()
    {
        return __x.__current_ >= __y.__current_;
    }

private:
    const
    {
        return __iter >= __begin_ && __iter < __end_;
    }
    template <class>
    friend struct pointer_traits;
    _Iterator __current_;
    _Iterator __begin_, __end_;
};
template <class _It>
{
    return __bounded_iter<_It>(std::move(__it), std::move(__begin), std::move(__end));
}
template <class _Iterator>
struct __is_cpp17_contiguous_iterator<__bounded_iter<_Iterator>> : true_type
{
};
template <class _Iterator>
struct pointer_traits<__bounded_iter<_Iterator>>
{
    using pointer = __bounded_iter<_Iterator>;
    using element_type = typename pointer_traits<_Iterator>::element_type;
    using difference_type = typename pointer_traits<_Iterator>::difference_type;
    {
        return std::__to_address(__it.__current_);
    }
};
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
template <class _Arg, class _Result>
struct unary_function
{
    typedef _Arg argument_type;
    typedef _Result result_type;
};
template <class _Arg, class _Result>
struct __unary_function_keep_layout_base
{
    using argument_type = _Arg;
    using result_type = _Result;
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
template <class _Arg, class _Result>
using __unary_function = unary_function<_Arg, _Result>;
#pragma clang diagnostic pop
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct tuple_size;
template <class _Tp>
struct tuple_size<const _Tp> : public tuple_size<_Tp>
{
};
template <class _Tp>
struct tuple_size<volatile _Tp> : public tuple_size<_Tp>
{
};
template <class _Tp>
struct tuple_size<const volatile _Tp> : public tuple_size<_Tp>
{
};
template <size_t _Ip, class _Tp>
struct tuple_element;
template <size_t _Ip, class _Tp>
struct tuple_element<_Ip, const _Tp>
{
    typedef typename add_const<typename tuple_element<_Ip, _Tp>::type>::type type;
};
template <size_t _Ip, class _Tp>
struct tuple_element<_Ip, volatile _Tp>
{
    typedef typename add_volatile<typename tuple_element<_Ip, _Tp>::type>::type type;
};
template <size_t _Ip, class _Tp>
struct tuple_element<_Ip, const volatile _Tp>
{
    typedef typename add_cv<typename tuple_element<_Ip, _Tp>::type>::type type;
};
template <class _Tp>
struct __tuple_like : false_type
{
};
template <class _Tp>
struct __tuple_like<const _Tp> : public __tuple_like<_Tp>
{
};
template <class _Tp>
struct __tuple_like<volatile _Tp> : public __tuple_like<_Tp>
{
};
template <class _Tp>
struct __tuple_like<const volatile _Tp> : public __tuple_like<_Tp>
{
};
template <class _T1, class _T2>
struct __tuple_like<pair<_T1, _T2>> : true_type
{
};
template <size_t _Ip, class _T1, class _T2>

typename tuple_element<_Ip, pair<_T1, _T2>>::type &
get(pair<_T1, _T2> &) throw();
template <size_t _Ip, class _T1, class _T2>

const typename tuple_element<_Ip, pair<_T1, _T2>>::type &
get(const pair<_T1, _T2> &) throw();
template <class _Tp, size_t _Size>
struct array;
template <class _Tp, size_t _Size>
struct __tuple_like<array<_Tp, _Size>> : true_type
{
};
template <size_t _Ip, class _Tp, size_t _Size>

_Tp &get(array<_Tp, _Size> &) throw();
template <size_t _Ip, class _Tp, size_t _Size>

const _Tp &
get(const array<_Tp, _Size> &) throw();
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}

namespace std
{
inline namespace __1
{
template <class _Tp>
struct __unwrap_reference
{
    typedef _Tp type;
};
template <class _Tp>
class reference_wrapper;
template <class _Tp>
struct __unwrap_reference<reference_wrapper<_Tp>>
{
    typedef _Tp &type;
};
template <class _Tp>
struct decay;
template <class _Tp>
struct __unwrap_ref_decay
    : __unwrap_reference<typename decay<_Tp>::type>
{
};
}
}
namespace std
{
inline namespace __1
{
struct = default;
};
extern const piecewise_construct_t piecewise_construct;
}
}
namespace std
{
inline namespace __1
{
template <class _T1, class _T2>
struct pair
{
    typedef _T1 first_type;
    typedef _T2 second_type;
    _T1 first;
    _T2 second;

    pair() : first(), second() {}

    pair(_T1 const &__t1, _T2 const &__t2) : first(__t1), second(__t2) {}
    template <class _U1, class _U2>

    pair(const pair<_U1, _U2> &__p) : first(__p.first), second(__p.second)
    {
    }

    pair &operator=(pair const &__p)
    {
        first = __p.first;
        second = __p.second;
        return *this;
    }

    void
    swap(pair &__p)
    {
        using std::swap;
        swap(first, __p.first);
        swap(second, __p.second);
    }

private:
};
template <class _T1, class _T2>
inline bool
operator==(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)
{
    return __x.first == __y.first && __x.second == __y.second;
}
template <class _T1, class _T2>
inline bool
operator!=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)
{
    return !(__x == __y);
}
template <class _T1, class _T2>
inline bool
operator<(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)
{
    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
}
template <class _T1, class _T2>
inline bool
operator>(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)
{
    return __y < __x;
}
template <class _T1, class _T2>
inline bool
operator>=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)
{
    return !(__x < __y);
}
template <class _T1, class _T2>
inline bool
operator<=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)
{
    return !(__y < __x);
}
template <class _T1, class _T2>
inline
    typename enable_if<
        __is_swappable<_T1>::value &&
            __is_swappable<_T2>::value,
        void>::type
    swap(pair<_T1, _T2> &__x, pair<_T1, _T2> &__y)
{
    __x.swap(__y);
}
template <class _T1, class _T2>
inline pair<_T1, _T2>
make_pair(_T1 __x, _T2 __y)
{
    return pair<_T1, _T2>(__x, __y);
}
template <class _T1, class _T2>
struct tuple_size<pair<_T1, _T2>>
    : public integral_constant<size_t, 2>
{
};
template <size_t _Ip, class _T1, class _T2>
struct tuple_element<_Ip, pair<_T1, _T2>>
{
    _Static_assert(_Ip < 2, "Index out of bounds in std::tuple_element<std::pair<T1, T2>>");
};
template <class _T1, class _T2>
struct tuple_element<0, pair<_T1, _T2>>
{
    typedef _T1 type;
};
template <class _T1, class _T2>
struct tuple_element<1, pair<_T1, _T2>>
{
    typedef _T2 type;
};
template <size_t _Ip>
struct __get_pair;
template <>
struct __get_pair<0>
{
    template <class _T1, class _T2>
    static

        _T1 &
        get(pair<_T1, _T2> &__p) throw()
    {
        return __p.first;
    }
    template <class _T1, class _T2>
    static

        const _T1 &
        get(const pair<_T1, _T2> &__p) throw()
    {
        return __p.first;
    }
};
template <>
struct __get_pair<1>
{
    template <class _T1, class _T2>
    static

        _T2 &
        get(pair<_T1, _T2> &__p) throw()
    {
        return __p.second;
    }
    template <class _T1, class _T2>
    static

        const _T2 &
        get(const pair<_T1, _T2> &__p) throw()
    {
        return __p.second;
    }
};
template <size_t _Ip, class _T1, class _T2>
inline
    typename tuple_element<_Ip, pair<_T1, _T2>>::type &
    get(pair<_T1, _T2> &__p) throw()
{
    return __get_pair<_Ip>::get(__p);
}
template <size_t _Ip, class _T1, class _T2>
inline const typename tuple_element<_Ip, pair<_T1, _T2>>::type &
get(const pair<_T1, _T2> &__p) throw()
{
    return __get_pair<_Ip>::get(__p);
}
}
}
namespace std
{
inline namespace __1
{
template <class>
using __swap_result_t = void;
template <class _Tp>
inline
{
    _Tp __t(std::move(__x));
    __x = std::move(__y);
    __y = std::move(__t);
}
template <class _Tp, size_t _Np>
inline typename enable_if<__is_swappable<_Tp>::value>::type
swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np])
{
    for (size_t __i = 0; __i != _Np; ++__i)
    {
        swap(__a[__i], __b[__i]);
    }
}
}
}
extern "C"
{
void *memchr(const void *__s, int __c, size_t __n);
int memcmp(const void *__s1, const void *__s2, size_t __n);
void *memcpy(void *__dst, const void *__src, size_t __n);
void *memmove(void *__dst, const void *__src, size_t __len);
void *memset(void *__b, int __c, size_t __len);
char *strcat(char *__s1, const char *__s2);
char *strchr(const char *__s, int __c);
int strcmp(const char *__s1, const char *__s2);
int strcoll(const char *__s1, const char *__s2);
char *strcpy(char *__dst, const char *__src);
size_t strcspn(const char *__s, const char *__charset);
char *strerror(int __errnum) __asm("_"
                                   "strerror");
size_t strlen(const char *__s);
char *strncat(char *__s1, const char *__s2, size_t __n);
int strncmp(const char *__s1, const char *__s2, size_t __n);
char *strncpy(char *__dst, const char *__src, size_t __n);
char *strpbrk(const char *__s, const char *__charset);
char *strrchr(const char *__s, int __c);
size_t strspn(const char *__s, const char *__charset);
char *strstr(const char *__big, const char *__little);
char *strtok(char *__str, const char *__sep);
size_t strxfrm(char *__s1, const char *__s2, size_t __n);
}
extern "C"
{
char *strtok_r(char *__str, const char *__sep, char **__lasts);
}
extern "C"
{
int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen);
char *strdup(const char *__s1);
void *memccpy(void *__dst, const void *__src, int __c, size_t __n);
}
extern "C"
{
char *stpcpy(char *__dst, const char *__src);
char *stpncpy(char *__dst, const char *__src, size_t __n);
char *strndup(const char *__s1, size_t __n);
size_t strnlen(const char *__s1, size_t __n);
char *strsignal(int __sig);
}
typedef int errno_t;

extern "C"
{
errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n);
}
extern "C"
{
void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len);
void memset_pattern4(void *__b, const void *__pattern4, size_t __len);
void memset_pattern8(void *__b, const void *__pattern8, size_t __len);
void memset_pattern16(void *__b, const void *__pattern16, size_t __len);
char *strcasestr(const char *__big, const char *__little);
char *strnstr(const char *__big, const char *__little, size_t __len);
size_t strlcat(char *__dst, const char *__source, size_t __size);
size_t strlcpy(char *__dst, const char *__source, size_t __size);
void strmode(int __mode, char *__bp);
char *strsep(char **__stringp, const char *__delim);
void swab(const void *, void *, ssize_t);

int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len);

int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen);
}
extern "C"
{
int bcmp(const void *, const void *, size_t);
void bcopy(const void *, void *, size_t);
void bzero(void *, size_t);
char *index(const char *, int);
char *rindex(const char *, int);
int ffs(int);
int strcasecmp(const char *, const char *);
int strncasecmp(const char *, const char *, size_t);
}
extern "C"
{
int ffsl(long);
int ffsll(long long);
int fls(int);
int flsl(long);
int flsll(long long);
}
extern "C++"
{
inline char *__libcpp_strchr(const char *__s, int __c) { return (char *)strchr(__s, __c); }
inline const char *strchr(const char *__s, int __c) { return __libcpp_strchr(__s, __c); }
inline char *strchr(char *__s, int __c) { return __libcpp_strchr(__s, __c); }
inline char *__libcpp_strpbrk(const char *__s1, const char *__s2) { return (char *)strpbrk(__s1, __s2); }
inline const char *strpbrk(const char *__s1, const char *__s2) { return __libcpp_strpbrk(__s1, __s2); }
inline char *strpbrk(char *__s1, const char *__s2) { return __libcpp_strpbrk(__s1, __s2); }
inline char *__libcpp_strrchr(const char *__s, int __c) { return (char *)strrchr(__s, __c); }
inline const char *strrchr(const char *__s, int __c) { return __libcpp_strrchr(__s, __c); }
inline char *strrchr(char *__s, int __c) { return __libcpp_strrchr(__s, __c); }
inline void *__libcpp_memchr(const void *__s, int __c, size_t __n) { return (void *)memchr(__s, __c, __n); }
inline const void *memchr(const void *__s, int __c, size_t __n) { return __libcpp_memchr(__s, __c, __n); }
inline void *memchr(void *__s, int __c, size_t __n) { return __libcpp_memchr(__s, __c, __n); }
inline char *__libcpp_strstr(const char *__s1, const char *__s2) { return (char *)strstr(__s1, __s2); }
inline const char *strstr(const char *__s1, const char *__s2) { return __libcpp_strstr(__s1, __s2); }
inline char *strstr(char *__s1, const char *__s2) { return __libcpp_strstr(__s1, __s2); }
}
namespace std
{
inline namespace __1
{
using ::memchr;
using ::memcmp;
using ::memcpy;
using ::memmove;
using ::memset;
using ::size_t;
using ::strcat;
using ::strchr;
using ::strcmp;
using ::strcoll;
using ::strcpy;
using ::strcspn;
using ::strerror;
using ::strlen;
using ::strncat;
using ::strncmp;
using ::strncpy;
using ::strpbrk;
using ::strrchr;
using ::strspn;
using ::strstr;
using ::strtok;
using ::strxfrm;
}
}
namespace std
{
inline namespace __1
{
template <class _Size>
inline _Size
__loadword(const void *__p)
{
    _Size __r;
    std::memcpy(&__r, __p, sizeof(__r));
    return __r;
}
template <class _Size, size_t = sizeof(_Size) * 8>
struct __murmur2_or_cityhash;
template <class _Size>
struct __murmur2_or_cityhash<_Size, 32>
{
    inline _Size operator()(const void *__key, _Size __len);
};
template <class _Size>
_Size __murmur2_or_cityhash<_Size, 32>::operator()(const void *__key, _Size __len)
{
    const _Size __m = 0x5bd1e995;
    const _Size __r = 24;
    _Size __h = __len;
    const unsigned char *__data = static_cast<const unsigned char *>(__key);
    for (; __len >= 4; __data += 4, __len -= 4)
    {
        _Size __k = __loadword<_Size>(__data);
        __k *= __m;
        __k ^= __k >> __r;
        __k *= __m;
        __h *= __m;
        __h ^= __k;
    }
    switch (__len)
    {
    case 3:
        __h ^= static_cast<_Size>(__data[2] << 16);
        ;
    case 2:
        __h ^= static_cast<_Size>(__data[1] << 8);
        ;
    case 1:
        __h ^= __data[0];
        __h *= __m;
    }
    __h ^= __h >> 13;
    __h *= __m;
    __h ^= __h >> 15;
    return __h;
}
template <class _Size>
struct __murmur2_or_cityhash<_Size, 64>
{
    inline _Size operator()(const void *__key, _Size __len);

private:
    static const _Size __k0 = 0xc3a5c85c97cb3127ULL;
    static const _Size __k1 = 0xb492b66fbe98f273ULL;
    static const _Size __k2 = 0x9ae16a3b2f90404fULL;
    static const _Size __k3 = 0xc949d7c7509e6557ULL;
    static _Size __rotate(_Size __val, int __shift)
    {
        return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));
    }
    static _Size __rotate_by_at_least_1(_Size __val, int __shift)
    {
        return (__val >> __shift) | (__val << (64 - __shift));
    }
    static _Size __shift_mix(_Size __val)
    {
        return __val ^ (__val >> 47);
    }
    static _Size __hash_len_16(_Size __u, _Size __v)

    {
        const _Size __mul = 0x9ddfea08eb382d69ULL;
        _Size __a = (__u ^ __v) * __mul;
        __a ^= (__a >> 47);
        _Size __b = (__v ^ __a) * __mul;
        __b ^= (__b >> 47);
        __b *= __mul;
        return __b;
    }
    static _Size __hash_len_0_to_16(const char *__s, _Size __len)

    {
        if (__len > 8)
        {
            const _Size __a = __loadword<_Size>(__s);
            const _Size __b = __loadword<_Size>(__s + __len - 8);
            return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;
        }
        if (__len >= 4)
        {
            const uint32_t __a = __loadword<uint32_t>(__s);
            const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);
            return __hash_len_16(__len + (__a << 3), __b);
        }
        if (__len > 0)
        {
            const unsigned char __a = static_cast<unsigned char>(__s[0]);
            const unsigned char __b = static_cast<unsigned char>(__s[__len >> 1]);
            const unsigned char __c = static_cast<unsigned char>(__s[__len - 1]);
            const uint32_t __y = static_cast<uint32_t>(__a) +
                                 (static_cast<uint32_t>(__b) << 8);
            const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);
            return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;
        }
        return __k2;
    }
    static _Size __hash_len_17_to_32(const char *__s, _Size __len)

    {
        const _Size __a = __loadword<_Size>(__s) * __k1;
        const _Size __b = __loadword<_Size>(__s + 8);
        const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;
        const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;
        return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,
                             __a + __rotate(__b ^ __k3, 20) - __c + __len);
    }
    static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
        _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b)

    {
        __a += __w;
        __b = __rotate(__b + __a + __z, 21);
        const _Size __c = __a;
        __a += __x;
        __a += __y;
        __b += __rotate(__a, 44);
        return pair<_Size, _Size>(__a + __z, __b + __c);
    }
    static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
        const char *__s, _Size __a, _Size __b)

    {
        return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),
                                             __loadword<_Size>(__s + 8),
                                             __loadword<_Size>(__s + 16),
                                             __loadword<_Size>(__s + 24),
                                             __a,
                                             __b);
    }
    static _Size __hash_len_33_to_64(const char *__s, size_t __len)

    {
        _Size __z = __loadword<_Size>(__s + 24);
        _Size __a = __loadword<_Size>(__s) +
                    (__len + __loadword<_Size>(__s + __len - 16)) * __k0;
        _Size __b = __rotate(__a + __z, 52);
        _Size __c = __rotate(__a, 37);
        __a += __loadword<_Size>(__s + 8);
        __c += __rotate(__a, 7);
        __a += __loadword<_Size>(__s + 16);
        _Size __vf = __a + __z;
        _Size __vs = __b + __rotate(__a, 31) + __c;
        __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);
        __z += __loadword<_Size>(__s + __len - 8);
        __b = __rotate(__a + __z, 52);
        __c = __rotate(__a, 37);
        __a += __loadword<_Size>(__s + __len - 24);
        __c += __rotate(__a, 7);
        __a += __loadword<_Size>(__s + __len - 16);
        _Size __wf = __a + __z;
        _Size __ws = __b + __rotate(__a, 31) + __c;
        _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);
        return __shift_mix(__r * __k0 + __vs) * __k2;
    }
};
template <class _Size>
_Size __murmur2_or_cityhash<_Size, 64>::operator()(const void *__key, _Size __len)
{
    const char *__s = static_cast<const char *>(__key);
    if (__len <= 32)
    {
        if (__len <= 16)
        {
            return __hash_len_0_to_16(__s, __len);
        }
        else
        {
            return __hash_len_17_to_32(__s, __len);
        }
    }
    else if (__len <= 64)
    {
        return __hash_len_33_to_64(__s, __len);
    }
    _Size __x = __loadword<_Size>(__s + __len - 40);
    _Size __y = __loadword<_Size>(__s + __len - 16) +
                __loadword<_Size>(__s + __len - 56);
    _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,
                              __loadword<_Size>(__s + __len - 24));
    pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);
    pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);
    __x = __x * __k1 + __loadword<_Size>(__s);
    __len = (__len - 1) & ~static_cast<_Size>(63);
    do
    {
        __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;
        __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;
        __x ^= __w.second;
        __y += __v.first + __loadword<_Size>(__s + 40);
        __z = __rotate(__z + __w.first, 33) * __k1;
        __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);
        __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,
                                            __y + __loadword<_Size>(__s + 16));
        std::swap(__z, __x);
        __s += 64;
        __len -= 64;
    } while (__len != 0);
    return __hash_len_16(
        __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,
        __hash_len_16(__v.second, __w.second) + __x);
}
template <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>
struct __scalar_hash;
template <class _Tp>
struct __scalar_hash<_Tp, 0>
    : public __unary_function<_Tp, size_t>
{

    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__a = 0;
        __u.__t = __v;
        return __u.__a;
    }
};
template <class _Tp>
struct __scalar_hash<_Tp, 1>
    : public __unary_function<_Tp, size_t>
{

    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __u.__a;
    }
};
template <class _Tp>
struct __scalar_hash<_Tp, 2>
    : public __unary_function<_Tp, size_t>
{

    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};
template <class _Tp>
struct __scalar_hash<_Tp, 3>
    : public __unary_function<_Tp, size_t>
{

    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};
template <class _Tp>
struct __scalar_hash<_Tp, 4>
    : public __unary_function<_Tp, size_t>
{

    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
                size_t __d;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};
struct _PairT
{
    size_t first;
    size_t second;
};

inline size_t __hash_combine(size_t __lhs, size_t __rhs) throw()
{
    typedef __scalar_hash<_PairT> _HashT;
    const _PairT __p = {__lhs, __rhs};
    return _HashT()(__p);
}
template <class _Tp>
struct hash<_Tp *>
    : public __unary_function<_Tp *, size_t>
{

    size_t operator()(_Tp *__v) const throw()
    {
        union
        {
            _Tp *__t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};
template <>
struct hash<bool>
    : public __unary_function<bool, size_t>
{

    size_t operator()(bool __v) const throw() { return static_cast<size_t>(__v); }
};
template <>
struct hash<char>
    : public __unary_function<char, size_t>
{

    size_t operator()(char __v) const throw() { return static_cast<size_t>(__v); }
};
template <>
struct hash<signed char>
    : public __unary_function<signed char, size_t>
{

    size_t operator()(signed char __v) const throw() { return static_cast<size_t>(__v); }
};
template <>
struct hash<unsigned char>
    : public __unary_function<unsigned char, size_t>
{

    size_t operator()(unsigned char __v) const throw() { return static_cast<size_t>(__v); }
};
template <>
struct hash<char16_t>
    : public __unary_function<char16_t, size_t>
{

    size_t operator()(char16_t __v) const throw() { return static_cast<size_t>(__v); }
};
template <>
struct hash<char32_t>
    : public __unary_function<char32_t, size_t>
{

    size_t operator()(char32_t __v) const throw() { return static_cast<size_t>(__v); }
};
template <>
struct hash<wchar_t>
    : public __unary_function<wchar_t, size_t>
{

    size_t operator()(wchar_t __v) const throw() { return static_cast<size_t>(__v); }
};
template <>
struct hash<short>
    : public __unary_function<short, size_t>
{

    size_t operator()(short __v) const throw() { return static_cast<size_t>(__v); }
};
template <>
struct hash<unsigned short>
    : public __unary_function<unsigned short, size_t>
{

    size_t operator()(unsigned short __v) const throw() { return static_cast<size_t>(__v); }
};
template <>
struct hash<int>
    : public __unary_function<int, size_t>
{

    size_t operator()(int __v) const throw() { return static_cast<size_t>(__v); }
};
template <>
struct hash<unsigned int>
    : public __unary_function<unsigned int, size_t>
{

    size_t operator()(unsigned int __v) const throw() { return static_cast<size_t>(__v); }
};
template <>
struct hash<long>
    : public __unary_function<long, size_t>
{

    size_t operator()(long __v) const throw() { return static_cast<size_t>(__v); }
};
template <>
struct hash<unsigned long>
    : public __unary_function<unsigned long, size_t>
{

    size_t operator()(unsigned long __v) const throw() { return static_cast<size_t>(__v); }
};
template <>
struct hash<long long>
    : public __scalar_hash<long long>
{
};
template <>
struct hash<unsigned long long>
    : public __scalar_hash<unsigned long long>
{
};
template <>
struct hash<__int128_t>
    : public __scalar_hash<__int128_t>
{
};
template <>
struct hash<__uint128_t>
    : public __scalar_hash<__uint128_t>
{
};
template <>
struct hash<float>
    : public __scalar_hash<float>
{

    size_t operator()(float __v) const throw()
    {
        if (__v == 0.0f)
            return 0;
        return __scalar_hash<float>::operator()(__v);
    }
};
template <>
struct hash<double>
    : public __scalar_hash<double>
{

    size_t operator()(double __v) const throw()
    {
        if (__v == 0.0)
            return 0;
        return __scalar_hash<double>::operator()(__v);
    }
};
template <>
struct hash<long double>
    : public __scalar_hash<long double>
{

    size_t operator()(long double __v) const throw()
    {
        if (__v == 0.0L)
            return 0;
        return __scalar_hash<long double>::operator()(__v);
    }
};
template <class _Tp, bool = is_enum<_Tp>::value>
struct __enum_hash
    : public __unary_function<_Tp, size_t>
{

    size_t operator()(_Tp __v) const throw()
    {
        typedef typename underlying_type<_Tp>::type type;
        return hash<type>()(static_cast<type>(__v));
    }
};
template <class _Tp>
struct __enum_hash<_Tp, false>
{
    __enum_hash() = delete;
    __enum_hash(__enum_hash const &) = delete;
    __enum_hash &operator=(__enum_hash const &) = delete;
};
template <class _Tp>
struct hash : public __enum_hash<_Tp>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Arg1, class _Arg2, class _Result>
struct binary_function
{
    typedef _Arg1 first_argument_type;
    typedef _Arg2 second_argument_type;
    typedef _Result result_type;
};
template <class _Arg1, class _Arg2, class _Result>
struct __binary_function_keep_layout_base
{
    using first_argument_type = _Arg1;
    using second_argument_type = _Arg2;
    using result_type = _Result;
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
template <class _Arg1, class _Arg2, class _Result>
using __binary_function = binary_function<_Arg1, _Arg2, _Result>;
#pragma clang diagnostic pop
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct plus
    : __binary_function<_Tp, _Tp, _Tp>
{
    typedef _Tp __result_type;

    _Tp operator()(const _Tp &__x, const _Tp &__y) const
    {
        return __x + __y;
    }
};
template <class _Tp>
struct minus
    : __binary_function<_Tp, _Tp, _Tp>
{
    typedef _Tp __result_type;

    _Tp operator()(const _Tp &__x, const _Tp &__y) const
    {
        return __x - __y;
    }
};
template <class _Tp>
struct multiplies
    : __binary_function<_Tp, _Tp, _Tp>
{
    typedef _Tp __result_type;

    _Tp operator()(const _Tp &__x, const _Tp &__y) const
    {
        return __x * __y;
    }
};
template <class _Tp>
struct divides
    : __binary_function<_Tp, _Tp, _Tp>
{
    typedef _Tp __result_type;

    _Tp operator()(const _Tp &__x, const _Tp &__y) const
    {
        return __x / __y;
    }
};
template <class _Tp>
struct modulus
    : __binary_function<_Tp, _Tp, _Tp>
{
    typedef _Tp __result_type;

    _Tp operator()(const _Tp &__x, const _Tp &__y) const
    {
        return __x % __y;
    }
};
template <class _Tp>
struct negate
    : __unary_function<_Tp, _Tp>
{
    typedef _Tp __result_type;

    _Tp operator()(const _Tp &__x) const
    {
        return -__x;
    }
};
template <class _Tp>
struct bit_and
    : __binary_function<_Tp, _Tp, _Tp>
{
    typedef _Tp __result_type;

    _Tp operator()(const _Tp &__x, const _Tp &__y) const
    {
        return __x & __y;
    }
};
template <class _Tp>
struct bit_or
    : __binary_function<_Tp, _Tp, _Tp>
{
    typedef _Tp __result_type;

    _Tp operator()(const _Tp &__x, const _Tp &__y) const
    {
        return __x | __y;
    }
};
template <class _Tp>
struct bit_xor
    : __binary_function<_Tp, _Tp, _Tp>
{
    typedef _Tp __result_type;

    _Tp operator()(const _Tp &__x, const _Tp &__y) const
    {
        return __x ^ __y;
    }
};
template <class _Tp>
struct equal_to
    : __binary_function<_Tp, _Tp, bool>
{
    typedef bool __result_type;

    bool operator()(const _Tp &__x, const _Tp &__y) const
    {
        return __x == __y;
    }
};
template <class _Tp>
struct not_equal_to
    : __binary_function<_Tp, _Tp, bool>
{
    typedef bool __result_type;

    bool operator()(const _Tp &__x, const _Tp &__y) const
    {
        return __x != __y;
    }
};
template <class _Tp>
struct less
    : __binary_function<_Tp, _Tp, bool>
{
    typedef bool __result_type;

    bool operator()(const _Tp &__x, const _Tp &__y) const
    {
        return __x < __y;
    }
};
template <class _Tp>
struct less_equal
    : __binary_function<_Tp, _Tp, bool>
{
    typedef bool __result_type;

    bool operator()(const _Tp &__x, const _Tp &__y) const
    {
        return __x <= __y;
    }
};
template <class _Tp>
struct greater_equal
    : __binary_function<_Tp, _Tp, bool>
{
    typedef bool __result_type;

    bool operator()(const _Tp &__x, const _Tp &__y) const
    {
        return __x >= __y;
    }
};
template <class _Tp>
struct greater
    : __binary_function<_Tp, _Tp, bool>
{
    typedef bool __result_type;

    bool operator()(const _Tp &__x, const _Tp &__y) const
    {
        return __x > __y;
    }
};
template <class _Tp>
struct logical_and
    : __binary_function<_Tp, _Tp, bool>
{
    typedef bool __result_type;

    bool operator()(const _Tp &__x, const _Tp &__y) const
    {
        return __x && __y;
    }
};
template <class _Tp>
struct logical_not
    : __unary_function<_Tp, bool>
{
    typedef bool __result_type;

    bool operator()(const _Tp &__x) const
    {
        return !__x;
    }
};
template <class _Tp>
struct logical_or
    : __binary_function<_Tp, _Tp, bool>
{
    typedef bool __result_type;

    bool operator()(const _Tp &__x, const _Tp &__y) const
    {
        return __x || __y;
    }
};
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
class exception
{
public:
{} = default;
virtual ~exception() throw();
virtual const char *what() const throw();
};
class bad_exception
    : public exception
{
public:
{
}
virtual ~bad_exception() throw();
virtual const char *what() const throw();
};
typedef void (*unexpected_handler)();
;
;
;
typedef void (*terminate_handler)();
;
;
;
;
;
class exception_ptr;
;
;
class exception_ptr
{
void *__ptr_;

public:
{} {
}
exception_ptr(const exception_ptr &) throw();
exception_ptr &operator=(const exception_ptr &) throw();
~exception_ptr() throw();

{
    return __ptr_ != __nullptr;
}
friend bool operator==(const exception_ptr &__x, const exception_ptr &__y) throw()
{
    return __x.__ptr_ == __y.__ptr_;
}
friend bool operator!=(const exception_ptr &__x, const exception_ptr &__y) throw()
{
    return !(__x == __y);
}
friend;
friend;
};
template <class _Ep>
exception_ptr
make_exception_ptr(_Ep __e) throw()
{
try
{
    throw __e;
}
catch (...)
{
    return current_exception();
}
}
class nested_exception
{
exception_ptr __ptr_;

public:
nested_exception() throw();
virtual ~nested_exception() throw();
const;
{
    return __ptr_;
}
};
template <class _Tp>
struct __nested
    : public _Tp,
      public nested_exception
{
{
}
};
template <class _Tp, class _Up, bool>
struct __throw_with_nested;
template <class _Tp, class _Up>
struct __throw_with_nested<_Tp, _Up, true>
{
void __do_throw(_Tp &&__t)
{
    throw __nested<_Up>(static_cast<_Tp &&>(__t));
}
};
template <class _Tp, class _Up>
struct __throw_with_nested<_Tp, _Up, false>
{
void __do_throw(_Tp &__t)
{
    throw static_cast<_Tp &&>(__t);
}
};
template <class _Tp>

void throw_with_nested(_Tp &&__t)
{
typedef typename decay<_Tp>::type _Up;
_Static_assert(is_copy_constructible<_Up>::value, "type thrown must be CopyConstructible");
__throw_with_nested<_Tp, _Up,
                    is_class<_Up>::value &&
                        !is_base_of<nested_exception, _Up>::value &&
                        !__libcpp_is_final<_Up>::value>::
    __do_throw(static_cast<_Tp &&>(__t));
}
template <class _From, class _To>
struct __can_dynamic_cast : _BoolConstant<
                                is_polymorphic<_From>::value &&
                                (!is_base_of<_To, _From>::value ||
                                 is_convertible<const _From *, const _To *>::value)>
{
};
template <class _Ep>
inline void
rethrow_if_nested(const _Ep &__e,
                  __enable_if_t<__can_dynamic_cast<_Ep, nested_exception>::value> * = 0)
{
const nested_exception *__nep = dynamic_cast<const nested_exception *>(std::addressof(__e));
if (__nep)
    __nep->rethrow_nested();
}
template <class _Ep>
inline void
rethrow_if_nested(const _Ep &,
                  __enable_if_t<!__can_dynamic_cast<_Ep, nested_exception>::value> * = 0)
{
}
}
namespace std
{
}

namespace std
{
struct = default;
};
extern const nothrow_t nothrow;
class bad_alloc
    : public exception
{
public:
bad_alloc() throw();
virtual ~bad_alloc() throw();
virtual const char *what() const throw();
};
class bad_array_new_length
    : public bad_alloc
{
public:
bad_array_new_length() throw();
virtual ~bad_array_new_length() throw();
virtual const char *what() const throw();
};
typedef void (*new_handler)();
;
;
;

void __throw_bad_array_new_length()
{
throw bad_array_new_length();
}
enum align_val_t
{
    __zero = 0,
    __max = (size_t)-1
};
}
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
inline { return __p; }
inline { return __p; }
inline {}
inline {}
namespace std
{
inline namespace __1
{
inline
{
    return __align > 16UL;
}
template <class... _Args>

void *__libcpp_operator_new(_Args... __args)
{
    return __builtin_operator_new(__args...);
}
template <class... _Args>

void __libcpp_operator_delete(_Args... __args)
{
    __builtin_operator_delete(__args...);
}
inline void *__libcpp_allocate(size_t __size, size_t __align)
{
    (void)__align;
    return __libcpp_operator_new(__size);
}
template <class... _Args>

void __do_deallocate_handle_size(void *__ptr, size_t __size, _Args... __args)
{
    (void)__size;
    return __libcpp_operator_delete(__ptr, __args...);
}
inline void __libcpp_deallocate(void *__ptr, size_t __size, size_t __align)
{
    (void)__align;
    return __do_deallocate_handle_size(__ptr, __size);
}
inline
{
    (void)__align;
    return __libcpp_operator_delete(__ptr);
}
inline void *__libcpp_aligned_alloc(std::size_t __alignment, std::size_t __size)
{
    void *__result = __nullptr;
    (void)::posix_memalign(&__result, __alignment, __size);
    return __result;
}
inline void __libcpp_aligned_free(void *__ptr)
{
    ::free(__ptr);
}
template <class _Tp>
inline _Tp *__launder(_Tp *__p) throw()
{
    _Static_assert(!(is_function<_Tp>::value), "can't launder functions");
    _Static_assert(!(is_same<void, typename remove_cv<_Tp>::type>::value), "can't launder cv-void");
    return __builtin_launder(__p);
}
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct __has_allocator_type
{
private:
    template <class _Up>
    static false_type __test(...);
    template <class _Up>
    static true_type __test(typename _Up::allocator_type * = 0);

public:
    static const bool value = __decltype(__test<_Tp>(0))::value;
};
template <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>
struct __uses_allocator
    : public integral_constant<bool,
                               is_convertible<_Alloc, typename _Tp::allocator_type>::value>
{
};
template <class _Tp, class _Alloc>
struct __uses_allocator<_Tp, _Alloc, false>
    : public false_type
{
};
template <class _Tp, class _Alloc>
struct uses_allocator
    : public __uses_allocator<_Tp, _Alloc>
{
};
}
}
namespace std
{
inline namespace __1
{
struct = default;
};
extern const allocator_arg_t allocator_arg;
}
}
namespace std
{
inline namespace __1
{
}
}
typedef __darwin_mbstate_t mbstate_t;
typedef __builtin_va_list va_list;
typedef __builtin_va_list __gnuc_va_list;
typedef __darwin_va_list va_list;
extern "C"
{
int renameat(int, const char *, int, const char *);
int renamex_np(const char *, const char *, unsigned int);
int renameatx_np(int, const char *, int, const char *, unsigned int);
}

typedef __darwin_off_t fpos_t;
struct __sbuf
{
unsigned char *_base;
int _size;
};
struct __sFILEX;
typedef struct __sFILE
{
unsigned char *_p;
int _r;
int _w;
short _flags;
short _file;
struct __sbuf _bf;
int _lbfsize;
void *_cookie;
int (*_Nullable _close)(void *);
int (*_Nullable _read)(void *, char *, int);
fpos_t (*_Nullable _seek)(void *, fpos_t, int);
int (*_Nullable _write)(void *, const char *, int);
struct __sbuf _ub;
struct __sFILEX *_extra;
int _ur;
unsigned char _ubuf[3];
unsigned char _nbuf[1];
struct __sbuf _lb;
int _blksize;
fpos_t _offset;
} FILE;

extern "C"
{
extern FILE *__stdinp;
extern FILE *__stdoutp;
extern FILE *__stderrp;
}
extern "C"
{
void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE *, fpos_t *);
char *fgets(char *, int, FILE *);
FILE *fopen(const char *__filename, const char *__mode) __asm("_"
                                                              "fopen");
int fprintf(FILE *, const char *, ...);
int fputc(int, FILE *);
int fputs(const char *, FILE *) __asm("_"
                                      "fputs");
size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream);
FILE *freopen(const char *, const char *,
              FILE *) __asm("_"
                            "freopen");
int fscanf(FILE *, const char *, ...);
int fseek(FILE *, long, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream) __asm("_"
                                                                                       "fwrite");
int getc(FILE *);
int getchar(void);

char *gets(char *);
void perror(const char *);
int printf(const char *, ...);
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int remove(const char *);
int rename(const char *__old, const char *__new);
void rewind(FILE *);
int scanf(const char *, ...);
void setbuf(FILE *, char *);
int setvbuf(FILE *, char *, int, size_t);

int sprintf(char *, const char *, ...);
int sscanf(const char *, const char *, ...);
FILE *tmpfile(void);

char *tmpnam(char *);
int ungetc(int, FILE *);
int vfprintf(FILE *, const char *, va_list);
int vprintf(const char *, va_list);

int vsprintf(char *, const char *, va_list);
}
extern "C"
{
FILE *fdopen(int, const char *) __asm("_"
                                      "fdopen");
int fileno(FILE *);
}
extern "C"
{
int pclose(FILE *);
FILE *popen(const char *, const char *) __asm("_"
                                              "popen");
}
extern "C"
{
int __srget(FILE *);
int __svfscanf(FILE *, const char *, va_list);
int __swbuf(int, FILE *);
}
inline __attribute__((__always_inline__)) int __sputc(int _c, FILE *_p)
{
if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
return (*_p->_p++ = _c);
else
return (__swbuf(_c, _p));
}
extern "C"
{
void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);
int getw(FILE *);
int putw(int, FILE *);

char *tempnam(const char *__dir, const char *__prefix) __asm("_"
                                                             "tempnam");
}
extern "C"
{
int fseeko(FILE *__stream, off_t __offset, int __whence);
off_t ftello(FILE *__stream);
}
extern "C"
{
int snprintf(char *__str, size_t __size, const char *__format, ...);
int vfscanf(FILE *__stream, const char *__format, va_list);
int vscanf(const char *__format, va_list);
int vsnprintf(char *__str, size_t __size, const char *__format, va_list);
int vsscanf(const char *__str, const char *__format, va_list);
}
extern "C"
{
int dprintf(int, const char *, ...);
int vdprintf(int, const char *, va_list);
ssize_t getdelim(char **__linep, size_t *__linecapp, int __delimiter, FILE *__stream);
ssize_t getline(char **__linep, size_t *__linecapp, FILE *__stream);
FILE *fmemopen(void *__buf, size_t __size, const char *__mode);
FILE *open_memstream(char **__bufp, size_t *__sizep);
}
extern "C"
{
extern const int sys_nerr;
extern const char *const sys_errlist[];
int asprintf(char **, const char *, ...);
char *ctermid_r(char *);
char *fgetln(FILE *, size_t *);
const char *fmtcheck(const char *, const char *);
int fpurge(FILE *);
void setbuffer(FILE *, char *, int);
int setlinebuf(FILE *);
int vasprintf(char **, const char *, va_list);
FILE *funopen(const void *,
              int (*_Nullable)(void *, char *, int),
              int (*_Nullable)(void *, const char *, int),
              fpos_t (*_Nullable)(void *, fpos_t, int),
              int (*_Nullable)(void *));
}
typedef __darwin_clock_t clock_t;
struct tm
{
int tm_sec;
int tm_min;
int tm_hour;
int tm_mday;
int tm_mon;
int tm_year;
int tm_wday;
int tm_yday;
int tm_isdst;
long tm_gmtoff;
char *tm_zone;
};
extern char *tzname[];
extern int getdate_err;
extern long timezone __asm("_"
                           "timezone");
extern int daylight;
extern "C"
{
char *asctime(const struct tm *);
clock_t clock(void) __asm("_"
                          "clock");
char *ctime(const time_t *);
double difftime(time_t, time_t);
struct tm *getdate(const char *);
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *) __asm("_"
                                 "mktime");
size_t strftime(char *, size_t, const char *, const struct tm *) __asm("_"
                                                                       "strftime");
char *strptime(const char *, const char *, struct tm *) __asm("_"
                                                              "strptime");
time_t time(time_t *);
void tzset(void);
char *asctime_r(const struct tm *, char *);
char *ctime_r(const time_t *, char *);
struct tm *gmtime_r(const time_t *, struct tm *);
struct tm *localtime_r(const time_t *, struct tm *);
time_t posix2time(time_t);
void tzsetwall(void);
time_t time2posix(time_t);
time_t timelocal(struct tm *const);
time_t timegm(struct tm *const);
int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp) __asm("_"
                                                                            "nanosleep");
typedef enum
{
    _CLOCK_REALTIME = 0,
    _CLOCK_MONOTONIC = 6,
    _CLOCK_MONOTONIC_RAW = 4,
    _CLOCK_MONOTONIC_RAW_APPROX = 5,
    _CLOCK_UPTIME_RAW = 8,
    _CLOCK_UPTIME_RAW_APPROX = 9,
    _CLOCK_PROCESS_CPUTIME_ID = 12,
    _CLOCK_THREAD_CPUTIME_ID = 16
} clockid_t;

int clock_getres(clockid_t __clock_id, struct timespec *__res);

int clock_gettime(clockid_t __clock_id, struct timespec *__tp);

__uint64_t clock_gettime_nsec_np(clockid_t __clock_id);

int clock_settime(clockid_t __clock_id, const struct timespec *__tp);

int timespec_get(struct timespec *ts, int base);
}
typedef __darwin_wint_t wint_t;

typedef __darwin_wctype_t wctype_t;
typedef struct
{
__darwin_rune_t __min;
__darwin_rune_t __max;
__darwin_rune_t __map;
__uint32_t *__types;
} _RuneEntry;
typedef struct
{
int __nranges;
_RuneEntry *__ranges;
} _RuneRange;
typedef struct
{
char __name[14];
__uint32_t __mask;
} _RuneCharClass;
typedef struct
{
char __magic[8];
char __encoding[32];
__darwin_rune_t (*__sgetrune)(const char *, __darwin_size_t, char const **);
int (*__sputrune)(__darwin_rune_t, char *, __darwin_size_t, char **);
__darwin_rune_t __invalid_rune;
__uint32_t __runetype[(1 << 8)];
__darwin_rune_t __maplower[(1 << 8)];
__darwin_rune_t __mapupper[(1 << 8)];
_RuneRange __runetype_ext;
_RuneRange __maplower_ext;
_RuneRange __mapupper_ext;
void *__variable;
int __variable_len;
int __ncharclasses;
_RuneCharClass *__charclasses;
} _RuneLocale;
extern "C"
{
extern _RuneLocale _DefaultRuneLocale;
extern _RuneLocale *_CurrentRuneLocale;
}
extern "C"
{
unsigned long ___runetype(__darwin_ct_rune_t);
__darwin_ct_rune_t ___tolower(__darwin_ct_rune_t);
__darwin_ct_rune_t ___toupper(__darwin_ct_rune_t);
}
inline int
isascii(int _c)
{
return ((_c & ~0x7F) == 0);
}
extern "C"
{
int __maskrune(__darwin_ct_rune_t, unsigned long);
}
inline int
__istype(__darwin_ct_rune_t _c, unsigned long _f)
{
return (isascii(_c) ? !!(_DefaultRuneLocale.__runetype[_c] & _f)
                    : !!__maskrune(_c, _f));
}
inline __darwin_ct_rune_t
__isctype(__darwin_ct_rune_t _c, unsigned long _f)
{
return (_c < 0 || _c >= (1 << 8)) ? 0 : !!(_DefaultRuneLocale.__runetype[_c] & _f);
}
extern "C"
{
__darwin_ct_rune_t __toupper(__darwin_ct_rune_t);
__darwin_ct_rune_t __tolower(__darwin_ct_rune_t);
}
inline int
__wcwidth(__darwin_ct_rune_t _c)
{
unsigned int _x;
if (_c == 0)
return (0);
_x = (unsigned int)__maskrune(_c, 0xe0000000L | 0x00040000L);
if ((_x & 0xe0000000L) != 0)
return ((_x & 0xe0000000L) >> 30);
return ((_x & 0x00040000L) != 0 ? 1 : -1);
}
inline int
isalnum(int _c)
{
return (__istype(_c, 0x00000100L | 0x00000400L));
}
inline int
isalpha(int _c)
{
return (__istype(_c, 0x00000100L));
}
inline int
isblank(int _c)
{
return (__istype(_c, 0x00020000L));
}
inline int
iscntrl(int _c)
{
return (__istype(_c, 0x00000200L));
}
inline int
isdigit(int _c)
{
return (__isctype(_c, 0x00000400L));
}
inline int
isgraph(int _c)
{
return (__istype(_c, 0x00000800L));
}
inline int
islower(int _c)
{
return (__istype(_c, 0x00001000L));
}
inline int
isprint(int _c)
{
return (__istype(_c, 0x00040000L));
}
inline int
ispunct(int _c)
{
return (__istype(_c, 0x00002000L));
}
inline int
isspace(int _c)
{
return (__istype(_c, 0x00004000L));
}
inline int
isupper(int _c)
{
return (__istype(_c, 0x00008000L));
}
inline int
isxdigit(int _c)
{
return (__isctype(_c, 0x00010000L));
}
inline int
toascii(int _c)
{
return (_c & 0x7F);
}
inline int
tolower(int _c)
{
return (__tolower(_c));
}
inline int
toupper(int _c)
{
return (__toupper(_c));
}
inline int
digittoint(int _c)
{
return (__maskrune(_c, 0x0F));
}
inline int
ishexnumber(int _c)
{
return (__istype(_c, 0x00010000L));
}
inline int
isideogram(int _c)
{
return (__istype(_c, 0x00080000L));
}
inline int
isnumber(int _c)
{
return (__istype(_c, 0x00000400L));
}
inline int
isphonogram(int _c)
{
return (__istype(_c, 0x00200000L));
}
inline int
isrune(int _c)
{
return (__istype(_c, 0xFFFFFFF0L));
}
inline int
isspecial(int _c)
{
return (__istype(_c, 0x00100000L));
}
inline int
iswalnum(wint_t _wc)
{
return (__istype(_wc, 0x00000100L | 0x00000400L));
}
inline int
iswalpha(wint_t _wc)
{
return (__istype(_wc, 0x00000100L));
}
inline int
iswcntrl(wint_t _wc)
{
return (__istype(_wc, 0x00000200L));
}
inline int
iswctype(wint_t _wc, wctype_t _charclass)
{
return (__istype(_wc, _charclass));
}
inline int
iswdigit(wint_t _wc)
{
return (__isctype(_wc, 0x00000400L));
}
inline int
iswgraph(wint_t _wc)
{
return (__istype(_wc, 0x00000800L));
}
inline int
iswlower(wint_t _wc)
{
return (__istype(_wc, 0x00001000L));
}
inline int
iswprint(wint_t _wc)
{
return (__istype(_wc, 0x00040000L));
}
inline int
iswpunct(wint_t _wc)
{
return (__istype(_wc, 0x00002000L));
}
inline int
iswspace(wint_t _wc)
{
return (__istype(_wc, 0x00004000L));
}
inline int
iswupper(wint_t _wc)
{
return (__istype(_wc, 0x00008000L));
}
inline int
iswxdigit(wint_t _wc)
{
return (__isctype(_wc, 0x00010000L));
}
inline wint_t
towlower(wint_t _wc)
{
return (__tolower(_wc));
}
inline wint_t
towupper(wint_t _wc)
{
return (__toupper(_wc));
}
extern "C"
{
wctype_t
wctype(const char *);
}
extern "C"
{
wint_t btowc(int);
wint_t fgetwc(FILE *);
wchar_t *fgetws(wchar_t *, int, FILE *);
wint_t fputwc(wchar_t, FILE *);
int fputws(const wchar_t *, FILE *);
int fwide(FILE *, int);
int fwprintf(FILE *, const wchar_t *, ...);
int fwscanf(FILE *, const wchar_t *, ...);
wint_t getwc(FILE *);
wint_t getwchar(void);
size_t mbrlen(const char *, size_t, mbstate_t *);
size_t mbrtowc(wchar_t *, const char *, size_t,
               mbstate_t *);
int mbsinit(const mbstate_t *);
size_t mbsrtowcs(wchar_t *, const char **, size_t,
                 mbstate_t *);
wint_t putwc(wchar_t, FILE *);
wint_t putwchar(wchar_t);
int swprintf(wchar_t *, size_t, const wchar_t *, ...);
int swscanf(const wchar_t *, const wchar_t *, ...);
wint_t ungetwc(wint_t, FILE *);
int vfwprintf(FILE *, const wchar_t *,
              __darwin_va_list);
int vswprintf(wchar_t *, size_t, const wchar_t *,
              __darwin_va_list);
int vwprintf(const wchar_t *, __darwin_va_list);
size_t wcrtomb(char *, wchar_t, mbstate_t *);
wchar_t *wcscat(wchar_t *, const wchar_t *);
wchar_t *wcschr(const wchar_t *, wchar_t);
int wcscmp(const wchar_t *, const wchar_t *);
int wcscoll(const wchar_t *, const wchar_t *);
wchar_t *wcscpy(wchar_t *, const wchar_t *);
size_t wcscspn(const wchar_t *, const wchar_t *);
size_t wcsftime(wchar_t *, size_t, const wchar_t *,
                const struct tm *) __asm("_"
                                         "wcsftime");
size_t wcslen(const wchar_t *);
wchar_t *wcsncat(wchar_t *, const wchar_t *, size_t);
int wcsncmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wcsncpy(wchar_t *, const wchar_t *, size_t);
wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
wchar_t *wcsrchr(const wchar_t *, wchar_t);
size_t wcsrtombs(char *, const wchar_t **, size_t,
                 mbstate_t *);
size_t wcsspn(const wchar_t *, const wchar_t *);
wchar_t *wcsstr(const wchar_t *, const wchar_t *);
size_t wcsxfrm(wchar_t *, const wchar_t *, size_t);
int wctob(wint_t);
double wcstod(const wchar_t *, wchar_t **);
wchar_t *wcstok(wchar_t *, const wchar_t *,
                wchar_t **);
long wcstol(const wchar_t *, wchar_t **, int);
unsigned long
wcstoul(const wchar_t *, wchar_t **, int);
wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
int wmemcmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wmemcpy(wchar_t *, const wchar_t *, size_t);
wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
wchar_t *wmemset(wchar_t *, wchar_t, size_t);
int wprintf(const wchar_t *, ...);
int wscanf(const wchar_t *, ...);
int wcswidth(const wchar_t *, size_t);
int wcwidth(wchar_t);
}
extern "C"
{
int vfwscanf(FILE *, const wchar_t *,
             __darwin_va_list);
int vswscanf(const wchar_t *, const wchar_t *,
             __darwin_va_list);
int vwscanf(const wchar_t *, __darwin_va_list);
float wcstof(const wchar_t *, wchar_t **);
long double
wcstold(const wchar_t *, wchar_t **);
long long
wcstoll(const wchar_t *, wchar_t **, int);
unsigned long long
wcstoull(const wchar_t *, wchar_t **, int);
}
extern "C"
{
size_t mbsnrtowcs(wchar_t *, const char **, size_t,
                  size_t, mbstate_t *);
wchar_t *wcpcpy(wchar_t *, const wchar_t *);
wchar_t *wcpncpy(wchar_t *, const wchar_t *, size_t);
wchar_t *wcsdup(const wchar_t *);
int wcscasecmp(const wchar_t *, const wchar_t *);
int wcsncasecmp(const wchar_t *, const wchar_t *, size_t n);
size_t wcsnlen(const wchar_t *, size_t);
size_t wcsnrtombs(char *, const wchar_t **, size_t,
                  size_t, mbstate_t *);
FILE *open_wmemstream(wchar_t **__bufp, size_t *__sizep);
}
extern "C"
{
wchar_t *fgetwln(FILE *, size_t *);
size_t wcslcat(wchar_t *, const wchar_t *, size_t);
size_t wcslcpy(wchar_t *, const wchar_t *, size_t);
}
extern "C++"
{
inline wchar_t *__libcpp_wcschr(const wchar_t *__s, wchar_t __c) { return (wchar_t *)wcschr(__s, __c); }
inline const wchar_t *wcschr(const wchar_t *__s, wchar_t __c) { return __libcpp_wcschr(__s, __c); }
inline wchar_t *wcschr(wchar_t *__s, wchar_t __c) { return __libcpp_wcschr(__s, __c); }
inline wchar_t *__libcpp_wcspbrk(const wchar_t *__s1, const wchar_t *__s2) { return (wchar_t *)wcspbrk(__s1, __s2); }
inline const wchar_t *wcspbrk(const wchar_t *__s1, const wchar_t *__s2) { return __libcpp_wcspbrk(__s1, __s2); }
inline wchar_t *wcspbrk(wchar_t *__s1, const wchar_t *__s2) { return __libcpp_wcspbrk(__s1, __s2); }
inline wchar_t *__libcpp_wcsrchr(const wchar_t *__s, wchar_t __c) { return (wchar_t *)wcsrchr(__s, __c); }
inline const wchar_t *wcsrchr(const wchar_t *__s, wchar_t __c) { return __libcpp_wcsrchr(__s, __c); }
inline wchar_t *wcsrchr(wchar_t *__s, wchar_t __c) { return __libcpp_wcsrchr(__s, __c); }
inline wchar_t *__libcpp_wcsstr(const wchar_t *__s1, const wchar_t *__s2) { return (wchar_t *)wcsstr(__s1, __s2); }
inline const wchar_t *wcsstr(const wchar_t *__s1, const wchar_t *__s2) { return __libcpp_wcsstr(__s1, __s2); }
inline wchar_t *wcsstr(wchar_t *__s1, const wchar_t *__s2) { return __libcpp_wcsstr(__s1, __s2); }
inline wchar_t *__libcpp_wmemchr(const wchar_t *__s, wchar_t __c, size_t __n) { return (wchar_t *)wmemchr(__s, __c, __n); }
inline const wchar_t *wmemchr(const wchar_t *__s, wchar_t __c, size_t __n) { return __libcpp_wmemchr(__s, __c, __n); }
inline wchar_t *wmemchr(wchar_t *__s, wchar_t __c, size_t __n) { return __libcpp_wmemchr(__s, __c, __n); }
}
namespace std
{
inline namespace __1
{
using ::mbstate_t;
}
}
namespace std
{
inline namespace __1
{
class ios_base;
template <class _CharT>
struct char_traits;
template <>
struct char_traits<char>;
template <>
struct char_traits<char16_t>;
template <>
struct char_traits<char32_t>;
template <>
struct char_traits<wchar_t>;
template <class _Tp>
class allocator;
template <class _CharT, class _Traits = char_traits<_CharT>>
class basic_ios;
template <class _CharT, class _Traits = char_traits<_CharT>>
class basic_streambuf;
template <class _CharT, class _Traits = char_traits<_CharT>>
class basic_istream;
template <class _CharT, class _Traits = char_traits<_CharT>>
class basic_ostream;
template <class _CharT, class _Traits = char_traits<_CharT>>
class basic_iostream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT>>
class basic_stringbuf;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT>>
class basic_istringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT>>
class basic_ostringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT>>
class basic_stringstream;
template <class _CharT, class _Traits = char_traits<_CharT>>
class basic_filebuf;
template <class _CharT, class _Traits = char_traits<_CharT>>
class basic_ifstream;
template <class _CharT, class _Traits = char_traits<_CharT>>
class basic_ofstream;
template <class _CharT, class _Traits = char_traits<_CharT>>
class basic_fstream;
template <class _CharT, class _Traits = char_traits<_CharT>>
class istreambuf_iterator;
template <class _CharT, class _Traits = char_traits<_CharT>>
class ostreambuf_iterator;
typedef basic_ios<char> ios;
typedef basic_ios<wchar_t> wios;
typedef basic_streambuf<char> streambuf;
typedef basic_istream<char> istream;
typedef basic_ostream<char> ostream;
typedef basic_iostream<char> iostream;
typedef basic_stringbuf<char> stringbuf;
typedef basic_istringstream<char> istringstream;
typedef basic_ostringstream<char> ostringstream;
typedef basic_stringstream<char> stringstream;
typedef basic_filebuf<char> filebuf;
typedef basic_ifstream<char> ifstream;
typedef basic_ofstream<char> ofstream;
typedef basic_fstream<char> fstream;
typedef basic_streambuf<wchar_t> wstreambuf;
typedef basic_istream<wchar_t> wistream;
typedef basic_ostream<wchar_t> wostream;
typedef basic_iostream<wchar_t> wiostream;
typedef basic_stringbuf<wchar_t> wstringbuf;
typedef basic_istringstream<wchar_t> wistringstream;
typedef basic_ostringstream<wchar_t> wostringstream;
typedef basic_stringstream<wchar_t> wstringstream;
typedef basic_filebuf<wchar_t> wfilebuf;
typedef basic_ifstream<wchar_t> wifstream;
typedef basic_ofstream<wchar_t> wofstream;
typedef basic_fstream<wchar_t> wfstream;
template <class _CharT, class _Traits>
class basic_ios;
template <class _CharT, class _Traits>
class basic_streambuf;
template <class _CharT, class _Traits>
class basic_istream;
template <class _CharT, class _Traits>
class basic_ostream;
template <class _CharT, class _Traits>
class basic_iostream;
template <class _CharT, class _Traits, class _Allocator>
class basic_stringbuf;
template <class _CharT, class _Traits, class _Allocator>
class basic_istringstream;
template <class _CharT, class _Traits, class _Allocator>
class basic_ostringstream;
template <class _CharT, class _Traits, class _Allocator>
class basic_stringstream;
template <class _CharT, class _Traits>
class basic_filebuf;
template <class _CharT, class _Traits>
class basic_ifstream;
template <class _CharT, class _Traits>
class basic_ofstream;
template <class _CharT, class _Traits>
class basic_fstream;
template <class _State>
class fpos;
typedef fpos<mbstate_t> streampos;
typedef fpos<mbstate_t> wstreampos;
typedef fpos<mbstate_t> u16streampos;
typedef fpos<mbstate_t> u32streampos;
typedef long long streamoff;
template <class _CharT,
          class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT>>
class basic_string;
typedef basic_string<char, char_traits<char>, allocator<char>> string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> wstring;
template <class _CharT, class _Traits, class _Allocator>
class basic_string;
template <class _Tp, class _Alloc = allocator<_Tp>>
class vector;
template <class _CharT, class _Traits>
class __save_flags
{
    typedef basic_ios<_CharT, _Traits> __stream_type;
    typedef typename __stream_type::fmtflags fmtflags;
    __stream_type &__stream_;
    fmtflags __fmtflags_;
    _CharT __fill_;
    __save_flags(const __save_flags &);
    __save_flags &operator=(const __save_flags &);

public:
    explicit __save_flags(__stream_type &__stream)
        : __stream_(__stream),
          __fmtflags_(__stream.flags()),
          __fill_(__stream.fill())
    {
    }

    ~__save_flags()
    {
        __stream_.flags(__fmtflags_);
        __stream_.fill(__fill_);
    }
};
}
}

namespace std
{
struct __type_info_implementations
{
struct __string_impl_base
{
    typedef const char *__type_name_t;

    static const char *__type_name_to_string(__type_name_t __v) throw()
    {
        return __v;
    }

    static __type_name_t __string_to_type_name(const char *__v) throw()
    {
        return __v;
    }
};
struct __unique_impl : __string_impl_base
{

    static size_t __hash(__type_name_t __v) throw()
    {
        return reinterpret_cast<size_t>(__v);
    }

    static bool __eq(__type_name_t __lhs, __type_name_t __rhs) throw()
    {
        return __lhs == __rhs;
    }

    static bool __lt(__type_name_t __lhs, __type_name_t __rhs) throw()
    {
        return __lhs < __rhs;
    }
};
struct __non_unique_impl : __string_impl_base
{

    static size_t __hash(__type_name_t __ptr) throw()
    {
        size_t __hash = 5381;
        while (unsigned char __c = static_cast<unsigned char>(*__ptr++))
            __hash = (__hash * 33) ^ __c;
        return __hash;
    }

    static bool __eq(__type_name_t __lhs, __type_name_t __rhs) throw()
    {
        return __lhs == __rhs || __builtin_strcmp(__lhs, __rhs) == 0;
    }

    static bool __lt(__type_name_t __lhs, __type_name_t __rhs) throw()
    {
        return __builtin_strcmp(__lhs, __rhs) < 0;
    }
};
struct __non_unique_arm_rtti_bit_impl
{
    typedef uintptr_t __type_name_t;

    static const char *__type_name_to_string(__type_name_t __v) throw()
    {
        return reinterpret_cast<const char *>(__v &
                                              ~__non_unique_rtti_bit::value);
    }

    static __type_name_t __string_to_type_name(const char *__v) throw()
    {
        return reinterpret_cast<__type_name_t>(__v);
    }

    static size_t __hash(__type_name_t __v) throw()
    {
        if (__is_type_name_unique(__v))
            return __v;
        return __non_unique_impl::__hash(__type_name_to_string(__v));
    }

    static bool __eq(__type_name_t __lhs, __type_name_t __rhs) throw()
    {
        if (__lhs == __rhs)
            return true;
        if (__is_type_name_unique(__lhs) || __is_type_name_unique(__rhs))
            return false;
        return __builtin_strcmp(__type_name_to_string(__lhs), __type_name_to_string(__rhs)) == 0;
    }

    static bool __lt(__type_name_t __lhs, __type_name_t __rhs) throw()
    {
        if (__is_type_name_unique(__lhs) || __is_type_name_unique(__rhs))
            return __lhs < __rhs;
        return __builtin_strcmp(__type_name_to_string(__lhs), __type_name_to_string(__rhs)) < 0;
    }

private:
    typedef integral_constant<__type_name_t,
                              (1ULL << ((8 * sizeof(__type_name_t)) - 1))>
        __non_unique_rtti_bit;

    static bool __is_type_name_unique(__type_name_t __lhs) throw()
    {
        return !(__lhs & __non_unique_rtti_bit::value);
    }
};
typedef __non_unique_arm_rtti_bit_impl
    __impl;
};
class type_info
{
type_info &operator=(const type_info &);
type_info(const type_info &);

protected:
typedef __type_info_implementations::__impl __impl;
__impl::__type_name_t __type_name;

explicit type_info(const char *__n)
    : __type_name(__impl::__string_to_type_name(__n)) {}

public:
virtual ~type_info();

const char *name() const throw()
{
    return __impl::__type_name_to_string(__type_name);
}

bool before(const type_info &__arg) const throw()
{
    return __impl::__lt(__type_name, __arg.__type_name);
}

size_t hash_code() const throw()
{
    return __impl::__hash(__type_name);
}

bool operator==(const type_info &__arg) const throw()
{
    return __impl::__eq(__type_name, __arg.__type_name);
}

bool operator!=(const type_info &__arg) const throw()
{
    return !operator==(__arg);
}
};
class bad_cast
    : public exception
{
public:
bad_cast() throw();
bad_cast(const bad_cast &) throw() = default;
virtual ~bad_cast() throw();
virtual const char *what() const throw();
};
class bad_typeid
    : public exception
{
public:
bad_typeid() throw();
virtual ~bad_typeid() throw();
virtual const char *what() const throw();
};
}
namespace std
{
inline namespace __1
{

void __throw_bad_cast()
{
    throw bad_cast();
}
}
}
namespace std
{
inline namespace __1
{
}
}

namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
template <size_t _Ip>
struct __priority_tag : __priority_tag<_Ip - 1>
{
};
template <>
struct __priority_tag<0>
{
};
}
}
namespace std
{
inline namespace __1
{
namespace rel_ops
{
    template <class _Tp>
    inline bool
    operator!=(const _Tp &__x, const _Tp &__y)
    {
        return !(__x == __y);
    }
    template <class _Tp>
    inline bool
    operator>(const _Tp &__x, const _Tp &__y)
    {
        return __y < __x;
    }
    template <class _Tp>
    inline bool
    operator<=(const _Tp &__x, const _Tp &__y)
    {
        return !(__y < __x);
    }
    template <class _Tp>
    inline bool
    operator>=(const _Tp &__x, const _Tp &__y)
    {
        return !(__x < __y);
    }
}
}
}

namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
template <class _Rollback>
struct __transaction
{
    __transaction() = delete;

    explicit __transaction(_Rollback __rollback)
        : __rollback_(std::move(__rollback)), __completed_(false)
    {
    }

    __transaction(__transaction &&__other)
        : __rollback_(std::move(__other.__rollback_)), __completed_(__other.__completed_)
    {
        __other.__completed_ = true;
    }
    __transaction(__transaction const &) = delete;
    __transaction &operator=(__transaction const &) = delete;
    __transaction &operator=(__transaction &&) = delete;

    void __complete() throw()
    {
        __completed_ = true;
    }

    ~__transaction()
    {
        if (!__completed_)
            __rollback_();
    }

private:
    _Rollback __rollback_;
    bool __completed_;
};
template <class _Rollback>
{
    return __transaction<_Rollback>(std::move(__rollback));
}
}
}
namespace std
{
inline namespace __1
{
}
}

namespace std
{
inline namespace __1
{
}
}
extern "C"
{
typedef float float_t;
typedef double double_t;
extern int __math_errhandling(void);
extern int __fpclassifyf(float);
extern int __fpclassifyd(double);
extern int __fpclassifyl(long double);
inline __attribute__((__always_inline__)) int __inline_isfinitef(float);
inline __attribute__((__always_inline__)) int __inline_isfinited(double);
inline __attribute__((__always_inline__)) int __inline_isfinitel(long double);
inline __attribute__((__always_inline__)) int __inline_isinff(float);
inline __attribute__((__always_inline__)) int __inline_isinfd(double);
inline __attribute__((__always_inline__)) int __inline_isinfl(long double);
inline __attribute__((__always_inline__)) int __inline_isnanf(float);
inline __attribute__((__always_inline__)) int __inline_isnand(double);
inline __attribute__((__always_inline__)) int __inline_isnanl(long double);
inline __attribute__((__always_inline__)) int __inline_isnormalf(float);
inline __attribute__((__always_inline__)) int __inline_isnormald(double);
inline __attribute__((__always_inline__)) int __inline_isnormall(long double);
inline __attribute__((__always_inline__)) int __inline_signbitf(float);
inline __attribute__((__always_inline__)) int __inline_signbitd(double);
inline __attribute__((__always_inline__)) int __inline_signbitl(long double);
inline __attribute__((__always_inline__)) int __inline_isfinitef(float __x)
{
return __x == __x && __builtin_fabsf(__x) != __builtin_inff();
}
inline __attribute__((__always_inline__)) int __inline_isfinited(double __x)
{
return __x == __x && __builtin_fabs(__x) != __builtin_inf();
}
inline __attribute__((__always_inline__)) int __inline_isfinitel(long double __x)
{
return __x == __x && __builtin_fabsl(__x) != __builtin_infl();
}
inline __attribute__((__always_inline__)) int __inline_isinff(float __x)
{
return __builtin_fabsf(__x) == __builtin_inff();
}
inline __attribute__((__always_inline__)) int __inline_isinfd(double __x)
{
return __builtin_fabs(__x) == __builtin_inf();
}
inline __attribute__((__always_inline__)) int __inline_isinfl(long double __x)
{
return __builtin_fabsl(__x) == __builtin_infl();
}
inline __attribute__((__always_inline__)) int __inline_isnanf(float __x)
{
return __x != __x;
}
inline __attribute__((__always_inline__)) int __inline_isnand(double __x)
{
return __x != __x;
}
inline __attribute__((__always_inline__)) int __inline_isnanl(long double __x)
{
return __x != __x;
}
inline __attribute__((__always_inline__)) int __inline_signbitf(float __x)
{
union
{
    float __f;
    unsigned int __u;
} __u;
__u.__f = __x;
return (int)(__u.__u >> 31);
}
inline __attribute__((__always_inline__)) int __inline_signbitd(double __x)
{
union
{
    double __f;
    unsigned long long __u;
} __u;
__u.__f = __x;
return (int)(__u.__u >> 63);
}
inline __attribute__((__always_inline__)) int __inline_signbitl(long double __x)
{
union
{
    long double __f;
    unsigned long long __u;
} __u;
__u.__f = __x;
return (int)(__u.__u >> 63);
}
inline __attribute__((__always_inline__)) int __inline_isnormalf(float __x)
{
return __inline_isfinitef(__x) && __builtin_fabsf(__x) >= 1.17549435e-38F;
}
inline __attribute__((__always_inline__)) int __inline_isnormald(double __x)
{
return __inline_isfinited(__x) && __builtin_fabs(__x) >= 2.2250738585072014e-308;
}
inline __attribute__((__always_inline__)) int __inline_isnormall(long double __x)
{
return __inline_isfinitel(__x) && __builtin_fabsl(__x) >= 2.2250738585072014e-308L;
}
extern float acosf(float);
extern double acos(double);
extern long double acosl(long double);
extern float asinf(float);
extern double asin(double);
extern long double asinl(long double);
extern float atanf(float);
extern double atan(double);
extern long double atanl(long double);
extern float atan2f(float, float);
extern double atan2(double, double);
extern long double atan2l(long double, long double);
extern float cosf(float);
extern double cos(double);
extern long double cosl(long double);
extern float sinf(float);
extern double sin(double);
extern long double sinl(long double);
extern float tanf(float);
extern double tan(double);
extern long double tanl(long double);
extern float acoshf(float);
extern double acosh(double);
extern long double acoshl(long double);
extern float asinhf(float);
extern double asinh(double);
extern long double asinhl(long double);
extern float atanhf(float);
extern double atanh(double);
extern long double atanhl(long double);
extern float coshf(float);
extern double cosh(double);
extern long double coshl(long double);
extern float sinhf(float);
extern double sinh(double);
extern long double sinhl(long double);
extern float tanhf(float);
extern double tanh(double);
extern long double tanhl(long double);
extern float expf(float);
extern double exp(double);
extern long double expl(long double);
extern float exp2f(float);
extern double exp2(double);
extern long double exp2l(long double);
extern float expm1f(float);
extern double expm1(double);
extern long double expm1l(long double);
extern float logf(float);
extern double log(double);
extern long double logl(long double);
extern float log10f(float);
extern double log10(double);
extern long double log10l(long double);
extern float log2f(float);
extern double log2(double);
extern long double log2l(long double);
extern float log1pf(float);
extern double log1p(double);
extern long double log1pl(long double);
extern float logbf(float);
extern double logb(double);
extern long double logbl(long double);
extern float modff(float, float *);
extern double modf(double, double *);
extern long double modfl(long double, long double *);
extern float ldexpf(float, int);
extern double ldexp(double, int);
extern long double ldexpl(long double, int);
extern float frexpf(float, int *);
extern double frexp(double, int *);
extern long double frexpl(long double, int *);
extern int ilogbf(float);
extern int ilogb(double);
extern int ilogbl(long double);
extern float scalbnf(float, int);
extern double scalbn(double, int);
extern long double scalbnl(long double, int);
extern float scalblnf(float, long int);
extern double scalbln(double, long int);
extern long double scalblnl(long double, long int);
extern float fabsf(float);
extern double fabs(double);
extern long double fabsl(long double);
extern float cbrtf(float);
extern double cbrt(double);
extern long double cbrtl(long double);
extern float hypotf(float, float);
extern double hypot(double, double);
extern long double hypotl(long double, long double);
extern float powf(float, float);
extern double pow(double, double);
extern long double powl(long double, long double);
extern float sqrtf(float);
extern double sqrt(double);
extern long double sqrtl(long double);
extern float erff(float);
extern double erf(double);
extern long double erfl(long double);
extern float erfcf(float);
extern double erfc(double);
extern long double erfcl(long double);
extern float lgammaf(float);
extern double lgamma(double);
extern long double lgammal(long double);
extern float tgammaf(float);
extern double tgamma(double);
extern long double tgammal(long double);
extern float ceilf(float);
extern double ceil(double);
extern long double ceill(long double);
extern float floorf(float);
extern double floor(double);
extern long double floorl(long double);
extern float nearbyintf(float);
extern double nearbyint(double);
extern long double nearbyintl(long double);
extern float rintf(float);
extern double rint(double);
extern long double rintl(long double);
extern long int lrintf(float);
extern long int lrint(double);
extern long int lrintl(long double);
extern float roundf(float);
extern double round(double);
extern long double roundl(long double);
extern long int lroundf(float);
extern long int lround(double);
extern long int lroundl(long double);
extern long long int llrintf(float);
extern long long int llrint(double);
extern long long int llrintl(long double);
extern long long int llroundf(float);
extern long long int llround(double);
extern long long int llroundl(long double);
extern float truncf(float);
extern double trunc(double);
extern long double truncl(long double);
extern float fmodf(float, float);
extern double fmod(double, double);
extern long double fmodl(long double, long double);
extern float remainderf(float, float);
extern double remainder(double, double);
extern long double remainderl(long double, long double);
extern float remquof(float, float, int *);
extern double remquo(double, double, int *);
extern long double remquol(long double, long double, int *);
extern float copysignf(float, float);
extern double copysign(double, double);
extern long double copysignl(long double, long double);
extern float nanf(const char *);
extern double nan(const char *);
extern long double nanl(const char *);
extern float nextafterf(float, float);
extern double nextafter(double, double);
extern long double nextafterl(long double, long double);
extern double nexttoward(double, long double);
extern float nexttowardf(float, long double);
extern long double nexttowardl(long double, long double);
extern float fdimf(float, float);
extern double fdim(double, double);
extern long double fdiml(long double, long double);
extern float fmaxf(float, float);
extern double fmax(double, double);
extern long double fmaxl(long double, long double);
extern float fminf(float, float);
extern double fmin(double, double);
extern long double fminl(long double, long double);
extern float fmaf(float, float, float);
extern double fma(double, double, double);
extern long double fmal(long double, long double, long double);
extern float __exp10f(float);
extern double __exp10(double);
inline __attribute__((__always_inline__)) void __sincosf(float __x, float *__sinp, float *__cosp);
inline __attribute__((__always_inline__)) void __sincos(double __x, double *__sinp, double *__cosp);
extern float __cospif(float);
extern double __cospi(double);
extern float __sinpif(float);
extern double __sinpi(double);
extern float __tanpif(float);
extern double __tanpi(double);
inline __attribute__((__always_inline__)) void __sincospif(float __x, float *__sinp, float *__cosp);
inline __attribute__((__always_inline__)) void __sincospi(double __x, double *__sinp, double *__cosp);
struct __float2
{
float __sinval;
float __cosval;
};
struct __double2
{
double __sinval;
double __cosval;
};
extern struct __float2 __sincosf_stret(float);
extern struct __double2 __sincos_stret(double);
extern struct __float2 __sincospif_stret(float);
extern struct __double2 __sincospi_stret(double);
inline __attribute__((__always_inline__)) void __sincosf(float __x, float *__sinp, float *__cosp)
{
const struct __float2 __stret = __sincosf_stret(__x);
*__sinp = __stret.__sinval;
*__cosp = __stret.__cosval;
}
inline __attribute__((__always_inline__)) void __sincos(double __x, double *__sinp, double *__cosp)
{
const struct __double2 __stret = __sincos_stret(__x);
*__sinp = __stret.__sinval;
*__cosp = __stret.__cosval;
}
inline __attribute__((__always_inline__)) void __sincospif(float __x, float *__sinp, float *__cosp)
{
const struct __float2 __stret = __sincospif_stret(__x);
*__sinp = __stret.__sinval;
*__cosp = __stret.__cosval;
}
inline __attribute__((__always_inline__)) void __sincospi(double __x, double *__sinp, double *__cosp)
{
const struct __double2 __stret = __sincospi_stret(__x);
*__sinp = __stret.__sinval;
*__cosp = __stret.__cosval;
}
extern double j0(double);
extern double j1(double);
extern double jn(int, double);
extern double y0(double);
extern double y1(double);
extern double yn(int, double);
extern double scalb(double, double);
extern int signgam;
}
extern "C++"
{
namespace std
{
inline namespace __1
{
    template <class _Tp>
    struct __numeric_type
    {
        static void __test(...);
        static float __test(float);
        static double __test(char);
        static double __test(int);
        static double __test(unsigned);
        static double __test(long);
        static double __test(unsigned long);
        static double __test(long long);
        static double __test(unsigned long long);
        static double __test(double);
        static long double __test(long double);
        typedef __decltype(__test(declval<_Tp>())) type;
        static const bool value = _IsNotSame<type, void>::value;
    };
    template <>
    struct __numeric_type<void>
    {
        static const bool value = true;
    };
    template <class _A1, class _A2 = void, class _A3 = void,
              bool = __numeric_type<_A1>::value &&
                  __numeric_type<_A2>::value &&
                      __numeric_type<_A3>::value>
    class __promote_imp
    {
    public:
        static const bool value = false;
    };
    template <class _A1, class _A2, class _A3>
    class __promote_imp<_A1, _A2, _A3, true>
    {
    private:
        typedef typename __promote_imp<_A1>::type __type1;
        typedef typename __promote_imp<_A2>::type __type2;
        typedef typename __promote_imp<_A3>::type __type3;

    public:
        typedef __decltype(__type1() + __type2() + __type3()) type;
        static const bool value = true;
    };
    template <class _A1, class _A2>
    class __promote_imp<_A1, _A2, void, true>
    {
    private:
        typedef typename __promote_imp<_A1>::type __type1;
        typedef typename __promote_imp<_A2>::type __type2;

    public:
        typedef __decltype(__type1() + __type2()) type;
        static const bool value = true;
    };
    template <class _A1>
    class __promote_imp<_A1, void, void, true>
    {
    public:
        typedef typename __numeric_type<_A1>::type type;
        static const bool value = true;
    };
    template <class _A1, class _A2 = void, class _A3 = void>
    class __promote : public __promote_imp<_A1, _A2, _A3>
    {
    };
}
}

template <class _A1>

bool __libcpp_signbit(_A1 __lcpp_x) throw()
{
return __builtin_signbit(__lcpp_x);
}
template <class _A1>
inline
    typename std::enable_if<std::is_floating_point<_A1>::value, bool>::type
    signbit(_A1 __lcpp_x) throw()
{
return __libcpp_signbit((typename std::__promote<_A1>::type)__lcpp_x);
}
template <class _A1>
inline
    typename std::enable_if<
        std::is_integral<_A1>::value && std::is_signed<_A1>::value, bool>::type
    signbit(_A1 __lcpp_x) throw()
{
return __lcpp_x < 0;
}
template <class _A1>
inline
    typename std::enable_if<
        std::is_integral<_A1>::value && !std::is_signed<_A1>::value, bool>::type
    signbit(_A1) throw()
{
return false;
}
template <class _A1>

int __libcpp_fpclassify(_A1 __lcpp_x) throw()
{
return __builtin_fpclassify(1, 2, 4, 5,
                            3, __lcpp_x);
}
template <class _A1>
inline
    typename std::enable_if<std::is_floating_point<_A1>::value, int>::type
    fpclassify(_A1 __lcpp_x) throw()
{
return __libcpp_fpclassify((typename std::__promote<_A1>::type)__lcpp_x);
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, int>::type
    fpclassify(_A1 __lcpp_x) throw()
{
return __lcpp_x == 0 ? 3 : 4;
}
template <class _A1>

bool __libcpp_isfinite(_A1 __lcpp_x) throw()
{
return __builtin_isfinite(__lcpp_x);
}
template <class _A1>
inline
    typename std::enable_if<
        std::is_arithmetic<_A1>::value && std::numeric_limits<_A1>::has_infinity,
        bool>::type
    isfinite(_A1 __lcpp_x) throw()
{
return __libcpp_isfinite((typename std::__promote<_A1>::type)__lcpp_x);
}
template <class _A1>
inline
    typename std::enable_if<
        std::is_arithmetic<_A1>::value && !std::numeric_limits<_A1>::has_infinity,
        bool>::type
    isfinite(_A1) throw()
{
return true;
}
template <class _A1>

bool __libcpp_isinf(_A1 __lcpp_x) throw()
{
return __builtin_isinf(__lcpp_x);
}
template <class _A1>
inline
    typename std::enable_if<
        std::is_arithmetic<_A1>::value && std::numeric_limits<_A1>::has_infinity,
        bool>::type
    isinf(_A1 __lcpp_x) throw()
{
return __libcpp_isinf((typename std::__promote<_A1>::type)__lcpp_x);
}
template <class _A1>
inline
    typename std::enable_if<
        std::is_arithmetic<_A1>::value && !std::numeric_limits<_A1>::has_infinity,
        bool>::type
    isinf(_A1) throw()
{
return false;
}
inline bool
isinf(float __lcpp_x) throw() { return __libcpp_isinf(__lcpp_x); }
inline bool
isinf(double __lcpp_x) throw() { return __libcpp_isinf(__lcpp_x); }
inline bool
isinf(long double __lcpp_x) throw() { return __libcpp_isinf(__lcpp_x); }
template <class _A1>

bool __libcpp_isnan(_A1 __lcpp_x) throw()
{
return __builtin_isnan(__lcpp_x);
}
template <class _A1>
inline
    typename std::enable_if<std::is_floating_point<_A1>::value, bool>::type
    isnan(_A1 __lcpp_x) throw()
{
return __libcpp_isnan((typename std::__promote<_A1>::type)__lcpp_x);
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, bool>::type
    isnan(_A1) throw()
{
return false;
}
inline bool
isnan(float __lcpp_x) throw() { return __libcpp_isnan(__lcpp_x); }
inline bool
isnan(double __lcpp_x) throw() { return __libcpp_isnan(__lcpp_x); }
inline bool
isnan(long double __lcpp_x) throw() { return __libcpp_isnan(__lcpp_x); }
template <class _A1>

bool __libcpp_isnormal(_A1 __lcpp_x) throw()
{
return __builtin_isnormal(__lcpp_x);
}
template <class _A1>
inline
    typename std::enable_if<std::is_floating_point<_A1>::value, bool>::type
    isnormal(_A1 __lcpp_x) throw()
{
return __libcpp_isnormal((typename std::__promote<_A1>::type)__lcpp_x);
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, bool>::type
    isnormal(_A1 __lcpp_x) throw()
{
return __lcpp_x != 0;
}
template <class _A1, class _A2>

bool __libcpp_isgreater(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
return __builtin_isgreater((__lcpp_x), (__lcpp_y));
}
template <class _A1, class _A2>
inline
    typename std::enable_if<
        std::is_arithmetic<_A1>::value &&
            std::is_arithmetic<_A2>::value,
        bool>::type
    isgreater(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
typedef typename std::__promote<_A1, _A2>::type type;
return __libcpp_isgreater((type)__lcpp_x, (type)__lcpp_y);
}
template <class _A1, class _A2>

bool __libcpp_isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
return __builtin_isgreaterequal((__lcpp_x), (__lcpp_y));
}
template <class _A1, class _A2>
inline
    typename std::enable_if<
        std::is_arithmetic<_A1>::value &&
            std::is_arithmetic<_A2>::value,
        bool>::type
    isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
typedef typename std::__promote<_A1, _A2>::type type;
return __libcpp_isgreaterequal((type)__lcpp_x, (type)__lcpp_y);
}
template <class _A1, class _A2>

bool __libcpp_isless(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
return __builtin_isless((__lcpp_x), (__lcpp_y));
}
template <class _A1, class _A2>
inline
    typename std::enable_if<
        std::is_arithmetic<_A1>::value &&
            std::is_arithmetic<_A2>::value,
        bool>::type
    isless(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
typedef typename std::__promote<_A1, _A2>::type type;
return __libcpp_isless((type)__lcpp_x, (type)__lcpp_y);
}
template <class _A1, class _A2>

bool __libcpp_islessequal(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
return __builtin_islessequal((__lcpp_x), (__lcpp_y));
}
template <class _A1, class _A2>
inline
    typename std::enable_if<
        std::is_arithmetic<_A1>::value &&
            std::is_arithmetic<_A2>::value,
        bool>::type
    islessequal(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
typedef typename std::__promote<_A1, _A2>::type type;
return __libcpp_islessequal((type)__lcpp_x, (type)__lcpp_y);
}
template <class _A1, class _A2>

bool __libcpp_islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
return __builtin_islessgreater((__lcpp_x), (__lcpp_y));
}
template <class _A1, class _A2>
inline
    typename std::enable_if<
        std::is_arithmetic<_A1>::value &&
            std::is_arithmetic<_A2>::value,
        bool>::type
    islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
typedef typename std::__promote<_A1, _A2>::type type;
return __libcpp_islessgreater((type)__lcpp_x, (type)__lcpp_y);
}
template <class _A1, class _A2>

bool __libcpp_isunordered(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
return __builtin_isunordered((__lcpp_x), (__lcpp_y));
}
template <class _A1, class _A2>
inline
    typename std::enable_if<
        std::is_arithmetic<_A1>::value &&
            std::is_arithmetic<_A2>::value,
        bool>::type
    isunordered(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
typedef typename std::__promote<_A1, _A2>::type type;
return __libcpp_isunordered((type)__lcpp_x, (type)__lcpp_y);
}
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    acos(_A1 __lcpp_x) throw() { return ::acos((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    asin(_A1 __lcpp_x) throw() { return ::asin((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    atan(_A1 __lcpp_x) throw() { return ::atan((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1, class _A2>
inline
    typename std::__enable_if_t<
        std::is_arithmetic<_A1>::value &&
            std::is_arithmetic<_A2>::value,
        std::__promote<_A1, _A2>>::type
    atan2(_A1 __lcpp_y, _A2 __lcpp_x) throw()
{
typedef typename std::__promote<_A1, _A2>::type __result_type;
_Static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), "");
return ::atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);
}
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    ceil(_A1 __lcpp_x) throw() { return ::ceil((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    cos(_A1 __lcpp_x) throw() { return ::cos((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    cosh(_A1 __lcpp_x) throw() { return ::cosh((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    exp(_A1 __lcpp_x) throw() { return ::exp((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    fabs(_A1 __lcpp_x) throw() { return ::fabs((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    floor(_A1 __lcpp_x) throw() { return ::floor((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1, class _A2>
inline
    typename std::__enable_if_t<
        std::is_arithmetic<_A1>::value &&
            std::is_arithmetic<_A2>::value,
        std::__promote<_A1, _A2>>::type
    fmod(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
typedef typename std::__promote<_A1, _A2>::type __result_type;
_Static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), "");
return ::fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    frexp(_A1 __lcpp_x, int *__lcpp_e) throw() { return ::frexp((double)__lcpp_x, __lcpp_e); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    ldexp(_A1 __lcpp_x, int __lcpp_e) throw() { return ::ldexp((double)__lcpp_x, __lcpp_e); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    log(_A1 __lcpp_x) throw() { return ::log((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    log10(_A1 __lcpp_x) throw() { return ::log10((double)__lcpp_x); }
inline;
}
inline;
}
inline;
}
inline;
}
template <class _A1, class _A2>
inline
    typename std::__enable_if_t<
        std::is_arithmetic<_A1>::value &&
            std::is_arithmetic<_A2>::value,
        std::__promote<_A1, _A2>>::type
    pow(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
typedef typename std::__promote<_A1, _A2>::type __result_type;
_Static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), "");
return ::pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    sin(_A1 __lcpp_x) throw() { return ::sin((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    sinh(_A1 __lcpp_x) throw() { return ::sinh((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    sqrt(_A1 __lcpp_x) throw() { return ::sqrt((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    tan(_A1 __lcpp_x) throw() { return ::tan((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    tanh(_A1 __lcpp_x) throw() { return ::tanh((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    acosh(_A1 __lcpp_x) throw() { return ::acosh((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    asinh(_A1 __lcpp_x) throw() { return ::asinh((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    atanh(_A1 __lcpp_x) throw() { return ::atanh((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    cbrt(_A1 __lcpp_x) throw() { return ::cbrt((double)__lcpp_x); }
inline
{
return __builtin_copysignf(__lcpp_x, __lcpp_y);
}
inline
{
return __builtin_copysign(__lcpp_x, __lcpp_y);
}
inline
{
return __builtin_copysignl(__lcpp_x, __lcpp_y);
}
template <class _A1, class _A2>
inline
    typename std::__enable_if_t<
        std::is_arithmetic<_A1>::value &&
            std::is_arithmetic<_A2>::value,
        std::__promote<_A1, _A2>>::type
    __libcpp_copysign(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
typedef typename std::__promote<_A1, _A2>::type __result_type;
_Static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), "");
return __builtin_copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}
inline
{
return ::__libcpp_copysign(__lcpp_x, __lcpp_y);
}
inline
{
return ::__libcpp_copysign(__lcpp_x, __lcpp_y);
}
template <class _A1, class _A2>
inline
    typename std::__enable_if_t<
        std::is_arithmetic<_A1>::value &&
            std::is_arithmetic<_A2>::value,
        std::__promote<_A1, _A2>>::type
    copysign(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
return ::__libcpp_copysign(__lcpp_x, __lcpp_y);
}
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    erf(_A1 __lcpp_x) throw() { return ::erf((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    erfc(_A1 __lcpp_x) throw() { return ::erfc((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    exp2(_A1 __lcpp_x) throw() { return ::exp2((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    expm1(_A1 __lcpp_x) throw() { return ::expm1((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1, class _A2>
inline
    typename std::__enable_if_t<
        std::is_arithmetic<_A1>::value &&
            std::is_arithmetic<_A2>::value,
        std::__promote<_A1, _A2>>::type
    fdim(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
typedef typename std::__promote<_A1, _A2>::type __result_type;
_Static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), "");
return ::fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}
inline
{
return __builtin_fmaf(__lcpp_x, __lcpp_y, __lcpp_z);
}
inline
{
return __builtin_fmal(__lcpp_x, __lcpp_y, __lcpp_z);
}
template <class _A1, class _A2, class _A3>
inline
    typename std::__enable_if_t<
        std::is_arithmetic<_A1>::value &&
            std::is_arithmetic<_A2>::value &&
            std::is_arithmetic<_A3>::value,
        std::__promote<_A1, _A2, _A3>>::type
    fma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) throw()
{
typedef typename std::__promote<_A1, _A2, _A3>::type __result_type;
_Static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value && std::_IsSame<_A3, __result_type>::value)), "");
return __builtin_fma((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);
}
inline;
}
inline;
}
template <class _A1, class _A2>
inline
    typename std::__enable_if_t<
        std::is_arithmetic<_A1>::value &&
            std::is_arithmetic<_A2>::value,
        std::__promote<_A1, _A2>>::type
    fmax(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
typedef typename std::__promote<_A1, _A2>::type __result_type;
_Static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), "");
return ::fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}
inline;
}
inline;
}
template <class _A1, class _A2>
inline
    typename std::__enable_if_t<
        std::is_arithmetic<_A1>::value &&
            std::is_arithmetic<_A2>::value,
        std::__promote<_A1, _A2>>::type
    fmin(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
typedef typename std::__promote<_A1, _A2>::type __result_type;
_Static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), "");
return ::fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}
inline;
}
inline;
}
template <class _A1, class _A2>
inline
    typename std::__enable_if_t<
        std::is_arithmetic<_A1>::value &&
            std::is_arithmetic<_A2>::value,
        std::__promote<_A1, _A2>>::type
    hypot(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
typedef typename std::__promote<_A1, _A2>::type __result_type;
_Static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), "");
return ::hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, int>::type
    ilogb(_A1 __lcpp_x) throw() { return ::ilogb((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    lgamma(_A1 __lcpp_x) throw() { return ::lgamma((double)__lcpp_x); }
inline
{
return __builtin_llrintf(__lcpp_x);
}
inline
{
return __builtin_llrintl(__lcpp_x);
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, long long>::type
    llrint(_A1 __lcpp_x) throw()
{
return __builtin_llrint((double)__lcpp_x);
}
inline
{
return __builtin_llroundf(__lcpp_x);
}
inline
{
return __builtin_llroundl(__lcpp_x);
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, long long>::type
    llround(_A1 __lcpp_x) throw()
{
return __builtin_llround((double)__lcpp_x);
}
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    log1p(_A1 __lcpp_x) throw() { return ::log1p((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    log2(_A1 __lcpp_x) throw() { return ::log2((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    logb(_A1 __lcpp_x) throw() { return ::logb((double)__lcpp_x); }
inline
{
return __builtin_lrintf(__lcpp_x);
}
inline
{
return __builtin_lrintl(__lcpp_x);
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, long>::type
    lrint(_A1 __lcpp_x) throw()
{
return __builtin_lrint((double)__lcpp_x);
}
inline
{
return __builtin_lroundf(__lcpp_x);
}
inline
{
return __builtin_lroundl(__lcpp_x);
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, long>::type
    lround(_A1 __lcpp_x) throw()
{
return __builtin_lround((double)__lcpp_x);
}
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    nearbyint(_A1 __lcpp_x) throw() { return ::nearbyint((double)__lcpp_x); }
inline;
}
inline;
}
template <class _A1, class _A2>
inline
    typename std::__enable_if_t<
        std::is_arithmetic<_A1>::value &&
            std::is_arithmetic<_A2>::value,
        std::__promote<_A1, _A2>>::type
    nextafter(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
typedef typename std::__promote<_A1, _A2>::type __result_type;
_Static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), "");
return ::nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    nexttoward(_A1 __lcpp_x, long double __lcpp_y) throw() { return ::nexttoward((double)__lcpp_x, __lcpp_y); }
inline;
}
inline;
}
template <class _A1, class _A2>
inline
    typename std::__enable_if_t<
        std::is_arithmetic<_A1>::value &&
            std::is_arithmetic<_A2>::value,
        std::__promote<_A1, _A2>>::type
    remainder(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
typedef typename std::__promote<_A1, _A2>::type __result_type;
_Static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), "");
return ::remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}
inline;
}
inline;
}
template <class _A1, class _A2>
inline
    typename std::__enable_if_t<
        std::is_arithmetic<_A1>::value &&
            std::is_arithmetic<_A2>::value,
        std::__promote<_A1, _A2>>::type
    remquo(_A1 __lcpp_x, _A2 __lcpp_y, int *__lcpp_z) throw()
{
typedef typename std::__promote<_A1, _A2>::type __result_type;
_Static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), "");
return ::remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);
}
inline
{
return __builtin_rintf(__lcpp_x);
}
inline
{
return __builtin_rintl(__lcpp_x);
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    rint(_A1 __lcpp_x) throw()
{
return __builtin_rint((double)__lcpp_x);
}
inline
{
return __builtin_round(__lcpp_x);
}
inline
{
return __builtin_roundl(__lcpp_x);
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    round(_A1 __lcpp_x) throw()
{
return __builtin_round((double)__lcpp_x);
}
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    scalbln(_A1 __lcpp_x, long __lcpp_y) throw() { return ::scalbln((double)__lcpp_x, __lcpp_y); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    scalbn(_A1 __lcpp_x, int __lcpp_y) throw() { return ::scalbn((double)__lcpp_x, __lcpp_y); }
inline;
}
inline;
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    tgamma(_A1 __lcpp_x) throw() { return ::tgamma((double)__lcpp_x); }
inline
{
return __builtin_trunc(__lcpp_x);
}
inline
{
return __builtin_truncl(__lcpp_x);
}
template <class _A1>
inline
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    trunc(_A1 __lcpp_x) throw()
{
return __builtin_trunc((double)__lcpp_x);
}
}

namespace std
{
inline namespace __1
{
using ::abs;
using ::acos;
using ::acosf;
using ::acosh;
using ::acoshf;
using ::acoshl;
using ::acosl;
using ::asin;
using ::asinf;
using ::asinh;
using ::asinhf;
using ::asinhl;
using ::asinl;
using ::atan;
using ::atan2;
using ::atan2f;
using ::atan2l;
using ::atanf;
using ::atanh;
using ::atanhf;
using ::atanhl;
using ::atanl;
using ::cbrt;
using ::cbrtf;
using ::cbrtl;
using ::ceil;
using ::ceilf;
using ::ceill;
using ::copysign;
using ::copysignf;
using ::copysignl;
using ::cos;
using ::cosf;
using ::cosh;
using ::coshf;
using ::coshl;
using ::cosl;
using ::double_t;
using ::erf;
using ::erfc;
using ::erfcf;
using ::erfcl;
using ::erff;
using ::erfl;
using ::exp;
using ::exp2;
using ::exp2f;
using ::exp2l;
using ::expf;
using ::expl;
using ::expm1;
using ::expm1f;
using ::expm1l;
using ::fabs;
using ::fabsf;
using ::fabsl;
using ::fdim;
using ::fdimf;
using ::fdiml;
using ::float_t;
using ::floor;
using ::floorf;
using ::floorl;
using ::fma;
using ::fmaf;
using ::fmal;
using ::fmax;
using ::fmaxf;
using ::fmaxl;
using ::fmin;
using ::fminf;
using ::fminl;
using ::fmod;
using ::fmodf;
using ::fmodl;
using ::fpclassify;
using ::frexp;
using ::frexpf;
using ::frexpl;
using ::hypot;
using ::hypotf;
using ::hypotl;
using ::ilogb;
using ::ilogbf;
using ::ilogbl;
using ::isfinite;
using ::isgreater;
using ::isgreaterequal;
using ::isinf;
using ::isless;
using ::islessequal;
using ::islessgreater;
using ::isnan;
using ::isnormal;
using ::isunordered;
using ::ldexp;
using ::ldexpf;
using ::ldexpl;
using ::lgamma;
using ::lgammaf;
using ::lgammal;
using ::llrint;
using ::llrintf;
using ::llrintl;
using ::llround;
using ::llroundf;
using ::llroundl;
using ::log;
using ::log10;
using ::log10f;
using ::log10l;
using ::log1p;
using ::log1pf;
using ::log1pl;
using ::log2;
using ::log2f;
using ::log2l;
using ::logb;
using ::logbf;
using ::logbl;
using ::logf;
using ::logl;
using ::lrint;
using ::lrintf;
using ::lrintl;
using ::lround;
using ::lroundf;
using ::lroundl;
using ::modf;
using ::modff;
using ::modfl;
using ::nan;
using ::nanf;
using ::nanl;
using ::nearbyint;
using ::nearbyintf;
using ::nearbyintl;
using ::nextafter;
using ::nextafterf;
using ::nextafterl;
using ::nexttoward;
using ::nexttowardf;
using ::nexttowardl;
using ::pow;
using ::powf;
using ::powl;
using ::remainder;
using ::remainderf;
using ::remainderl;
using ::remquo;
using ::remquof;
using ::remquol;
using ::rint;
using ::rintf;
using ::rintl;
using ::round;
using ::roundf;
using ::roundl;
using ::scalbln;
using ::scalblnf;
using ::scalblnl;
using ::scalbn;
using ::scalbnf;
using ::scalbnl;
using ::signbit;
using ::sin;
using ::sinf;
using ::sinh;
using ::sinhf;
using ::sinhl;
using ::sinl;
using ::sqrt;
using ::sqrtf;
using ::sqrtl;
using ::tan;
using ::tanf;
using ::tanh;
using ::tanhf;
using ::tanhl;
using ::tanl;
using ::tgamma;
using ::tgammaf;
using ::tgammal;
using ::trunc;
using ::truncf;
using ::truncl;
template <class _A1>

typename enable_if<is_floating_point<_A1>::value, bool>::type
__libcpp_isnan_or_builtin(_A1 __lcpp_x) throw()
{
    return __builtin_isnan(__lcpp_x);
}
template <class _A1>

typename enable_if<!is_floating_point<_A1>::value, bool>::type
__libcpp_isnan_or_builtin(_A1 __lcpp_x) throw()
{
    return isnan(__lcpp_x);
}
template <class _A1>

typename enable_if<is_floating_point<_A1>::value, bool>::type
__libcpp_isinf_or_builtin(_A1 __lcpp_x) throw()
{
    return __builtin_isinf(__lcpp_x);
}
template <class _A1>

typename enable_if<!is_floating_point<_A1>::value, bool>::type
__libcpp_isinf_or_builtin(_A1 __lcpp_x) throw()
{
    return isinf(__lcpp_x);
}
template <class _A1>

typename enable_if<is_floating_point<_A1>::value, bool>::type
__libcpp_isfinite_or_builtin(_A1 __lcpp_x) throw()
{
    return __builtin_isfinite(__lcpp_x);
}
template <class _A1>

typename enable_if<!is_floating_point<_A1>::value, bool>::type
__libcpp_isfinite_or_builtin(_A1 __lcpp_x) throw()
{
    return isfinite(__lcpp_x);
}
}
}

namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}

namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}

namespace std
{
class bad_variant_access : public exception
{
public:
virtual const char *what() const throw();
};
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}

namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}

namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}

namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
template <class _InputIter>
inline
    typename iterator_traits<_InputIter>::difference_type
    __distance(_InputIter __first, _InputIter __last, input_iterator_tag)
{
    typename iterator_traits<_InputIter>::difference_type __r(0);
    for (; __first != __last; ++__first)
        ++__r;
    return __r;
}
template <class _RandIter>
inline
    typename iterator_traits<_RandIter>::difference_type
    __distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)
{
    return __last - __first;
}
template <class _InputIter>
inline
    typename iterator_traits<_InputIter>::difference_type
    distance(_InputIter __first, _InputIter __last)
{
    return std::__distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());
}
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
template <class _Container, class _Predicate>

typename _Container::size_type
__libcpp_erase_if_container(_Container &__c, _Predicate &__pred)
{
    typename _Container::size_type __old_size = __c.size();
    const typename _Container::iterator __last = __c.end();
    for (typename _Container::iterator __iter = __c.begin(); __iter != __last;)
    {
        if (__pred(*__iter))
            __iter = __c.erase(__iter);
        else
            ++__iter;
    }
    return __old_size - __c.size();
}
}
}
namespace std
{
inline namespace __1
{
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Container>
class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
#pragma GCC diagnostic pop
protected:
    _Container *container;

public:
    typedef output_iterator_tag iterator_category;
    typedef void value_type;
    typedef void difference_type;
    typedef void pointer;
    typedef void reference;
    typedef _Container container_type;
    {}

    {
        container->push_front(__value);
        return *this;
    }
    {
        return *this;
    }
    {
        return *this;
    }
    {
        return *this;
    }
};
template <class _Container>
inline front_insert_iterator<_Container>
front_inserter(_Container &__x)
{
    return front_insert_iterator<_Container>(__x);
}
}
}

namespace std
{
inline namespace __1
{
struct __identity
{
    template <class _Tp>
    _Tp &&operator()(_Tp &&__t) const throw()
    {
        return std::forward<_Tp>(__t);
    }
    using is_transparent = void;
};
}
}

namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
template <class _Container>
using __insert_iterator_iter_t = typename _Container::iterator;
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Container>
class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
#pragma GCC diagnostic pop
protected:
    _Container *container;
    __insert_iterator_iter_t<_Container> iter;

public:
    typedef output_iterator_tag iterator_category;
    typedef void value_type;
    typedef void difference_type;
    typedef void pointer;
    typedef void reference;
    typedef _Container container_type;

        : container(std::addressof(__x)), iter(__i) {}

        {
            iter = container->insert(iter, __value);
            ++iter;
            return *this;
        }
        {
            return *this;
        }
        {
            return *this;
        }
        {
            return *this;
        }
};
template <class _Container>
inline insert_iterator<_Container>
inserter(_Container &__x, __insert_iterator_iter_t<_Container> __i)
{
        return insert_iterator<_Container>(__x, __i);
}
}
}
namespace std
{
inline namespace __1
{
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp, class _CharT = char,
          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>
class istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp *, const _Tp &>
{
#pragma GCC diagnostic pop
    public:
        typedef input_iterator_tag iterator_category;
        typedef _Tp value_type;
        typedef _Distance difference_type;
        typedef const _Tp *pointer;
        typedef const _Tp &reference;
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef basic_istream<_CharT, _Traits> istream_type;

    private:
        istream_type *__in_stream_;
        _Tp __value_;

    public:
        {}

        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = __nullptr;
        }
        const { return __value_; };
}

{
        if (!(*__in_stream_ >> __value_))
            __in_stream_ = __nullptr;
        return *this;
}

{
        istream_iterator __t(*this);
        ++(*this);
        return __t;
}
template <class _Up, class _CharU, class _TraitsU, class _DistanceU>
friend bool
operator==(const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU> &__x,
           const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU> &__y);
};
template <class _Tp, class _CharT, class _Traits, class _Distance>
inline bool
operator==(const istream_iterator<_Tp, _CharT, _Traits, _Distance> &__x,
           const istream_iterator<_Tp, _CharT, _Traits, _Distance> &__y)
{
return __x.__in_stream_ == __y.__in_stream_;
}
template <class _Tp, class _CharT, class _Traits, class _Distance>
inline bool
operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Distance> &__x,
           const istream_iterator<_Tp, _CharT, _Traits, _Distance> &__y)
{
return !(__x == __y);
}
}
}
namespace std
{
inline namespace __1
{
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _CharT, class _Traits>
class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT,
                      typename _Traits::off_type, _CharT *,
                      _CharT>
{
#pragma GCC diagnostic pop
    public:
        typedef input_iterator_tag iterator_category;
        typedef _CharT value_type;
        typedef typename _Traits::off_type difference_type;
        typedef _CharT *pointer;
        typedef _CharT reference;
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef typename _Traits::int_type int_type;
        typedef basic_streambuf<_CharT, _Traits> streambuf_type;
        typedef basic_istream<_CharT, _Traits> istream_type;

    private:
        mutable streambuf_type *__sbuf_;
        class __proxy
        {
            char_type __keep_;
            streambuf_type *__sbuf_;

            explicit __proxy(char_type __c, streambuf_type *__s)
                : __keep_(__c), __sbuf_(__s) {}
            friend class istreambuf_iterator;

        public:
            const { return __keep_; }
        };

        bool __test_for_eof() const
        {
            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))
                __sbuf_ = __nullptr;
            return __sbuf_ == __nullptr;
        }

    public:
        {}

            : __sbuf_(__s.rdbuf()){}

            : __sbuf_(__s){}

            : __sbuf_(__p.__sbuf_)
        {
        }
        const
        {
            return static_cast<char_type>(__sbuf_->sgetc());
        }

        {
            __sbuf_->sbumpc();
            return *this;
        }

        {
            return __proxy(__sbuf_->sbumpc(), __sbuf_);
        }
        const
        {
            return __test_for_eof() == __b.__test_for_eof();
        }
};
template <class _CharT, class _Traits>
inline bool operator==(const istreambuf_iterator<_CharT, _Traits> &__a,
                       const istreambuf_iterator<_CharT, _Traits> &__b)
{
        return __a.equal(__b);
}
template <class _CharT, class _Traits>
inline bool operator!=(const istreambuf_iterator<_CharT, _Traits> &__a,
                       const istreambuf_iterator<_CharT, _Traits> &__b)
{
        return !__a.equal(__b);
}
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
template <class _Iter>
class move_iterator
{
    public:
        typedef _Iter iterator_type;
        typedef _If<
            __is_cpp17_random_access_iterator<_Iter>::value,
            random_access_iterator_tag,
            typename iterator_traits<_Iter>::iterator_category>
            iterator_category;
        typedef typename iterator_traits<iterator_type>::value_type value_type;
        typedef typename iterator_traits<iterator_type>::difference_type difference_type;
        typedef iterator_type pointer;
        typedef typename iterator_traits<iterator_type>::reference __reference;
        typedef typename conditional<
            is_reference<__reference>::value,
            typename remove_reference<__reference>::type &&,
            __reference>::type reference;

        explicit move_iterator(_Iter __i) : __current_(std::move(__i)) {}

        move_iterator &operator++()
        {
            ++__current_;
            return *this;
        }

        pointer operator->() const { return __current_; }

        move_iterator() : __current_() {}
        template <class _Up, class = __enable_if_t<
                                 !is_same<_Up, _Iter>::value && is_convertible<const _Up &, _Iter>::value>>

        move_iterator(const move_iterator<_Up> &__u) : __current_(__u.base())
        {
        }
        template <class _Up, class = __enable_if_t<
                                 !is_same<_Up, _Iter>::value &&
                                 is_convertible<const _Up &, _Iter>::value &&
                                 is_assignable<_Iter &, const _Up &>::value>>

        move_iterator &operator=(const move_iterator<_Up> &__u)
        {
            __current_ = __u.base();
            return *this;
        }

        _Iter base() const { return __current_; }

        reference operator*() const { return static_cast<reference>(*__current_); }

        reference operator[](difference_type __n) const { return static_cast<reference>(__current_[__n]); }

        move_iterator operator++(int)
        {
            move_iterator __tmp(*this);
            ++__current_;
            return __tmp;
        }

        move_iterator &operator--()
        {
            --__current_;
            return *this;
        }

        move_iterator operator--(int)
        {
            move_iterator __tmp(*this);
            --__current_;
            return __tmp;
        }

        move_iterator operator+(difference_type __n) const { return move_iterator(__current_ + __n); }

        move_iterator &operator+=(difference_type __n)
        {
            __current_ += __n;
            return *this;
        }

        move_iterator operator-(difference_type __n) const { return move_iterator(__current_ - __n); }

        move_iterator &operator-=(difference_type __n)
        {
            __current_ -= __n;
            return *this;
        }

    private:
        template <class _It2>
        friend class move_iterator;
        _Iter __current_;
};
template <class _Iter1, class _Iter2>
inline bool operator==(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y)
{
        return __x.base() == __y.base();
}
template <class _Iter1, class _Iter2>
inline bool operator!=(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y)
{
        return __x.base() != __y.base();
}
template <class _Iter1, class _Iter2>
inline bool operator<(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y)
{
        return __x.base() < __y.base();
}
template <class _Iter1, class _Iter2>
inline bool operator>(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y)
{
        return __x.base() > __y.base();
}
template <class _Iter1, class _Iter2>
inline bool operator<=(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y)
{
        return __x.base() <= __y.base();
}
template <class _Iter1, class _Iter2>
inline bool operator>=(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y)
{
        return __x.base() >= __y.base();
}
template <class _Iter1, class _Iter2>
inline
    typename move_iterator<_Iter1>::difference_type
    operator-(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y)
{
        return __x.base() - __y.base();
}
template <class _Iter>
inline move_iterator<_Iter>
operator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter> &__x)
{
        return move_iterator<_Iter>(__x.base() + __n);
}
template <class _Iter>
inline move_iterator<_Iter>
make_move_iterator(_Iter __i)
{
        return move_iterator<_Iter>(std::move(__i));
}
}
}

namespace std
{
inline namespace __1
{
template <class _InputIter>
inline
    typename enable_if<__is_cpp17_input_iterator<_InputIter>::value, _InputIter>::type
    next(_InputIter __x, typename iterator_traits<_InputIter>::difference_type __n = 1)
{
        ((void)0);
        std::advance(__x, __n);
        return __x;
}
}
}
namespace std
{
inline namespace __1
{
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT>>
class ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
#pragma GCC diagnostic pop
    public:
        typedef output_iterator_tag iterator_category;
        typedef void value_type;
        typedef void difference_type;
        typedef void pointer;
        typedef void reference;
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef basic_ostream<_CharT, _Traits> ostream_type;

    private:
        ostream_type *__out_stream_;
        const char_type *__delim_;

    public:
        : __out_stream_(std::addressof(__s)), __delim_(__nullptr) {}
    
        : __out_stream_(std::addressof(__s)), __delim_(__delimiter) {}

        {
            *__out_stream_ << __value;
            if (__delim_)
                *__out_stream_ << __delim_;
            return *this;
        }
        {
            return *this;
        }
        {
            return *this;
        }
        {
            return *this;
        }
};
}
}
namespace std
{
inline namespace __1
{
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _CharT, class _Traits>
class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
#pragma GCC diagnostic pop
    public:
        typedef output_iterator_tag iterator_category;
        typedef void value_type;
        typedef void difference_type;
        typedef void pointer;
        typedef void reference;
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef basic_streambuf<_CharT, _Traits> streambuf_type;
        typedef basic_ostream<_CharT, _Traits> ostream_type;

    private:
        streambuf_type *__sbuf_;

    public:
        : __sbuf_(__s.rdbuf()) {}
    
        : __sbuf_(__s) {}

        {
            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))
                __sbuf_ = __nullptr;
            return *this;
        }
        {
            return *this;
        }
        {
            return *this;
        }
        {
            return *this;
        }
        {
            return __sbuf_ == __nullptr;
        }
        template <class _Ch, class _Tr>
        friend

            ostreambuf_iterator<_Ch, _Tr>
            __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,
                             const _Ch *__ob, const _Ch *__op, const _Ch *__oe,
                             ios_base &__iob, _Ch __fl);
};
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
template <class _InputIter>
inline
    typename enable_if<__is_cpp17_input_iterator<_InputIter>::value, _InputIter>::type
    prev(_InputIter __x, typename iterator_traits<_InputIter>::difference_type __n = 1)
{
        ((void)0);
        std::advance(__x, -__n);
        return __x;
}
}
}
namespace std
{
inline namespace __1
{
template <class _Iter, bool = __is_cpp17_contiguous_iterator<_Iter>::value>
struct __unwrap_iter_impl
{
        static { return __iter; }
        static { return __i; }
};
template <class _Iter>
struct __unwrap_iter_impl<_Iter, true>
{
        using _ToAddressT = __decltype(std::__to_address(std::declval<_Iter>()));
        static
        {
            return __orig_iter + (__unwrapped_iter - std::__to_address(__orig_iter));
        }
        static
        {
            return std::__to_address(__i);
        }
};
template <class _Iter,
          class _Impl = __unwrap_iter_impl<_Iter>,
          __enable_if_t<is_copy_constructible<_Iter>::value, int> = 0>
inline __decltype(_Impl::__unwrap(std::declval<_Iter>())) __unwrap_iter(_Iter __i) throw()
{
        return _Impl::__unwrap(__i);
}
template <class _OrigIter, class _Iter, class _Impl = __unwrap_iter_impl<_OrigIter>>
{
        return _Impl::__rewrap(std::move(__orig_iter), std::move(__iter));
}
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Iter>
class reverse_iterator
    : public iterator<typename iterator_traits<_Iter>::iterator_category,
                      typename iterator_traits<_Iter>::value_type,
                      typename iterator_traits<_Iter>::difference_type,
                      typename iterator_traits<_Iter>::pointer,
                      typename iterator_traits<_Iter>::reference>
{
#pragma GCC diagnostic pop
    private:
        _Iter __t;

    protected:
        _Iter current;

    public:
        using iterator_type = _Iter;
        using iterator_category = _If<__is_cpp17_random_access_iterator<_Iter>::value,
                                      random_access_iterator_tag,
                                      typename iterator_traits<_Iter>::iterator_category>;
        using pointer = typename iterator_traits<_Iter>::pointer;
        using value_type = typename iterator_traits<_Iter>::value_type;
        using difference_type = typename iterator_traits<_Iter>::difference_type;
        using reference = typename iterator_traits<_Iter>::reference;

        reverse_iterator() : __t(), current() {}

        explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}
        template <class _Up, class = __enable_if_t<
                                 !is_same<_Up, _Iter>::value && is_convertible<_Up const &, _Iter>::value>>

        reverse_iterator(const reverse_iterator<_Up> &__u)
            : __t(__u.base()), current(__u.base())
        {
        }
        template <class _Up, class = __enable_if_t<
                                 !is_same<_Up, _Iter>::value &&
                                 is_convertible<_Up const &, _Iter>::value &&
                                 is_assignable<_Iter &, _Up const &>::value>>

        reverse_iterator &operator=(const reverse_iterator<_Up> &__u)
        {
            __t = current = __u.base();
            return *this;
        }

        _Iter base() const { return current; }

        reference operator*() const
        {
            _Iter __tmp = current;
            return *--__tmp;
        }

        pointer operator->() const
        {
            return std::addressof(operator*());
        }

        reverse_iterator &operator++()
        {
            --current;
            return *this;
        }

        reverse_iterator operator++(int)
        {
            reverse_iterator __tmp(*this);
            --current;
            return __tmp;
        }

        reverse_iterator &operator--()
        {
            ++current;
            return *this;
        }

        reverse_iterator operator--(int)
        {
            reverse_iterator __tmp(*this);
            ++current;
            return __tmp;
        }

        reverse_iterator operator+(difference_type __n) const { return reverse_iterator(current - __n); }

        reverse_iterator &operator+=(difference_type __n)
        {
            current -= __n;
            return *this;
        }

        reverse_iterator operator-(difference_type __n) const { return reverse_iterator(current + __n); }

        reverse_iterator &operator-=(difference_type __n)
        {
            current += __n;
            return *this;
        }

        reference operator[](difference_type __n) const { return *(*this + __n); }
};
template <class _Iter>
struct __is_reverse_iterator : false_type
{
};
template <class _Iter>
struct __is_reverse_iterator<reverse_iterator<_Iter>> : true_type
{
};
template <class _Iter1, class _Iter2>
inline bool
operator==(const reverse_iterator<_Iter1> &__x, const reverse_iterator<_Iter2> &__y)
{
        return __x.base() == __y.base();
}
template <class _Iter1, class _Iter2>
inline bool
operator<(const reverse_iterator<_Iter1> &__x, const reverse_iterator<_Iter2> &__y)
{
        return __x.base() > __y.base();
}
template <class _Iter1, class _Iter2>
inline bool
operator!=(const reverse_iterator<_Iter1> &__x, const reverse_iterator<_Iter2> &__y)
{
        return __x.base() != __y.base();
}
template <class _Iter1, class _Iter2>
inline bool
operator>(const reverse_iterator<_Iter1> &__x, const reverse_iterator<_Iter2> &__y)
{
        return __x.base() < __y.base();
}
template <class _Iter1, class _Iter2>
inline bool
operator>=(const reverse_iterator<_Iter1> &__x, const reverse_iterator<_Iter2> &__y)
{
        return __x.base() <= __y.base();
}
template <class _Iter1, class _Iter2>
inline bool
operator<=(const reverse_iterator<_Iter1> &__x, const reverse_iterator<_Iter2> &__y)
{
        return __x.base() >= __y.base();
}
template <class _Iter1, class _Iter2>
inline
    typename reverse_iterator<_Iter1>::difference_type
    operator-(const reverse_iterator<_Iter1> &__x, const reverse_iterator<_Iter2> &__y)
{
        return __y.base() - __x.base();
}
template <class _Iter>
inline reverse_iterator<_Iter>
operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter> &__x)
{
        return reverse_iterator<_Iter>(__x.base() - __n);
}
template <class _Iter>
using __unconstrained_reverse_iterator = reverse_iterator<_Iter>;
template <template <class> class _RevIter1, template <class> class _RevIter2, class _Iter>
struct __unwrap_reverse_iter_impl
{
        using _UnwrappedIter = __decltype(__unwrap_iter_impl<_Iter>::__unwrap(std::declval<_Iter>()));
        using _ReverseWrapper = _RevIter1<_RevIter2<_Iter>>;
        static _ReverseWrapper
        __rewrap(_ReverseWrapper __orig_iter, _UnwrappedIter __unwrapped_iter)
        {
            return _ReverseWrapper(
                _RevIter2<_Iter>(__unwrap_iter_impl<_Iter>::__rewrap(__orig_iter.base().base(), __unwrapped_iter)));
        }
        static
        {
            return __unwrap_iter_impl<_Iter>::__unwrap(__i.base().base());
        }
};
template <class _Iter, bool __b>
struct __unwrap_iter_impl<reverse_iterator<reverse_iterator<_Iter>>, __b>
    : __unwrap_reverse_iter_impl<reverse_iterator, reverse_iterator, _Iter>
{
};
}
}
namespace std
{
inline namespace __1
{
}
}

namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
template <class _Iter>
class __wrap_iter
{
    public:
        typedef _Iter iterator_type;
        typedef typename iterator_traits<iterator_type>::value_type value_type;
        typedef typename iterator_traits<iterator_type>::difference_type difference_type;
        typedef typename iterator_traits<iterator_type>::pointer pointer;
        typedef typename iterator_traits<iterator_type>::reference reference;
        typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;

    private:
        iterator_type __i;

    public:
                : __i()
                {
                    std::__debug_db_insert_i(this);
                }
                template <class _Up>
                __wrap_iter(const __wrap_iter<_Up> &__u,
                            typename enable_if<is_convertible<_Up, iterator_type>::value>::type * = __nullptr) throw()
                    : __i(__u.base()){}

                {
                    ((void)0);
                    return *__i;
                }

                {
                    ((void)0);
                    return std::__to_address(__i);
                }

                {
                    ((void)0);
                    ++__i;
                    return *this;
                }

                {
                    __wrap_iter __tmp(*this);
                    ++(*this);
                    return __tmp;
                }

                {
                    ((void)0);
                    --__i;
                    return *this;
                }

                {
                    __wrap_iter __tmp(*this);
                    --(*this);
                    return __tmp;
                }

                {
                    __wrap_iter __w(*this);
                    __w += __n;
                    return __w;
                }

                {
                    ((void)0);
                    __i += __n;
                    return *this;
                }

                {
                    return *this + (-__n);
                }

                {
                    *this += -__n;
                    return *this;
                }

                {
                    ((void)0);
                    return __i[__n];
                }
                {
                    return __i;
                }

            private:
                explicit __wrap_iter(const void *__p, iterator_type __x) throw() : __i(__x)
                {
                    (void)__p;
                }
                template <class _Up>
                friend class __wrap_iter;
                template <class _CharT, class _Traits, class _Alloc>
                friend class basic_string;
                template <class _Tp, class _Alloc>
                friend class vector;
                template <class _Tp, size_t>
                friend class span;
};
template <class _Iter1>

bool operator==(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter1> &__y) throw()
{
                return __x.base() == __y.base();
}
template <class _Iter1, class _Iter2>

bool operator==(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter2> &__y) throw()
{
                return __x.base() == __y.base();
}
template <class _Iter1>

bool operator<(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter1> &__y) throw()
{
                ((void)0);
                return __x.base() < __y.base();
}
template <class _Iter1, class _Iter2>

bool operator<(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter2> &__y) throw()
{
                ((void)0);
                return __x.base() < __y.base();
}
template <class _Iter1>

bool operator!=(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter1> &__y) throw()
{
                return !(__x == __y);
}
template <class _Iter1, class _Iter2>

bool operator!=(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter2> &__y) throw()
{
                return !(__x == __y);
}
template <class _Iter1>

bool operator>(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter1> &__y) throw()
{
                return __y < __x;
}
template <class _Iter1, class _Iter2>

bool operator>(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter2> &__y) throw()
{
                return __y < __x;
}
template <class _Iter1>

bool operator>=(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter1> &__y) throw()
{
                return !(__x < __y);
}
template <class _Iter1, class _Iter2>

bool operator>=(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter2> &__y) throw()
{
                return !(__x < __y);
}
template <class _Iter1>

bool operator<=(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter1> &__y) throw()
{
                return !(__y < __x);
}
template <class _Iter1, class _Iter2>

bool operator<=(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter2> &__y) throw()
{
                return !(__y < __x);
}
template <class _Iter1, class _Iter2>

typename __wrap_iter<_Iter1>::difference_type
operator-(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter2> &__y) throw()
{
                ((void)0);
                return __x.base() - __y.base();
}
template <class _Iter1>

__wrap_iter<_Iter1> operator+(typename __wrap_iter<_Iter1>::difference_type __n, __wrap_iter<_Iter1> __x) throw()
{
                __x += __n;
                return __x;
}
template <class _It>
struct __is_cpp17_contiguous_iterator<__wrap_iter<_It>> : true_type
{
};
template <class _It>
struct pointer_traits<__wrap_iter<_It>>
{
                typedef __wrap_iter<_It> pointer;
                typedef typename pointer_traits<_It>::element_type element_type;
                typedef typename pointer_traits<_It>::difference_type difference_type;

                static element_type *to_address(pointer __w) throw()
                {
                    return std::__to_address(__w.base());
                }
};
}
}
namespace boost
{
template <class T>
inline T *
addressof(T &o)
{
return __builtin_addressof(o);
}
}
namespace boost
{
namespace operators_impl
{
namespace operators_detail
{
                template <typename T>
                class empty_base
                {
                };
}
template <class T, class U, class B = operators_detail::empty_base<T>>
struct less_than_comparable2 : B
{
                friend bool operator<=(const T &x, const U &y) { return !static_cast<bool>(x > y); }
                friend bool operator>=(const T &x, const U &y) { return !static_cast<bool>(x < y); }
                friend bool operator>(const U &x, const T &y) { return y < x; }
                friend bool operator<(const U &x, const T &y) { return y > x; }
                friend bool operator<=(const U &x, const T &y) { return !static_cast<bool>(y < x); }
                friend bool operator>=(const U &x, const T &y) { return !static_cast<bool>(y > x); }
};
template <class T, class B = operators_detail::empty_base<T>>
struct less_than_comparable1 : B
{
                friend bool operator>(const T &x, const T &y) { return y < x; }
                friend bool operator<=(const T &x, const T &y) { return !static_cast<bool>(y < x); }
                friend bool operator>=(const T &x, const T &y) { return !static_cast<bool>(x < y); }
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct equality_comparable2 : B
{
                friend bool operator==(const U &y, const T &x) { return x == y; }
                friend bool operator!=(const U &y, const T &x) { return !static_cast<bool>(x == y); }
                friend bool operator!=(const T &y, const U &x) { return !static_cast<bool>(y == x); }
};
template <class T, class B = operators_detail::empty_base<T>>
struct equality_comparable1 : B
{
                friend bool operator!=(const T &x, const T &y) { return !static_cast<bool>(x == y); }
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct multipliable2 : B
{
                friend T operator*(const T &lhs, const U &rhs)
                {
                    T nrv(lhs);
                    nrv *= rhs;
                    return nrv;
                }
                friend T operator*(const U &lhs, const T &rhs)
                {
                    T nrv(rhs);
                    nrv *= lhs;
                    return nrv;
                }
};
template <class T, class B = operators_detail::empty_base<T>>
struct multipliable1 : B
{
                friend T operator*(const T &lhs, const T &rhs)
                {
                    T nrv(lhs);
                    nrv *= rhs;
                    return nrv;
                }
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct addable2 : B
{
                friend T operator+(const T &lhs, const U &rhs)
                {
                    T nrv(lhs);
                    nrv += rhs;
                    return nrv;
                }
                friend T operator+(const U &lhs, const T &rhs)
                {
                    T nrv(rhs);
                    nrv += lhs;
                    return nrv;
                }
};
template <class T, class B = operators_detail::empty_base<T>>
struct addable1 : B
{
                friend T operator+(const T &lhs, const T &rhs)
                {
                    T nrv(lhs);
                    nrv += rhs;
                    return nrv;
                }
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct subtractable2 : B
{
                friend T operator-(const T &lhs, const U &rhs)
                {
                    T nrv(lhs);
                    nrv -= rhs;
                    return nrv;
                }
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct subtractable2_left : B
{
                friend T operator-(const U &lhs, const T &rhs)
                {
                    T nrv(lhs);
                    nrv -= rhs;
                    return nrv;
                }
};
template <class T, class B = operators_detail::empty_base<T>>
struct subtractable1 : B
{
                friend T operator-(const T &lhs, const T &rhs)
                {
                    T nrv(lhs);
                    nrv -= rhs;
                    return nrv;
                }
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct dividable2 : B
{
                friend T operator/(const T &lhs, const U &rhs)
                {
                    T nrv(lhs);
                    nrv /= rhs;
                    return nrv;
                }
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct dividable2_left : B
{
                friend T operator/(const U &lhs, const T &rhs)
                {
                    T nrv(lhs);
                    nrv /= rhs;
                    return nrv;
                }
};
template <class T, class B = operators_detail::empty_base<T>>
struct dividable1 : B
{
                friend T operator/(const T &lhs, const T &rhs)
                {
                    T nrv(lhs);
                    nrv /= rhs;
                    return nrv;
                }
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct modable2 : B
{
                friend T operator%(const T &lhs, const U &rhs)
                {
                    T nrv(lhs);
                    nrv %= rhs;
                    return nrv;
                }
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct modable2_left : B
{
                friend T operator%(const U &lhs, const T &rhs)
                {
                    T nrv(lhs);
                    nrv %= rhs;
                    return nrv;
                }
};
template <class T, class B = operators_detail::empty_base<T>>
struct modable1 : B
{
                friend T operator%(const T &lhs, const T &rhs)
                {
                    T nrv(lhs);
                    nrv %= rhs;
                    return nrv;
                }
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct xorable2 : B
{
                friend T operator^(const T &lhs, const U &rhs)
                {
                    T nrv(lhs);
                    nrv ^= rhs;
                    return nrv;
                }
                friend T operator^(const U &lhs, const T &rhs)
                {
                    T nrv(rhs);
                    nrv ^= lhs;
                    return nrv;
                }
};
template <class T, class B = operators_detail::empty_base<T>>
struct xorable1 : B
{
                friend T operator^(const T &lhs, const T &rhs)
                {
                    T nrv(lhs);
                    nrv ^= rhs;
                    return nrv;
                }
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct andable2 : B
{
                friend T operator&(const T &lhs, const U &rhs)
                {
                    T nrv(lhs);
                    nrv &= rhs;
                    return nrv;
                }
                friend T operator&(const U &lhs, const T &rhs)
                {
                    T nrv(rhs);
                    nrv &= lhs;
                    return nrv;
                }
};
template <class T, class B = operators_detail::empty_base<T>>
struct andable1 : B
{
                friend T operator&(const T &lhs, const T &rhs)
                {
                    T nrv(lhs);
                    nrv &= rhs;
                    return nrv;
                }
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct orable2 : B
{
                friend T operator|(const T &lhs, const U &rhs)
                {
                    T nrv(lhs);
                    nrv |= rhs;
                    return nrv;
                }
                friend T operator|(const U &lhs, const T &rhs)
                {
                    T nrv(rhs);
                    nrv |= lhs;
                    return nrv;
                }
};
template <class T, class B = operators_detail::empty_base<T>>
struct orable1 : B
{
                friend T operator|(const T &lhs, const T &rhs)
                {
                    T nrv(lhs);
                    nrv |= rhs;
                    return nrv;
                }
};
template <class T, class B = operators_detail::empty_base<T>>
struct incrementable : B
{
                friend T operator++(T &x, int)
                {
                    incrementable_type nrv(x);
                    ++x;
                    return nrv;
                }

            private:
                typedef T incrementable_type;
};
template <class T, class B = operators_detail::empty_base<T>>
struct decrementable : B
{
                friend T operator--(T &x, int)
                {
                    decrementable_type nrv(x);
                    --x;
                    return nrv;
                }

            private:
                typedef T decrementable_type;
};
template <class T, class P, class B = operators_detail::empty_base<T>>
struct dereferenceable : B
{
                P operator->() const
                {
                    return ::boost::addressof(*static_cast<const T &>(*this));
                }
};
template <class T, class I, class R, class B = operators_detail::empty_base<T>>
struct indexable : B
{
                R operator[](I n) const
                {
                    return *(static_cast<const T &>(*this) + n);
                }
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct left_shiftable2 : B
{
                friend T operator<<(const T &lhs, const U &rhs)
                {
                    T nrv(lhs);
                    nrv <<= rhs;
                    return nrv;
                }
};
template <class T, class B = operators_detail::empty_base<T>>
struct left_shiftable1 : B
{
                friend T operator<<(const T &lhs, const T &rhs)
                {
                    T nrv(lhs);
                    nrv <<= rhs;
                    return nrv;
                }
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct right_shiftable2 : B
{
                friend T operator>>(const T &lhs, const U &rhs)
                {
                    T nrv(lhs);
                    nrv >>= rhs;
                    return nrv;
                }
};
template <class T, class B = operators_detail::empty_base<T>>
struct right_shiftable1 : B
{
                friend T operator>>(const T &lhs, const T &rhs)
                {
                    T nrv(lhs);
                    nrv >>= rhs;
                    return nrv;
                }
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct equivalent2 : B
{
                friend bool operator==(const T &x, const U &y)
                {
                    return !static_cast<bool>(x < y) && !static_cast<bool>(x > y);
                }
};
template <class T, class B = operators_detail::empty_base<T>>
struct equivalent1 : B
{
                friend bool operator==(const T &x, const T &y)
                {
                    return !static_cast<bool>(x < y) && !static_cast<bool>(y < x);
                }
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct partially_ordered2 : B
{
                friend bool operator<=(const T &x, const U &y)
                {
                    return static_cast<bool>(x < y) || static_cast<bool>(x == y);
                }
                friend bool operator>=(const T &x, const U &y)
                {
                    return static_cast<bool>(x > y) || static_cast<bool>(x == y);
                }
                friend bool operator>(const U &x, const T &y)
                {
                    return y < x;
                }
                friend bool operator<(const U &x, const T &y)
                {
                    return y > x;
                }
                friend bool operator<=(const U &x, const T &y)
                {
                    return static_cast<bool>(y > x) || static_cast<bool>(y == x);
                }
                friend bool operator>=(const U &x, const T &y)
                {
                    return static_cast<bool>(y < x) || static_cast<bool>(y == x);
                }
};
template <class T, class B = operators_detail::empty_base<T>>
struct partially_ordered1 : B
{
                friend bool operator>(const T &x, const T &y)
                {
                    return y < x;
                }
                friend bool operator<=(const T &x, const T &y)
                {
                    return static_cast<bool>(x < y) || static_cast<bool>(x == y);
                }
                friend bool operator>=(const T &x, const T &y)
                {
                    return static_cast<bool>(y < x) || static_cast<bool>(x == y);
                }
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct totally_ordered2
    : less_than_comparable2<T, U, equality_comparable2<T, U, B>>
{
};
template <class T, class B = operators_detail::empty_base<T>>
struct totally_ordered1
    : less_than_comparable1<T, equality_comparable1<T, B>>
{
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct additive2
    : addable2<T, U, subtractable2<T, U, B>>
{
};
template <class T, class B = operators_detail::empty_base<T>>
struct additive1
    : addable1<T, subtractable1<T, B>>
{
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct multiplicative2
    : multipliable2<T, U, dividable2<T, U, B>>
{
};
template <class T, class B = operators_detail::empty_base<T>>
struct multiplicative1
    : multipliable1<T, dividable1<T, B>>
{
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct integer_multiplicative2
    : multiplicative2<T, U, modable2<T, U, B>>
{
};
template <class T, class B = operators_detail::empty_base<T>>
struct integer_multiplicative1
    : multiplicative1<T, modable1<T, B>>
{
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct arithmetic2
    : additive2<T, U, multiplicative2<T, U, B>>
{
};
template <class T, class B = operators_detail::empty_base<T>>
struct arithmetic1
    : additive1<T, multiplicative1<T, B>>
{
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct integer_arithmetic2
    : additive2<T, U, integer_multiplicative2<T, U, B>>
{
};
template <class T, class B = operators_detail::empty_base<T>>
struct integer_arithmetic1
    : additive1<T, integer_multiplicative1<T, B>>
{
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct bitwise2
    : xorable2<T, U, andable2<T, U, orable2<T, U, B>>>
{
};
template <class T, class B = operators_detail::empty_base<T>>
struct bitwise1
    : xorable1<T, andable1<T, orable1<T, B>>>
{
};
template <class T, class B = operators_detail::empty_base<T>>
struct unit_steppable
    : incrementable<T, decrementable<T, B>>
{
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct shiftable2
    : left_shiftable2<T, U, right_shiftable2<T, U, B>>
{
};
template <class T, class B = operators_detail::empty_base<T>>
struct shiftable1
    : left_shiftable1<T, right_shiftable1<T, B>>
{
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct ring_operators2
    : additive2<T, U, subtractable2_left<T, U, multipliable2<T, U, B>>>
{
};
template <class T, class B = operators_detail::empty_base<T>>
struct ring_operators1
    : additive1<T, multipliable1<T, B>>
{
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct ordered_ring_operators2
    : ring_operators2<T, U, totally_ordered2<T, U, B>>
{
};
template <class T, class B = operators_detail::empty_base<T>>
struct ordered_ring_operators1
    : ring_operators1<T, totally_ordered1<T, B>>
{
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct field_operators2
    : ring_operators2<T, U, dividable2<T, U, dividable2_left<T, U, B>>>
{
};
template <class T, class B = operators_detail::empty_base<T>>
struct field_operators1
    : ring_operators1<T, dividable1<T, B>>
{
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct ordered_field_operators2
    : field_operators2<T, U, totally_ordered2<T, U, B>>
{
};
template <class T, class B = operators_detail::empty_base<T>>
struct ordered_field_operators1
    : field_operators1<T, totally_ordered1<T, B>>
{
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct euclidian_ring_operators2
    : ring_operators2<T, U, dividable2<T, U, dividable2_left<T, U, modable2<T, U, modable2_left<T, U, B>>>>>
{
};
template <class T, class B = operators_detail::empty_base<T>>
struct euclidian_ring_operators1
    : ring_operators1<T, dividable1<T, modable1<T, B>>>
{
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct ordered_euclidian_ring_operators2
    : totally_ordered2<T, U, euclidian_ring_operators2<T, U, B>>
{
};
template <class T, class B = operators_detail::empty_base<T>>
struct ordered_euclidian_ring_operators1
    : totally_ordered1<T, euclidian_ring_operators1<T, B>>
{
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct euclidean_ring_operators2
    : ring_operators2<T, U, dividable2<T, U, dividable2_left<T, U, modable2<T, U, modable2_left<T, U, B>>>>>
{
};
template <class T, class B = operators_detail::empty_base<T>>
struct euclidean_ring_operators1
    : ring_operators1<T, dividable1<T, modable1<T, B>>>
{
};
template <class T, class U, class B = operators_detail::empty_base<T>>
struct ordered_euclidean_ring_operators2
    : totally_ordered2<T, U, euclidean_ring_operators2<T, U, B>>
{
};
template <class T, class B = operators_detail::empty_base<T>>
struct ordered_euclidean_ring_operators1
    : totally_ordered1<T, euclidean_ring_operators1<T, B>>
{
};
template <class T, class P, class B = operators_detail::empty_base<T>>
struct input_iteratable
    : equality_comparable1<T, incrementable<T, dereferenceable<T, P, B>>>
{
};
template <class T, class B = operators_detail::empty_base<T>>
struct output_iteratable
    : incrementable<T, B>
{
};
template <class T, class P, class B = operators_detail::empty_base<T>>
struct forward_iteratable
    : input_iteratable<T, P, B>
{
};
template <class T, class P, class B = operators_detail::empty_base<T>>
struct bidirectional_iteratable
    : forward_iteratable<T, P, decrementable<T, B>>
{
};
template <class T, class P, class D, class R, class B = operators_detail::empty_base<T>>
struct random_access_iteratable
    : bidirectional_iteratable<T, P, less_than_comparable1<T, additive2<T, D, indexable<T, D, R, B>>>>
{
};
namespace operators_detail
{
                struct true_t
                {
                };
                struct false_t
                {
                };
}
template <class T>
struct is_chained_base
{
                typedef operators_detail::false_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct less_than_comparable;
template <class T, class U, class B>
struct less_than_comparable<T, U, B, operators_detail::false_t> : less_than_comparable2<T, U, B>
{
};
template <class T, class U>
struct less_than_comparable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : less_than_comparable1<T, U>
{
};
template <class T, class B>
struct less_than_comparable<T, T, B, operators_detail::false_t> : less_than_comparable1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<less_than_comparable<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<less_than_comparable2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<less_than_comparable1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct equality_comparable;
template <class T, class U, class B>
struct equality_comparable<T, U, B, operators_detail::false_t> : equality_comparable2<T, U, B>
{
};
template <class T, class U>
struct equality_comparable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : equality_comparable1<T, U>
{
};
template <class T, class B>
struct equality_comparable<T, T, B, operators_detail::false_t> : equality_comparable1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<equality_comparable<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<equality_comparable2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<equality_comparable1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct multipliable;
template <class T, class U, class B>
struct multipliable<T, U, B, operators_detail::false_t> : multipliable2<T, U, B>
{
};
template <class T, class U>
struct multipliable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : multipliable1<T, U>
{
};
template <class T, class B>
struct multipliable<T, T, B, operators_detail::false_t> : multipliable1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<multipliable<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<multipliable2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<multipliable1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct addable;
template <class T, class U, class B>
struct addable<T, U, B, operators_detail::false_t> : addable2<T, U, B>
{
};
template <class T, class U>
struct addable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : addable1<T, U>
{
};
template <class T, class B>
struct addable<T, T, B, operators_detail::false_t> : addable1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<addable<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<addable2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<addable1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct subtractable;
template <class T, class U, class B>
struct subtractable<T, U, B, operators_detail::false_t> : subtractable2<T, U, B>
{
};
template <class T, class U>
struct subtractable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : subtractable1<T, U>
{
};
template <class T, class B>
struct subtractable<T, T, B, operators_detail::false_t> : subtractable1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<subtractable<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<subtractable2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<subtractable1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<subtractable2_left<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct dividable;
template <class T, class U, class B>
struct dividable<T, U, B, operators_detail::false_t> : dividable2<T, U, B>
{
};
template <class T, class U>
struct dividable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : dividable1<T, U>
{
};
template <class T, class B>
struct dividable<T, T, B, operators_detail::false_t> : dividable1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<dividable<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<dividable2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<dividable1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<dividable2_left<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct modable;
template <class T, class U, class B>
struct modable<T, U, B, operators_detail::false_t> : modable2<T, U, B>
{
};
template <class T, class U>
struct modable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : modable1<T, U>
{
};
template <class T, class B>
struct modable<T, T, B, operators_detail::false_t> : modable1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<modable<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<modable2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<modable1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<modable2_left<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct xorable;
template <class T, class U, class B>
struct xorable<T, U, B, operators_detail::false_t> : xorable2<T, U, B>
{
};
template <class T, class U>
struct xorable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : xorable1<T, U>
{
};
template <class T, class B>
struct xorable<T, T, B, operators_detail::false_t> : xorable1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<xorable<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<xorable2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<xorable1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct andable;
template <class T, class U, class B>
struct andable<T, U, B, operators_detail::false_t> : andable2<T, U, B>
{
};
template <class T, class U>
struct andable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : andable1<T, U>
{
};
template <class T, class B>
struct andable<T, T, B, operators_detail::false_t> : andable1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<andable<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<andable2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<andable1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct orable;
template <class T, class U, class B>
struct orable<T, U, B, operators_detail::false_t> : orable2<T, U, B>
{
};
template <class T, class U>
struct orable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : orable1<T, U>
{
};
template <class T, class B>
struct orable<T, T, B, operators_detail::false_t> : orable1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<orable<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<orable2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<orable1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<incrementable<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<decrementable<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<dereferenceable<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class V, class B>
struct is_chained_base<indexable<T, U, V, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct left_shiftable;
template <class T, class U, class B>
struct left_shiftable<T, U, B, operators_detail::false_t> : left_shiftable2<T, U, B>
{
};
template <class T, class U>
struct left_shiftable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : left_shiftable1<T, U>
{
};
template <class T, class B>
struct left_shiftable<T, T, B, operators_detail::false_t> : left_shiftable1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<left_shiftable<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<left_shiftable2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<left_shiftable1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct right_shiftable;
template <class T, class U, class B>
struct right_shiftable<T, U, B, operators_detail::false_t> : right_shiftable2<T, U, B>
{
};
template <class T, class U>
struct right_shiftable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : right_shiftable1<T, U>
{
};
template <class T, class B>
struct right_shiftable<T, T, B, operators_detail::false_t> : right_shiftable1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<right_shiftable<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<right_shiftable2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<right_shiftable1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct equivalent;
template <class T, class U, class B>
struct equivalent<T, U, B, operators_detail::false_t> : equivalent2<T, U, B>
{
};
template <class T, class U>
struct equivalent<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : equivalent1<T, U>
{
};
template <class T, class B>
struct equivalent<T, T, B, operators_detail::false_t> : equivalent1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<equivalent<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<equivalent2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<equivalent1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct partially_ordered;
template <class T, class U, class B>
struct partially_ordered<T, U, B, operators_detail::false_t> : partially_ordered2<T, U, B>
{
};
template <class T, class U>
struct partially_ordered<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : partially_ordered1<T, U>
{
};
template <class T, class B>
struct partially_ordered<T, T, B, operators_detail::false_t> : partially_ordered1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<partially_ordered<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<partially_ordered2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<partially_ordered1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct totally_ordered;
template <class T, class U, class B>
struct totally_ordered<T, U, B, operators_detail::false_t> : totally_ordered2<T, U, B>
{
};
template <class T, class U>
struct totally_ordered<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : totally_ordered1<T, U>
{
};
template <class T, class B>
struct totally_ordered<T, T, B, operators_detail::false_t> : totally_ordered1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<totally_ordered<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<totally_ordered2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<totally_ordered1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct additive;
template <class T, class U, class B>
struct additive<T, U, B, operators_detail::false_t> : additive2<T, U, B>
{
};
template <class T, class U>
struct additive<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : additive1<T, U>
{
};
template <class T, class B>
struct additive<T, T, B, operators_detail::false_t> : additive1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<additive<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<additive2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<additive1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct multiplicative;
template <class T, class U, class B>
struct multiplicative<T, U, B, operators_detail::false_t> : multiplicative2<T, U, B>
{
};
template <class T, class U>
struct multiplicative<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : multiplicative1<T, U>
{
};
template <class T, class B>
struct multiplicative<T, T, B, operators_detail::false_t> : multiplicative1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<multiplicative<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<multiplicative2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<multiplicative1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct integer_multiplicative;
template <class T, class U, class B>
struct integer_multiplicative<T, U, B, operators_detail::false_t> : integer_multiplicative2<T, U, B>
{
};
template <class T, class U>
struct integer_multiplicative<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : integer_multiplicative1<T, U>
{
};
template <class T, class B>
struct integer_multiplicative<T, T, B, operators_detail::false_t> : integer_multiplicative1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<integer_multiplicative<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<integer_multiplicative2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<integer_multiplicative1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct arithmetic;
template <class T, class U, class B>
struct arithmetic<T, U, B, operators_detail::false_t> : arithmetic2<T, U, B>
{
};
template <class T, class U>
struct arithmetic<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : arithmetic1<T, U>
{
};
template <class T, class B>
struct arithmetic<T, T, B, operators_detail::false_t> : arithmetic1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<arithmetic<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<arithmetic2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<arithmetic1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct integer_arithmetic;
template <class T, class U, class B>
struct integer_arithmetic<T, U, B, operators_detail::false_t> : integer_arithmetic2<T, U, B>
{
};
template <class T, class U>
struct integer_arithmetic<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : integer_arithmetic1<T, U>
{
};
template <class T, class B>
struct integer_arithmetic<T, T, B, operators_detail::false_t> : integer_arithmetic1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<integer_arithmetic<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<integer_arithmetic2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<integer_arithmetic1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct bitwise;
template <class T, class U, class B>
struct bitwise<T, U, B, operators_detail::false_t> : bitwise2<T, U, B>
{
};
template <class T, class U>
struct bitwise<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : bitwise1<T, U>
{
};
template <class T, class B>
struct bitwise<T, T, B, operators_detail::false_t> : bitwise1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<bitwise<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<bitwise2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<bitwise1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<unit_steppable<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct shiftable;
template <class T, class U, class B>
struct shiftable<T, U, B, operators_detail::false_t> : shiftable2<T, U, B>
{
};
template <class T, class U>
struct shiftable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : shiftable1<T, U>
{
};
template <class T, class B>
struct shiftable<T, T, B, operators_detail::false_t> : shiftable1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<shiftable<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<shiftable2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<shiftable1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct ring_operators;
template <class T, class U, class B>
struct ring_operators<T, U, B, operators_detail::false_t> : ring_operators2<T, U, B>
{
};
template <class T, class U>
struct ring_operators<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : ring_operators1<T, U>
{
};
template <class T, class B>
struct ring_operators<T, T, B, operators_detail::false_t> : ring_operators1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<ring_operators<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<ring_operators2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<ring_operators1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct ordered_ring_operators;
template <class T, class U, class B>
struct ordered_ring_operators<T, U, B, operators_detail::false_t> : ordered_ring_operators2<T, U, B>
{
};
template <class T, class U>
struct ordered_ring_operators<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : ordered_ring_operators1<T, U>
{
};
template <class T, class B>
struct ordered_ring_operators<T, T, B, operators_detail::false_t> : ordered_ring_operators1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<ordered_ring_operators<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<ordered_ring_operators2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<ordered_ring_operators1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct field_operators;
template <class T, class U, class B>
struct field_operators<T, U, B, operators_detail::false_t> : field_operators2<T, U, B>
{
};
template <class T, class U>
struct field_operators<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : field_operators1<T, U>
{
};
template <class T, class B>
struct field_operators<T, T, B, operators_detail::false_t> : field_operators1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<field_operators<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<field_operators2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<field_operators1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct ordered_field_operators;
template <class T, class U, class B>
struct ordered_field_operators<T, U, B, operators_detail::false_t> : ordered_field_operators2<T, U, B>
{
};
template <class T, class U>
struct ordered_field_operators<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : ordered_field_operators1<T, U>
{
};
template <class T, class B>
struct ordered_field_operators<T, T, B, operators_detail::false_t> : ordered_field_operators1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<ordered_field_operators<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<ordered_field_operators2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<ordered_field_operators1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct euclidian_ring_operators;
template <class T, class U, class B>
struct euclidian_ring_operators<T, U, B, operators_detail::false_t> : euclidian_ring_operators2<T, U, B>
{
};
template <class T, class U>
struct euclidian_ring_operators<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : euclidian_ring_operators1<T, U>
{
};
template <class T, class B>
struct euclidian_ring_operators<T, T, B, operators_detail::false_t> : euclidian_ring_operators1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<euclidian_ring_operators<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<euclidian_ring_operators2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<euclidian_ring_operators1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct ordered_euclidian_ring_operators;
template <class T, class U, class B>
struct ordered_euclidian_ring_operators<T, U, B, operators_detail::false_t> : ordered_euclidian_ring_operators2<T, U, B>
{
};
template <class T, class U>
struct ordered_euclidian_ring_operators<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : ordered_euclidian_ring_operators1<T, U>
{
};
template <class T, class B>
struct ordered_euclidian_ring_operators<T, T, B, operators_detail::false_t> : ordered_euclidian_ring_operators1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<ordered_euclidian_ring_operators<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<ordered_euclidian_ring_operators2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<ordered_euclidian_ring_operators1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct euclidean_ring_operators;
template <class T, class U, class B>
struct euclidean_ring_operators<T, U, B, operators_detail::false_t> : euclidean_ring_operators2<T, U, B>
{
};
template <class T, class U>
struct euclidean_ring_operators<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : euclidean_ring_operators1<T, U>
{
};
template <class T, class B>
struct euclidean_ring_operators<T, T, B, operators_detail::false_t> : euclidean_ring_operators1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<euclidean_ring_operators<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<euclidean_ring_operators2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<euclidean_ring_operators1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U = T, class B = operators_detail::empty_base<T>, class O = typename is_chained_base<U>::value>
struct ordered_euclidean_ring_operators;
template <class T, class U, class B>
struct ordered_euclidean_ring_operators<T, U, B, operators_detail::false_t> : ordered_euclidean_ring_operators2<T, U, B>
{
};
template <class T, class U>
struct ordered_euclidean_ring_operators<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : ordered_euclidean_ring_operators1<T, U>
{
};
template <class T, class B>
struct ordered_euclidean_ring_operators<T, T, B, operators_detail::false_t> : ordered_euclidean_ring_operators1<T, B>
{
};
template <class T, class U, class B, class O>
struct is_chained_base<ordered_euclidean_ring_operators<T, U, B, O>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<ordered_euclidean_ring_operators2<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<ordered_euclidean_ring_operators1<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<input_iteratable<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class B>
struct is_chained_base<output_iteratable<T, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<forward_iteratable<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class B>
struct is_chained_base<bidirectional_iteratable<T, U, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U, class V, class W, class B>
struct is_chained_base<random_access_iteratable<T, U, V, W, B>>
{
                typedef operators_detail::true_t value;
};
template <class T, class U>
struct operators2
    : totally_ordered2<T, U, integer_arithmetic2<T, U, bitwise2<T, U>>>
{
};
template <class T, class U = T>
struct operators : operators2<T, U>
{
};
template <class T>
struct operators<T, T>
    : totally_ordered<T, integer_arithmetic<T, bitwise<T, unit_steppable<T>>>>
{
};
template <class Category,
          class T,
          class Distance = std::ptrdiff_t,
          class Pointer = T *,
          class Reference = T &>
struct iterator_helper
{
                typedef Category iterator_category;
                typedef T value_type;
                typedef Distance difference_type;
                typedef Pointer pointer;
                typedef Reference reference;
};
template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V const *,
          class R = V const &>
struct input_iterator_helper
    : input_iteratable<T, P, iterator_helper<std::input_iterator_tag, V, D, P, R>>
{
};
template <class T>
struct output_iterator_helper
    : output_iteratable<T, iterator_helper<std::output_iterator_tag, void, void, void, void>>
{
                T &operator*() { return static_cast<T &>(*this); }
                T &operator++() { return static_cast<T &>(*this); }
};
template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V *,
          class R = V &>
struct forward_iterator_helper
    : forward_iteratable<T, P, iterator_helper<std::forward_iterator_tag, V, D, P, R>>
{
};
template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V *,
          class R = V &>
struct bidirectional_iterator_helper
    : bidirectional_iteratable<T, P, iterator_helper<std::bidirectional_iterator_tag, V, D, P, R>>
{
};
template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V *,
          class R = V &>
struct random_access_iterator_helper
    : random_access_iteratable<T, P, D, R, iterator_helper<std::random_access_iterator_tag, V, D, P, R>>
{
                friend D requires_difference_operator(const T &x, const T &y)
                {
                    return x - y;
                }
};
}
using namespace operators_impl;
}

namespace boost
{
namespace date_time
{
template <typename YearType, typename MonthType, typename DayType>
struct year_month_day_base
{
                year_month_day_base(YearType year,
                                    MonthType month,
                                    DayType day);
                YearType year;
                MonthType month;
                DayType day;
                typedef YearType year_type;
                typedef MonthType month_type;
                typedef DayType day_type;
};
template <typename YearType, typename MonthType, typename DayType>
inline year_month_day_base<YearType, MonthType, DayType>::year_month_day_base(YearType y,
                                                                              MonthType m,
                                                                              DayType d) : year(y),
                                                                                           month(m),
                                                                                           day(d)
{
}
}
}
namespace boost
{
namespace date_time
{
enum special_values
{
    not_a_date_time,
    neg_infin,
    pos_infin,
    min_date_time,
    max_date_time,
    not_special,
    NumSpecialValues
};
}
}

namespace boost
{
namespace date_time
{
template <class T, class calendar, class duration_type_>
class date : private boost::less_than_comparable<T, boost::equality_comparable<T>>
{
            public:
                typedef T date_type;
                typedef calendar calendar_type;
                typedef typename calendar::date_traits_type traits_type;
                typedef duration_type_ duration_type;
                typedef typename calendar::year_type year_type;
                typedef typename calendar::month_type month_type;
                typedef typename calendar::day_type day_type;
                typedef typename calendar::ymd_type ymd_type;
                typedef typename calendar::date_rep_type date_rep_type;
                typedef typename calendar::date_int_type date_int_type;
                typedef typename calendar::day_of_week_type day_of_week_type;
                date(year_type y, month_type m, day_type d)
                    : days_(calendar::day_number(ymd_type(y, m, d)))
                {
                }
                date(const ymd_type &ymd)
                    : days_(calendar::day_number(ymd))
                {
                }
                year_type year() const
                {
                    ymd_type ymd = calendar::from_day_number(days_);
                    return ymd.year;
                }
                month_type month() const
                {
                    ymd_type ymd = calendar::from_day_number(days_);
                    return ymd.month;
                }
                day_type day() const
                {
                    ymd_type ymd = calendar::from_day_number(days_);
                    return ymd.day;
                }
                day_of_week_type day_of_week() const
                {
                    ymd_type ymd = calendar::from_day_number(days_);
                    return calendar::day_of_week(ymd);
                }
                ymd_type year_month_day() const
                {
                    return calendar::from_day_number(days_);
                }
                bool operator<(const date_type &rhs) const
                {
                    return days_ < rhs.days_;
                }
                bool operator==(const date_type &rhs) const
                {
                    return days_ == rhs.days_;
                }
                bool is_special() const
                {
                    return (is_not_a_date() || is_infinity());
                }
                bool is_not_a_date() const
                {
                    return traits_type::is_not_a_number(days_);
                }
                bool is_infinity() const
                {
                    return traits_type::is_inf(days_);
                }
                bool is_pos_infinity() const
                {
                    return traits_type::is_pos_inf(days_);
                }
                bool is_neg_infinity() const
                {
                    return traits_type::is_neg_inf(days_);
                }
                special_values as_special() const
                {
                    return traits_type::to_special(days_);
                }
                duration_type operator-(const date_type &d) const
                {
                    if (!this->is_special() && !d.is_special())
                    {
                        typedef typename duration_type::duration_rep_type duration_rep_type;
                        return duration_type(static_cast<duration_rep_type>(days_) - static_cast<duration_rep_type>(d.days_));
                    }
                    else
                    {
                        date_rep_type val = date_rep_type(days_) - date_rep_type(d.days_);
                        return duration_type(val.as_special());
                    }
                }
                date_type operator-(const duration_type &dd) const
                {
                    if (dd.is_special())
                    {
                        return date_type(date_rep_type(days_) - dd.get_rep());
                    }
                    return date_type(date_rep_type(days_) - static_cast<date_int_type>(dd.days()));
                }
                date_type operator-=(const duration_type &dd)
                {
                    *this = *this - dd;
                    return date_type(days_);
                }
                date_rep_type day_count() const
                {
                    return days_;
                }
                date_type operator+(const duration_type &dd) const
                {
                    if (dd.is_special())
                    {
                        return date_type(date_rep_type(days_) + dd.get_rep());
                    }
                    return date_type(date_rep_type(days_) + static_cast<date_int_type>(dd.days()));
                }
                date_type operator+=(const duration_type &dd)
                {
                    *this = *this + dd;
                    return date_type(days_);
                }

            protected:
                explicit date(date_int_type days) : days_(days) {}
                explicit date(date_rep_type days) : days_(days.as_number()) {}
                date_int_type days_;
};
}
}
namespace boost
{
namespace date_time
{
template <class point_rep, class duration_rep>
class period : private boost::less_than_comparable<period<point_rep, duration_rep>, boost::equality_comparable<period<point_rep, duration_rep>>>
{
            public:
                typedef point_rep point_type;
                typedef duration_rep duration_type;
                period(point_rep first_point, point_rep end_point);
                period(point_rep first_point, duration_rep len);
                point_rep begin() const;
                point_rep end() const;
                point_rep last() const;
                duration_rep length() const;
                bool is_null() const;
                bool operator==(const period &rhs) const;
                bool operator<(const period &rhs) const;
                void shift(const duration_rep &d);
                void expand(const duration_rep &d);
                bool contains(const point_rep &point) const;
                bool contains(const period &other) const;
                bool intersects(const period &other) const;
                bool is_adjacent(const period &other) const;
                bool is_before(const point_rep &point) const;
                bool is_after(const point_rep &point) const;
                period intersection(const period &other) const;
                period merge(const period &other) const;
                period span(const period &other) const;

            private:
                point_rep begin_;
                point_rep last_;
};
template <class point_rep, class duration_rep>
inline period<point_rep, duration_rep>::period(point_rep first_point,
                                               point_rep end_point) : begin_(first_point),
                                                                      last_(end_point - duration_rep::unit())
{
}
template <class point_rep, class duration_rep>
inline period<point_rep, duration_rep>::period(point_rep first_point, duration_rep len) : begin_(first_point),
                                                                                          last_(first_point + len - duration_rep::unit())
{
}
template <class point_rep, class duration_rep>
inline point_rep period<point_rep, duration_rep>::begin() const
{
                return begin_;
}
template <class point_rep, class duration_rep>
inline point_rep period<point_rep, duration_rep>::end() const
{
                return last_ + duration_rep::unit();
}
template <class point_rep, class duration_rep>
inline point_rep period<point_rep, duration_rep>::last() const
{
                return last_;
}
template <class point_rep, class duration_rep>
inline bool period<point_rep, duration_rep>::is_null() const
{
                return end() <= begin_;
}
template <class point_rep, class duration_rep>
inline duration_rep period<point_rep, duration_rep>::length() const
{
                if (last_ < begin_)
                {
                    return last_ + duration_rep::unit() - begin_;
                }
                else
                {
                    return end() - begin_;
                }
}
template <class point_rep, class duration_rep>
inline bool period<point_rep, duration_rep>::operator==(const period &rhs) const
{
                return ((begin_ == rhs.begin_) &&
                        (last_ == rhs.last_));
}
template <class point_rep, class duration_rep>
inline bool period<point_rep, duration_rep>::operator<(const period &rhs) const
{
                return (last_ < rhs.begin_);
}
template <class point_rep, class duration_rep>
inline void period<point_rep, duration_rep>::shift(const duration_rep &d)
{
                begin_ = begin_ + d;
                last_ = last_ + d;
}
template <class point_rep, class duration_rep>
inline void period<point_rep, duration_rep>::expand(const duration_rep &d)
{
                begin_ = begin_ - d;
                last_ = last_ + d;
}
template <class point_rep, class duration_rep>
inline bool period<point_rep, duration_rep>::contains(const point_rep &point) const
{
                return ((point >= begin_) &&
                        (point <= last_));
}
template <class point_rep, class duration_rep>
inline bool period<point_rep, duration_rep>::contains(const period<point_rep, duration_rep> &other) const
{
                return ((begin_ <= other.begin_) && (last_ >= other.last_));
}
template <class point_rep, class duration_rep>
inline bool period<point_rep, duration_rep>::is_adjacent(const period<point_rep, duration_rep> &other) const
{
                return (other.begin() == end() ||
                        begin_ == other.end());
}
template <class point_rep, class duration_rep>
inline bool period<point_rep, duration_rep>::is_after(const point_rep &t) const
{
                if (is_null())
                {
                    return false;
                }
                return t < begin_;
}
template <class point_rep, class duration_rep>
inline bool period<point_rep, duration_rep>::is_before(const point_rep &t) const
{
                if (is_null())
                {
                    return false;
                }
                return last_ < t;
}
template <class point_rep, class duration_rep>
inline bool period<point_rep, duration_rep>::intersects(const period<point_rep, duration_rep> &other) const
{
                return (contains(other.begin_) ||
                        other.contains(begin_) ||
                        ((other.begin_ < begin_) && (other.last_ >= begin_)));
}
template <class point_rep, class duration_rep>
inline period<point_rep, duration_rep>
period<point_rep, duration_rep>::intersection(const period<point_rep, duration_rep> &other) const
{
                if (begin_ > other.begin_)
                {
                    if (last_ <= other.last_)
                    {
                        return *this;
                    }
                    return period<point_rep, duration_rep>(begin_, other.end());
                }
                else
                {
                    if (last_ <= other.last_)
                    {
                        return period<point_rep, duration_rep>(other.begin_, this->end());
                    }
                    return other;
                }
}
template <class point_rep, class duration_rep>
inline period<point_rep, duration_rep>
period<point_rep, duration_rep>::merge(const period<point_rep, duration_rep> &other) const
{
                if (this->intersects(other))
                {
                    if (begin_ < other.begin_)
                    {
                        return period<point_rep, duration_rep>(begin_, last_ > other.last_ ? this->end() : other.end());
                    }
                    return period<point_rep, duration_rep>(other.begin_, last_ > other.last_ ? this->end() : other.end());
                }
                return period<point_rep, duration_rep>(begin_, begin_);
}
template <class point_rep, class duration_rep>
inline period<point_rep, duration_rep>
period<point_rep, duration_rep>::span(const period<point_rep, duration_rep> &other) const
{
                point_rep start((begin_ < other.begin_) ? begin() : other.begin());
                point_rep newend((last_ < other.last_) ? other.end() : this->end());
                return period<point_rep, duration_rep>(start, newend);
}
}
}

namespace std
{
inline namespace __1
{
class __libcpp_refstring
{
                const char *__imp_;
                bool __uses_refcount() const;

            public:
                explicit __libcpp_refstring(const char *__msg);
                __libcpp_refstring(const __libcpp_refstring &__s) throw();
                __libcpp_refstring &operator=(const __libcpp_refstring &__s) throw();
                ~__libcpp_refstring();
                const char *c_str() const throw() { return __imp_; }
};
}
}
namespace std
{
class logic_error
    : public exception
{
private:
std::__libcpp_refstring __imp_;

public:
explicit logic_error(const string &);
explicit logic_error(const char *);
logic_error(const logic_error &) throw();
logic_error &operator=(const logic_error &) throw();
virtual ~logic_error() throw();
virtual const char *what() const throw();
};
class runtime_error
    : public exception
{
private:
std::__libcpp_refstring __imp_;

public:
explicit runtime_error(const string &);
explicit runtime_error(const char *);
runtime_error(const runtime_error &) throw();
runtime_error &operator=(const runtime_error &) throw();
virtual ~runtime_error() throw();
virtual const char *what() const throw();
};
class domain_error
    : public logic_error
{
public:
{} {
}
domain_error(const domain_error &) throw() = default;
virtual ~domain_error() throw();
};
class invalid_argument
    : public logic_error
{
public:
{} {
}
invalid_argument(const invalid_argument &) throw() = default;
virtual ~invalid_argument() throw();
};
class length_error
    : public logic_error
{
public:
{} {
}
length_error(const length_error &) throw() = default;
virtual ~length_error() throw();
};
class out_of_range
    : public logic_error
{
public:
{} {
}
out_of_range(const out_of_range &) throw() = default;
virtual ~out_of_range() throw();
};
class range_error
    : public runtime_error
{
public:
{} {
}
range_error(const range_error &) throw() = default;
virtual ~range_error() throw();
};
class overflow_error
    : public runtime_error
{
public:
{} {
}
overflow_error(const overflow_error &) throw() = default;
virtual ~overflow_error() throw();
};
class underflow_error
    : public runtime_error
{
public:
{} {
}
underflow_error(const underflow_error &) throw() = default;
virtual ~underflow_error() throw();
};
}
namespace std
{
inline namespace __1
{
;

void __throw_logic_error(const char *__msg)
{
                throw logic_error(__msg);
}

void __throw_domain_error(const char *__msg)
{
                throw domain_error(__msg);
}

void __throw_invalid_argument(const char *__msg)
{
                throw invalid_argument(__msg);
}

void __throw_length_error(const char *__msg)
{
                throw length_error(__msg);
}

void __throw_out_of_range(const char *__msg)
{
                throw out_of_range(__msg);
}

void __throw_range_error(const char *__msg)
{
                throw range_error(__msg);
}

void __throw_overflow_error(const char *__msg)
{
                throw overflow_error(__msg);
}

void __throw_underflow_error(const char *__msg)
{
                throw underflow_error(__msg);
}
}
}

namespace boost
{
namespace detail
{
inline void current_function_helper()
{
}
}
}

namespace std
{
inline namespace __1
{
template <class _T1, class _T2 = _T1>
struct __equal_to
{
                const { return __x == __y; }
                const { return __x == __y; }
                const { return __x == __y; }
                const { return __x == __y; }
};
template <class _T1>
struct __equal_to<_T1, _T1>
{

                bool operator()(const _T1 &__x, const _T1 &__y) const { return __x == __y; }
};
template <class _T1>
struct __equal_to<const _T1, _T1>
{

                bool operator()(const _T1 &__x, const _T1 &__y) const { return __x == __y; }
};
template <class _T1>
struct __equal_to<_T1, const _T1>
{

                bool operator()(const _T1 &__x, const _T1 &__y) const { return __x == __y; }
};
template <class _T1, class _T2 = _T1>
struct __less
{

                bool operator()(const _T1 &__x, const _T1 &__y) const { return __x < __y; }

                bool operator()(const _T1 &__x, const _T2 &__y) const { return __x < __y; }

                bool operator()(const _T2 &__x, const _T1 &__y) const { return __x < __y; }

                bool operator()(const _T2 &__x, const _T2 &__y) const { return __x < __y; }
};
template <class _T1>
struct __less<_T1, _T1>
{

                bool operator()(const _T1 &__x, const _T1 &__y) const { return __x < __y; }
};
template <class _T1>
struct __less<const _T1, _T1>
{

                bool operator()(const _T1 &__x, const _T1 &__y) const { return __x < __y; }
};
template <class _T1>
struct __less<_T1, const _T1>
{

                bool operator()(const _T1 &__x, const _T1 &__y) const { return __x < __y; }
};
}
}
namespace std
{
inline namespace __1
{
template <class _Compare>
struct __debug_less
{
                _Compare &__comp_;
                __debug_less(_Compare &__c) : __comp_(__c) {}
                template <class _Tp, class _Up>
                bool operator()(const _Tp &__x, const _Up &__y)
                {
                    bool __r = __comp_(__x, __y);
                    if (__r)
                        __do_compare_assert(0, __y, __x);
                    return __r;
                }
                template <class _Tp, class _Up>
                bool operator()(_Tp &__x, _Up &__y)
                {
                    bool __r = __comp_(__x, __y);
                    if (__r)
                        __do_compare_assert(0, __y, __x);
                    return __r;
                }
                template <class _LHS, class _RHS>
                inline __decltype((void)declval<_Compare &>()(declval<_LHS &>(), declval<_RHS &>()))
                __do_compare_assert(int, _LHS &__l, _RHS &__r)
                {
                    ((void)0);
                    (void)__l;
                    (void)__r;
                }
                template <class _LHS, class _RHS>
                inline void __do_compare_assert(long, _LHS &, _RHS &) {}
};
template <class _Comp>
struct __comp_ref_type
{
                typedef _Comp &type;
};
}
}
namespace std
{
inline namespace __1
{
template <class _Compare, class _ForwardIterator>
inline _ForwardIterator
__max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
                _Static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value, "std::max_element requires a ForwardIterator");
                if (__first != __last)
                {
                    _ForwardIterator __i = __first;
                    while (++__i != __last)
                        if (__comp(*__first, *__i))
                            __first = __i;
                }
                return __first;
}
template <class _ForwardIterator, class _Compare>
inline _ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
                typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
                return std::__max_element<_Comp_ref>(__first, __last, __comp);
}
template <class _ForwardIterator>
inline _ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last)
{
                return std::max_element(__first, __last,
                                        __less<typename iterator_traits<_ForwardIterator>::value_type>());
}
}
}

namespace std
{
inline namespace __1
{
template <class _Tp, class _Compare>
inline

    const _Tp &
    max(const _Tp &__a, const _Tp &__b, _Compare __comp)
{
                return __comp(__a, __b) ? __b : __a;
}
template <class _Tp>
inline

    const _Tp &
    max(const _Tp &__a, const _Tp &__b)
{
                return std::max(__a, __b, __less<_Tp>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _Comp, class _Iter, class _Sent, class _Proj>
inline _Iter __min_element(_Iter __first, _Sent __last, _Comp __comp, _Proj &__proj)
{
                if (__first == __last)
                    return __first;
                _Iter __i = __first;
                while (++__i != __last)
                    if (std::__invoke(__comp, std::__invoke(__proj, *__i), std::__invoke(__proj, *__first)))
                        __first = __i;
                return __first;
}
template <class _Comp, class _Iter, class _Sent>

_Iter __min_element(_Iter __first, _Sent __last, _Comp __comp)
{
                auto __proj = __identity();
                return std::__min_element<_Comp>(std::move(__first), std::move(__last), __comp, __proj);
}
template <class _ForwardIterator, class _Compare>
inline _ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
                _Static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value, "std::min_element requires a ForwardIterator");
                _Static_assert(__is_callable<_Compare, __decltype(*__first), __decltype(*__first)>::value, "The comparator has to be callable");
                typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
                return std::__min_element<_Comp_ref>(std::move(__first), std::move(__last), __comp);
}
template <class _ForwardIterator>
inline _ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last)
{
                return std::min_element(__first, __last,
                                        __less<typename iterator_traits<_ForwardIterator>::value_type>());
}
}
}

namespace std
{
inline namespace __1
{
template <class _Tp, class _Compare>
inline

    const _Tp &
    min(const _Tp &__a, const _Tp &__b, _Compare __comp)
{
                return __comp(__b, __a) ? __b : __a;
}
template <class _Tp>
inline

    const _Tp &
    min(const _Tp &__a, const _Tp &__b)
{
                return std::min(__a, __b, __less<_Tp>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _InputIterator, class _Tp>
inline _InputIterator
find(_InputIterator __first, _InputIterator __last, const _Tp &__value)
{
                for (; __first != __last; ++__first)
                    if (*__first == __value)
                        break;
                return __first;
}
}
}
namespace std
{
inline namespace __1
{
template <class _InputIterator, class _Predicate>
inline _InputIterator
find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
                for (; __first != __last; ++__first)
                    if (__pred(*__first))
                        break;
                return __first;
}
}
}
namespace std
{
inline namespace __1
{
template <class _ForwardIterator, class _Tp>
_ForwardIterator
remove(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)
{
                __first = std::find(__first, __last, __value);
                if (__first != __last)
                {
                    _ForwardIterator __i = __first;
                    while (++__i != __last)
                    {
                        if (!(*__i == __value))
                        {
                            *__first = std::move(*__i);
                            ++__first;
                        }
                    }
                }
                return __first;
}
}
}
namespace std
{
inline namespace __1
{
template <class _ForwardIterator, class _Predicate>
_ForwardIterator
remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
                __first = std::find_if<_ForwardIterator, _Predicate &>(__first, __last, __pred);
                if (__first != __last)
                {
                    _ForwardIterator __i = __first;
                    while (++__i != __last)
                    {
                        if (!__pred(*__i))
                        {
                            *__first = std::move(*__i);
                            ++__first;
                        }
                    }
                }
                return __first;
}
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
template <class _StateT>
class fpos
{
            private:
                _StateT __st_;
                streamoff __off_;

            public:
                {
                }
                const { return __off_; }
                const { return __st_; }
                {
                    __st_ = __st;
                }
                {
                    __off_ += __off;
                    return *this;
                }
                const
                {
                    fpos __t(*this);
                    __t += __off;
                    return __t;
                }
                {
                    __off_ -= __off;
                    return *this;
                }
                const
                {
                    fpos __t(*this);
                    __t -= __off;
                    return __t;
                }
};
template <class _StateT>
inline streamoff operator-(const fpos<_StateT> &__x, const fpos<_StateT> &__y)
{
                return streamoff(__x) - streamoff(__y);
}
template <class _StateT>
inline bool operator==(const fpos<_StateT> &__x, const fpos<_StateT> &__y)
{
                return streamoff(__x) == streamoff(__y);
}
template <class _StateT>
inline bool operator!=(const fpos<_StateT> &__x, const fpos<_StateT> &__y)
{
                return streamoff(__x) != streamoff(__y);
}
}
}
namespace std
{
inline namespace __1
{
template <typename _Tp>
{
                return const_cast<void *>(static_cast<const volatile void *>(std::addressof(__from)));
}
}
}
namespace std
{
inline namespace __1
{
template <class _Tp, class... _Args, class = __decltype(::new (declval<void *>()) _Tp(declval<_Args>()...))>
{
                return ((void)0),
                       ::new (std::__voidify(*__location)) _Tp(std::forward<_Args>(__args)...);
}
template <class _ForwardIterator>

_ForwardIterator __destroy(_ForwardIterator, _ForwardIterator);
template <class _Tp, typename enable_if<!is_array<_Tp>::value, int>::type = 0>

void __destroy_at(_Tp *__loc)
{
                ((void)0);
                __loc->~_Tp();
}
template <class _ForwardIterator>

_ForwardIterator __destroy(_ForwardIterator __first, _ForwardIterator __last)
{
                for (; __first != __last; ++__first)
                    std::__destroy_at(std::addressof(*__first));
                return __first;
}
}
}

namespace std
{
inline namespace __1
{
template <class _Tp, class = void>
struct __has_pointer : false_type
{
};
template <class _Tp>
struct __has_pointer<_Tp, typename __void_t<typename _Tp::pointer>::type> : true_type
{
};
template <class _Tp, class _Alloc,
          class _RawAlloc = typename remove_reference<_Alloc>::type,
          bool = __has_pointer<_RawAlloc>::value>
struct __pointer
{
                using type = typename _RawAlloc::pointer;
};
template <class _Tp, class _Alloc, class _RawAlloc>
struct __pointer<_Tp, _Alloc, _RawAlloc, false>
{
                using type = _Tp *;
};
template <class _Tp, class = void>
struct __has_const_pointer : false_type
{
};
template <class _Tp>
struct __has_const_pointer<_Tp, typename __void_t<typename _Tp::const_pointer>::type> : true_type
{
};
template <class _Tp, class _Ptr, class _Alloc,
          bool = __has_const_pointer<_Alloc>::value>
struct __const_pointer
{
                using type = typename _Alloc::const_pointer;
};
template <class _Tp, class _Ptr, class _Alloc>
struct __const_pointer<_Tp, _Ptr, _Alloc, false>
{
                using type = typename pointer_traits<_Ptr>::template rebind<const _Tp>::other;
};
template <class _Tp, class = void>
struct __has_void_pointer : false_type
{
};
template <class _Tp>
struct __has_void_pointer<_Tp, typename __void_t<typename _Tp::void_pointer>::type> : true_type
{
};
template <class _Ptr, class _Alloc,
          bool = __has_void_pointer<_Alloc>::value>
struct __void_pointer
{
                using type = typename _Alloc::void_pointer;
};
template <class _Ptr, class _Alloc>
struct __void_pointer<_Ptr, _Alloc, false>
{
                using type = typename pointer_traits<_Ptr>::template rebind<void>::other;
};
template <class _Tp, class = void>
struct __has_const_void_pointer : false_type
{
};
template <class _Tp>
struct __has_const_void_pointer<_Tp, typename __void_t<typename _Tp::const_void_pointer>::type> : true_type
{
};
template <class _Ptr, class _Alloc,
          bool = __has_const_void_pointer<_Alloc>::value>
struct __const_void_pointer
{
                using type = typename _Alloc::const_void_pointer;
};
template <class _Ptr, class _Alloc>
struct __const_void_pointer<_Ptr, _Alloc, false>
{
                using type = typename pointer_traits<_Ptr>::template rebind<const void>::other;
};
template <class _Tp, class = void>
struct __has_size_type : false_type
{
};
template <class _Tp>
struct __has_size_type<_Tp, typename __void_t<typename _Tp::size_type>::type> : true_type
{
};
template <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>
struct __size_type : make_unsigned<_DiffType>
{
};
template <class _Alloc, class _DiffType>
struct __size_type<_Alloc, _DiffType, true>
{
                using type = typename _Alloc::size_type;
};
template <class _Tp, class = void>
struct __has_alloc_traits_difference_type : false_type
{
};
template <class _Tp>
struct __has_alloc_traits_difference_type<_Tp, typename __void_t<typename _Tp::difference_type>::type> : true_type
{
};
template <class _Alloc, class _Ptr, bool = __has_alloc_traits_difference_type<_Alloc>::value>
struct __alloc_traits_difference_type
{
                using type = typename pointer_traits<_Ptr>::difference_type;
};
template <class _Alloc, class _Ptr>
struct __alloc_traits_difference_type<_Alloc, _Ptr, true>
{
                using type = typename _Alloc::difference_type;
};
template <class _Tp, class = void>
struct __has_propagate_on_container_copy_assignment : false_type
{
};
template <class _Tp>
struct __has_propagate_on_container_copy_assignment<_Tp, typename __void_t<typename _Tp::propagate_on_container_copy_assignment>::type> : true_type
{
};
template <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>
struct __propagate_on_container_copy_assignment : false_type
{
};
template <class _Alloc>
struct __propagate_on_container_copy_assignment<_Alloc, true>
{
                using type = typename _Alloc::propagate_on_container_copy_assignment;
};
template <class _Tp, class = void>
struct __has_propagate_on_container_move_assignment : false_type
{
};
template <class _Tp>
struct __has_propagate_on_container_move_assignment<_Tp, typename __void_t<typename _Tp::propagate_on_container_move_assignment>::type> : true_type
{
};
template <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>
struct __propagate_on_container_move_assignment : false_type
{
};
template <class _Alloc>
struct __propagate_on_container_move_assignment<_Alloc, true>
{
                using type = typename _Alloc::propagate_on_container_move_assignment;
};
template <class _Tp, class = void>
struct __has_propagate_on_container_swap : false_type
{
};
template <class _Tp>
struct __has_propagate_on_container_swap<_Tp, typename __void_t<typename _Tp::propagate_on_container_swap>::type> : true_type
{
};
template <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>
struct __propagate_on_container_swap : false_type
{
};
template <class _Alloc>
struct __propagate_on_container_swap<_Alloc, true>
{
                using type = typename _Alloc::propagate_on_container_swap;
};
template <class _Tp, class = void>
struct __has_is_always_equal : false_type
{
};
template <class _Tp>
struct __has_is_always_equal<_Tp, typename __void_t<typename _Tp::is_always_equal>::type> : true_type
{
};
template <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>
struct __is_always_equal : is_empty<_Alloc>
{
};
template <class _Alloc>
struct __is_always_equal<_Alloc, true>
{
                using type = typename _Alloc::is_always_equal;
};
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp, class _Up, class = void>
struct __has_rebind_other : false_type
{
};
template <class _Tp, class _Up>
struct __has_rebind_other<_Tp, _Up, typename __void_t<typename _Tp::template rebind<_Up>::other>::type> : true_type
{
};
template <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>
struct __allocator_traits_rebind
{
                using type = typename _Tp::template rebind<_Up>::other;
};
template <template <class, class...> class _Alloc, class _Tp, class... _Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>
{
                using type = typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other;
};
template <template <class, class...> class _Alloc, class _Tp, class... _Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>
{
                using type = _Alloc<_Up, _Args...>;
};
#pragma GCC diagnostic pop
template <class _Alloc, class _Tp>
using __allocator_traits_rebind_t = typename __allocator_traits_rebind<_Alloc, _Tp>::type;
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Alloc, class _SizeType, class _ConstVoidPtr, class = void>
struct __has_allocate_hint : false_type
{
};
template <class _Alloc, class _SizeType, class _ConstVoidPtr>
struct __has_allocate_hint<_Alloc, _SizeType, _ConstVoidPtr, __decltype((void)declval<_Alloc>().allocate(declval<_SizeType>(), declval<_ConstVoidPtr>()))> : true_type
{
};
template <class, class _Alloc, class... _Args>
struct __has_construct_impl : false_type
{
};
template <class _Alloc, class... _Args>
struct __has_construct_impl<__decltype((void)declval<_Alloc>().construct(declval<_Args>()...)), _Alloc, _Args...> : true_type
{
};
template <class _Alloc, class... _Args>
struct __has_construct : __has_construct_impl<void, _Alloc, _Args...>
{
};
template <class _Alloc, class _Pointer, class = void>
struct __has_destroy : false_type
{
};
template <class _Alloc, class _Pointer>
struct __has_destroy<_Alloc, _Pointer, __decltype((void)declval<_Alloc>().destroy(declval<_Pointer>()))> : true_type
{
};
template <class _Alloc, class = void>
struct __has_max_size : false_type
{
};
template <class _Alloc>
struct __has_max_size<_Alloc, __decltype((void)declval<_Alloc &>().max_size())> : true_type
{
};
template <class _Alloc, class = void>
struct __has_select_on_container_copy_construction : false_type
{
};
template <class _Alloc>
struct __has_select_on_container_copy_construction<_Alloc, __decltype((void)declval<_Alloc>().select_on_container_copy_construction())> : true_type
{
};
#pragma GCC diagnostic pop
template <class _Alloc>
struct allocator_traits
{
                using allocator_type = _Alloc;
                using value_type = typename allocator_type::value_type;
                using pointer = typename __pointer<value_type, allocator_type>::type;
                using const_pointer = typename __const_pointer<value_type, pointer, allocator_type>::type;
                using void_pointer = typename __void_pointer<pointer, allocator_type>::type;
                using const_void_pointer = typename __const_void_pointer<pointer, allocator_type>::type;
                using difference_type = typename __alloc_traits_difference_type<allocator_type, pointer>::type;
                using size_type = typename __size_type<allocator_type, difference_type>::type;
                using propagate_on_container_copy_assignment = typename __propagate_on_container_copy_assignment<allocator_type>::type;
                using propagate_on_container_move_assignment = typename __propagate_on_container_move_assignment<allocator_type>::type;
                using propagate_on_container_swap = typename __propagate_on_container_swap<allocator_type>::type;
                using is_always_equal = typename __is_always_equal<allocator_type>::type;
                template <class _Tp>
                struct rebind_alloc
                {
                    using other = __allocator_traits_rebind_t<allocator_type, _Tp>;
                };
                template <class _Tp>
                struct rebind_traits
                {
                    using other = allocator_traits<typename rebind_alloc<_Tp>::other>;
                };

                static pointer allocate(allocator_type &__a, size_type __n)
                {
                    return __a.allocate(__n);
                }
                template <class _Ap = _Alloc, class =
                                                  __enable_if_t<__has_allocate_hint<_Ap, size_type, const_void_pointer>::value>>

                static pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint)
                {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
                    return __a.allocate(__n, __hint);
#pragma GCC diagnostic pop
                }
                template <class _Ap = _Alloc, class = void, class = __enable_if_t<!__has_allocate_hint<_Ap, size_type, const_void_pointer>::value>>

                static pointer allocate(allocator_type &__a, size_type __n, const_void_pointer)
                {
                    return __a.allocate(__n);
                }

                static void deallocate(allocator_type &__a, pointer __p, size_type __n) throw()
                {
                    __a.deallocate(__p, __n);
                }
                template <class _Tp, class... _Args, class = __enable_if_t<__has_construct<allocator_type, _Tp *, _Args...>::value>>

                static void construct(allocator_type &__a, _Tp *__p, _Args &&...__args)
                {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
                    __a.construct(__p, std::forward<_Args>(__args)...);
#pragma GCC diagnostic pop
                }
                template <class _Tp, class... _Args, class = void, class = __enable_if_t<!__has_construct<allocator_type, _Tp *, _Args...>::value>>

                static void construct(allocator_type &, _Tp *__p, _Args &&...__args)
                {
                    ::new ((void *)__p) _Tp(std::forward<_Args>(__args)...);
                }
                template <class _Tp, class =
                                         __enable_if_t<__has_destroy<allocator_type, _Tp *>::value>>

                static void destroy(allocator_type &__a, _Tp *__p)
                {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
                    __a.destroy(__p);
#pragma GCC diagnostic pop
                }
                template <class _Tp, class = void, class = __enable_if_t<!__has_destroy<allocator_type, _Tp *>::value>>

                static void destroy(allocator_type &, _Tp *__p)
                {
                    __p->~_Tp();
                }
                template <class _Ap = _Alloc, class =
                                                  __enable_if_t<__has_max_size<const _Ap>::value>>

                static size_type max_size(const allocator_type &__a) throw()
                {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
                    return __a.max_size();
#pragma GCC diagnostic pop
                }
                template <class _Ap = _Alloc, class = void, class = __enable_if_t<!__has_max_size<const _Ap>::value>>

                static size_type max_size(const allocator_type &) throw()
                {
                    return numeric_limits<size_type>::max() / sizeof(value_type);
                }
                template <class _Ap = _Alloc, class =
                                                  __enable_if_t<__has_select_on_container_copy_construction<const _Ap>::value>>

                static allocator_type select_on_container_copy_construction(const allocator_type &__a)
                {
                    return __a.select_on_container_copy_construction();
                }
                template <class _Ap = _Alloc, class = void, class = __enable_if_t<!__has_select_on_container_copy_construction<const _Ap>::value>>

                static allocator_type select_on_container_copy_construction(const allocator_type &__a)
                {
                    return __a;
                }
};
template <class _Traits, class _Tp>
struct __rebind_alloc_helper
{
                using type = typename _Traits::template rebind_alloc<_Tp>::other;
};
template <class _Tp>
struct __is_default_allocator : false_type
{
};
template <class>
class allocator;
template <class _Tp>
struct __is_default_allocator<allocator<_Tp>> : true_type
{
};
template <class _Alloc, class = void>
struct __is_cpp17_move_insertable
    : is_move_constructible<typename _Alloc::value_type>
{
};
template <class _Alloc>
struct __is_cpp17_move_insertable<_Alloc, __enable_if_t<
                                              !__is_default_allocator<_Alloc>::value &&
                                              __has_construct<_Alloc, typename _Alloc::value_type *, typename _Alloc::value_type &&>::value>> : true_type
{
};
template <class _Alloc, class = void>
struct __is_cpp17_copy_insertable
    : integral_constant<bool,
                        is_copy_constructible<typename _Alloc::value_type>::value &&
                            __is_cpp17_move_insertable<_Alloc>::value>
{
};
template <class _Alloc>
struct __is_cpp17_copy_insertable<_Alloc, __enable_if_t<
                                              !__is_default_allocator<_Alloc>::value &&
                                              __has_construct<_Alloc, typename _Alloc::value_type *, const typename _Alloc::value_type &>::value>>
    : __is_cpp17_move_insertable<_Alloc>
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _Pointer>
struct __allocation_result
{
                _Pointer ptr;
                size_t count;
};
template <class _Alloc>

__allocation_result<typename allocator_traits<_Alloc>::pointer> __allocate_at_least(_Alloc &__alloc, size_t __n)
{
                return {__alloc.allocate(__n), __n};
}
}
}
namespace std
{
inline namespace __1
{
template <typename _Alloc>

{
                using std::swap;
                swap(__a1, __a2);
}
template <typename _Alloc>
inline void
__swap_allocator(_Alloc &, _Alloc &, false_type) throw() {}
template <typename _Alloc>
inline
{
                std::__swap_allocator(
                    __a1, __a2, integral_constant<bool, allocator_traits<_Alloc>::propagate_on_container_swap::value>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _Iter, class _Unwrapped = __decltype(std::__unwrap_iter(std::declval<_Iter>()))>
{
                return std::make_pair(std::__unwrap_iter(std::move(__first)), std::__unwrap_iter(std::move(__last)));
}
template <class _Iter, class _Unwrapped = __decltype(std::__unwrap_iter(std::declval<_Iter>()))>
{
                return std::__rewrap_iter(std::move(__orig_iter), std::move(__iter));
}
}
}
namespace std
{
inline namespace __1
{
template <class _InIter, class _Sent, class _OutIter>
inline pair<_InIter, _OutIter> __copy_impl(_InIter __first, _Sent __last, _OutIter __result)
{
                while (__first != __last)
                {
                    *__result = *__first;
                    ++__first;
                    ++__result;
                }
                return pair<_InIter, _OutIter>(std::move(__first), std::move(__result));
}
template <class _InValueT,
          class _OutValueT,
          class = __enable_if_t<is_same<typename remove_const<_InValueT>::type, _OutValueT>::value && is_trivially_copy_assignable<_OutValueT>::value>>
inline pair<_InValueT *, _OutValueT *> __copy_impl(_InValueT *__first, _InValueT *__last, _OutValueT *__result)
{
                if (__libcpp_is_constant_evaluated() && !is_trivially_copyable<_InValueT>::value)
                    return std::__copy_impl<_InValueT *, _InValueT *, _OutValueT *>(__first, __last, __result);
                const size_t __n = static_cast<size_t>(__last - __first);
                if (__n > 0)
                    ::__builtin_memmove(__result, __first, __n * sizeof(_OutValueT));
                return std::make_pair(__first + __n, __result + __n);
}
template <class _InIter, class _OutIter,
          __enable_if_t<is_same<typename remove_const<__iter_value_type<_InIter>>::type, __iter_value_type<_OutIter>>::value && __is_cpp17_contiguous_iterator<typename _InIter::iterator_type>::value && __is_cpp17_contiguous_iterator<typename _OutIter::iterator_type>::value && is_trivially_copy_assignable<__iter_value_type<_OutIter>>::value && __is_reverse_iterator<_InIter>::value && __is_reverse_iterator<_OutIter>::value, int> = 0>
inline pair<_InIter, _OutIter>
__copy_impl(_InIter __first, _InIter __last, _OutIter __result)
{
                auto __first_base = std::__unwrap_iter(__first.base());
                auto __last_base = std::__unwrap_iter(__last.base());
                auto __result_base = std::__unwrap_iter(__result.base());
                auto __result_first = __result_base - (__first_base - __last_base);
                std::__copy_impl(__last_base, __first_base, __result_first);
                return std::make_pair(__last, _OutIter(std::__rewrap_iter(__result.base(), __result_first)));
}
template <class _InIter, class _Sent, class _OutIter,
          __enable_if_t<!(is_copy_constructible<_InIter>::value && is_copy_constructible<_Sent>::value && is_copy_constructible<_OutIter>::value), int> = 0>
inline pair<_InIter, _OutIter> __copy(_InIter __first, _Sent __last, _OutIter __result)
{
                return std::__copy_impl(std::move(__first), std::move(__last), std::move(__result));
}
template <class _InIter, class _Sent, class _OutIter,
          __enable_if_t<is_copy_constructible<_InIter>::value && is_copy_constructible<_Sent>::value && is_copy_constructible<_OutIter>::value, int> = 0>
inline pair<_InIter, _OutIter> __copy(_InIter __first, _Sent __last, _OutIter __result)
{
                auto __range = std::__unwrap_range(__first, __last);
                auto __ret = std::__copy_impl(std::move(__range.first), std::move(__range.second), std::__unwrap_iter(__result));
                return std::make_pair(
                    std::__rewrap_range<_Sent>(__first, __ret.first), std::__rewrap_iter(__result, __ret.second));
}
template <class _InputIterator, class _OutputIterator>
inline _OutputIterator
copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
                return std::__copy(__first, __last, __result).second;
}
}
}
namespace std
{
inline namespace __1
{
template <class _InputIterator, class _Size, class _OutputIterator>
inline
    typename enable_if<
        __is_cpp17_input_iterator<_InputIterator>::value &&
            !__is_cpp17_random_access_iterator<_InputIterator>::value,
        _OutputIterator>::type
    copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)
{
                typedef __decltype(std::__convert_to_integral(__orig_n)) _IntegralSize;
                _IntegralSize __n = __orig_n;
                if (__n > 0)
                {
                    *__result = *__first;
                    ++__result;
                    for (--__n; __n > 0; --__n)
                    {
                        ++__first;
                        *__result = *__first;
                        ++__result;
                    }
                }
                return __result;
}
template <class _InputIterator, class _Size, class _OutputIterator>
inline
    typename enable_if<
        __is_cpp17_random_access_iterator<_InputIterator>::value,
        _OutputIterator>::type
    copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)
{
                typedef typename iterator_traits<_InputIterator>::difference_type difference_type;
                typedef __decltype(std::__convert_to_integral(__orig_n)) _IntegralSize;
                _IntegralSize __n = __orig_n;
                return std::copy(__first, __first + difference_type(__n), __result);
}
}
}
namespace std
{
inline namespace __1
{
template <class _OutputIterator, class _Size, class _Tp>
inline _OutputIterator
__fill_n(_OutputIterator __first, _Size __n, const _Tp &__value)
{
                for (; __n > 0; ++__first, (void)--__n)
                    *__first = __value;
                return __first;
}
template <class _OutputIterator, class _Size, class _Tp>
inline _OutputIterator
fill_n(_OutputIterator __first, _Size __n, const _Tp &__value)
{
                return std::__fill_n(__first, std::__convert_to_integral(__n), __value);
}
}
}
namespace std
{
inline namespace __1
{
template <class _ForwardIterator1, class _ForwardIterator2>
inline void iter_swap(_ForwardIterator1 __a,
                      _ForwardIterator2 __b)
{
                swap(*__a, *__b);
}
}
}
namespace std
{
inline namespace __1
{
template <class _AlgPolicy>
struct _IterOps;
struct _ClassicAlgPolicy
{
};
template <>
struct _IterOps<_ClassicAlgPolicy>
{
                template <class _Iter>
                using __value_type = typename iterator_traits<_Iter>::value_type;
                template <class _Iter>
                using __iterator_category = typename iterator_traits<_Iter>::iterator_category;
                template <class _Iter>
                using __difference_type = typename iterator_traits<_Iter>::difference_type;
                template <class _Iter, class _Distance>

                static void advance(_Iter &__iter, _Distance __count)
                {
                    std::advance(__iter, __count);
                }
                template <class _Iter>

                static typename iterator_traits<_Iter>::difference_type distance(_Iter __first, _Iter __last)
                {
                    return std::distance(__first, __last);
                }
                template <class _Iter>
                using __deref_t = __decltype(*std::declval<_Iter &>());
                template <class _Iter>
                using __move_t = __decltype(std::move(*std::declval<_Iter &>()));
                template <class _Iter>

                static void __validate_iter_reference()
                {
                    _Static_assert(is_same<__deref_t<_Iter>, typename iterator_traits<__uncvref_t<_Iter>>::reference>::value, "It looks like your iterator's `iterator_traits<It>::reference` does not match the return type of "
                                                                                                                              "dereferencing the iterator, i.e., calling `*it`. This is undefined behavior according to [input.iterators] "
                                                                                                                              "and can lead to dangling reference issues at runtime, so we are flagging this.");
                }
                template <class _Iter>
                static __enable_if_t<
                    is_reference<__deref_t<_Iter>>::value,
                    __move_t<_Iter>>
                __iter_move(_Iter &&__i)
                {
                    __validate_iter_reference<_Iter>();
                    return std::move(*std::forward<_Iter>(__i));
                }
                template <class _Iter>
                static __enable_if_t<
                    !is_reference<__deref_t<_Iter>>::value,
                    __deref_t<_Iter>>
                __iter_move(_Iter &&__i)
                {
                    __validate_iter_reference<_Iter>();
                    return *std::forward<_Iter>(__i);
                }
                template <class _Iter1, class _Iter2>

                static void iter_swap(_Iter1 &&__a, _Iter2 &&__b)
                {
                    std::iter_swap(std::forward<_Iter1>(__a), std::forward<_Iter2>(__b));
                }
                template <class _Iterator>
                static _Iterator next(_Iterator, _Iterator __last)
                {
                    return __last;
                }
                template <class _Iter>
                static __uncvref_t<_Iter> next(_Iter &&__it,
                                               typename iterator_traits<__uncvref_t<_Iter>>::difference_type __n = 1)
                {
                    return std::next(std::forward<_Iter>(__it), __n);
                }
                template <class _Iter>
                static __uncvref_t<_Iter> prev(_Iter &&__iter,
                                               typename iterator_traits<__uncvref_t<_Iter>>::difference_type __n = 1)
                {
                    return std::prev(std::forward<_Iter>(__iter), __n);
                }
                template <class _Iter>
                static void __advance_to(_Iter &__first, _Iter __last)
                {
                    __first = __last;
                }
};
}
}
namespace std
{
inline namespace __1
{
template <class _AlgPolicy,
          class _Iter1, class _Sent1,
          class _Iter2, class _Sent2,
          class _Pred,
          class _Proj1,
          class _Proj2>

pair<_Iter1, _Iter1> __search_forward_impl(_Iter1 __first1, _Sent1 __last1,
                                           _Iter2 __first2, _Sent2 __last2,
                                           _Pred &__pred,
                                           _Proj1 &__proj1,
                                           _Proj2 &__proj2)
{
                if (__first2 == __last2)
                    return std::make_pair(__first1, __first1);
                while (true)
                {
                    while (true)
                    {
                        if (__first1 == __last1)
                        {
                            _IterOps<_AlgPolicy>::__advance_to(__first1, __last1);
                            return std::make_pair(__first1, __first1);
                        }
                        if (std::__invoke(__pred, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
                            break;
                        ++__first1;
                    }
                    _Iter1 __m1 = __first1;
                    _Iter2 __m2 = __first2;
                    while (true)
                    {
                        if (++__m2 == __last2)
                            return std::make_pair(__first1, ++__m1);
                        if (++__m1 == __last1)
                        {
                            return std::make_pair(__m1, __m1);
                        }
                        if (!std::__invoke(__pred, std::__invoke(__proj1, *__m1), std::__invoke(__proj2, *__m2)))
                        {
                            ++__first1;
                            break;
                        }
                    }
                }
}
template <class _AlgPolicy,
          class _Iter1, class _Sent1,
          class _Iter2, class _Sent2,
          class _Pred,
          class _Proj1,
          class _Proj2,
          class _DiffT1,
          class _DiffT2>

pair<_Iter1, _Iter1> __search_random_access_impl(_Iter1 __first1, _Sent1 __last1,
                                                 _Iter2 __first2, _Sent2 __last2,
                                                 _Pred &__pred,
                                                 _Proj1 &__proj1,
                                                 _Proj2 &__proj2,
                                                 _DiffT1 __size1,
                                                 _DiffT2 __size2)
{
                const _Iter1 __s = __first1 + __size1 - _DiffT1(__size2 - 1);
                while (true)
                {
                    while (true)
                    {
                        if (__first1 == __s)
                        {
                            _IterOps<_AlgPolicy>::__advance_to(__first1, __last1);
                            return std::make_pair(__first1, __first1);
                        }
                        if (std::__invoke(__pred, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
                            break;
                        ++__first1;
                    }
                    _Iter1 __m1 = __first1;
                    _Iter2 __m2 = __first2;
                    while (true)
                    {
                        if (++__m2 == __last2)
                            return std::make_pair(__first1, __first1 + _DiffT1(__size2));
                        ++__m1;
                        if (!std::__invoke(__pred, std::__invoke(__proj1, *__m1), std::__invoke(__proj2, *__m2)))
                        {
                            ++__first1;
                            break;
                        }
                    }
                }
}
template <class _Iter1, class _Sent1,
          class _Iter2, class _Sent2,
          class _Pred,
          class _Proj1,
          class _Proj2>

pair<_Iter1, _Iter1> __search_impl(_Iter1 __first1, _Sent1 __last1,
                                   _Iter2 __first2, _Sent2 __last2,
                                   _Pred &__pred,
                                   _Proj1 &__proj1,
                                   _Proj2 &__proj2,
                                   __enable_if_t<__is_cpp17_random_access_iterator<_Iter1>::value && __is_cpp17_random_access_iterator<_Iter2>::value> * = __nullptr)
{
                auto __size2 = __last2 - __first2;
                if (__size2 == 0)
                    return std::make_pair(__first1, __first1);
                auto __size1 = __last1 - __first1;
                if (__size1 < __size2)
                {
                    return std::make_pair(__last1, __last1);
                }
                return std::__search_random_access_impl<_ClassicAlgPolicy>(__first1, __last1,
                                                                           __first2, __last2,
                                                                           __pred,
                                                                           __proj1,
                                                                           __proj2,
                                                                           __size1,
                                                                           __size2);
}
template <class _Iter1, class _Sent1,
          class _Iter2, class _Sent2,
          class _Pred,
          class _Proj1,
          class _Proj2>

pair<_Iter1, _Iter1> __search_impl(_Iter1 __first1, _Sent1 __last1,
                                   _Iter2 __first2, _Sent2 __last2,
                                   _Pred &__pred,
                                   _Proj1 &__proj1,
                                   _Proj2 &__proj2,
                                   __enable_if_t<__is_cpp17_forward_iterator<_Iter1>::value && __is_cpp17_forward_iterator<_Iter2>::value && !(__is_cpp17_random_access_iterator<_Iter1>::value && __is_cpp17_random_access_iterator<_Iter2>::value)> * = __nullptr)
{
                return std::__search_forward_impl<_ClassicAlgPolicy>(__first1, __last1,
                                                                     __first2, __last2,
                                                                     __pred,
                                                                     __proj1,
                                                                     __proj2);
}
template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
inline _ForwardIterator1 search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                                _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                                _BinaryPredicate __pred)
{
                _Static_assert(__is_callable<_BinaryPredicate, __decltype(*__first1), __decltype(*__first2)>::value, "BinaryPredicate has to be callable");
                auto __proj = __identity();
                return std::__search_impl(__first1, __last1, __first2, __last2, __pred, __proj, __proj).first;
}
template <class _ForwardIterator1, class _ForwardIterator2>
inline _ForwardIterator1 search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                                _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
                using __v1 = typename iterator_traits<_ForwardIterator1>::value_type;
                using __v2 = typename iterator_traits<_ForwardIterator2>::value_type;
                return std::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}
}
}
namespace std
{
inline namespace __1
{
template <
    class _AlgPolicy,
    class _Iter1,
    class _Sent1,
    class _Iter2,
    class _Sent2,
    class _Pred,
    class _Proj1,
    class _Proj2>
inline pair<_Iter1, _Iter1> __find_end_impl(
    _Iter1 __first1,
    _Sent1 __last1,
    _Iter2 __first2,
    _Sent2 __last2,
    _Pred &__pred,
    _Proj1 &__proj1,
    _Proj2 &__proj2,
    forward_iterator_tag,
    forward_iterator_tag)
{
                _Iter1 __match_first = _IterOps<_AlgPolicy>::next(__first1, __last1);
                _Iter1 __match_last = __match_first;
                if (__first2 == __last2)
                    return pair<_Iter1, _Iter1>(__match_last, __match_last);
                while (true)
                {
                    while (true)
                    {
                        if (__first1 == __last1)
                            return pair<_Iter1, _Iter1>(__match_first, __match_last);
                        if (std::__invoke(__pred, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
                            break;
                        ++__first1;
                    }
                    _Iter1 __m1 = __first1;
                    _Iter2 __m2 = __first2;
                    while (true)
                    {
                        if (++__m2 == __last2)
                        {
                            __match_first = __first1;
                            __match_last = ++__m1;
                            ++__first1;
                            break;
                        }
                        if (++__m1 == __last1)
                            return pair<_Iter1, _Iter1>(__match_first, __match_last);
                        if (!std::__invoke(__pred, std::__invoke(__proj1, *__m1), std::__invoke(__proj2, *__m2)))
                        {
                            ++__first1;
                            break;
                        }
                    }
                }
}
template <
    class _IterOps,
    class _Pred,
    class _Iter1,
    class _Sent1,
    class _Iter2,
    class _Sent2,
    class _Proj1,
    class _Proj2>
_Iter1 __find_end(
    _Iter1 __first1,
    _Sent1 __sent1,
    _Iter2 __first2,
    _Sent2 __sent2,
    _Pred &__pred,
    _Proj1 &__proj1,
    _Proj2 &__proj2,
    bidirectional_iterator_tag,
    bidirectional_iterator_tag)
{
                auto __last1 = _IterOps::next(__first1, __sent1);
                auto __last2 = _IterOps::next(__first2, __sent2);
                if (__first2 == __last2)
                    return __last1;
                _Iter1 __l1 = __last1;
                _Iter2 __l2 = __last2;
                --__l2;
                while (true)
                {
                    while (true)
                    {
                        if (__first1 == __l1)
                            return __last1;
                        if (std::__invoke(__pred, std::__invoke(__proj1, *--__l1), std::__invoke(__proj2, *__l2)))
                            break;
                    }
                    _Iter1 __m1 = __l1;
                    _Iter2 __m2 = __l2;
                    while (true)
                    {
                        if (__m2 == __first2)
                            return __m1;
                        if (__m1 == __first1)
                            return __last1;
                        if (!std::__invoke(__pred, std::__invoke(__proj1, *--__m1), std::__invoke(__proj2, *--__m2)))
                        {
                            break;
                        }
                    }
                }
}
template <
    class _AlgPolicy,
    class _Pred,
    class _Iter1,
    class _Sent1,
    class _Iter2,
    class _Sent2,
    class _Proj1,
    class _Proj2>
_Iter1 __find_end(
    _Iter1 __first1,
    _Sent1 __sent1,
    _Iter2 __first2,
    _Sent2 __sent2,
    _Pred &__pred,
    _Proj1 &__proj1,
    _Proj2 &__proj2,
    random_access_iterator_tag,
    random_access_iterator_tag)
{
                typedef typename iterator_traits<_Iter1>::difference_type _D1;
                auto __last1 = _IterOps<_AlgPolicy>::next(__first1, __sent1);
                auto __last2 = _IterOps<_AlgPolicy>::next(__first2, __sent2);
                auto __len2 = __last2 - __first2;
                if (__len2 == 0)
                    return __last1;
                auto __len1 = __last1 - __first1;
                if (__len1 < __len2)
                    return __last1;
                const _Iter1 __s = __first1 + _D1(__len2 - 1);
                _Iter1 __l1 = __last1;
                _Iter2 __l2 = __last2;
                --__l2;
                while (true)
                {
                    while (true)
                    {
                        if (__s == __l1)
                            return __last1;
                        if (std::__invoke(__pred, std::__invoke(__proj1, *--__l1), std::__invoke(__proj2, *__l2)))
                            break;
                    }
                    _Iter1 __m1 = __l1;
                    _Iter2 __m2 = __l2;
                    while (true)
                    {
                        if (__m2 == __first2)
                            return __m1;
                        if (!std::__invoke(__pred, std::__invoke(__proj1, *--__m1), std::__invoke(*--__m2)))
                        {
                            break;
                        }
                    }
                }
}
template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
inline _ForwardIterator1 __find_end_classic(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                                            _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                                            _BinaryPredicate &__pred)
{
                auto __proj = __identity();
                return std::__find_end_impl<_ClassicAlgPolicy>(
                           __first1,
                           __last1,
                           __first2,
                           __last2,
                           __pred,
                           __proj,
                           __proj,
                           typename iterator_traits<_ForwardIterator1>::iterator_category(),
                           typename iterator_traits<_ForwardIterator2>::iterator_category())
                    .first;
}
template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
inline _ForwardIterator1 find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                                  _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                                  _BinaryPredicate __pred)
{
                return std::__find_end_classic(__first1, __last1, __first2, __last2, __pred);
}
template <class _ForwardIterator1, class _ForwardIterator2>
inline _ForwardIterator1 find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                                  _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
                using __v1 = typename iterator_traits<_ForwardIterator1>::value_type;
                using __v2 = typename iterator_traits<_ForwardIterator2>::value_type;
                return std::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
_ForwardIterator1 __find_first_of_ce(_ForwardIterator1 __first1,
                                     _ForwardIterator1 __last1,
                                     _ForwardIterator2 __first2,
                                     _ForwardIterator2 __last2,
                                     _BinaryPredicate &&__pred)
{
                for (; __first1 != __last1; ++__first1)
                    for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
                        if (__pred(*__first1, *__j))
                            return __first1;
                return __last1;
}
template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
inline _ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
              _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
                return std::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);
}
template <class _ForwardIterator1, class _ForwardIterator2>
inline _ForwardIterator1 find_first_of(
    _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
                typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
                typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
                return std::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}
}
}
namespace std
{
inline namespace __1
{
using ::clearerr;
using ::fclose;
using ::feof;
using ::ferror;
using ::fflush;
using ::fgetc;
using ::fgetpos;
using ::fgets;
using ::FILE;
using ::fopen;
using ::fpos_t;
using ::fprintf;
using ::fputc;
using ::fputs;
using ::fread;
using ::freopen;
using ::fscanf;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::fwrite;
using ::getc;
using ::getchar;
using ::gets;
using ::perror;
using ::printf;
using ::putc;
using ::putchar;
using ::puts;
using ::remove;
using ::rename;
using ::rewind;
using ::scanf;
using ::setbuf;
using ::setvbuf;
using ::size_t;
using ::snprintf;
using ::sprintf;
using ::sscanf;
using ::tmpfile;
using ::tmpnam;
using ::ungetc;
using ::vfprintf;
using ::vfscanf;
using ::vprintf;
using ::vscanf;
using ::vsnprintf;
using ::vsprintf;
using ::vsscanf;
}
}
namespace std
{
inline namespace __1
{
using ::isalnum;
using ::isalpha;
using ::isblank;
using ::iscntrl;
using ::isdigit;
using ::isgraph;
using ::islower;
using ::isprint;
using ::ispunct;
using ::isspace;
using ::isupper;
using ::isxdigit;
using ::tolower;
using ::toupper;
}
}
typedef __darwin_wctrans_t wctrans_t;
inline int
iswblank(wint_t _wc)
{
return (__istype(_wc, 0x00020000L));
}
inline int
iswascii(wint_t _wc)
{
return ((_wc & ~0x7F) == 0);
}
inline int
iswhexnumber(wint_t _wc)
{
return (__istype(_wc, 0x00010000L));
}
inline int
iswideogram(wint_t _wc)
{
return (__istype(_wc, 0x00080000L));
}
inline int
iswnumber(wint_t _wc)
{
return (__istype(_wc, 0x00000400L));
}
inline int
iswphonogram(wint_t _wc)
{
return (__istype(_wc, 0x00200000L));
}
inline int
iswrune(wint_t _wc)
{
return (__istype(_wc, 0xFFFFFFF0L));
}
inline int
iswspecial(wint_t _wc)
{
return (__istype(_wc, 0x00100000L));
}
extern "C"
{
wint_t nextwctype(wint_t, wctype_t);
wint_t towctrans(wint_t, wctrans_t);
wctrans_t
wctrans(const char *);
}
namespace std
{
inline namespace __1
{
using ::iswalnum;
using ::iswalpha;
using ::iswblank;
using ::iswcntrl;
using ::iswctype;
using ::iswdigit;
using ::iswgraph;
using ::iswlower;
using ::iswprint;
using ::iswpunct;
using ::iswspace;
using ::iswupper;
using ::iswxdigit;
using ::towctrans;
using ::towlower;
using ::towupper;
using ::wctrans;
using ::wctrans_t;
using ::wctype;
using ::wctype_t;
using ::wint_t;
}
}
namespace std
{
inline namespace __1
{
using ::btowc;
using ::fgetwc;
using ::fgetws;
using ::FILE;
using ::fputwc;
using ::fputws;
using ::fwide;
using ::fwprintf;
using ::fwscanf;
using ::getwc;
using ::getwchar;
using ::mbrlen;
using ::mbrtowc;
using ::mbsinit;
using ::mbsrtowcs;
using ::mbstate_t;
using ::putwc;
using ::putwchar;
using ::size_t;
using ::swprintf;
using ::swscanf;
using ::tm;
using ::ungetwc;
using ::vfwprintf;
using ::vfwscanf;
using ::vswprintf;
using ::vswscanf;
using ::vwprintf;
using ::vwscanf;
using ::wcrtomb;
using ::wcscat;
using ::wcschr;
using ::wcscmp;
using ::wcscoll;
using ::wcscpy;
using ::wcscspn;
using ::wcsftime;
using ::wcslen;
using ::wcsncat;
using ::wcsncmp;
using ::wcsncpy;
using ::wcspbrk;
using ::wcsrchr;
using ::wcsrtombs;
using ::wcsspn;
using ::wcsstr;
using ::wcstod;
using ::wcstof;
using ::wcstok;
using ::wcstol;
using ::wcstold;
using ::wcstoll;
using ::wcstoul;
using ::wcstoull;
using ::wcsxfrm;
using ::wctob;
using ::wint_t;
using ::wmemchr;
using ::wmemcmp;
using ::wmemcpy;
using ::wmemmove;
using ::wmemset;
using ::wprintf;
using ::wscanf;
}
}

namespace std
{
inline namespace __1
{
template <class _CharT>
struct char_traits
{
                typedef _CharT char_type;
                typedef int int_type;
                typedef streamoff off_type;
                typedef streampos pos_type;
                typedef mbstate_t state_type;
                static inline void
                assign(char_type &__c1, const char_type &__c2) throw() { __c1 = __c2; }
                static inline bool eq(char_type __c1, char_type __c2) throw()
                {
                    return __c1 == __c2;
                }
                static inline bool lt(char_type __c1, char_type __c2) throw()
                {
                    return __c1 < __c2;
                }
                static int compare(const char_type *__s1, const char_type *__s2, size_t __n);
                static size_t length(const char_type *__s);
                static const char_type *find(const char_type *__s, size_t __n, const char_type &__a);
                static char_type *move(char_type *__s1, const char_type *__s2, size_t __n);

                static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n);

                static char_type *assign(char_type *__s, size_t __n, char_type __a);
                static inline int_type not_eof(int_type __c) throw()
                {
                    return eq_int_type(__c, eof()) ? ~eof() : __c;
                }
                static inline char_type to_char_type(int_type __c) throw()
                {
                    return char_type(__c);
                }
                static inline int_type to_int_type(char_type __c) throw()
                {
                    return int_type(__c);
                }
                static inline bool eq_int_type(int_type __c1, int_type __c2) throw()
                {
                    return __c1 == __c2;
                }
                static inline int_type eof() throw()
                {
                    return int_type((-1));
                }
};
template <class _CharT>
int char_traits<_CharT>::compare(const char_type *__s1, const char_type *__s2, size_t __n)
{
                for (; __n; --__n, ++__s1, ++__s2)
                {
                    if (lt(*__s1, *__s2))
                        return -1;
                    if (lt(*__s2, *__s1))
                        return 1;
                }
                return 0;
}
template <class _CharT>
inline size_t
char_traits<_CharT>::length(const char_type *__s)
{
                size_t __len = 0;
                for (; !eq(*__s, char_type(0)); ++__s)
                    ++__len;
                return __len;
}
template <class _CharT>
inline const _CharT *
char_traits<_CharT>::find(const char_type *__s, size_t __n, const char_type &__a)
{
                for (; __n; --__n)
                {
                    if (eq(*__s, __a))
                        return __s;
                    ++__s;
                }
                return __nullptr;
}
template <class _CharT>
_CharT *
char_traits<_CharT>::move(char_type *__s1, const char_type *__s2, size_t __n)
{
                if (__n == 0)
                    return __s1;
                char_type *__r = __s1;
                if (__s1 < __s2)
                {
                    for (; __n; --__n, ++__s1, ++__s2)
                        assign(*__s1, *__s2);
                }
                else if (__s2 < __s1)
                {
                    __s1 += __n;
                    __s2 += __n;
                    for (; __n; --__n)
                        assign(*--__s1, *--__s2);
                }
                return __r;
}
template <class _CharT>
inline _CharT *
char_traits<_CharT>::copy(char_type *__s1, const char_type *__s2, size_t __n)
{
                if (!__libcpp_is_constant_evaluated())
                {
                    ((void)0);
                }
                char_type *__r = __s1;
                for (; __n; --__n, ++__s1, ++__s2)
                    assign(*__s1, *__s2);
                return __r;
}
template <class _CharT>
inline _CharT *
char_traits<_CharT>::assign(char_type *__s, size_t __n, char_type __a)
{
                char_type *__r = __s;
                for (; __n; --__n, ++__s)
                    assign(*__s, __a);
                return __r;
}
template <class _CharT>
static inline _CharT *__char_traits_move(_CharT *__dest, const _CharT *__source, size_t __n) throw()
{
                ::__builtin_memmove(__dest, __source, __n * sizeof(_CharT));
                return __dest;
}
template <>
struct char_traits<char>
{
                typedef char char_type;
                typedef int int_type;
                typedef streamoff off_type;
                typedef streampos pos_type;
                typedef mbstate_t state_type;
                static inline void assign(char_type &__c1, const char_type &__c2) throw() { __c1 = __c2; }
                static inline bool eq(char_type __c1, char_type __c2) throw()
                {
                    return __c1 == __c2;
                }
                static inline bool lt(char_type __c1, char_type __c2) throw()
                {
                    return (unsigned char)__c1 < (unsigned char)__c2;
                }
                static int compare(const char_type *__s1, const char_type *__s2, size_t __n) throw();
                static inline size_t length(const char_type *__s) throw()
                {
                    return __builtin_strlen(__s);
                }
                static const char_type *find(const char_type *__s, size_t __n, const char_type &__a) throw();
                static inline char_type *move(char_type *__s1, const char_type *__s2, size_t __n) throw()
                {
                    return std::__char_traits_move(__s1, __s2, __n);
                }
                static inline char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) throw()
                {
                    if (!__libcpp_is_constant_evaluated())
                        ((void)0);
                    std::copy_n(__s2, __n, __s1);
                    return __s1;
                }
                static inline char_type *assign(char_type *__s, size_t __n, char_type __a) throw()
                {
                    std::fill_n(__s, __n, __a);
                    return __s;
                }
                static inline int_type not_eof(int_type __c) throw()
                {
                    return eq_int_type(__c, eof()) ? ~eof() : __c;
                }
                static inline char_type to_char_type(int_type __c) throw()
                {
                    return char_type(__c);
                }
                static inline int_type to_int_type(char_type __c) throw()
                {
                    return int_type((unsigned char)__c);
                }
                static inline bool eq_int_type(int_type __c1, int_type __c2) throw()
                {
                    return __c1 == __c2;
                }
                static inline int_type eof() throw()
                {
                    return int_type((-1));
                }
};
inline int
char_traits<char>::compare(const char_type *__s1, const char_type *__s2, size_t __n) throw()
{
                if (__n == 0)
                    return 0;
                return std::memcmp(__s1, __s2, __n);
}
inline const char *
char_traits<char>::find(const char_type *__s, size_t __n, const char_type &__a) throw()
{
                if (__n == 0)
                    return __nullptr;
                return (const char_type *)std::memchr(__s, to_int_type(__a), __n);
}
template <>
struct char_traits<wchar_t>
{
                typedef wchar_t char_type;
                typedef wint_t int_type;
                typedef streamoff off_type;
                typedef streampos pos_type;
                typedef mbstate_t state_type;
                static inline void assign(char_type &__c1, const char_type &__c2) throw() { __c1 = __c2; }
                static inline bool eq(char_type __c1, char_type __c2) throw()
                {
                    return __c1 == __c2;
                }
                static inline bool lt(char_type __c1, char_type __c2) throw()
                {
                    return __c1 < __c2;
                }
                static int compare(const char_type *__s1, const char_type *__s2, size_t __n) throw();
                static size_t length(const char_type *__s) throw();
                static const char_type *find(const char_type *__s, size_t __n, const char_type &__a) throw();
                static inline char_type *move(char_type *__s1, const char_type *__s2, size_t __n) throw()
                {
                    return std::__char_traits_move(__s1, __s2, __n);
                }
                static inline char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) throw()
                {
                    if (!__libcpp_is_constant_evaluated())
                        ((void)0);
                    std::copy_n(__s2, __n, __s1);
                    return __s1;
                }
                static inline char_type *assign(char_type *__s, size_t __n, char_type __a) throw()
                {
                    std::fill_n(__s, __n, __a);
                    return __s;
                }
                static inline int_type not_eof(int_type __c) throw()
                {
                    return eq_int_type(__c, eof()) ? ~eof() : __c;
                }
                static inline char_type to_char_type(int_type __c) throw()
                {
                    return char_type(__c);
                }
                static inline int_type to_int_type(char_type __c) throw()
                {
                    return int_type(__c);
                }
                static inline bool eq_int_type(int_type __c1, int_type __c2) throw()
                {
                    return __c1 == __c2;
                }
                static inline int_type eof() throw()
                {
                    return int_type(((__darwin_wint_t)-1));
                }
};
inline int
char_traits<wchar_t>::compare(const char_type *__s1, const char_type *__s2, size_t __n) throw()
{
                if (__n == 0)
                    return 0;
                return std::wmemcmp(__s1, __s2, __n);
}
inline size_t
char_traits<wchar_t>::length(const char_type *__s) throw()
{
                return std::wcslen(__s);
}
inline const wchar_t *
char_traits<wchar_t>::find(const char_type *__s, size_t __n, const char_type &__a) throw()
{
                if (__n == 0)
                    return __nullptr;
                return std::wmemchr(__s, __a, __n);
}
template <>
struct char_traits<char16_t>
{
                typedef char16_t char_type;
                typedef uint_least16_t int_type;
                typedef streamoff off_type;
                typedef u16streampos pos_type;
                typedef mbstate_t state_type;
                static inline void assign(char_type &__c1, const char_type &__c2) throw() { __c1 = __c2; }
                static inline bool eq(char_type __c1, char_type __c2) throw()
                {
                    return __c1 == __c2;
                }
                static inline bool lt(char_type __c1, char_type __c2) throw()
                {
                    return __c1 < __c2;
                }
                static int compare(const char_type *__s1, const char_type *__s2, size_t __n) throw();
                static size_t length(const char_type *__s) throw();
                static const char_type *find(const char_type *__s, size_t __n, const char_type &__a) throw();

                static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) throw()
                {
                    return std::__char_traits_move(__s1, __s2, __n);
                }

                static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) throw()
                {
                    if (!__libcpp_is_constant_evaluated())
                        ((void)0);
                    std::copy_n(__s2, __n, __s1);
                    return __s1;
                }

                static char_type *assign(char_type *__s, size_t __n, char_type __a) throw()
                {
                    std::fill_n(__s, __n, __a);
                    return __s;
                }
                static inline int_type not_eof(int_type __c) throw()
                {
                    return eq_int_type(__c, eof()) ? ~eof() : __c;
                }
                static inline char_type to_char_type(int_type __c) throw()
                {
                    return char_type(__c);
                }
                static inline int_type to_int_type(char_type __c) throw()
                {
                    return int_type(__c);
                }
                static inline bool eq_int_type(int_type __c1, int_type __c2) throw()
                {
                    return __c1 == __c2;
                }
                static inline int_type eof() throw()
                {
                    return int_type(0xFFFF);
                }
};
inline int
char_traits<char16_t>::compare(const char_type *__s1, const char_type *__s2, size_t __n) throw()
{
                for (; __n; --__n, ++__s1, ++__s2)
                {
                    if (lt(*__s1, *__s2))
                        return -1;
                    if (lt(*__s2, *__s1))
                        return 1;
                }
                return 0;
}
inline size_t
char_traits<char16_t>::length(const char_type *__s) throw()
{
                size_t __len = 0;
                for (; !eq(*__s, char_type(0)); ++__s)
                    ++__len;
                return __len;
}
inline const char16_t *
char_traits<char16_t>::find(const char_type *__s, size_t __n, const char_type &__a) throw()
{
                for (; __n; --__n)
                {
                    if (eq(*__s, __a))
                        return __s;
                    ++__s;
                }
                return __nullptr;
}
template <>
struct char_traits<char32_t>
{
                typedef char32_t char_type;
                typedef uint_least32_t int_type;
                typedef streamoff off_type;
                typedef u32streampos pos_type;
                typedef mbstate_t state_type;
                static inline void assign(char_type &__c1, const char_type &__c2) throw() { __c1 = __c2; }
                static inline bool eq(char_type __c1, char_type __c2) throw()
                {
                    return __c1 == __c2;
                }
                static inline bool lt(char_type __c1, char_type __c2) throw()
                {
                    return __c1 < __c2;
                }
                static int compare(const char_type *__s1, const char_type *__s2, size_t __n) throw();
                static size_t length(const char_type *__s) throw();
                static const char_type *find(const char_type *__s, size_t __n, const char_type &__a) throw();

                static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) throw()
                {
                    return std::__char_traits_move(__s1, __s2, __n);
                }

                static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) throw()
                {
                    std::copy_n(__s2, __n, __s1);
                    return __s1;
                }

                static char_type *assign(char_type *__s, size_t __n, char_type __a) throw()
                {
                    std::fill_n(__s, __n, __a);
                    return __s;
                }
                static inline int_type not_eof(int_type __c) throw()
                {
                    return eq_int_type(__c, eof()) ? ~eof() : __c;
                }
                static inline char_type to_char_type(int_type __c) throw()
                {
                    return char_type(__c);
                }
                static inline int_type to_int_type(char_type __c) throw()
                {
                    return int_type(__c);
                }
                static inline bool eq_int_type(int_type __c1, int_type __c2) throw()
                {
                    return __c1 == __c2;
                }
                static inline int_type eof() throw()
                {
                    return int_type(0xFFFFFFFF);
                }
};
inline int
char_traits<char32_t>::compare(const char_type *__s1, const char_type *__s2, size_t __n) throw()
{
                for (; __n; --__n, ++__s1, ++__s2)
                {
                    if (lt(*__s1, *__s2))
                        return -1;
                    if (lt(*__s2, *__s1))
                        return 1;
                }
                return 0;
}
inline size_t
char_traits<char32_t>::length(const char_type *__s) throw()
{
                size_t __len = 0;
                for (; !eq(*__s, char_type(0)); ++__s)
                    ++__len;
                return __len;
}
inline const char32_t *
char_traits<char32_t>::find(const char_type *__s, size_t __n, const char_type &__a) throw()
{
                for (; __n; --__n)
                {
                    if (eq(*__s, __a))
                        return __s;
                    ++__s;
                }
                return __nullptr;
}
template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT
__str_find(const _CharT *__p, _SizeT __sz,
           _CharT __c, _SizeT __pos) throw()
{
                if (__pos >= __sz)
                    return __npos;
                const _CharT *__r = _Traits::find(__p + __pos, __sz - __pos, __c);
                if (__r == __nullptr)
                    return __npos;
                return static_cast<_SizeT>(__r - __p);
}
template <class _CharT, class _Traits>
inline const _CharT *
__search_substring(const _CharT *__first1, const _CharT *__last1,
                   const _CharT *__first2, const _CharT *__last2) throw()
{
                const ptrdiff_t __len2 = __last2 - __first2;
                if (__len2 == 0)
                    return __first1;
                ptrdiff_t __len1 = __last1 - __first1;
                if (__len1 < __len2)
                    return __last1;
                _CharT __f2 = *__first2;
                while (true)
                {
                    __len1 = __last1 - __first1;
                    if (__len1 < __len2)
                        return __last1;
                    __first1 = _Traits::find(__first1, __len1 - __len2 + 1, __f2);
                    if (__first1 == __nullptr)
                        return __last1;
                    if (_Traits::compare(__first1, __first2, __len2) == 0)
                        return __first1;
                    ++__first1;
                }
}
template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT
__str_find(const _CharT *__p, _SizeT __sz,
           const _CharT *__s, _SizeT __pos, _SizeT __n) throw()
{
                if (__pos > __sz)
                    return __npos;
                if (__n == 0)
                    return __pos;
                const _CharT *__r = __search_substring<_CharT, _Traits>(
                    __p + __pos, __p + __sz, __s, __s + __n);
                if (__r == __p + __sz)
                    return __npos;
                return static_cast<_SizeT>(__r - __p);
}
template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT
__str_rfind(const _CharT *__p, _SizeT __sz,
            _CharT __c, _SizeT __pos) throw()
{
                if (__sz < 1)
                    return __npos;
                if (__pos < __sz)
                    ++__pos;
                else
                    __pos = __sz;
                for (const _CharT *__ps = __p + __pos; __ps != __p;)
                {
                    if (_Traits::eq(*--__ps, __c))
                        return static_cast<_SizeT>(__ps - __p);
                }
                return __npos;
}
template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT
__str_rfind(const _CharT *__p, _SizeT __sz,
            const _CharT *__s, _SizeT __pos, _SizeT __n) throw()
{
                __pos = std::min(__pos, __sz);
                if (__n < __sz - __pos)
                    __pos += __n;
                else
                    __pos = __sz;
                const _CharT *__r = std::__find_end_classic(__p, __p + __pos, __s, __s + __n, _Traits::eq);
                if (__n > 0 && __r == __p + __pos)
                    return __npos;
                return static_cast<_SizeT>(__r - __p);
}
template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT
__str_find_first_of(const _CharT *__p, _SizeT __sz,
                    const _CharT *__s, _SizeT __pos, _SizeT __n) throw()
{
                if (__pos >= __sz || __n == 0)
                    return __npos;
                const _CharT *__r = std::__find_first_of_ce(__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq);
                if (__r == __p + __sz)
                    return __npos;
                return static_cast<_SizeT>(__r - __p);
}
template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT
__str_find_last_of(const _CharT *__p, _SizeT __sz,
                   const _CharT *__s, _SizeT __pos, _SizeT __n) throw()
{
                if (__n != 0)
                {
                    if (__pos < __sz)
                        ++__pos;
                    else
                        __pos = __sz;
                    for (const _CharT *__ps = __p + __pos; __ps != __p;)
                    {
                        const _CharT *__r = _Traits::find(__s, __n, *--__ps);
                        if (__r)
                            return static_cast<_SizeT>(__ps - __p);
                    }
                }
                return __npos;
}
template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT
__str_find_first_not_of(const _CharT *__p, _SizeT __sz,
                        const _CharT *__s, _SizeT __pos, _SizeT __n) throw()
{
                if (__pos < __sz)
                {
                    const _CharT *__pe = __p + __sz;
                    for (const _CharT *__ps = __p + __pos; __ps != __pe; ++__ps)
                        if (_Traits::find(__s, __n, *__ps) == __nullptr)
                            return static_cast<_SizeT>(__ps - __p);
                }
                return __npos;
}
template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT
__str_find_first_not_of(const _CharT *__p, _SizeT __sz,
                        _CharT __c, _SizeT __pos) throw()
{
                if (__pos < __sz)
                {
                    const _CharT *__pe = __p + __sz;
                    for (const _CharT *__ps = __p + __pos; __ps != __pe; ++__ps)
                        if (!_Traits::eq(*__ps, __c))
                            return static_cast<_SizeT>(__ps - __p);
                }
                return __npos;
}
template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT
__str_find_last_not_of(const _CharT *__p, _SizeT __sz,
                       const _CharT *__s, _SizeT __pos, _SizeT __n) throw()
{
                if (__pos < __sz)
                    ++__pos;
                else
                    __pos = __sz;
                for (const _CharT *__ps = __p + __pos; __ps != __p;)
                    if (_Traits::find(__s, __n, *--__ps) == __nullptr)
                        return static_cast<_SizeT>(__ps - __p);
                return __npos;
}
template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT
__str_find_last_not_of(const _CharT *__p, _SizeT __sz,
                       _CharT __c, _SizeT __pos) throw()
{
                if (__pos < __sz)
                    ++__pos;
                else
                    __pos = __sz;
                for (const _CharT *__ps = __p + __pos; __ps != __p;)
                    if (!_Traits::eq(*--__ps, __c))
                        return static_cast<_SizeT>(__ps - __p);
                return __npos;
}
template <class _Ptr>
inline size_t __do_string_hash(_Ptr __p, _Ptr __e)
{
                typedef typename iterator_traits<_Ptr>::value_type value_type;
                return __murmur2_or_cityhash<size_t>()(__p, (__e - __p) * sizeof(value_type));
}
}
}
namespace std
{
inline namespace __1
{
template <class _AlgPolicy, class _InIter, class _Sent, class _OutIter>
inline pair<_InIter, _OutIter> __move_impl(_InIter __first, _Sent __last, _OutIter __result)
{
                while (__first != __last)
                {
                    *__result = _IterOps<_AlgPolicy>::__iter_move(__first);
                    ++__first;
                    ++__result;
                }
                return std::make_pair(std::move(__first), std::move(__result));
}
template <class _AlgPolicy,
          class _InType,
          class _OutType,
          class = __enable_if_t<is_same<typename remove_const<_InType>::type, _OutType>::value && is_trivially_move_assignable<_OutType>::value>>
inline pair<_InType *, _OutType *> __move_impl(_InType *__first, _InType *__last, _OutType *__result)
{
                if (__libcpp_is_constant_evaluated() && !is_trivially_copyable<_InType>::value)
                    return std::__move_impl<_AlgPolicy, _InType *, _InType *, _OutType *>(__first, __last, __result);
                const size_t __n = static_cast<size_t>(__last - __first);
                ::__builtin_memmove(__result, __first, __n * sizeof(_OutType));
                return std::make_pair(__first + __n, __result + __n);
}
template <class>
struct __is_trivially_move_assignable_unwrapped_impl : false_type
{
};
template <class _Type>
struct __is_trivially_move_assignable_unwrapped_impl<_Type *> : is_trivially_move_assignable<_Type>
{
};
template <class _Iter>
struct __is_trivially_move_assignable_unwrapped
    : __is_trivially_move_assignable_unwrapped_impl<__decltype(std::__unwrap_iter<_Iter>(std::declval<_Iter>()))>
{
};
template <class _AlgPolicy,
          class _InIter,
          class _OutIter,
          __enable_if_t<is_same<typename remove_const<typename iterator_traits<_InIter>::value_type>::type,
                                typename iterator_traits<_OutIter>::value_type>::value &&
                            __is_cpp17_contiguous_iterator<_InIter>::value && __is_cpp17_contiguous_iterator<_OutIter>::value && is_trivially_move_assignable<__iter_value_type<_OutIter>>::value,
                        int> = 0>
inline pair<reverse_iterator<_InIter>, reverse_iterator<_OutIter>>
__move_impl(reverse_iterator<_InIter> __first,
            reverse_iterator<_InIter> __last,
            reverse_iterator<_OutIter> __result)
{
                auto __first_base = std::__unwrap_iter(__first.base());
                auto __last_base = std::__unwrap_iter(__last.base());
                auto __result_base = std::__unwrap_iter(__result.base());
                auto __result_first = __result_base - (__first_base - __last_base);
                std::__move_impl<_AlgPolicy>(__last_base, __first_base, __result_first);
                return std::make_pair(__last, reverse_iterator<_OutIter>(std::__rewrap_iter(__result.base(), __result_first)));
}
template <class _AlgPolicy, class _InIter, class _Sent, class _OutIter>
inline __enable_if_t<is_copy_constructible<_InIter>::value && is_copy_constructible<_Sent>::value && is_copy_constructible<_OutIter>::value, pair<_InIter, _OutIter>>
__move(_InIter __first, _Sent __last, _OutIter __result)
{
                auto __ret = std::__move_impl<_AlgPolicy>(
                    std::__unwrap_iter(__first), std::__unwrap_iter(__last), std::__unwrap_iter(__result));
                return std::make_pair(std::__rewrap_iter(__first, __ret.first), std::__rewrap_iter(__result, __ret.second));
}
template <class _AlgPolicy, class _InIter, class _Sent, class _OutIter>
inline __enable_if_t<!is_copy_constructible<_InIter>::value || !is_copy_constructible<_Sent>::value || !is_copy_constructible<_OutIter>::value, pair<_InIter, _OutIter>>
__move(_InIter __first, _Sent __last, _OutIter __result)
{
                return std::__move_impl<_AlgPolicy>(std::move(__first), std::move(__last), std::move(__result));
}
template <class _InputIterator, class _OutputIterator>
inline _OutputIterator move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
                return std::__move<_ClassicAlgPolicy>(__first, __last, __result).second;
}
}
}
namespace std
{
inline namespace __1
{
template <class _Alloc>
struct __allocation_guard
{
                using _Pointer = typename allocator_traits<_Alloc>::pointer;
                using _Size = typename allocator_traits<_Alloc>::size_type;
                template <class _AllocT>

                explicit __allocation_guard(_AllocT __alloc, _Size __n)
                    : __alloc_(std::move(__alloc)), __n_(__n), __ptr_(allocator_traits<_Alloc>::allocate(__alloc_, __n_))
                {
                }

                ~__allocation_guard() throw()
                {
                    if (__ptr_ != __nullptr)
                    {
                        allocator_traits<_Alloc>::deallocate(__alloc_, __ptr_, __n_);
                    }
                }

                _Pointer __release_ptr() throw()
                {
                    _Pointer __tmp = __ptr_;
                    __ptr_ = __nullptr;
                    return __tmp;
                }

                _Pointer __get() const throw()
                {
                    return __ptr_;
                }

            private:
                _Alloc __alloc_;
                _Size __n_;
                _Pointer __ptr_;
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
class allocator;
template <>
class allocator<void>
{
            public:
                typedef void *pointer;
                typedef const void *const_pointer;
                typedef void value_type;
                template <class _Up>
                struct rebind
                {
                    typedef allocator<_Up> other;
                };
};
template <>
class allocator<const void>
{
            public:
                typedef const void *pointer;
                typedef const void *const_pointer;
                typedef const void value_type;
                template <class _Up>
                struct rebind
                {
                    typedef allocator<_Up> other;
                };
};
template <bool _Cond, class _Unique>
struct __non_trivial_if
{
};
template <class _Unique>
struct __non_trivial_if<true, _Unique>
{

                __non_trivial_if() throw() {}
};
template <class _Tp>
class allocator
    : private __non_trivial_if<!is_void<_Tp>::value, allocator<_Tp>>
{
                _Static_assert(!is_volatile<_Tp>::value, "std::allocator does not support volatile types");

            public:
                typedef size_t size_type;
                typedef ptrdiff_t difference_type;
                typedef _Tp value_type;
                typedef true_type propagate_on_container_move_assignment;
                typedef true_type is_always_equal;

                allocator() throw() = default;
                template <class _Up>

                allocator(const allocator<_Up> &) throw()
                {
                }

                _Tp *allocate(size_t __n)
                {
                    if (__n > allocator_traits<allocator>::max_size(*this))
                        __throw_bad_array_new_length();
                    if (__libcpp_is_constant_evaluated())
                    {
                        return static_cast<_Tp *>(::operator new(__n * sizeof(_Tp)));
                    }
                    else
                    {
                        return static_cast<_Tp *>(std::__libcpp_allocate(__n * sizeof(_Tp), _Alignof(_Tp)));
                    }
                }

                void deallocate(_Tp *__p, size_t __n) throw()
                {
                    if (__libcpp_is_constant_evaluated())
                    {
                        ::operator delete(__p);
                    }
                    else
                    {
                        std::__libcpp_deallocate((void *)__p, __n * sizeof(_Tp), _Alignof(_Tp));
                    }
                }
                typedef _Tp *pointer;
                typedef const _Tp *const_pointer;
                typedef _Tp &reference;
                typedef const _Tp &const_reference;
                template <class _Up>
                struct rebind
                {
                    typedef allocator<_Up> other;
                };

                pointer address(reference __x) const throw()
                {
                    return std::addressof(__x);
                }

                const_pointer address(const_reference __x) const throw()
                {
                    return std::addressof(__x);
                }

                _Tp *allocate(size_t __n, const void *)
                {
                    return allocate(__n);
                }
                {
                    return size_type(~0) / sizeof(_Tp);
                }
                template <class _Up, class... _Args>

                void construct(_Up *__p, _Args &&...__args)
                {
                    ::new ((void *)__p) _Up(std::forward<_Args>(__args)...);
                }

                void destroy(pointer __p)
                {
                    __p->~_Tp();
                }
};
template <class _Tp>
class allocator<const _Tp>
    : private __non_trivial_if<!is_void<_Tp>::value, allocator<const _Tp>>
{
                _Static_assert(!is_volatile<_Tp>::value, "std::allocator does not support volatile types");

            public:
                typedef size_t size_type;
                typedef ptrdiff_t difference_type;
                typedef const _Tp value_type;
                typedef true_type propagate_on_container_move_assignment;
                typedef true_type is_always_equal;

                allocator() throw() = default;
                template <class _Up>

                allocator(const allocator<_Up> &) throw()
                {
                }

                const _Tp *allocate(size_t __n)
                {
                    if (__n > allocator_traits<allocator>::max_size(*this))
                        __throw_bad_array_new_length();
                    if (__libcpp_is_constant_evaluated())
                    {
                        return static_cast<const _Tp *>(::operator new(__n * sizeof(_Tp)));
                    }
                    else
                    {
                        return static_cast<const _Tp *>(std::__libcpp_allocate(__n * sizeof(_Tp), _Alignof(_Tp)));
                    }
                }

                void deallocate(const _Tp *__p, size_t __n)
                {
                    if (__libcpp_is_constant_evaluated())
                    {
                        ::operator delete(const_cast<_Tp *>(__p));
                    }
                    else
                    {
                        std::__libcpp_deallocate((void *)const_cast<_Tp *>(__p), __n * sizeof(_Tp), _Alignof(_Tp));
                    }
                }
                typedef const _Tp *pointer;
                typedef const _Tp *const_pointer;
                typedef const _Tp &reference;
                typedef const _Tp &const_reference;
                template <class _Up>
                struct rebind
                {
                    typedef allocator<_Up> other;
                };

                const_pointer address(const_reference __x) const throw()
                {
                    return std::addressof(__x);
                }

                const _Tp *allocate(size_t __n, const void *)
                {
                    return allocate(__n);
                }
                {
                    return size_type(~0) / sizeof(_Tp);
                }
                template <class _Up, class... _Args>

                void construct(_Up *__p, _Args &&...__args)
                {
                    ::new ((void *)__p) _Up(std::forward<_Args>(__args)...);
                }

                void destroy(pointer __p)
                {
                    __p->~_Tp();
                }
};
template <class _Tp, class _Up>
inline bool operator==(const allocator<_Tp> &, const allocator<_Up> &) throw() { return true; }
template <class _Tp, class _Up>
inline bool operator!=(const allocator<_Tp> &, const allocator<_Up> &) throw() { return false; }
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct auto_ptr_ref
{
                _Tp *__ptr_;
};
template <class _Tp>
class auto_ptr
{
            private:
                _Tp *__ptr_;

            public:
                typedef _Tp element_type;
                {} {
                }
                template <class _Up>
                    : __ptr_(__p.release()){}

                {
                    reset(__p.release());
                    return *this;
                }
                template <class _Up>
                {
                    reset(__p.release());
                    return *this;
                }

                {
                    reset(__p.__ptr_);
                    return *this;
                }
                {
                    delete __ptr_;
                }

                {
                    return *__ptr_;
                }
                {
                    return __ptr_;
                }
                {
                    return __ptr_;
                }

                {
                    _Tp *__t = __ptr_;
                    __ptr_ = __nullptr;
                    return __t;
                }

                {
                    if (__ptr_ != __p)
                        delete __ptr_;
                    __ptr_ = __p;
                }
                {
                }
                template <class _Up>
                {
                    auto_ptr_ref<_Up> __t;
                    __t.__ptr_ = release();
                    return __t;
                }
                template <class _Up>
                {
                    return auto_ptr<_Up>(release());
                }
};
template <>
class auto_ptr<void>
{
            public:
                typedef void element_type;
};
}
}
namespace std
{
inline namespace __1
{
struct __default_init_tag
{
};
struct __value_init_tag
{
};
template <class _Tp, int _Idx, bool _CanBeEmptyBase = is_empty<_Tp>::value && !__libcpp_is_final<_Tp>::value>
struct __compressed_pair_elem
{
                using _ParamT = _Tp;
                using reference = _Tp &;
                using const_reference = const _Tp &;
                {} {
                }
                template <class _Up, class = __enable_if_t<!is_same<__compressed_pair_elem, typename decay<_Up>::type>::value>>

                explicit __compressed_pair_elem(_Up &&__u) : __value_(std::forward<_Up>(__u)){}
                {
                    return __value_;
                }
                {
                    return __value_;
                }

            private:
                _Tp __value_;
};
template <class _Tp, int _Idx>
struct __compressed_pair_elem<_Tp, _Idx, true> : private _Tp
{
                using _ParamT = _Tp;
                using reference = _Tp &;
                using const_reference = const _Tp &;
                using __value_type = _Tp;
                = default;
                {} {
                }
                template <class _Up, class = __enable_if_t<!is_same<__compressed_pair_elem, typename decay<_Up>::type>::value>>

                explicit __compressed_pair_elem(_Up &&__u) : __value_type(std::forward<_Up>(__u)){}
                {
                    return *this;
                }
                {
                    return *this;
                }
};
template <class _T1, class _T2>
class __compressed_pair : private __compressed_pair_elem<_T1, 0>,
                          private __compressed_pair_elem<_T2, 1>
{
            public:
                _Static_assert((!is_same<_T1, _T2>::value), "__compressed_pair cannot be instantiated when T1 and T2 are the same type; "
                                                            "The current implementation is NOT ABI-compatible with the previous implementation for this configuration");
                using _Base1 = __compressed_pair_elem<_T1, 0>;
                using _Base2 = __compressed_pair_elem<_T2, 1>;
                template <bool _Dummy = true,
                          class = __enable_if_t<
                              __dependent_type<is_default_constructible<_T1>, _Dummy>::value &&
                              __dependent_type<is_default_constructible<_T2>, _Dummy>::value>>

                explicit __compressed_pair() : _Base1(__value_init_tag()), _Base2(__value_init_tag())
                {
                }
                template <class _U1, class _U2>

                explicit __compressed_pair(_U1 &&__t1, _U2 &&__t2) : _Base1(std::forward<_U1>(__t1)), _Base2(std::forward<_U2>(__t2))
                {
                }

                typename _Base1::reference first() throw()
                {
                    return static_cast<_Base1 &>(*this).__get();
                }

                typename _Base1::const_reference first() const throw()
                {
                    return static_cast<_Base1 const &>(*this).__get();
                }

                typename _Base2::reference second() throw()
                {
                    return static_cast<_Base2 &>(*this).__get();
                }

                typename _Base2::const_reference second() const throw()
                {
                    return static_cast<_Base2 const &>(*this).__get();
                }
                static _Base1 *__get_first_base(__compressed_pair *__pair) throw()
                {
                    return static_cast<_Base1 *>(__pair);
                }
                static _Base2 *__get_second_base(__compressed_pair *__pair) throw()
                {
                    return static_cast<_Base2 *>(__pair);
                }

                void swap(__compressed_pair &__x)
                {
                    using std::swap;
                    swap(first(), __x.first());
                    swap(second(), __x.second());
                }
};
template <class _T1, class _T2>
inline void swap(__compressed_pair<_T1, _T2> &__x, __compressed_pair<_T1, _T2> &__y)
{
                __x.swap(__y);
}
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
struct __unreachable_sentinel
{
                template <class _Iter>
                {
                    return true;
                }
};
template <class _ValueType, class _InputIterator, class _Sentinel1, class _ForwardIterator, class _Sentinel2>
inline pair<_InputIterator, _ForwardIterator>
__uninitialized_copy(_InputIterator __ifirst, _Sentinel1 __ilast,
                     _ForwardIterator __ofirst, _Sentinel2 __olast)
{
                _ForwardIterator __idx = __ofirst;
                try
                {
                    for (; __ifirst != __ilast && __idx != __olast; ++__ifirst, (void)++__idx)
                        ::new (std::__voidify(*__idx)) _ValueType(*__ifirst);
                }
                catch (...)
                {
                    std::__destroy(__ofirst, __idx);
                    throw;
                }
                return pair<_InputIterator, _ForwardIterator>(std::move(__ifirst), std::move(__idx));
}
template <class _InputIterator, class _ForwardIterator>
_ForwardIterator uninitialized_copy(_InputIterator __ifirst, _InputIterator __ilast,
                                    _ForwardIterator __ofirst)
{
                typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
                auto __result = std::__uninitialized_copy<_ValueType>(std::move(__ifirst), std::move(__ilast),
                                                                      std::move(__ofirst), __unreachable_sentinel());
                return std::move(__result.second);
}
template <class _ValueType, class _InputIterator, class _Size, class _ForwardIterator, class _Sentinel>
inline pair<_InputIterator, _ForwardIterator>
__uninitialized_copy_n(_InputIterator __ifirst, _Size __n,
                       _ForwardIterator __ofirst, _Sentinel __olast)
{
                _ForwardIterator __idx = __ofirst;
                try
                {
                    for (; __n > 0 && __idx != __olast; ++__ifirst, (void)++__idx, (void)--__n)
                        ::new (std::__voidify(*__idx)) _ValueType(*__ifirst);
                }
                catch (...)
                {
                    std::__destroy(__ofirst, __idx);
                    throw;
                }
                return pair<_InputIterator, _ForwardIterator>(std::move(__ifirst), std::move(__idx));
}
template <class _InputIterator, class _Size, class _ForwardIterator>
inline _ForwardIterator uninitialized_copy_n(_InputIterator __ifirst, _Size __n,
                                             _ForwardIterator __ofirst)
{
                typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
                auto __result = std::__uninitialized_copy_n<_ValueType>(std::move(__ifirst), __n, std::move(__ofirst),
                                                                        __unreachable_sentinel());
                return std::move(__result.second);
}
template <class _ValueType, class _ForwardIterator, class _Sentinel, class _Tp>
inline _ForwardIterator __uninitialized_fill(_ForwardIterator __first, _Sentinel __last, const _Tp &__x)
{
                _ForwardIterator __idx = __first;
                try
                {
                    for (; __idx != __last; ++__idx)
                        ::new (std::__voidify(*__idx)) _ValueType(__x);
                }
                catch (...)
                {
                    std::__destroy(__first, __idx);
                    throw;
                }
                return __idx;
}
template <class _ForwardIterator, class _Tp>
inline void uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x)
{
                typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
                (void)std::__uninitialized_fill<_ValueType>(__first, __last, __x);
}
template <class _ValueType, class _ForwardIterator, class _Size, class _Tp>
inline _ForwardIterator __uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp &__x)
{
                _ForwardIterator __idx = __first;
                try
                {
                    for (; __n > 0; ++__idx, (void)--__n)
                        ::new (std::__voidify(*__idx)) _ValueType(__x);
                }
                catch (...)
                {
                    std::__destroy(__first, __idx);
                    throw;
                }
                return __idx;
}
template <class _ForwardIterator, class _Size, class _Tp>
inline _ForwardIterator uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp &__x)
{
                typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
                return std::__uninitialized_fill_n<_ValueType>(__first, __n, __x);
}
template <class _Alloc, class _Iter, class _Sent>
void __allocator_destroy(_Alloc &__alloc, _Iter __first, _Sent __last)
{
                for (; __first != __last; ++__first)
                    allocator_traits<_Alloc>::destroy(__alloc, std::__to_address(__first));
}
template <class _Alloc, class _Iter>
class _AllocatorDestroyRangeReverse
{
            public:
                _AllocatorDestroyRangeReverse(_Alloc &__alloc, _Iter &__first, _Iter &__last)
                    : __alloc_(__alloc), __first_(__first), __last_(__last) {}
                const
                {
                    std::__allocator_destroy(__alloc_, std::reverse_iterator<_Iter>(__last_), std::reverse_iterator<_Iter>(__first_));
                }

            private:
                _Alloc &__alloc_;
                _Iter &__first_;
                _Iter &__last_;
};
template <class _Alloc, class _Iter1, class _Sent1, class _Iter2>
_Iter2
__uninitialized_allocator_copy(_Alloc &__alloc, _Iter1 __first1, _Sent1 __last1, _Iter2 __first2)
{
                auto __destruct_first = __first2;
                try
                {
                    while (__first1 != __last1)
                    {
                        allocator_traits<_Alloc>::construct(__alloc, std::__to_address(__first2), *__first1);
                        ++__first1;
                        ++__first2;
                    }
                }
                catch (...)
                {
                    _AllocatorDestroyRangeReverse<_Alloc, _Iter2>(__alloc, __destruct_first, __first2)();
                    throw;
                }
                return __first2;
}
template <class _Alloc, class _Type>
struct __allocator_has_trivial_copy_construct : _Not<__has_construct<_Alloc, _Type *, const _Type &>>
{
};
template <class _Type>
struct __allocator_has_trivial_copy_construct<allocator<_Type>, _Type> : true_type
{
};
template <class _Alloc,
          class _Type,
          class _RawType = typename remove_const<_Type>::type,
          __enable_if_t<
              is_trivially_copy_constructible<_RawType>::value && is_trivially_copy_assignable<_RawType>::value &&
              __allocator_has_trivial_copy_construct<_Alloc, _RawType>::value> * = __nullptr>
_Type *
__uninitialized_allocator_copy(_Alloc &, const _Type *__first1, const _Type *__last1, _Type *__first2)
{
                if (__libcpp_is_constant_evaluated())
                {
                    while (__first1 != __last1)
                    {
                        std::__construct_at(std::__to_address(__first2), *__first1);
                        ++__first1;
                        ++__first2;
                    }
                    return __first2;
                }
                else
                {
                    return std::copy(__first1, __last1, const_cast<_RawType *>(__first2));
                }
}
template <class _Alloc, class _Iter1, class _Sent1, class _Iter2>
_Iter2 __uninitialized_allocator_move_if_noexcept(
    _Alloc &__alloc, _Iter1 __first1, _Sent1 __last1, _Iter2 __first2)
{
                _Static_assert(__is_cpp17_move_insertable<_Alloc>::value, "The specified type does not meet the requirements of Cpp17MoveInsertable");
                auto __destruct_first = __first2;
                try
                {
                    while (__first1 != __last1)
                    {
                        allocator_traits<_Alloc>::construct(__alloc, std::__to_address(__first2), std::move_if_noexcept(*__first1));
                        ++__first1;
                        ++__first2;
                    }
                }
                catch (...)
                {
                    _AllocatorDestroyRangeReverse<_Alloc, _Iter2>(__alloc, __destruct_first, __first2)();
                    throw;
                }
                return __first2;
}
template <class _Alloc, class _Type>
struct __allocator_has_trivial_move_construct : _Not<__has_construct<_Alloc, _Type *, _Type &&>>
{
};
template <class _Type>
struct __allocator_has_trivial_move_construct<allocator<_Type>, _Type> : true_type
{
};
template <
    class _Alloc,
    class _Iter1,
    class _Iter2,
    class _Type = typename iterator_traits<_Iter1>::value_type,
    class = __enable_if_t<is_trivially_move_constructible<_Type>::value && is_trivially_move_assignable<_Type>::value &&
                          __allocator_has_trivial_move_construct<_Alloc, _Type>::value>>
_Iter2
__uninitialized_allocator_move_if_noexcept(_Alloc &, _Iter1 __first1, _Iter1 __last1, _Iter2 __first2)
{
                if (__libcpp_is_constant_evaluated())
                {
                    while (__first1 != __last1)
                    {
                        std::__construct_at(std::__to_address(__first2), std::move(*__first1));
                        ++__first1;
                        ++__first2;
                    }
                    return __first2;
                }
                else
                {
                    return std::move(__first1, __last1, __first2);
                }
}
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _OutputIterator, class _Tp>
class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
#pragma GCC diagnostic pop
            private:
                _OutputIterator __x_;

            public:
                typedef output_iterator_tag iterator_category;
                typedef void value_type;
                typedef void difference_type;
                typedef void pointer;
                typedef void reference;
                {} {
                    return *this;
                }

                {
                    ::new ((void *)std::addressof(*__x_)) _Tp(__element);
                    return *this;
                }
                {
                    ++__x_;
                    return *this;
                }

                {
                    raw_storage_iterator __t(*this);
                    ++__x_;
                    return __t;
                }
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct __has_result_type
{
            private:
                template <class _Up>
                static false_type __test(...);
                template <class _Up>
                static true_type __test(typename _Up::result_type * = 0);

            public:
                static const bool value = __decltype(__test<_Tp>(0))::value;
};
template <class _Tp>
struct __derives_from_unary_function
{
            private:
                struct __two
                {
                    char __lx;
                    char __lxx;
                };
                static __two __test(...);
                template <class _Ap, class _Rp>
                static __unary_function<_Ap, _Rp>
                __test(const volatile __unary_function<_Ap, _Rp> *);

            public:
                static const bool value = !is_same<__decltype(__test((_Tp *)0)), __two>::value;
                typedef __decltype(__test((_Tp *)0)) type;
};
template <class _Tp>
struct __derives_from_binary_function
{
            private:
                struct __two
                {
                    char __lx;
                    char __lxx;
                };
                static __two __test(...);
                template <class _A1, class _A2, class _Rp>
                static __binary_function<_A1, _A2, _Rp>
                __test(const volatile __binary_function<_A1, _A2, _Rp> *);

            public:
                static const bool value = !is_same<__decltype(__test((_Tp *)0)), __two>::value;
                typedef __decltype(__test((_Tp *)0)) type;
};
template <class _Tp, bool = __derives_from_unary_function<_Tp>::value>
struct __maybe_derive_from_unary_function
    : public __derives_from_unary_function<_Tp>::type
{
};
template <class _Tp>
struct __maybe_derive_from_unary_function<_Tp, false>
{
};
template <class _Tp, bool = __derives_from_binary_function<_Tp>::value>
struct __maybe_derive_from_binary_function
    : public __derives_from_binary_function<_Tp>::type
{
};
template <class _Tp>
struct __maybe_derive_from_binary_function<_Tp, false>
{
};
template <class _Tp, bool = __has_result_type<_Tp>::value>
struct __weak_result_type_imp
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
                using result_type = typename _Tp::result_type;
};
template <class _Tp>
struct __weak_result_type_imp<_Tp, false>
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
};
template <class _Tp>
struct __weak_result_type
    : public __weak_result_type_imp<_Tp>
{
};
template <class _Rp>
struct __weak_result_type<_Rp()>
{
                using result_type = _Rp;
};
template <class _Rp>
struct __weak_result_type<_Rp (&)()>
{
                using result_type = _Rp;
};
template <class _Rp>
struct __weak_result_type<_Rp (*)()>
{
                using result_type = _Rp;
};
template <class _Rp, class _A1>
struct __weak_result_type<_Rp(_A1)>
    : public __unary_function<_A1, _Rp>
{
};
template <class _Rp, class _A1>
struct __weak_result_type<_Rp (&)(_A1)>
    : public __unary_function<_A1, _Rp>
{
};
template <class _Rp, class _A1>
struct __weak_result_type<_Rp (*)(_A1)>
    : public __unary_function<_A1, _Rp>
{
};
template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)()>
    : public __unary_function<_Cp *, _Rp>
{
};
template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const>
    : public __unary_function<const _Cp *, _Rp>
{
};
template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() volatile>
    : public __unary_function<volatile _Cp *, _Rp>
{
};
template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const volatile>
    : public __unary_function<const volatile _Cp *, _Rp>
{
};
template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp(_A1, _A2)>
    : public __binary_function<_A1, _A2, _Rp>
{
};
template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (*)(_A1, _A2)>
    : public __binary_function<_A1, _A2, _Rp>
{
};
template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (&)(_A1, _A2)>
    : public __binary_function<_A1, _A2, _Rp>
{
};
template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1)>
    : public __binary_function<_Cp *, _A1, _Rp>
{
};
template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const>
    : public __binary_function<const _Cp *, _A1, _Rp>
{
};
template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>
    : public __binary_function<volatile _Cp *, _A1, _Rp>
{
};
template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>
    : public __binary_function<const volatile _Cp *, _A1, _Rp>
{
};
template <class _Rp, class _A1, class _A2, class _A3, class... _A4>
struct __weak_result_type<_Rp(_A1, _A2, _A3, _A4...)>
{
                using result_type = _Rp;
};
template <class _Rp, class _A1, class _A2, class _A3, class... _A4>
struct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>
{
                using result_type = _Rp;
};
template <class _Rp, class _A1, class _A2, class _A3, class... _A4>
struct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>
{
                using result_type = _Rp;
};
template <class _Rp, class _Cp, class _A1, class _A2, class... _A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>
{
                using result_type = _Rp;
};
template <class _Rp, class _Cp, class _A1, class _A2, class... _A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>
{
                using result_type = _Rp;
};
template <class _Rp, class _Cp, class _A1, class _A2, class... _A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>
{
                using result_type = _Rp;
};
template <class _Rp, class _Cp, class _A1, class _A2, class... _A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>
{
                using result_type = _Rp;
};
template <class _Tp, class... _Args>
struct __invoke_return
{
                typedef __decltype(std::__invoke(declval<_Tp>(), declval<_Args>()...)) type;
};
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
class reference_wrapper : public __weak_result_type<_Tp>
{
            public:
                typedef _Tp type;

            private:
                type *__f_;
                static void __fun(_Tp &) throw();
                static void __fun(_Tp &&) = delete;

            public:
                template <class _Up, class = __enable_if_t<!__is_same_uncvref<_Up, reference_wrapper>::value, __decltype(__fun(declval<_Up>()))>>

                reference_wrapper(_Up &&__u)
                {
                    type &__f = static_cast<_Up &&>(__u);
                    __f_ = std::addressof(__f);
                }

                operator type &() const throw() { return *__f_; }

                type &get() const throw() { return *__f_; }
                template <class... _ArgTypes>

                typename __invoke_of<type &, _ArgTypes...>::type
                operator()(_ArgTypes &&...__args) const
                {
                    return std::__invoke(get(), std::forward<_ArgTypes>(__args)...);
                }
};
template <class _Tp>
inline reference_wrapper<_Tp>
ref(_Tp &__t) throw()
{
                return reference_wrapper<_Tp>(__t);
}
template <class _Tp>
inline reference_wrapper<_Tp>
ref(reference_wrapper<_Tp> __t) throw()
{
                return __t;
}
template <class _Tp>
inline reference_wrapper<const _Tp>
cref(const _Tp &__t) throw()
{
                return reference_wrapper<const _Tp>(__t);
}
template <class _Tp>
inline reference_wrapper<const _Tp>
cref(reference_wrapper<_Tp> __t) throw()
{
                return __t;
}
template <class _Tp>
void ref(const _Tp &&) = delete;
template <class _Tp>
void cref(const _Tp &&) = delete;
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct default_delete
{
                _Static_assert(!is_function<_Tp>::value, "default_delete cannot be instantiated for function types");
                {
                }
                template <class _Up>

                default_delete(const default_delete<_Up> &,
                               typename enable_if<is_convertible<_Up *, _Tp *>::value>::type * =
                                   0) throw(){}
                {
                    _Static_assert(sizeof(_Tp) >= 0, "cannot delete an incomplete type");
                    _Static_assert(!is_void<_Tp>::value, "cannot delete an incomplete type");
                    delete __ptr;
                }
};
template <class _Tp>
struct default_delete<_Tp[]>
{
            private:
                template <class _Up>
                struct _EnableIfConvertible
                    : enable_if<is_convertible<_Up (*)[], _Tp (*)[]>::value>
                {
                };

            public:
                {
                }
                template <class _Up>

                default_delete(const default_delete<_Up[]> &,
                               typename _EnableIfConvertible<_Up>::type * = 0) throw()
                {
                }
                template <class _Up>

                typename _EnableIfConvertible<_Up>::type
                operator()(_Up *__ptr) const throw()
                {
                    _Static_assert(sizeof(_Up) >= 0, "cannot delete an incomplete type");
                    delete[] __ptr;
                }
};
template <class _Deleter>
struct __unique_ptr_deleter_sfinae
{
                _Static_assert(!is_reference<_Deleter>::value, "incorrect specialization");
                typedef const _Deleter &__lval_ref_type;
                typedef _Deleter &&__good_rval_ref_type;
                typedef true_type __enable_rval_overload;
};
template <class _Deleter>
struct __unique_ptr_deleter_sfinae<_Deleter const &>
{
                typedef const _Deleter &__lval_ref_type;
                typedef const _Deleter &&__bad_rval_ref_type;
                typedef false_type __enable_rval_overload;
};
template <class _Deleter>
struct __unique_ptr_deleter_sfinae<_Deleter &>
{
                typedef _Deleter &__lval_ref_type;
                typedef _Deleter &&__bad_rval_ref_type;
                typedef false_type __enable_rval_overload;
};
template <class _Tp, class _Dp = default_delete<_Tp>>
class unique_ptr
{
            public:
                typedef _Tp element_type;
                typedef _Dp deleter_type;
                typedef typename __pointer<_Tp, deleter_type>::type pointer;
                _Static_assert(!is_rvalue_reference<deleter_type>::value, "the specified deleter type cannot be an rvalue reference");

            private:
                __compressed_pair<pointer, deleter_type> __ptr_;
                struct __nat
                {
                    int __for_bool_;
                };
                typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;
                template <bool _Dummy>
                using _LValRefType =
                    typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;
                template <bool _Dummy>
                using _GoodRValRefType =
                    typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;
                template <bool _Dummy>
                using _BadRValRefType =
                    typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;
                template <bool _Dummy, class _Deleter = typename __dependent_type<
                                           __type_identity<deleter_type>, _Dummy>::type>
                using _EnableIfDeleterDefaultConstructible =
                    typename enable_if<is_default_constructible<_Deleter>::value &&
                                       !is_pointer<_Deleter>::value>::type;
                template <class _ArgType>
                using _EnableIfDeleterConstructible =
                    typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;
                template <class _UPtr, class _Up>
                using _EnableIfMoveConvertible = typename enable_if<
                    is_convertible<typename _UPtr::pointer, pointer>::value &&
                    !is_array<_Up>::value>::type;
                template <class _UDel>
                using _EnableIfDeleterConvertible = typename enable_if<
                    (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
                    (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)>::type;
                template <class _UDel>
                using _EnableIfDeleterAssignable = typename enable_if<
                    is_assignable<_Dp &, _UDel &&>::value>::type;

            public:
                template <bool _Dummy = true,
                          class = _EnableIfDeleterDefaultConstructible<_Dummy>>

                unique_ptr() throw() : __ptr_(__value_init_tag(), __value_init_tag())
                {
                }
                template <bool _Dummy = true,
                          class = _EnableIfDeleterDefaultConstructible<_Dummy>>

                unique_ptr(nullptr_t) throw() : __ptr_(__value_init_tag(), __value_init_tag())
                {
                }
                template <bool _Dummy = true,
                          class = _EnableIfDeleterDefaultConstructible<_Dummy>>

                explicit unique_ptr(pointer __p) throw() : __ptr_(__p, __value_init_tag())
                {
                }
                template <bool _Dummy = true,
                          class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>>

                unique_ptr(pointer __p, _LValRefType<_Dummy> __d) throw()
                    : __ptr_(__p, __d)
                {
                }
                template <bool _Dummy = true,
                          class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>>

                unique_ptr(pointer __p, _GoodRValRefType<_Dummy> __d) throw()
                    : __ptr_(__p, std::move(__d))
                {
                    _Static_assert(!is_reference<deleter_type>::value, "rvalue deleter bound to reference");
                }
                template <bool _Dummy = true,
                          class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy>>>

                unique_ptr(pointer __p, _BadRValRefType<_Dummy> __d) = delete;

                unique_ptr(unique_ptr &&__u) throw()
                    : __ptr_(__u.release(), std::forward<deleter_type>(__u.get_deleter()))
                {
                }
                template <class _Up, class _Ep,
                          class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
                          class = _EnableIfDeleterConvertible<_Ep>>

                unique_ptr(unique_ptr<_Up, _Ep> &&__u) throw()
                    : __ptr_(__u.release(), std::forward<_Ep>(__u.get_deleter()))
                {
                }
                template <class _Up>

                unique_ptr(auto_ptr<_Up> &&__p,
                           typename enable_if<is_convertible<_Up *, _Tp *>::value &&
                                                  is_same<_Dp, default_delete<_Tp>>::value,
                                              __nat>::type = __nat()) throw()
                    : __ptr_(__p.release(), __value_init_tag())
                {
                }

                unique_ptr &operator=(unique_ptr &&__u) throw()
                {
                    reset(__u.release());
                    __ptr_.second() = std::forward<deleter_type>(__u.get_deleter());
                    return *this;
                }
                template <class _Up, class _Ep,
                          class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
                          class = _EnableIfDeleterAssignable<_Ep>>

                unique_ptr &operator=(unique_ptr<_Up, _Ep> &&__u) throw()
                {
                    reset(__u.release());
                    __ptr_.second() = std::forward<_Ep>(__u.get_deleter());
                    return *this;
                }
                template <class _Up>

                typename enable_if<is_convertible<_Up *, _Tp *>::value &&
                                       is_same<_Dp, default_delete<_Tp>>::value,
                                   unique_ptr &>::type
                operator=(auto_ptr<_Up> __p)
                {
                    reset(__p.release());
                    return *this;
                }
                unique_ptr(unique_ptr const &) = delete;
                unique_ptr &operator=(unique_ptr const &) = delete;

                ~unique_ptr() { reset(); }

                unique_ptr &operator=(nullptr_t) throw()
                {
                    reset();
                    return *this;
                }

                typename add_lvalue_reference<_Tp>::type
                operator*() const
                {
                    return *__ptr_.first();
                }

                pointer operator->() const throw()
                {
                    return __ptr_.first();
                }

                pointer get() const throw()
                {
                    return __ptr_.first();
                }

                deleter_type &get_deleter() throw()
                {
                    return __ptr_.second();
                }

                const deleter_type &get_deleter() const throw()
                {
                    return __ptr_.second();
                }

                explicit operator bool() const throw()
                {
                    return __ptr_.first() != __nullptr;
                }

                pointer release() throw()
                {
                    pointer __t = __ptr_.first();
                    __ptr_.first() = pointer();
                    return __t;
                }

                void reset(pointer __p = pointer()) throw()
                {
                    pointer __tmp = __ptr_.first();
                    __ptr_.first() = __p;
                    if (__tmp)
                        __ptr_.second()(__tmp);
                }

                void swap(unique_ptr &__u) throw()
                {
                    __ptr_.swap(__u.__ptr_);
                }
};
template <class _Tp, class _Dp>
class unique_ptr<_Tp[], _Dp>
{
            public:
                typedef _Tp element_type;
                typedef _Dp deleter_type;
                typedef typename __pointer<_Tp, deleter_type>::type pointer;

            private:
                __compressed_pair<pointer, deleter_type> __ptr_;
                template <class _From>
                struct _CheckArrayPointerConversion : is_same<_From, pointer>
                {
                };
                template <class _FromElem>
                struct _CheckArrayPointerConversion<_FromElem *>
                    : integral_constant<bool,
                                        is_same<_FromElem *, pointer>::value ||
                                            (is_same<pointer, element_type *>::value &&
                                             is_convertible<_FromElem (*)[], element_type (*)[]>::value)>
                {
                };
                typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;
                template <bool _Dummy>
                using _LValRefType =
                    typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;
                template <bool _Dummy>
                using _GoodRValRefType =
                    typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;
                template <bool _Dummy>
                using _BadRValRefType =
                    typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;
                template <bool _Dummy, class _Deleter = typename __dependent_type<
                                           __type_identity<deleter_type>, _Dummy>::type>
                using _EnableIfDeleterDefaultConstructible =
                    typename enable_if<is_default_constructible<_Deleter>::value &&
                                       !is_pointer<_Deleter>::value>::type;
                template <class _ArgType>
                using _EnableIfDeleterConstructible =
                    typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;
                template <class _Pp>
                using _EnableIfPointerConvertible = typename enable_if<
                    _CheckArrayPointerConversion<_Pp>::value>::type;
                template <class _UPtr, class _Up,
                          class _ElemT = typename _UPtr::element_type>
                using _EnableIfMoveConvertible = typename enable_if<
                    is_array<_Up>::value &&
                    is_same<pointer, element_type *>::value &&
                    is_same<typename _UPtr::pointer, _ElemT *>::value &&
                    is_convertible<_ElemT (*)[], element_type (*)[]>::value>::type;
                template <class _UDel>
                using _EnableIfDeleterConvertible = typename enable_if<
                    (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
                    (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)>::type;
                template <class _UDel>
                using _EnableIfDeleterAssignable = typename enable_if<
                    is_assignable<_Dp &, _UDel &&>::value>::type;

            public:
                template <bool _Dummy = true,
                          class = _EnableIfDeleterDefaultConstructible<_Dummy>>

                unique_ptr() throw() : __ptr_(__value_init_tag(), __value_init_tag())
                {
                }
                template <bool _Dummy = true,
                          class = _EnableIfDeleterDefaultConstructible<_Dummy>>

                unique_ptr(nullptr_t) throw() : __ptr_(__value_init_tag(), __value_init_tag())
                {
                }
                template <class _Pp, bool _Dummy = true,
                          class = _EnableIfDeleterDefaultConstructible<_Dummy>,
                          class = _EnableIfPointerConvertible<_Pp>>

                explicit unique_ptr(_Pp __p) throw()
                    : __ptr_(__p, __value_init_tag())
                {
                }
                template <class _Pp, bool _Dummy = true,
                          class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>,
                          class = _EnableIfPointerConvertible<_Pp>>

                unique_ptr(_Pp __p, _LValRefType<_Dummy> __d) throw()
                    : __ptr_(__p, __d)
                {
                }
                template <bool _Dummy = true,
                          class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>>

                unique_ptr(nullptr_t, _LValRefType<_Dummy> __d) throw()
                    : __ptr_(__nullptr, __d)
                {
                }
                template <class _Pp, bool _Dummy = true,
                          class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>,
                          class = _EnableIfPointerConvertible<_Pp>>

                unique_ptr(_Pp __p, _GoodRValRefType<_Dummy> __d) throw()
                    : __ptr_(__p, std::move(__d))
                {
                    _Static_assert(!is_reference<deleter_type>::value, "rvalue deleter bound to reference");
                }
                template <bool _Dummy = true,
                          class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>>

                unique_ptr(nullptr_t, _GoodRValRefType<_Dummy> __d) throw()
                    : __ptr_(__nullptr, std::move(__d))
                {
                    _Static_assert(!is_reference<deleter_type>::value, "rvalue deleter bound to reference");
                }
                template <class _Pp, bool _Dummy = true,
                          class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy>>,
                          class = _EnableIfPointerConvertible<_Pp>>

                unique_ptr(_Pp __p, _BadRValRefType<_Dummy> __d) = delete;

                unique_ptr(unique_ptr &&__u) throw()
                    : __ptr_(__u.release(), std::forward<deleter_type>(__u.get_deleter()))
                {
                }

                unique_ptr &operator=(unique_ptr &&__u) throw()
                {
                    reset(__u.release());
                    __ptr_.second() = std::forward<deleter_type>(__u.get_deleter());
                    return *this;
                }
                template <class _Up, class _Ep,
                          class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
                          class = _EnableIfDeleterConvertible<_Ep>>

                unique_ptr(unique_ptr<_Up, _Ep> &&__u) throw()
                    : __ptr_(__u.release(), std::forward<_Ep>(__u.get_deleter()))
                {
                }
                template <class _Up, class _Ep,
                          class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
                          class = _EnableIfDeleterAssignable<_Ep>>

                unique_ptr &
                operator=(unique_ptr<_Up, _Ep> &&__u) throw()
                {
                    reset(__u.release());
                    __ptr_.second() = std::forward<_Ep>(__u.get_deleter());
                    return *this;
                }
                unique_ptr(unique_ptr const &) = delete;
                unique_ptr &operator=(unique_ptr const &) = delete;

            public:
                ~unique_ptr() { reset(); }

                unique_ptr &operator=(nullptr_t) throw()
                {
                    reset();
                    return *this;
                }

                typename add_lvalue_reference<_Tp>::type
                operator[](size_t __i) const
                {
                    return __ptr_.first()[__i];
                }

                pointer get() const throw()
                {
                    return __ptr_.first();
                }

                deleter_type &get_deleter() throw()
                {
                    return __ptr_.second();
                }

                const deleter_type &get_deleter() const throw()
                {
                    return __ptr_.second();
                }

                explicit operator bool() const throw()
                {
                    return __ptr_.first() != __nullptr;
                }

                pointer release() throw()
                {
                    pointer __t = __ptr_.first();
                    __ptr_.first() = pointer();
                    return __t;
                }
                template <class _Pp>

                typename enable_if<
                    _CheckArrayPointerConversion<_Pp>::value>::type
                reset(_Pp __p) throw()
                {
                    pointer __tmp = __ptr_.first();
                    __ptr_.first() = __p;
                    if (__tmp)
                        __ptr_.second()(__tmp);
                }

                void reset(nullptr_t = __nullptr) throw()
                {
                    pointer __tmp = __ptr_.first();
                    __ptr_.first() = __nullptr;
                    if (__tmp)
                        __ptr_.second()(__tmp);
                }

                void swap(unique_ptr &__u) throw()
                {
                    __ptr_.swap(__u.__ptr_);
                }
};
template <class _Tp, class _Dp>
inline
    typename enable_if<
        __is_swappable<_Dp>::value,
        void>::type
    swap(unique_ptr<_Tp, _Dp> &__x, unique_ptr<_Tp, _Dp> &__y) throw() { __x.swap(__y); }
template <class _T1, class _D1, class _T2, class _D2>
inline bool
operator==(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) { return __x.get() == __y.get(); }
template <class _T1, class _D1, class _T2, class _D2>
inline bool
operator!=(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) { return !(__x == __y); }
template <class _T1, class _D1, class _T2, class _D2>
inline bool
operator<(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y)
{
                typedef typename unique_ptr<_T1, _D1>::pointer _P1;
                typedef typename unique_ptr<_T2, _D2>::pointer _P2;
                typedef typename common_type<_P1, _P2>::type _Vp;
                return less<_Vp>()(__x.get(), __y.get());
}
template <class _T1, class _D1, class _T2, class _D2>
inline bool
operator>(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) { return __y < __x; }
template <class _T1, class _D1, class _T2, class _D2>
inline bool
operator<=(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) { return !(__y < __x); }
template <class _T1, class _D1, class _T2, class _D2>
inline bool
operator>=(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) { return !(__x < __y); }
template <class _T1, class _D1>
inline bool
operator==(const unique_ptr<_T1, _D1> &__x, nullptr_t) throw()
{
                return !__x;
}
template <class _T1, class _D1>
inline bool
operator==(nullptr_t, const unique_ptr<_T1, _D1> &__x) throw()
{
                return !__x;
}
template <class _T1, class _D1>
inline bool
operator!=(const unique_ptr<_T1, _D1> &__x, nullptr_t) throw()
{
                return static_cast<bool>(__x);
}
template <class _T1, class _D1>
inline bool
operator!=(nullptr_t, const unique_ptr<_T1, _D1> &__x) throw()
{
                return static_cast<bool>(__x);
}
template <class _T1, class _D1>
inline bool
operator<(const unique_ptr<_T1, _D1> &__x, nullptr_t)
{
                typedef typename unique_ptr<_T1, _D1>::pointer _P1;
                return less<_P1>()(__x.get(), __nullptr);
}
template <class _T1, class _D1>
inline bool
operator<(nullptr_t, const unique_ptr<_T1, _D1> &__x)
{
                typedef typename unique_ptr<_T1, _D1>::pointer _P1;
                return less<_P1>()(__nullptr, __x.get());
}
template <class _T1, class _D1>
inline bool
operator>(const unique_ptr<_T1, _D1> &__x, nullptr_t)
{
                return __nullptr < __x;
}
template <class _T1, class _D1>
inline bool
operator>(nullptr_t, const unique_ptr<_T1, _D1> &__x)
{
                return __x < __nullptr;
}
template <class _T1, class _D1>
inline bool
operator<=(const unique_ptr<_T1, _D1> &__x, nullptr_t)
{
                return !(__nullptr < __x);
}
template <class _T1, class _D1>
inline bool
operator<=(nullptr_t, const unique_ptr<_T1, _D1> &__x)
{
                return !(__x < __nullptr);
}
template <class _T1, class _D1>
inline bool
operator>=(const unique_ptr<_T1, _D1> &__x, nullptr_t)
{
                return !(__x < __nullptr);
}
template <class _T1, class _D1>
inline bool
operator>=(nullptr_t, const unique_ptr<_T1, _D1> &__x)
{
                return !(__nullptr < __x);
}
template <class _Tp>
struct hash;
template <class _Tp, class _Dp>
struct hash<unique_ptr<_Tp, _Dp>>
{
                typedef unique_ptr<_Tp, _Dp> argument_type;
                typedef size_t result_type;

                size_t operator()(const unique_ptr<_Tp, _Dp> &__ptr) const
                {
                    typedef typename unique_ptr<_Tp, _Dp>::pointer pointer;
                    return hash<pointer>()(__ptr.get());
                }
};
}
}
namespace std
{
inline namespace __1
{
template <intmax_t _Xp, intmax_t _Yp>
struct __static_gcd
{
                static const intmax_t value = __static_gcd<_Yp, _Xp % _Yp>::value;
};
template <intmax_t _Xp>
struct __static_gcd<_Xp, 0>
{
                static const intmax_t value = _Xp;
};
template <>
struct __static_gcd<0, 0>
{
                static const intmax_t value = 1;
};
template <intmax_t _Xp, intmax_t _Yp>
struct __static_lcm
{
                static const intmax_t value = _Xp / __static_gcd<_Xp, _Yp>::value * _Yp;
};
template <intmax_t _Xp>
struct __static_abs
{
                static const intmax_t value = _Xp < 0 ? -_Xp : _Xp;
};
template <intmax_t _Xp>
struct __static_sign
{
                static const intmax_t value = _Xp == 0 ? 0 : (_Xp < 0 ? -1 : 1);
};
template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_add;
template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 1>
{
                static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
                static const intmax_t max = -min;
                _Static_assert(_Xp <= max - _Yp, "overflow in __ll_add");

            public:
                static const intmax_t value = _Xp + _Yp;
};
template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 0>
{
            public:
                static const intmax_t value = _Xp;
};
template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, -1>
{
                static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
                static const intmax_t max = -min;
                _Static_assert(min - _Yp <= _Xp, "overflow in __ll_add");

            public:
                static const intmax_t value = _Xp + _Yp;
};
template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_sub;
template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 1>
{
                static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
                static const intmax_t max = -min;
                _Static_assert(min + _Yp <= _Xp, "overflow in __ll_sub");

            public:
                static const intmax_t value = _Xp - _Yp;
};
template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 0>
{
            public:
                static const intmax_t value = _Xp;
};
template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, -1>
{
                static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
                static const intmax_t max = -min;
                _Static_assert(_Xp <= max + _Yp, "overflow in __ll_sub");

            public:
                static const intmax_t value = _Xp - _Yp;
};
template <intmax_t _Xp, intmax_t _Yp>
class __ll_mul
{
                static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
                static const intmax_t min = nan + 1;
                static const intmax_t max = -min;
                static const intmax_t __a_x = __static_abs<_Xp>::value;
                static const intmax_t __a_y = __static_abs<_Yp>::value;
                _Static_assert(_Xp != nan && _Yp != nan && __a_x <= max / __a_y, "overflow in __ll_mul");

            public:
                static const intmax_t value = _Xp * _Yp;
};
template <intmax_t _Yp>
class __ll_mul<0, _Yp>
{
            public:
                static const intmax_t value = 0;
};
template <intmax_t _Xp>
class __ll_mul<_Xp, 0>
{
            public:
                static const intmax_t value = 0;
};
template <>
class __ll_mul<0, 0>
{
            public:
                static const intmax_t value = 0;
};
template <intmax_t _Xp, intmax_t _Yp>
class __ll_div
{
                static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
                static const intmax_t min = nan + 1;
                static const intmax_t max = -min;
                _Static_assert(_Xp != nan && _Yp != nan && _Yp != 0, "overflow in __ll_div");

            public:
                static const intmax_t value = _Xp / _Yp;
};
template <intmax_t _Num, intmax_t _Den = 1>
class ratio
{
                _Static_assert(__static_abs<_Num>::value >= 0, "ratio numerator is out of range");
                _Static_assert(_Den != 0, "ratio divide by 0");
                _Static_assert(__static_abs<_Den>::value > 0, "ratio denominator is out of range");
                static const intmax_t __na = __static_abs<_Num>::value;
                static const intmax_t __da = __static_abs<_Den>::value;
                static const intmax_t __s = __static_sign<_Num>::value * __static_sign<_Den>::value;
                static const intmax_t __gcd = __static_gcd<__na, __da>::value;

            public:
                static const intmax_t num = __s * __na / __gcd;
                static const intmax_t den = __da / __gcd;
                typedef ratio<num, den> type;
};
template <intmax_t _Num, intmax_t _Den>
const intmax_t ratio<_Num, _Den>::num;
template <intmax_t _Num, intmax_t _Den>
const intmax_t ratio<_Num, _Den>::den;
template <class _Tp>
struct __is_ratio : false_type
{
};
template <intmax_t _Num, intmax_t _Den>
struct __is_ratio<ratio<_Num, _Den>> : true_type
{
};
typedef ratio<1LL, 1000000000000000000LL> atto;
typedef ratio<1LL, 1000000000000000LL> femto;
typedef ratio<1LL, 1000000000000LL> pico;
typedef ratio<1LL, 1000000000LL> nano;
typedef ratio<1LL, 1000000LL> micro;
typedef ratio<1LL, 1000LL> milli;
typedef ratio<1LL, 100LL> centi;
typedef ratio<1LL, 10LL> deci;
typedef ratio<10LL, 1LL> deca;
typedef ratio<100LL, 1LL> hecto;
typedef ratio<1000LL, 1LL> kilo;
typedef ratio<1000000LL, 1LL> mega;
typedef ratio<1000000000LL, 1LL> giga;
typedef ratio<1000000000000LL, 1LL> tera;
typedef ratio<1000000000000000LL, 1LL> peta;
typedef ratio<1000000000000000000LL, 1LL> exa;
template <class _R1, class _R2>
struct __ratio_multiply
{
            private:
                static const intmax_t __gcd_n1_d2 = __static_gcd<_R1::num, _R2::den>::value;
                static const intmax_t __gcd_d1_n2 = __static_gcd<_R1::den, _R2::num>::value;

            public:
                typedef typename ratio<
                    __ll_mul<_R1::num / __gcd_n1_d2, _R2::num / __gcd_d1_n2>::value,
                    __ll_mul<_R2::den / __gcd_n1_d2, _R1::den / __gcd_d1_n2>::value>::type type;
};
template <class _R1, class _R2>
struct ratio_multiply
    : public __ratio_multiply<_R1, _R2>::type
{
};
template <class _R1, class _R2>
struct __ratio_divide
{
            private:
                static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
                static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;

            public:
                typedef typename ratio<
                    __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                    __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value>::type type;
};
template <class _R1, class _R2>
struct ratio_divide
    : public __ratio_divide<_R1, _R2>::type
{
};
template <class _R1, class _R2>
struct __ratio_add
{
            private:
                static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
                static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;

            public:
                typedef typename ratio_multiply<
                    ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
                    ratio<
                        __ll_add<
                            __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                            __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value>::value,
                        _R2::den>>::type type;
};
template <class _R1, class _R2>
struct ratio_add
    : public __ratio_add<_R1, _R2>::type
{
};
template <class _R1, class _R2>
struct __ratio_subtract
{
            private:
                static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
                static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;

            public:
                typedef typename ratio_multiply<
                    ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
                    ratio<
                        __ll_sub<
                            __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                            __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value>::value,
                        _R2::den>>::type type;
};
template <class _R1, class _R2>
struct ratio_subtract
    : public __ratio_subtract<_R1, _R2>::type
{
};
template <class _R1, class _R2>
struct ratio_equal
    : _BoolConstant<(_R1::num == _R2::num && _R1::den == _R2::den)>
{
};
template <class _R1, class _R2>
struct ratio_not_equal
    : _BoolConstant<!ratio_equal<_R1, _R2>::value>
{
};
template <class _R1, class _R2, bool _Odd = false,
          intmax_t _Q1 = _R1::num / _R1::den, intmax_t _M1 = _R1::num % _R1::den,
          intmax_t _Q2 = _R2::num / _R2::den, intmax_t _M2 = _R2::num % _R2::den>
struct __ratio_less1
{
                static const bool value = _Odd ? _Q2 < _Q1 : _Q1 < _Q2;
};
template <class _R1, class _R2, bool _Odd, intmax_t _Qp>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, 0>
{
                static const bool value = false;
};
template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, _M2>
{
                static const bool value = !_Odd;
};
template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, 0>
{
                static const bool value = _Odd;
};
template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1,
          intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, _M2>
{
                static const bool value = __ratio_less1<ratio<_R1::den, _M1>,
                                                        ratio<_R2::den, _M2>, !_Odd>::value;
};
template <class _R1, class _R2, intmax_t _S1 = __static_sign<_R1::num>::value,
          intmax_t _S2 = __static_sign<_R2::num>::value>
struct __ratio_less
{
                static const bool value = _S1 < _S2;
};
template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, 1LL, 1LL>
{
                static const bool value = __ratio_less1<_R1, _R2>::value;
};
template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, -1LL, -1LL>
{
                static const bool value = __ratio_less1<ratio<-_R2::num, _R2::den>, ratio<-_R1::num, _R1::den>>::value;
};
template <class _R1, class _R2>
struct ratio_less
    : _BoolConstant<__ratio_less<_R1, _R2>::value>
{
};
template <class _R1, class _R2>
struct ratio_less_equal
    : _BoolConstant<!ratio_less<_R2, _R1>::value>
{
};
template <class _R1, class _R2>
struct ratio_greater
    : _BoolConstant<ratio_less<_R2, _R1>::value>
{
};
template <class _R1, class _R2>
struct ratio_greater_equal
    : _BoolConstant<!ratio_less<_R1, _R2>::value>
{
};
template <class _R1, class _R2>
struct __ratio_gcd
{
                typedef ratio<__static_gcd<_R1::num, _R2::num>::value,
                              __static_lcm<_R1::den, _R2::den>::value>
                    type;
};
}
}

namespace std
{
inline namespace __1
{
namespace chrono
{
                template <class _Rep, class _Period = ratio<1>>
                class duration;
                template <class _Tp>
                struct __is_duration : false_type
                {
                };
                template <class _Rep, class _Period>
                struct __is_duration<duration<_Rep, _Period>> : true_type
                {
                };
                template <class _Rep, class _Period>
                struct __is_duration<const duration<_Rep, _Period>> : true_type
                {
                };
                template <class _Rep, class _Period>
                struct __is_duration<volatile duration<_Rep, _Period>> : true_type
                {
                };
                template <class _Rep, class _Period>
                struct __is_duration<const volatile duration<_Rep, _Period>> : true_type
                {
                };
}
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
struct common_type<chrono::duration<_Rep1, _Period1>,
                   chrono::duration<_Rep2, _Period2>>
{
                typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
                                         typename __ratio_gcd<_Period1, _Period2>::type>
                    type;
};
namespace chrono
{
                template <class _FromDuration, class _ToDuration,
                          class _Period = typename ratio_divide<typename _FromDuration::period, typename _ToDuration::period>::type,
                          bool = _Period::num == 1,
                          bool = _Period::den == 1>
                struct __duration_cast;
                template <class _FromDuration, class _ToDuration, class _Period>
                struct __duration_cast<_FromDuration, _ToDuration, _Period, true, true>
                {

                    _ToDuration operator()(const _FromDuration &__fd) const
                    {
                        return _ToDuration(static_cast<typename _ToDuration::rep>(__fd.count()));
                    }
                };
                template <class _FromDuration, class _ToDuration, class _Period>
                struct __duration_cast<_FromDuration, _ToDuration, _Period, true, false>
                {

                    _ToDuration operator()(const _FromDuration &__fd) const
                    {
                        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
                        return _ToDuration(static_cast<typename _ToDuration::rep>(
                            static_cast<_Ct>(__fd.count()) / static_cast<_Ct>(_Period::den)));
                    }
                };
                template <class _FromDuration, class _ToDuration, class _Period>
                struct __duration_cast<_FromDuration, _ToDuration, _Period, false, true>
                {

                    _ToDuration operator()(const _FromDuration &__fd) const
                    {
                        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
                        return _ToDuration(static_cast<typename _ToDuration::rep>(
                            static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)));
                    }
                };
                template <class _FromDuration, class _ToDuration, class _Period>
                struct __duration_cast<_FromDuration, _ToDuration, _Period, false, false>
                {

                    _ToDuration operator()(const _FromDuration &__fd) const
                    {
                        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
                        return _ToDuration(static_cast<typename _ToDuration::rep>(
                            static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num) / static_cast<_Ct>(_Period::den)));
                    }
                };
                template <class _ToDuration, class _Rep, class _Period>
                inline
                    typename enable_if<
                        __is_duration<_ToDuration>::value,
                        _ToDuration>::type
                    duration_cast(const duration<_Rep, _Period> &__fd)
                {
                    return __duration_cast<duration<_Rep, _Period>, _ToDuration>()(__fd);
                }
                template <class _Rep>
                struct treat_as_floating_point : is_floating_point<_Rep>
                {
                };
                template <class _Rep>
                struct duration_values
                {
                public:
                    ;
                };
};
}
};
template <class _Rep, class _Period>
class duration
{
_Static_assert(!__is_duration<_Rep>::value, "A duration representation can not be a duration");
_Static_assert(__is_ratio<_Period>::value, "Second template parameter of duration must be a std::ratio");
_Static_assert(_Period::num > 0, "duration period must be positive");
template <class _R1, class _R2>
struct __no_overflow
{
private:
static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
static const intmax_t __n1 = _R1::num / __gcd_n1_n2;
static const intmax_t __d1 = _R1::den / __gcd_d1_d2;
static const intmax_t __n2 = _R2::num / __gcd_n1_n2;
static const intmax_t __d2 = _R2::den / __gcd_d1_d2;
static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);
template <intmax_t _Xp, intmax_t _Yp, bool __overflow>
struct __mul
{
                static const intmax_t value = _Xp * _Yp;
};
template <intmax_t _Xp, intmax_t _Yp>
struct __mul<_Xp, _Yp, true>
{
                static const intmax_t value = 1;
};

public:
static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
typedef ratio<__mul<__n1, __d2, !value>::value,
              __mul<__n2, __d1, !value>::value>
    type;
};

public:
typedef _Rep rep;
typedef typename _Period::type period;

private:
rep __rep_;

public:
duration() {}
template <class _Rep2>

explicit duration(const _Rep2 &__r,
                  typename enable_if<
                      is_convertible<const _Rep2 &, rep>::value &&
                      (treat_as_floating_point<rep>::value ||
                       !treat_as_floating_point<_Rep2>::value)>::type * = __nullptr)
    : __rep_(__r)
{
}
template <class _Rep2, class _Period2>

duration(const duration<_Rep2, _Period2> &__d,
         typename enable_if<
             __no_overflow<_Period2, period>::value && (treat_as_floating_point<rep>::value ||
                                                        (__no_overflow<_Period2, period>::type::den == 1 &&
                                                         !treat_as_floating_point<_Rep2>::value))>::type * = __nullptr)
    : __rep_(chrono::duration_cast<duration>(__d).count())
{
}
const { return __rep_; };
};
}
{
++__rep_;
return *this;
};
}
{
--__rep_;
return *this;
};
}
;
return *this;
}
;
return *this;
}
{
__rep_ *= __rhs;
return *this;
}
{
__rep_ /= __rhs;
return *this;
}
{
__rep_ %= __rhs;
return *this;
};
return *this;
}
;
}
;
}
;
}
}
;
typedef duration<long long, nano> nanoseconds;
typedef duration<long long, micro> microseconds;
typedef duration<long long, milli> milliseconds;
typedef duration<long long> seconds;
typedef duration<long, ratio<60>> minutes;
typedef duration<long, ratio<3600>> hours;
template <class _LhsDuration, class _RhsDuration>
struct __duration_eq
{

bool operator()(const _LhsDuration &__lhs, const _RhsDuration &__rhs) const
{
typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
return _Ct(__lhs).count() == _Ct(__rhs).count();
}
};
template <class _LhsDuration>
struct __duration_eq<_LhsDuration, _LhsDuration>
{

bool operator()(const _LhsDuration &__lhs, const _LhsDuration &__rhs) const
{
return __lhs.count() == __rhs.count();
}
};
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline bool
operator==(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs)
{
return __duration_eq<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>()(__lhs, __rhs);
}
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline bool
operator!=(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs)
{
return !(__lhs == __rhs);
}
template <class _LhsDuration, class _RhsDuration>
struct __duration_lt
{

bool operator()(const _LhsDuration &__lhs, const _RhsDuration &__rhs) const
{
typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
return _Ct(__lhs).count() < _Ct(__rhs).count();
}
};
template <class _LhsDuration>
struct __duration_lt<_LhsDuration, _LhsDuration>
{

bool operator()(const _LhsDuration &__lhs, const _LhsDuration &__rhs) const
{
return __lhs.count() < __rhs.count();
}
};
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline bool
operator<(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs)
{
return __duration_lt<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>()(__lhs, __rhs);
}
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline bool
operator>(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs)
{
return __rhs < __lhs;
}
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline bool
operator<=(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs)
{
return !(__rhs < __lhs);
}
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline bool
operator>=(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs)
{
return !(__lhs < __rhs);
}
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline
    typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>::type
    operator+(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs)
{
typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>::type _Cd;
return _Cd(_Cd(__lhs).count() + _Cd(__rhs).count());
}
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline
    typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>::type
    operator-(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs)
{
typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>::type _Cd;
return _Cd(_Cd(__lhs).count() - _Cd(__rhs).count());
}
template <class _Rep1, class _Period, class _Rep2>
inline
    typename enable_if<
        is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
        duration<typename common_type<_Rep1, _Rep2>::type, _Period>>::type
    operator*(const duration<_Rep1, _Period> &__d, const _Rep2 &__s)
{
typedef typename common_type<_Rep1, _Rep2>::type _Cr;
typedef duration<_Cr, _Period> _Cd;
return _Cd(_Cd(__d).count() * static_cast<_Cr>(__s));
}
template <class _Rep1, class _Period, class _Rep2>
inline
    typename enable_if<
        is_convertible<_Rep1, typename common_type<_Rep1, _Rep2>::type>::value,
        duration<typename common_type<_Rep1, _Rep2>::type, _Period>>::type
    operator*(const _Rep1 &__s, const duration<_Rep2, _Period> &__d)
{
return __d * __s;
}
template <class _Rep1, class _Period, class _Rep2>
inline
    typename enable_if<
        !__is_duration<_Rep2>::value &&
            is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
        duration<typename common_type<_Rep1, _Rep2>::type, _Period>>::type
    operator/(const duration<_Rep1, _Period> &__d, const _Rep2 &__s)
{
typedef typename common_type<_Rep1, _Rep2>::type _Cr;
typedef duration<_Cr, _Period> _Cd;
return _Cd(_Cd(__d).count() / static_cast<_Cr>(__s));
}
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline
    typename common_type<_Rep1, _Rep2>::type
    operator/(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs)
{
typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>::type _Ct;
return _Ct(__lhs).count() / _Ct(__rhs).count();
}
template <class _Rep1, class _Period, class _Rep2>
inline
    typename enable_if<
        !__is_duration<_Rep2>::value &&
            is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
        duration<typename common_type<_Rep1, _Rep2>::type, _Period>>::type
    operator%(const duration<_Rep1, _Period> &__d, const _Rep2 &__s)
{
typedef typename common_type<_Rep1, _Rep2>::type _Cr;
typedef duration<_Cr, _Period> _Cd;
return _Cd(_Cd(__d).count() % static_cast<_Cr>(__s));
}
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline
    typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>::type
    operator%(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs)
{
typedef typename common_type<_Rep1, _Rep2>::type _Cr;
typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>::type _Cd;
return _Cd(static_cast<_Cr>(_Cd(__lhs).count()) % static_cast<_Cr>(_Cd(__rhs).count()));
}
}
}
}

namespace std
{
inline namespace __1
{
namespace chrono
{
                template <class _Clock, class _Duration = typename _Clock::duration>
                class time_point
                {
                    _Static_assert(__is_duration<_Duration>::value, "Second template parameter of time_point must be a std::chrono::duration");

                public:
                    typedef _Clock clock;
                    typedef _Duration duration;
                    typedef typename duration::rep rep;
                    typedef typename duration::period period;

                private:
                    duration __d_;

                public:
                    {} {
                    }
                    template <class _Duration2>

                    time_point(const time_point<clock, _Duration2> &__t,
                               typename enable_if<
                                   is_convertible<_Duration2, duration>::value>::type * = __nullptr)
                        : __d_(__t.time_since_epoch())
                    {
                    }
                    const { return __d_; }
                    {
                        __d_ += __d;
                        return *this;
                    }
                    {
                        __d_ -= __d;
                        return *this;
                    };
                };
}
};
}
template <class _Clock, class _Duration1, class _Duration2>
struct common_type<chrono::time_point<_Clock, _Duration1>,
                   chrono::time_point<_Clock, _Duration2>>
{
typedef chrono::time_point<_Clock, typename common_type<_Duration1, _Duration2>::type> type;
};
namespace chrono
{
template <class _ToDuration, class _Clock, class _Duration>
inline time_point<_Clock, _ToDuration>
time_point_cast(const time_point<_Clock, _Duration> &__t)
{
return time_point<_Clock, _ToDuration>(chrono::duration_cast<_ToDuration>(__t.time_since_epoch()));
}
template <class _Clock, class _Duration1, class _Duration2>
inline bool
operator==(const time_point<_Clock, _Duration1> &__lhs, const time_point<_Clock, _Duration2> &__rhs)
{
return __lhs.time_since_epoch() == __rhs.time_since_epoch();
}
template <class _Clock, class _Duration1, class _Duration2>
inline bool
operator!=(const time_point<_Clock, _Duration1> &__lhs, const time_point<_Clock, _Duration2> &__rhs)
{
return !(__lhs == __rhs);
}
template <class _Clock, class _Duration1, class _Duration2>
inline bool
operator<(const time_point<_Clock, _Duration1> &__lhs, const time_point<_Clock, _Duration2> &__rhs)
{
return __lhs.time_since_epoch() < __rhs.time_since_epoch();
}
template <class _Clock, class _Duration1, class _Duration2>
inline bool
operator>(const time_point<_Clock, _Duration1> &__lhs, const time_point<_Clock, _Duration2> &__rhs)
{
return __rhs < __lhs;
}
template <class _Clock, class _Duration1, class _Duration2>
inline bool
operator<=(const time_point<_Clock, _Duration1> &__lhs, const time_point<_Clock, _Duration2> &__rhs)
{
return !(__rhs < __lhs);
}
template <class _Clock, class _Duration1, class _Duration2>
inline bool
operator>=(const time_point<_Clock, _Duration1> &__lhs, const time_point<_Clock, _Duration2> &__rhs)
{
return !(__lhs < __rhs);
}
template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2>>::type>
operator+(const time_point<_Clock, _Duration1> &__lhs, const duration<_Rep2, _Period2> &__rhs)
{
typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2>>::type> _Tr;
return _Tr(__lhs.time_since_epoch() + __rhs);
}
template <class _Rep1, class _Period1, class _Clock, class _Duration2>
inline time_point<_Clock, typename common_type<duration<_Rep1, _Period1>, _Duration2>::type>
operator+(const duration<_Rep1, _Period1> &__lhs, const time_point<_Clock, _Duration2> &__rhs)
{
return __rhs + __lhs;
}
template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2>>::type>
operator-(const time_point<_Clock, _Duration1> &__lhs, const duration<_Rep2, _Period2> &__rhs)
{
typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2>>::type> _Ret;
return _Ret(__lhs.time_since_epoch() - __rhs);
}
template <class _Clock, class _Duration1, class _Duration2>
inline
    typename common_type<_Duration1, _Duration2>::type
    operator-(const time_point<_Clock, _Duration1> &__lhs, const time_point<_Clock, _Duration2> &__rhs)
{
return __lhs.time_since_epoch() - __rhs.time_since_epoch();
}
}
}
}
namespace std
{
inline namespace __1
{
namespace chrono
{
                class steady_clock
                {
                public:
                    typedef nanoseconds duration;
                    typedef duration::rep rep;
                    typedef duration::period period;
                    typedef chrono::time_point<steady_clock, duration> time_point;
                    static const bool is_steady = true;
                    static time_point now() throw();
                };
}
}
}
namespace std
{
inline namespace __1
{
using ::asctime;
using ::clock;
using ::clock_t;
using ::ctime;
using ::difftime;
using ::gmtime;
using ::localtime;
using ::mktime;
using ::size_t;
using ::strftime;
using ::time;
using ::time_t;
using ::tm;
}
}
namespace std
{
inline namespace __1
{
namespace chrono
{
                class system_clock
                {
                public:
                    typedef microseconds duration;
                    typedef duration::rep rep;
                    typedef duration::period period;
                    typedef chrono::time_point<system_clock> time_point;
                    static const bool is_steady = false;
                    static time_point now() throw();
                    static time_t to_time_t(const time_point &__t) throw();
                    static time_point from_time_t(time_t __t) throw();
                };
}
}
}
namespace std
{
inline namespace __1
{
namespace chrono
{
                typedef steady_clock high_resolution_clock;
}
}
}
namespace std
{
inline namespace __1
{
static const int __libcpp_polling_count = 64;
template <class _Fn, class _BFn>

bool __libcpp_thread_poll_with_backoff(_Fn &&__f, _BFn &&__bf, chrono::nanoseconds __max_elapsed = chrono::nanoseconds::zero())
{
                auto const __start = chrono::high_resolution_clock::now();
                for (int __count = 0;;)
                {
                    if (__f())
                        return true;
                    if (__count < __libcpp_polling_count)
                    {
                        __count += 1;
                        continue;
                    }
                    chrono::nanoseconds const __elapsed = chrono::high_resolution_clock::now() - __start;
                    if (__max_elapsed != chrono::nanoseconds::zero() && __max_elapsed < __elapsed)
                        return false;
                    if (__bf(__elapsed))
                        return false;
                }
}
struct __spinning_backoff_policy
{

                bool operator()(chrono::nanoseconds const &) const
                {
                    return false;
                }
};
}
}

namespace std
{
inline namespace __1
{
template <class _TimeSpec>
inline _TimeSpec __convert_to_timespec(const chrono::nanoseconds &__ns)
{
                using namespace chrono;
                seconds __s = duration_cast<seconds>(__ns);
                _TimeSpec __ts;
                typedef __decltype(__ts.tv_sec) __ts_sec;
                const __ts_sec __ts_sec_max = numeric_limits<__ts_sec>::max();
                if (__s.count() < __ts_sec_max)
                {
                    __ts.tv_sec = static_cast<__ts_sec>(__s.count());
                    __ts.tv_nsec = static_cast<__decltype(__ts.tv_nsec)>((__ns - __s).count());
                }
                else
                {
                    __ts.tv_sec = __ts_sec_max;
                    __ts.tv_nsec = 999999999;
                }
                return __ts;
}
}
}
extern "C"
{
extern int *__error(void);
}
#pragma clang assume_nonnull begin
#pragma clang assume_nonnull end

extern "C"
{
struct sched_param
{
int sched_priority;
char __opaque[4];
};
extern int sched_yield(void);
extern int sched_get_priority_min(int);
extern int sched_get_priority_max(int);
}
typedef __darwin_pthread_cond_t pthread_cond_t;
typedef __darwin_pthread_condattr_t pthread_condattr_t;
typedef __darwin_pthread_key_t pthread_key_t;
typedef __darwin_pthread_mutex_t pthread_mutex_t;
typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;
typedef __darwin_pthread_once_t pthread_once_t;
typedef __darwin_pthread_rwlock_t pthread_rwlock_t;
typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;
typedef __darwin_pthread_t pthread_t;

enum
{
    QOS_CLASS_USER_INTERACTIVE = 0x00,
};
typedef unsigned int qos_class_t;
extern "C"
{

qos_class_t
qos_class_self(void);

qos_class_t
qos_class_main(void);
}
#pragma clang assume_nonnull begin
extern "C"
{

int pthread_attr_set_qos_class_np(pthread_attr_t *__attr,
                                  qos_class_t __qos_class, int __relative_priority);

int pthread_attr_get_qos_class_np(pthread_attr_t *__attr,
                                  qos_class_t *_Nullable __qos_class,
                                  int *_Nullable __relative_priority);

int pthread_set_qos_class_self_np(qos_class_t __qos_class,
                                  int __relative_priority);

int pthread_get_qos_class_np(pthread_t __pthread,
                             qos_class_t *_Nullable __qos_class,
                             int *_Nullable __relative_priority);
typedef struct pthread_override_s *pthread_override_t;

pthread_override_t
pthread_override_qos_class_start_np(pthread_t __pthread,
                                    qos_class_t __qos_class, int __relative_priority);

int pthread_override_qos_class_end_np(pthread_override_t __override);
}
#pragma clang assume_nonnull end
typedef __darwin_mach_port_t mach_port_t;
#pragma clang assume_nonnull begin
extern "C"
{

int pthread_atfork(void (*_Nullable)(void), void (*_Nullable)(void),
                   void (*_Nullable)(void));

int pthread_attr_destroy(pthread_attr_t *);

int pthread_attr_getdetachstate(const pthread_attr_t *, int *);

int pthread_attr_getguardsize(const pthread_attr_t *, size_t *);

int pthread_attr_getinheritsched(const pthread_attr_t *, int *);

int pthread_attr_getschedparam(const pthread_attr_t *,
                               struct sched_param *);

int pthread_attr_getschedpolicy(const pthread_attr_t *, int *);

int pthread_attr_getscope(const pthread_attr_t *, int *);

int pthread_attr_getstack(const pthread_attr_t *,
                          void *_Nullable *_Nonnull, size_t *);

int pthread_attr_getstackaddr(const pthread_attr_t *,
                              void *_Nullable *_Nonnull);

int pthread_attr_getstacksize(const pthread_attr_t *, size_t *);

int pthread_attr_init(pthread_attr_t *);

int pthread_attr_setdetachstate(pthread_attr_t *, int);

int pthread_attr_setguardsize(pthread_attr_t *, size_t);

int pthread_attr_setinheritsched(pthread_attr_t *, int);

int pthread_attr_setschedparam(pthread_attr_t *,
                               const struct sched_param *);

int pthread_attr_setschedpolicy(pthread_attr_t *, int);

int pthread_attr_setscope(pthread_attr_t *, int);

int pthread_attr_setstack(pthread_attr_t *, void *, size_t);

int pthread_attr_setstackaddr(pthread_attr_t *, void *);

int pthread_attr_setstacksize(pthread_attr_t *, size_t);

int pthread_cancel(pthread_t) __asm("_"
                                    "pthread_cancel");

int pthread_cond_broadcast(pthread_cond_t *);

int pthread_cond_destroy(pthread_cond_t *);

int pthread_cond_init(
    pthread_cond_t *,
    const pthread_condattr_t *_Nullable) __asm("_"
                                               "pthread_cond_init");

int pthread_cond_signal(pthread_cond_t *);

int pthread_cond_timedwait(
    pthread_cond_t *, pthread_mutex_t *,
    const struct timespec *_Nullable) __asm("_"
                                            "pthread_cond_timedwait");

int pthread_cond_wait(pthread_cond_t *,
                      pthread_mutex_t *) __asm("_"
                                               "pthread_cond_wait");

int pthread_condattr_destroy(pthread_condattr_t *);

int pthread_condattr_init(pthread_condattr_t *);

int pthread_condattr_getpshared(const pthread_condattr_t *,
                                int *);

int pthread_condattr_setpshared(pthread_condattr_t *, int);

int pthread_create(pthread_t _Nullable *_Nonnull,
                   const pthread_attr_t *_Nullable,
                   void *_Nullable (*_Nonnull)(void *_Nullable),
                   void *_Nullable);

int pthread_detach(pthread_t);

int pthread_equal(pthread_t _Nullable, pthread_t _Nullable);

void pthread_exit(void *_Nullable);

int pthread_getconcurrency(void);

int pthread_getschedparam(pthread_t, int *_Nullable,
                          struct sched_param *_Nullable);

void *_Nullable pthread_getspecific(pthread_key_t);

int pthread_join(pthread_t, void *_Nullable *_Nullable) __asm("_"
                                                              "pthread_join");

int pthread_key_create(pthread_key_t *, void (*_Nullable)(void *));

int pthread_key_delete(pthread_key_t);

int pthread_mutex_destroy(pthread_mutex_t *);

int pthread_mutex_getprioceiling(const pthread_mutex_t *,
                                 int *);

int pthread_mutex_init(pthread_mutex_t *,
                       const pthread_mutexattr_t *_Nullable);

int pthread_mutex_lock(pthread_mutex_t *);

int pthread_mutex_setprioceiling(pthread_mutex_t *, int,
                                 int *);

int pthread_mutex_trylock(pthread_mutex_t *);

int pthread_mutex_unlock(pthread_mutex_t *);

int pthread_mutexattr_destroy(pthread_mutexattr_t *) __asm("_"
                                                           "pthread_mutexattr_destroy");

int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *,
                                     int *);

int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *,
                                  int *);

int pthread_mutexattr_getpshared(const pthread_mutexattr_t *,
                                 int *);

int pthread_mutexattr_gettype(const pthread_mutexattr_t *,
                              int *);

int pthread_mutexattr_getpolicy_np(const pthread_mutexattr_t *,
                                   int *);

int pthread_mutexattr_init(pthread_mutexattr_t *);

int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);

int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);

int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);

int pthread_mutexattr_settype(pthread_mutexattr_t *, int);

int pthread_mutexattr_setpolicy_np(pthread_mutexattr_t *, int);

int pthread_once(pthread_once_t *, void (*_Nonnull)(void));

int pthread_rwlock_destroy(pthread_rwlock_t *) __asm("_"
                                                     "pthread_rwlock_destroy");

int pthread_rwlock_init(pthread_rwlock_t *,
                        const pthread_rwlockattr_t *_Nullable) __asm("_"
                                                                     "pthread_rwlock_init");

int pthread_rwlock_rdlock(pthread_rwlock_t *) __asm("_"
                                                    "pthread_rwlock_rdlock");

int pthread_rwlock_tryrdlock(pthread_rwlock_t *) __asm("_"
                                                       "pthread_rwlock_tryrdlock");

int pthread_rwlock_trywrlock(pthread_rwlock_t *) __asm("_"
                                                       "pthread_rwlock_trywrlock");

int pthread_rwlock_wrlock(pthread_rwlock_t *) __asm("_"
                                                    "pthread_rwlock_wrlock");

int pthread_rwlock_unlock(pthread_rwlock_t *) __asm("_"
                                                    "pthread_rwlock_unlock");

int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);

int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *,
                                  int *);

int pthread_rwlockattr_init(pthread_rwlockattr_t *);

int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);

pthread_t pthread_self(void);

int pthread_setcancelstate(int, int *_Nullable) __asm("_"
                                                      "pthread_setcancelstate");

int pthread_setcanceltype(int, int *_Nullable) __asm("_"
                                                     "pthread_setcanceltype");

int pthread_setconcurrency(int);

int pthread_setschedparam(pthread_t, int, const struct sched_param *);

int pthread_setspecific(pthread_key_t, const void *_Nullable);

void pthread_testcancel(void) __asm("_"
                                    "pthread_testcancel");

int pthread_is_threaded_np(void);

int pthread_threadid_np(pthread_t _Nullable, __uint64_t *_Nullable);

int pthread_getname_np(pthread_t, char *, size_t);

int pthread_setname_np(const char *);

int pthread_main_np(void);

mach_port_t pthread_mach_thread_np(pthread_t);

size_t pthread_get_stacksize_np(pthread_t);

void *pthread_get_stackaddr_np(pthread_t);

int pthread_cond_signal_thread_np(pthread_cond_t *, pthread_t _Nullable);

int pthread_cond_timedwait_relative_np(pthread_cond_t *, pthread_mutex_t *,
                                       const struct timespec *_Nullable);

int pthread_create_suspended_np(
    pthread_t _Nullable *_Nonnull, const pthread_attr_t *_Nullable,
    void *_Nullable (*_Nonnull)(void *_Nullable), void *_Nullable);

int pthread_kill(pthread_t, int);

_Nullable pthread_t pthread_from_mach_thread_np(mach_port_t);

int pthread_sigmask(int, const sigset_t *_Nullable, sigset_t *_Nullable) __asm("_"
                                                                               "pthread_sigmask");

void pthread_yield_np(void);

void pthread_jit_write_protect_np(int enabled);

int pthread_jit_write_protect_supported_np(void);
typedef int (*pthread_jit_write_callback_t)(void *_Nullable ctx);

int pthread_jit_write_with_callback_np(
    pthread_jit_write_callback_t _Nonnull callback, void *_Nullable ctx);

void pthread_jit_write_freeze_callbacks_np(void);

int pthread_cpu_number_np(size_t *cpu_number_out);
}
#pragma clang assume_nonnull end
typedef ::timespec __libcpp_timespec_t;
namespace std
{
inline namespace __1
{
typedef pthread_mutex_t __libcpp_mutex_t;
typedef pthread_mutex_t __libcpp_recursive_mutex_t;
typedef pthread_cond_t __libcpp_condvar_t;
typedef pthread_once_t __libcpp_exec_once_flag;
typedef pthread_t __libcpp_thread_id;
typedef pthread_t __libcpp_thread_t;
typedef pthread_key_t __libcpp_tls_key;
inline int __libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t *__m);
inline int __libcpp_recursive_mutex_lock(__libcpp_recursive_mutex_t *__m);
inline bool __libcpp_recursive_mutex_trylock(__libcpp_recursive_mutex_t *__m);
inline int __libcpp_recursive_mutex_unlock(__libcpp_recursive_mutex_t *__m);
inline int __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m);
inline int __libcpp_mutex_lock(__libcpp_mutex_t *__m);
inline bool __libcpp_mutex_trylock(__libcpp_mutex_t *__m);
inline int __libcpp_mutex_unlock(__libcpp_mutex_t *__m);
inline int __libcpp_mutex_destroy(__libcpp_mutex_t *__m);
inline int __libcpp_condvar_signal(__libcpp_condvar_t *__cv);
inline int __libcpp_condvar_broadcast(__libcpp_condvar_t *__cv);
inline int __libcpp_condvar_wait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m);
inline int __libcpp_condvar_timedwait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m,
                                      __libcpp_timespec_t *__ts);
inline int __libcpp_condvar_destroy(__libcpp_condvar_t *__cv);
inline int __libcpp_execute_once(__libcpp_exec_once_flag *__flag,
                                 void (*__init_routine)());
inline bool __libcpp_thread_id_equal(__libcpp_thread_id __t1, __libcpp_thread_id __t2);
inline bool __libcpp_thread_id_less(__libcpp_thread_id __t1, __libcpp_thread_id __t2);
inline bool __libcpp_thread_isnull(const __libcpp_thread_t *__t);
inline int __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
                                  void *__arg);
inline __libcpp_thread_id __libcpp_thread_get_current_id();
inline __libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t);
inline int __libcpp_thread_join(__libcpp_thread_t *__t);
inline int __libcpp_thread_detach(__libcpp_thread_t *__t);
inline void __libcpp_thread_yield();
inline void __libcpp_thread_sleep_for(const chrono::nanoseconds &__ns);
inline int __libcpp_tls_create(__libcpp_tls_key *__key,
                               void (*__at_exit)(void *));
inline void *__libcpp_tls_get(__libcpp_tls_key __key);
inline int __libcpp_tls_set(__libcpp_tls_key __key, void *__p);
int __libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t *__m)
{
                pthread_mutexattr_t attr;
                int __ec = pthread_mutexattr_init(&attr);
                if (__ec)
                    return __ec;
                __ec = pthread_mutexattr_settype(&attr, 2);
                if (__ec)
                {
                    pthread_mutexattr_destroy(&attr);
                    return __ec;
                }
                __ec = pthread_mutex_init(__m, &attr);
                if (__ec)
                {
                    pthread_mutexattr_destroy(&attr);
                    return __ec;
                }
                __ec = pthread_mutexattr_destroy(&attr);
                if (__ec)
                {
                    pthread_mutex_destroy(__m);
                    return __ec;
                }
                return 0;
}
int __libcpp_recursive_mutex_lock(__libcpp_recursive_mutex_t *__m)
{
                return pthread_mutex_lock(__m);
}
bool __libcpp_recursive_mutex_trylock(__libcpp_recursive_mutex_t *__m)
{
                return pthread_mutex_trylock(__m) == 0;
}
int __libcpp_recursive_mutex_unlock(__libcpp_recursive_mutex_t *__m)
{
                return pthread_mutex_unlock(__m);
}
int __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m)
{
                return pthread_mutex_destroy(__m);
}
int __libcpp_mutex_lock(__libcpp_mutex_t *__m)
{
                return pthread_mutex_lock(__m);
}
bool __libcpp_mutex_trylock(__libcpp_mutex_t *__m)
{
                return pthread_mutex_trylock(__m) == 0;
}
int __libcpp_mutex_unlock(__libcpp_mutex_t *__m)
{
                return pthread_mutex_unlock(__m);
}
int __libcpp_mutex_destroy(__libcpp_mutex_t *__m)
{
                return pthread_mutex_destroy(__m);
}
int __libcpp_condvar_signal(__libcpp_condvar_t *__cv)
{
                return pthread_cond_signal(__cv);
}
int __libcpp_condvar_broadcast(__libcpp_condvar_t *__cv)
{
                return pthread_cond_broadcast(__cv);
}
int __libcpp_condvar_wait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m)
{
                return pthread_cond_wait(__cv, __m);
}
int __libcpp_condvar_timedwait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m,
                               __libcpp_timespec_t *__ts)
{
                return pthread_cond_timedwait(__cv, __m, __ts);
}
int __libcpp_condvar_destroy(__libcpp_condvar_t *__cv)
{
                return pthread_cond_destroy(__cv);
}
int __libcpp_execute_once(__libcpp_exec_once_flag *__flag,
                          void (*__init_routine)())
{
                return pthread_once(__flag, __init_routine);
}
bool __libcpp_thread_id_equal(__libcpp_thread_id __t1, __libcpp_thread_id __t2)
{
                return __t1 == __t2;
}
bool __libcpp_thread_id_less(__libcpp_thread_id __t1, __libcpp_thread_id __t2)
{
                return __t1 < __t2;
}
bool __libcpp_thread_isnull(const __libcpp_thread_t *__t)
{
                return __libcpp_thread_get_id(__t) == 0;
}
int __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
                           void *__arg)
{
                return pthread_create(__t, __nullptr, __func, __arg);
}
__libcpp_thread_id __libcpp_thread_get_current_id()
{
                const __libcpp_thread_t thread = pthread_self();
                return __libcpp_thread_get_id(&thread);
}
__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t)
{
                return *__t;
}
int __libcpp_thread_join(__libcpp_thread_t *__t)
{
                return pthread_join(*__t, __nullptr);
}
int __libcpp_thread_detach(__libcpp_thread_t *__t)
{
                return pthread_detach(*__t);
}
void __libcpp_thread_yield()
{
                sched_yield();
}
void __libcpp_thread_sleep_for(const chrono::nanoseconds &__ns)
{
                __libcpp_timespec_t __ts = std::__convert_to_timespec<__libcpp_timespec_t>(__ns);
                while (nanosleep(&__ts, &__ts) == -1 && (*__error()) == 4)
                    ;
}
int __libcpp_tls_create(__libcpp_tls_key *__key, void (*__at_exit)(void *))
{
                return pthread_key_create(__key, __at_exit);
}
void *__libcpp_tls_get(__libcpp_tls_key __key)
{
                return pthread_getspecific(__key);
}
int __libcpp_tls_set(__libcpp_tls_key __key, void *__p)
{
                return pthread_setspecific(__key, __p);
}
class thread;
class __thread_id;
namespace this_thread
{
                ;
}
template <>
struct hash<__thread_id>;
class __thread_id
{
                __libcpp_thread_id __id_;

            public:
                __thread_id() throw() : __id_(0) {}
                friend bool operator==(__thread_id __x, __thread_id __y) throw()
                {
                    if (__x.__id_ == 0)
                        return __y.__id_ == 0;
                    if (__y.__id_ == 0)
                        return false;
                    return __libcpp_thread_id_equal(__x.__id_, __y.__id_);
                }
                friend bool operator!=(__thread_id __x, __thread_id __y) throw()
                {
                    return !(__x == __y);
                }
                friend bool operator<(__thread_id __x, __thread_id __y) throw()
                {
                    if (__x.__id_ == 0)
                        return __y.__id_ != 0;
                    if (__y.__id_ == 0)
                        return false;
                    return __libcpp_thread_id_less(__x.__id_, __y.__id_);
                }
                friend bool operator<=(__thread_id __x, __thread_id __y) throw()
                {
                    return !(__y < __x);
                }
                friend bool operator>(__thread_id __x, __thread_id __y) throw()
                {
                    return __y < __x;
                }
                friend bool operator>=(__thread_id __x, __thread_id __y) throw()
                {
                    return !(__x < __y);
                }

                void __reset() { __id_ = 0; }
                template <class _CharT, class _Traits>
                friend

                    basic_ostream<_CharT, _Traits> &
                    operator<<(basic_ostream<_CharT, _Traits> &__os, __thread_id __id);

            private:
                __thread_id(__libcpp_thread_id __id) : __id_(__id) {}
                friend __thread_id this_thread::get_id() throw();
                friend class thread;
                friend struct hash<__thread_id>;
};
namespace this_thread
{
                inline __thread_id
                get_id() throw()
                {
                    return __libcpp_thread_get_current_id();
                }
}
}
}
namespace std
{
inline namespace __1
{
struct __libcpp_timed_backoff_policy
{

                bool operator()(chrono::nanoseconds __elapsed) const
                {
                    if (__elapsed > chrono::milliseconds(128))
                        __libcpp_thread_sleep_for(chrono::milliseconds(8));
                    else if (__elapsed > chrono::microseconds(64))
                        __libcpp_thread_sleep_for(__elapsed / 2);
                    else if (__elapsed > chrono::microseconds(4))
                        __libcpp_thread_yield();
                    else
                    {
                    }
                    return false;
                }
};
}
}

namespace std
{
inline namespace __1
{
enum __legacy_memory_order
{
    __mo_relaxed,
    __mo_consume,
    __mo_acquire,
    __mo_release,
    __mo_acq_rel,
    __mo_seq_cst
};
typedef underlying_type<__legacy_memory_order>::type __memory_order_underlying_t;
typedef enum memory_order
{
    memory_order_relaxed = __mo_relaxed,
    memory_order_consume = __mo_consume,
    memory_order_acquire = __mo_acquire,
    memory_order_release = __mo_release,
    memory_order_acq_rel = __mo_acq_rel,
    memory_order_seq_cst = __mo_seq_cst,
} memory_order;
template <typename _Tp>
bool __cxx_nonatomic_compare_equal(_Tp const &__lhs, _Tp const &__rhs)
{
                return std::memcmp(&__lhs, &__rhs, sizeof(_Tp)) == 0;
}
_Static_assert((is_same<underlying_type<memory_order>::type, __memory_order_underlying_t>::value), "unexpected underlying type for std::memory_order");
template <typename _Tp>
struct __cxx_atomic_base_impl
{

                __cxx_atomic_base_impl() throw() : __a_value() {}
                explicit __cxx_atomic_base_impl(_Tp __value) throw()
                    : __a_value(__value) {}
                __extension__ _Atomic(_Tp) __a_value;
};
inline void __cxx_atomic_thread_fence(memory_order __order) throw()
{
                __c11_atomic_thread_fence(static_cast<__memory_order_underlying_t>(__order));
}
inline void __cxx_atomic_signal_fence(memory_order __order) throw()
{
                __c11_atomic_signal_fence(static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>

void __cxx_atomic_init(__cxx_atomic_base_impl<_Tp> volatile *__a, _Tp __val) throw()
{
                __c11_atomic_init(&__a->__a_value, __val);
}
template <class _Tp>

void __cxx_atomic_init(__cxx_atomic_base_impl<_Tp> *__a, _Tp __val) throw()
{
                __c11_atomic_init(&__a->__a_value, __val);
}
template <class _Tp>

void __cxx_atomic_store(__cxx_atomic_base_impl<_Tp> volatile *__a, _Tp __val, memory_order __order) throw()
{
                __c11_atomic_store(&__a->__a_value, __val, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>

void __cxx_atomic_store(__cxx_atomic_base_impl<_Tp> *__a, _Tp __val, memory_order __order) throw()
{
                __c11_atomic_store(&__a->__a_value, __val, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>

_Tp __cxx_atomic_load(__cxx_atomic_base_impl<_Tp> const volatile *__a, memory_order __order) throw()
{
                using __ptr_type = typename remove_const<__decltype(__a->__a_value)>::type *;
                return __c11_atomic_load(const_cast<__ptr_type>(&__a->__a_value), static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>

_Tp __cxx_atomic_load(__cxx_atomic_base_impl<_Tp> const *__a, memory_order __order) throw()
{
                using __ptr_type = typename remove_const<__decltype(__a->__a_value)>::type *;
                return __c11_atomic_load(const_cast<__ptr_type>(&__a->__a_value), static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>

_Tp __cxx_atomic_exchange(__cxx_atomic_base_impl<_Tp> volatile *__a, _Tp __value, memory_order __order) throw()
{
                return __c11_atomic_exchange(&__a->__a_value, __value, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>

_Tp __cxx_atomic_exchange(__cxx_atomic_base_impl<_Tp> *__a, _Tp __value, memory_order __order) throw()
{
                return __c11_atomic_exchange(&__a->__a_value, __value, static_cast<__memory_order_underlying_t>(__order));
}
{
                return __order == memory_order_release ? memory_order_relaxed : (__order == memory_order_acq_rel ? memory_order_acquire : __order);
}
template <class _Tp>

bool __cxx_atomic_compare_exchange_strong(__cxx_atomic_base_impl<_Tp> volatile *__a, _Tp *__expected, _Tp __value, memory_order __success, memory_order __failure) throw()
{
                return __c11_atomic_compare_exchange_strong(&__a->__a_value, __expected, __value, static_cast<__memory_order_underlying_t>(__success), static_cast<__memory_order_underlying_t>(__to_failure_order(__failure)));
}
template <class _Tp>

bool __cxx_atomic_compare_exchange_strong(__cxx_atomic_base_impl<_Tp> *__a, _Tp *__expected, _Tp __value, memory_order __success, memory_order __failure) throw()
{
                return __c11_atomic_compare_exchange_strong(&__a->__a_value, __expected, __value, static_cast<__memory_order_underlying_t>(__success), static_cast<__memory_order_underlying_t>(__to_failure_order(__failure)));
}
template <class _Tp>

bool __cxx_atomic_compare_exchange_weak(__cxx_atomic_base_impl<_Tp> volatile *__a, _Tp *__expected, _Tp __value, memory_order __success, memory_order __failure) throw()
{
                return __c11_atomic_compare_exchange_weak(&__a->__a_value, __expected, __value, static_cast<__memory_order_underlying_t>(__success), static_cast<__memory_order_underlying_t>(__to_failure_order(__failure)));
}
template <class _Tp>

bool __cxx_atomic_compare_exchange_weak(__cxx_atomic_base_impl<_Tp> *__a, _Tp *__expected, _Tp __value, memory_order __success, memory_order __failure) throw()
{
                return __c11_atomic_compare_exchange_weak(&__a->__a_value, __expected, __value, static_cast<__memory_order_underlying_t>(__success), static_cast<__memory_order_underlying_t>(__to_failure_order(__failure)));
}
template <class _Tp>

_Tp __cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp> volatile *__a, _Tp __delta, memory_order __order) throw()
{
                return __c11_atomic_fetch_add(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>

_Tp __cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp> *__a, _Tp __delta, memory_order __order) throw()
{
                return __c11_atomic_fetch_add(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>

_Tp *__cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp *> volatile *__a, ptrdiff_t __delta, memory_order __order) throw()
{
                return __c11_atomic_fetch_add(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>

_Tp *__cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp *> *__a, ptrdiff_t __delta, memory_order __order) throw()
{
                return __c11_atomic_fetch_add(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>

_Tp __cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp> volatile *__a, _Tp __delta, memory_order __order) throw()
{
                return __c11_atomic_fetch_sub(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>

_Tp __cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp> *__a, _Tp __delta, memory_order __order) throw()
{
                return __c11_atomic_fetch_sub(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>

_Tp *__cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp *> volatile *__a, ptrdiff_t __delta, memory_order __order) throw()
{
                return __c11_atomic_fetch_sub(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>

_Tp *__cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp *> *__a, ptrdiff_t __delta, memory_order __order) throw()
{
                return __c11_atomic_fetch_sub(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>

_Tp __cxx_atomic_fetch_and(__cxx_atomic_base_impl<_Tp> volatile *__a, _Tp __pattern, memory_order __order) throw()
{
                return __c11_atomic_fetch_and(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>

_Tp __cxx_atomic_fetch_and(__cxx_atomic_base_impl<_Tp> *__a, _Tp __pattern, memory_order __order) throw()
{
                return __c11_atomic_fetch_and(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>

_Tp __cxx_atomic_fetch_or(__cxx_atomic_base_impl<_Tp> volatile *__a, _Tp __pattern, memory_order __order) throw()
{
                return __c11_atomic_fetch_or(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>

_Tp __cxx_atomic_fetch_or(__cxx_atomic_base_impl<_Tp> *__a, _Tp __pattern, memory_order __order) throw()
{
                return __c11_atomic_fetch_or(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>

_Tp __cxx_atomic_fetch_xor(__cxx_atomic_base_impl<_Tp> volatile *__a, _Tp __pattern, memory_order __order) throw()
{
                return __c11_atomic_fetch_xor(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>

_Tp __cxx_atomic_fetch_xor(__cxx_atomic_base_impl<_Tp> *__a, _Tp __pattern, memory_order __order) throw()
{
                return __c11_atomic_fetch_xor(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>

_Tp kill_dependency(_Tp __y) throw()
{
                return __y;
}
template <class _Tp>
struct __libcpp_is_always_lock_free
{
                static const bool __value = __atomic_always_lock_free(sizeof(_Tp), 0);
};
template <typename _Tp,
          typename _Base = __cxx_atomic_base_impl<_Tp>>
struct __cxx_atomic_impl : public _Base
{
                _Static_assert(is_trivially_copyable<_Tp>::value, "std::atomic<T> requires that 'T' be a trivially copyable type");
                = default;

    : _Base(__value) {}
};
using __cxx_contention_t = int64_t;
using __cxx_atomic_contention_t = __cxx_atomic_impl<__cxx_contention_t>;
;
;
;
;
;
;
;
;
template <class _Atp, class _Fn>
struct __libcpp_atomic_wait_backoff_impl
{
    _Atp *__a;
    _Fn __test_fn;

    const
    {
        if (__elapsed > chrono::microseconds(64))
        {
            auto const __monitor = __libcpp_atomic_monitor(__a);
            if (__test_fn())
                return true;
            __libcpp_atomic_wait(__a, __monitor);
        }
        else if (__elapsed > chrono::microseconds(4))
            __libcpp_thread_yield();
        else
        {
        }
        return false;
    }
};
template <class _Atp, class _Fn>

{
    __libcpp_atomic_wait_backoff_impl<_Atp, typename decay<_Fn>::type> __backoff_fn = {__a, __test_fn};
    return __libcpp_thread_poll_with_backoff(__test_fn, __backoff_fn);
}
template <class _Atp, class _Tp>
struct __cxx_atomic_wait_test_fn_impl
{
    _Atp *__a;
    _Tp __val;
    memory_order __order;
    const
    {
        return !__cxx_nonatomic_compare_equal(__cxx_atomic_load(__a, __order), __val);
    }
};
template <class _Atp, class _Tp>

{
    __cxx_atomic_wait_test_fn_impl<_Atp, _Tp> __test_fn = {__a, __val, __order};
    return __cxx_atomic_wait(__a, __test_fn);
}
template <class _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value>
struct __atomic_base
{
    mutable __cxx_atomic_impl<_Tp> __a_;

    bool is_lock_free() const volatile throw()
    {
        return __c11_atomic_is_lock_free(sizeof(_Tp));
    }

    bool is_lock_free() const throw()
    {
        return static_cast<__atomic_base const volatile *>(this)->is_lock_free();
    }

    void store(_Tp __d, memory_order __m = memory_order_seq_cst) volatile throw()

    {
        __cxx_atomic_store(&__a_, __d, __m);
    }

    void store(_Tp __d, memory_order __m = memory_order_seq_cst) throw()

    {
        __cxx_atomic_store(&__a_, __d, __m);
    }

    _Tp load(memory_order __m = memory_order_seq_cst) const volatile throw()

    {
        return __cxx_atomic_load(&__a_, __m);
    }

    _Tp load(memory_order __m = memory_order_seq_cst) const throw()

    {
        return __cxx_atomic_load(&__a_, __m);
    }

    operator _Tp() const volatile throw() { return load(); }

    operator _Tp() const throw() { return load(); }

    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) volatile throw()
    {
        return __cxx_atomic_exchange(&__a_, __d, __m);
    }

    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) throw()
    {
        return __cxx_atomic_exchange(&__a_, __d, __m);
    }

    bool compare_exchange_weak(_Tp &__e, _Tp __d,
                               memory_order __s, memory_order __f) volatile throw()

    {
        return __cxx_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);
    }

    bool compare_exchange_weak(_Tp &__e, _Tp __d,
                               memory_order __s, memory_order __f) throw()

    {
        return __cxx_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);
    }

    bool compare_exchange_strong(_Tp &__e, _Tp __d,
                                 memory_order __s, memory_order __f) volatile throw()

    {
        return __cxx_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);
    }

    bool compare_exchange_strong(_Tp &__e, _Tp __d,
                                 memory_order __s, memory_order __f) throw()

    {
        return __cxx_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);
    }

    bool compare_exchange_weak(_Tp &__e, _Tp __d,
                               memory_order __m = memory_order_seq_cst) volatile throw()
    {
        return __cxx_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);
    }

    bool compare_exchange_weak(_Tp &__e, _Tp __d,
                               memory_order __m = memory_order_seq_cst) throw()
    {
        return __cxx_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);
    }

    bool compare_exchange_strong(_Tp &__e, _Tp __d,
                                 memory_order __m = memory_order_seq_cst) volatile throw()
    {
        return __cxx_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);
    }

    bool compare_exchange_strong(_Tp &__e, _Tp __d,
                                 memory_order __m = memory_order_seq_cst) throw()
    {
        return __cxx_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);
    }

    {
        __cxx_atomic_wait(&__a_, __v, __m);
    }

    {
        __cxx_atomic_wait(&__a_, __v, __m);
    }

    {
        __cxx_atomic_notify_one(&__a_);
    }

    {
        __cxx_atomic_notify_one(&__a_);
    }

    {
        __cxx_atomic_notify_all(&__a_);
    }

    {
        __cxx_atomic_notify_all(&__a_);
    }

    __atomic_base() throw() = default;

    __atomic_base(_Tp __d) throw() : __a_(__d) {}
    __atomic_base(const __atomic_base &) = delete;
};
template <class _Tp>
struct __atomic_base<_Tp, true>
    : public __atomic_base<_Tp, false>
{
    typedef __atomic_base<_Tp, false> __base;

    __atomic_base() throw() = default;

    __atomic_base(_Tp __d) throw() : __base(__d) {}

    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) volatile throw()
    {
        return __cxx_atomic_fetch_add(&this->__a_, __op, __m);
    }

    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) throw()
    {
        return __cxx_atomic_fetch_add(&this->__a_, __op, __m);
    }

    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) volatile throw()
    {
        return __cxx_atomic_fetch_sub(&this->__a_, __op, __m);
    }

    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) throw()
    {
        return __cxx_atomic_fetch_sub(&this->__a_, __op, __m);
    }

    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) volatile throw()
    {
        return __cxx_atomic_fetch_and(&this->__a_, __op, __m);
    }

    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) throw()
    {
        return __cxx_atomic_fetch_and(&this->__a_, __op, __m);
    }

    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) volatile throw()
    {
        return __cxx_atomic_fetch_or(&this->__a_, __op, __m);
    }

    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) throw()
    {
        return __cxx_atomic_fetch_or(&this->__a_, __op, __m);
    }

    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) volatile throw()
    {
        return __cxx_atomic_fetch_xor(&this->__a_, __op, __m);
    }

    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) throw()
    {
        return __cxx_atomic_fetch_xor(&this->__a_, __op, __m);
    }

    _Tp operator++(int) volatile throw() { return fetch_add(_Tp(1)); }

    _Tp operator++(int) throw() { return fetch_add(_Tp(1)); }

    _Tp operator--(int) volatile throw() { return fetch_sub(_Tp(1)); }

    _Tp operator--(int) throw() { return fetch_sub(_Tp(1)); }

    _Tp operator++() volatile throw() { return fetch_add(_Tp(1)) + _Tp(1); }

    _Tp operator++() throw() { return fetch_add(_Tp(1)) + _Tp(1); }

    _Tp operator--() volatile throw() { return fetch_sub(_Tp(1)) - _Tp(1); }

    _Tp operator--() throw() { return fetch_sub(_Tp(1)) - _Tp(1); }

    _Tp operator+=(_Tp __op) volatile throw() { return fetch_add(__op) + __op; }

    _Tp operator+=(_Tp __op) throw() { return fetch_add(__op) + __op; }

    _Tp operator-=(_Tp __op) volatile throw() { return fetch_sub(__op) - __op; }

    _Tp operator-=(_Tp __op) throw() { return fetch_sub(__op) - __op; }

    _Tp operator&=(_Tp __op) volatile throw() { return fetch_and(__op) & __op; }

    _Tp operator&=(_Tp __op) throw() { return fetch_and(__op) & __op; }

    _Tp operator|=(_Tp __op) volatile throw() { return fetch_or(__op) | __op; }

    _Tp operator|=(_Tp __op) throw() { return fetch_or(__op) | __op; }

    _Tp operator^=(_Tp __op) volatile throw() { return fetch_xor(__op) ^ __op; }

    _Tp operator^=(_Tp __op) throw() { return fetch_xor(__op) ^ __op; }
};
template <class _Tp>
struct atomic
    : public __atomic_base<_Tp>
{
    typedef __atomic_base<_Tp> __base;
    typedef _Tp value_type;
    typedef value_type difference_type;

    atomic() throw() = default;

    atomic(_Tp __d) throw() : __base(__d) {}

    _Tp operator=(_Tp __d) volatile throw()
    {
        __base::store(__d);
        return __d;
    }

    _Tp operator=(_Tp __d) throw()
    {
        __base::store(__d);
        return __d;
    }
    atomic &operator=(const atomic &) = delete;
    atomic &operator=(const atomic &) volatile = delete;
};
template <class _Tp>
struct atomic<_Tp *>
    : public __atomic_base<_Tp *>
{
    typedef __atomic_base<_Tp *> __base;
    typedef _Tp *value_type;
    typedef ptrdiff_t difference_type;

    atomic() throw() = default;

    atomic(_Tp *__d) throw() : __base(__d) {}

    _Tp *operator=(_Tp *__d) volatile throw()
    {
        __base::store(__d);
        return __d;
    }

    _Tp *operator=(_Tp *__d) throw()
    {
        __base::store(__d);
        return __d;
    }

    _Tp *fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) volatile throw()
    {
        _Static_assert(!is_function<typename remove_pointer<_Tp>::type>::value, "Pointer to function isn't allowed");
        return __cxx_atomic_fetch_add(&this->__a_, __op, __m);
    }

    _Tp *fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) throw()
    {
        _Static_assert(!is_function<typename remove_pointer<_Tp>::type>::value, "Pointer to function isn't allowed");
        return __cxx_atomic_fetch_add(&this->__a_, __op, __m);
    }

    _Tp *fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) volatile throw()
    {
        _Static_assert(!is_function<typename remove_pointer<_Tp>::type>::value, "Pointer to function isn't allowed");
        return __cxx_atomic_fetch_sub(&this->__a_, __op, __m);
    }

    _Tp *fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) throw()
    {
        _Static_assert(!is_function<typename remove_pointer<_Tp>::type>::value, "Pointer to function isn't allowed");
        return __cxx_atomic_fetch_sub(&this->__a_, __op, __m);
    }

    _Tp *operator++(int) volatile throw() { return fetch_add(1); }

    _Tp *operator++(int) throw() { return fetch_add(1); }

    _Tp *operator--(int) volatile throw() { return fetch_sub(1); }

    _Tp *operator--(int) throw() { return fetch_sub(1); }

    _Tp *operator++() volatile throw() { return fetch_add(1) + 1; }

    _Tp *operator++() throw() { return fetch_add(1) + 1; }

    _Tp *operator--() volatile throw() { return fetch_sub(1) - 1; }

    _Tp *operator--() throw() { return fetch_sub(1) - 1; }

    _Tp *operator+=(ptrdiff_t __op) volatile throw() { return fetch_add(__op) + __op; }

    _Tp *operator+=(ptrdiff_t __op) throw() { return fetch_add(__op) + __op; }

    _Tp *operator-=(ptrdiff_t __op) volatile throw() { return fetch_sub(__op) - __op; }

    _Tp *operator-=(ptrdiff_t __op) throw() { return fetch_sub(__op) - __op; }
    atomic &operator=(const atomic &) = delete;
    atomic &operator=(const atomic &) volatile = delete;
};
template <class _Tp>

bool atomic_is_lock_free(const volatile atomic<_Tp> *__o) throw()
{
    return __o->is_lock_free();
}
template <class _Tp>

bool atomic_is_lock_free(const atomic<_Tp> *__o) throw()
{
    return __o->is_lock_free();
}
template <class _Tp>

void atomic_init(volatile atomic<_Tp> *__o, typename atomic<_Tp>::value_type __d) throw()
{
    __cxx_atomic_init(&__o->__a_, __d);
}
template <class _Tp>

void atomic_init(atomic<_Tp> *__o, typename atomic<_Tp>::value_type __d) throw()
{
    __cxx_atomic_init(&__o->__a_, __d);
}
template <class _Tp>

void atomic_store(volatile atomic<_Tp> *__o, typename atomic<_Tp>::value_type __d) throw()
{
    __o->store(__d);
}
template <class _Tp>

void atomic_store(atomic<_Tp> *__o, typename atomic<_Tp>::value_type __d) throw()
{
    __o->store(__d);
}
template <class _Tp>

void atomic_store_explicit(volatile atomic<_Tp> *__o, typename atomic<_Tp>::value_type __d, memory_order __m) throw()

{
    __o->store(__d, __m);
}
template <class _Tp>

void atomic_store_explicit(atomic<_Tp> *__o, typename atomic<_Tp>::value_type __d, memory_order __m) throw()

{
    __o->store(__d, __m);
}
template <class _Tp>

_Tp atomic_load(const volatile atomic<_Tp> *__o) throw()
{
    return __o->load();
}
template <class _Tp>

_Tp atomic_load(const atomic<_Tp> *__o) throw()
{
    return __o->load();
}
template <class _Tp>

_Tp atomic_load_explicit(const volatile atomic<_Tp> *__o, memory_order __m) throw()

{
    return __o->load(__m);
}
template <class _Tp>

_Tp atomic_load_explicit(const atomic<_Tp> *__o, memory_order __m) throw()

{
    return __o->load(__m);
}
template <class _Tp>

_Tp atomic_exchange(volatile atomic<_Tp> *__o, typename atomic<_Tp>::value_type __d) throw()
{
    return __o->exchange(__d);
}
template <class _Tp>

_Tp atomic_exchange(atomic<_Tp> *__o, typename atomic<_Tp>::value_type __d) throw()
{
    return __o->exchange(__d);
}
template <class _Tp>

_Tp atomic_exchange_explicit(volatile atomic<_Tp> *__o, typename atomic<_Tp>::value_type __d, memory_order __m) throw()
{
    return __o->exchange(__d, __m);
}
template <class _Tp>

_Tp atomic_exchange_explicit(atomic<_Tp> *__o, typename atomic<_Tp>::value_type __d, memory_order __m) throw()
{
    return __o->exchange(__d, __m);
}
template <class _Tp>

bool atomic_compare_exchange_weak(volatile atomic<_Tp> *__o, typename atomic<_Tp>::value_type *__e, typename atomic<_Tp>::value_type __d) throw()
{
    return __o->compare_exchange_weak(*__e, __d);
}
template <class _Tp>

bool atomic_compare_exchange_weak(atomic<_Tp> *__o, typename atomic<_Tp>::value_type *__e, typename atomic<_Tp>::value_type __d) throw()
{
    return __o->compare_exchange_weak(*__e, __d);
}
template <class _Tp>

bool atomic_compare_exchange_strong(volatile atomic<_Tp> *__o, typename atomic<_Tp>::value_type *__e, typename atomic<_Tp>::value_type __d) throw()
{
    return __o->compare_exchange_strong(*__e, __d);
}
template <class _Tp>

bool atomic_compare_exchange_strong(atomic<_Tp> *__o, typename atomic<_Tp>::value_type *__e, typename atomic<_Tp>::value_type __d) throw()
{
    return __o->compare_exchange_strong(*__e, __d);
}
template <class _Tp>

bool atomic_compare_exchange_weak_explicit(volatile atomic<_Tp> *__o, typename atomic<_Tp>::value_type *__e,
                                           typename atomic<_Tp>::value_type __d,
                                           memory_order __s, memory_order __f) throw()

{
    return __o->compare_exchange_weak(*__e, __d, __s, __f);
}
template <class _Tp>

bool atomic_compare_exchange_weak_explicit(atomic<_Tp> *__o, typename atomic<_Tp>::value_type *__e, typename atomic<_Tp>::value_type __d,
                                           memory_order __s, memory_order __f) throw()

{
    return __o->compare_exchange_weak(*__e, __d, __s, __f);
}
template <class _Tp>

bool atomic_compare_exchange_strong_explicit(volatile atomic<_Tp> *__o,
                                             typename atomic<_Tp>::value_type *__e, typename atomic<_Tp>::value_type __d,
                                             memory_order __s, memory_order __f) throw()

{
    return __o->compare_exchange_strong(*__e, __d, __s, __f);
}
template <class _Tp>

bool atomic_compare_exchange_strong_explicit(atomic<_Tp> *__o, typename atomic<_Tp>::value_type *__e,
                                             typename atomic<_Tp>::value_type __d,
                                             memory_order __s, memory_order __f) throw()

{
    return __o->compare_exchange_strong(*__e, __d, __s, __f);
}
template <class _Tp>

void atomic_wait(const volatile atomic<_Tp> *__o,
                 typename atomic<_Tp>::value_type __v) throw()
{
    return __o->wait(__v);
}
template <class _Tp>

void atomic_wait(const atomic<_Tp> *__o,
                 typename atomic<_Tp>::value_type __v) throw()
{
    return __o->wait(__v);
}
template <class _Tp>

void atomic_wait_explicit(const volatile atomic<_Tp> *__o,
                          typename atomic<_Tp>::value_type __v,
                          memory_order __m) throw()

{
    return __o->wait(__v, __m);
}
template <class _Tp>

void atomic_wait_explicit(const atomic<_Tp> *__o,
                          typename atomic<_Tp>::value_type __v,
                          memory_order __m) throw()

{
    return __o->wait(__v, __m);
}
template <class _Tp>

void atomic_notify_one(volatile atomic<_Tp> *__o) throw()
{
    __o->notify_one();
}
template <class _Tp>

void atomic_notify_one(atomic<_Tp> *__o) throw()
{
    __o->notify_one();
}
template <class _Tp>

void atomic_notify_all(volatile atomic<_Tp> *__o) throw()
{
    __o->notify_all();
}
template <class _Tp>

void atomic_notify_all(atomic<_Tp> *__o) throw()
{
    __o->notify_all();
}
template <class _Tp>

_Tp atomic_fetch_add(volatile atomic<_Tp> *__o, typename atomic<_Tp>::difference_type __op) throw()
{
    return __o->fetch_add(__op);
}
template <class _Tp>

_Tp atomic_fetch_add(atomic<_Tp> *__o, typename atomic<_Tp>::difference_type __op) throw()
{
    return __o->fetch_add(__op);
}
template <class _Tp>

_Tp atomic_fetch_add_explicit(volatile atomic<_Tp> *__o, typename atomic<_Tp>::difference_type __op, memory_order __m) throw()
{
    return __o->fetch_add(__op, __m);
}
template <class _Tp>

_Tp atomic_fetch_add_explicit(atomic<_Tp> *__o, typename atomic<_Tp>::difference_type __op, memory_order __m) throw()
{
    return __o->fetch_add(__op, __m);
}
template <class _Tp>

_Tp atomic_fetch_sub(volatile atomic<_Tp> *__o, typename atomic<_Tp>::difference_type __op) throw()
{
    return __o->fetch_sub(__op);
}
template <class _Tp>

_Tp atomic_fetch_sub(atomic<_Tp> *__o, typename atomic<_Tp>::difference_type __op) throw()
{
    return __o->fetch_sub(__op);
}
template <class _Tp>

_Tp atomic_fetch_sub_explicit(volatile atomic<_Tp> *__o, typename atomic<_Tp>::difference_type __op, memory_order __m) throw()
{
    return __o->fetch_sub(__op, __m);
}
template <class _Tp>

_Tp atomic_fetch_sub_explicit(atomic<_Tp> *__o, typename atomic<_Tp>::difference_type __op, memory_order __m) throw()
{
    return __o->fetch_sub(__op, __m);
}
template <class _Tp>

typename enable_if<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp>::type
atomic_fetch_and(volatile atomic<_Tp> *__o, typename atomic<_Tp>::value_type __op) throw()
{
    return __o->fetch_and(__op);
}
template <class _Tp>

typename enable_if<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp>::type
atomic_fetch_and(atomic<_Tp> *__o, typename atomic<_Tp>::value_type __op) throw()
{
    return __o->fetch_and(__op);
}
template <class _Tp>

typename enable_if<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp>::type
atomic_fetch_and_explicit(volatile atomic<_Tp> *__o, typename atomic<_Tp>::value_type __op, memory_order __m) throw()
{
    return __o->fetch_and(__op, __m);
}
template <class _Tp>

typename enable_if<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp>::type
atomic_fetch_and_explicit(atomic<_Tp> *__o, typename atomic<_Tp>::value_type __op, memory_order __m) throw()
{
    return __o->fetch_and(__op, __m);
}
template <class _Tp>

typename enable_if<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp>::type
atomic_fetch_or(volatile atomic<_Tp> *__o, typename atomic<_Tp>::value_type __op) throw()
{
    return __o->fetch_or(__op);
}
template <class _Tp>

typename enable_if<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp>::type
atomic_fetch_or(atomic<_Tp> *__o, typename atomic<_Tp>::value_type __op) throw()
{
    return __o->fetch_or(__op);
}
template <class _Tp>

typename enable_if<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp>::type
atomic_fetch_or_explicit(volatile atomic<_Tp> *__o, typename atomic<_Tp>::value_type __op, memory_order __m) throw()
{
    return __o->fetch_or(__op, __m);
}
template <class _Tp>

typename enable_if<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp>::type
atomic_fetch_or_explicit(atomic<_Tp> *__o, typename atomic<_Tp>::value_type __op, memory_order __m) throw()
{
    return __o->fetch_or(__op, __m);
}
template <class _Tp>

typename enable_if<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp>::type
atomic_fetch_xor(volatile atomic<_Tp> *__o, typename atomic<_Tp>::value_type __op) throw()
{
    return __o->fetch_xor(__op);
}
template <class _Tp>

typename enable_if<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp>::type
atomic_fetch_xor(atomic<_Tp> *__o, typename atomic<_Tp>::value_type __op) throw()
{
    return __o->fetch_xor(__op);
}
template <class _Tp>

typename enable_if<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp>::type
atomic_fetch_xor_explicit(volatile atomic<_Tp> *__o, typename atomic<_Tp>::value_type __op, memory_order __m) throw()
{
    return __o->fetch_xor(__op, __m);
}
template <class _Tp>

typename enable_if<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp>::type
atomic_fetch_xor_explicit(atomic<_Tp> *__o, typename atomic<_Tp>::value_type __op, memory_order __m) throw()
{
    return __o->fetch_xor(__op, __m);
}
typedef struct atomic_flag
{
    __cxx_atomic_impl<bool> __a_;

    bool test(memory_order __m = memory_order_seq_cst) const volatile throw()
    {
        return bool(true) == __cxx_atomic_load(&__a_, __m);
    }

    bool test(memory_order __m = memory_order_seq_cst) const throw()
    {
        return bool(true) == __cxx_atomic_load(&__a_, __m);
    }

    bool test_and_set(memory_order __m = memory_order_seq_cst) volatile throw()
    {
        return __cxx_atomic_exchange(&__a_, bool(true), __m);
    }

    bool test_and_set(memory_order __m = memory_order_seq_cst) throw()
    {
        return __cxx_atomic_exchange(&__a_, bool(true), __m);
    }

    void clear(memory_order __m = memory_order_seq_cst) volatile throw()
    {
        __cxx_atomic_store(&__a_, bool(false), __m);
    }

    void clear(memory_order __m = memory_order_seq_cst) throw()
    {
        __cxx_atomic_store(&__a_, bool(false), __m);
    }

    void wait(bool __v, memory_order __m = memory_order_seq_cst) const volatile throw()
    {
        __cxx_atomic_wait(&__a_, bool(__v), __m);
    }

    void wait(bool __v, memory_order __m = memory_order_seq_cst) const throw()
    {
        __cxx_atomic_wait(&__a_, bool(__v), __m);
    }

    void notify_one() volatile throw()
    {
        __cxx_atomic_notify_one(&__a_);
    }

    void notify_one() throw()
    {
        __cxx_atomic_notify_one(&__a_);
    }

    void notify_all() volatile throw()
    {
        __cxx_atomic_notify_all(&__a_);
    }

    void notify_all() throw()
    {
        __cxx_atomic_notify_all(&__a_);
    }

    atomic_flag() throw() = default;

    atomic_flag(bool __b) throw() : __a_(__b) {}
    atomic_flag(const atomic_flag &) = delete;
    atomic_flag &operator=(const atomic_flag &) = delete;
    atomic_flag &operator=(const atomic_flag &) volatile = delete;
} atomic_flag;
inline bool
atomic_flag_test(const volatile atomic_flag *__o) throw()
{
    return __o->test();
}
inline bool
atomic_flag_test(const atomic_flag *__o) throw()
{
    return __o->test();
}
inline bool
atomic_flag_test_explicit(const volatile atomic_flag *__o, memory_order __m) throw()
{
    return __o->test(__m);
}
inline bool
atomic_flag_test_explicit(const atomic_flag *__o, memory_order __m) throw()
{
    return __o->test(__m);
}
inline bool
atomic_flag_test_and_set(volatile atomic_flag *__o) throw()
{
    return __o->test_and_set();
}
inline bool
atomic_flag_test_and_set(atomic_flag *__o) throw()
{
    return __o->test_and_set();
}
inline bool
atomic_flag_test_and_set_explicit(volatile atomic_flag *__o, memory_order __m) throw()
{
    return __o->test_and_set(__m);
}
inline bool
atomic_flag_test_and_set_explicit(atomic_flag *__o, memory_order __m) throw()
{
    return __o->test_and_set(__m);
}
inline void
atomic_flag_clear(volatile atomic_flag *__o) throw()
{
    __o->clear();
}
inline void
atomic_flag_clear(atomic_flag *__o) throw()
{
    __o->clear();
}
inline void
atomic_flag_clear_explicit(volatile atomic_flag *__o, memory_order __m) throw()
{
    __o->clear(__m);
}
inline void
atomic_flag_clear_explicit(atomic_flag *__o, memory_order __m) throw()
{
    __o->clear(__m);
}
inline void
atomic_flag_wait(const volatile atomic_flag *__o, bool __v) throw()
{
    __o->wait(__v);
}
inline void
atomic_flag_wait(const atomic_flag *__o, bool __v) throw()
{
    __o->wait(__v);
}
inline void
atomic_flag_wait_explicit(const volatile atomic_flag *__o,
                          bool __v, memory_order __m) throw()
{
    __o->wait(__v, __m);
}
inline void
atomic_flag_wait_explicit(const atomic_flag *__o,
                          bool __v, memory_order __m) throw()
{
    __o->wait(__v, __m);
}
inline void
atomic_flag_notify_one(volatile atomic_flag *__o) throw()
{
    __o->notify_one();
}
inline void
atomic_flag_notify_one(atomic_flag *__o) throw()
{
    __o->notify_one();
}
inline void
atomic_flag_notify_all(volatile atomic_flag *__o) throw()
{
    __o->notify_all();
}
inline void
atomic_flag_notify_all(atomic_flag *__o) throw()
{
    __o->notify_all();
}
inline void
atomic_thread_fence(memory_order __m) throw()
{
    __cxx_atomic_thread_fence(__m);
}
inline void
atomic_signal_fence(memory_order __m) throw()
{
    __cxx_atomic_signal_fence(__m);
}
typedef atomic<bool> atomic_bool;
typedef atomic<char> atomic_char;
typedef atomic<signed char> atomic_schar;
typedef atomic<unsigned char> atomic_uchar;
typedef atomic<short> atomic_short;
typedef atomic<unsigned short> atomic_ushort;
typedef atomic<int> atomic_int;
typedef atomic<unsigned int> atomic_uint;
typedef atomic<long> atomic_long;
typedef atomic<unsigned long> atomic_ulong;
typedef atomic<long long> atomic_llong;
typedef atomic<unsigned long long> atomic_ullong;
typedef atomic<char16_t> atomic_char16_t;
typedef atomic<char32_t> atomic_char32_t;
typedef atomic<wchar_t> atomic_wchar_t;
typedef atomic<int_least8_t> atomic_int_least8_t;
typedef atomic<uint_least8_t> atomic_uint_least8_t;
typedef atomic<int_least16_t> atomic_int_least16_t;
typedef atomic<uint_least16_t> atomic_uint_least16_t;
typedef atomic<int_least32_t> atomic_int_least32_t;
typedef atomic<uint_least32_t> atomic_uint_least32_t;
typedef atomic<int_least64_t> atomic_int_least64_t;
typedef atomic<uint_least64_t> atomic_uint_least64_t;
typedef atomic<int_fast8_t> atomic_int_fast8_t;
typedef atomic<uint_fast8_t> atomic_uint_fast8_t;
typedef atomic<int_fast16_t> atomic_int_fast16_t;
typedef atomic<uint_fast16_t> atomic_uint_fast16_t;
typedef atomic<int_fast32_t> atomic_int_fast32_t;
typedef atomic<uint_fast32_t> atomic_uint_fast32_t;
typedef atomic<int_fast64_t> atomic_int_fast64_t;
typedef atomic<uint_fast64_t> atomic_uint_fast64_t;
typedef atomic<int8_t> atomic_int8_t;
typedef atomic<uint8_t> atomic_uint8_t;
typedef atomic<int16_t> atomic_int16_t;
typedef atomic<uint16_t> atomic_uint16_t;
typedef atomic<int32_t> atomic_int32_t;
typedef atomic<uint32_t> atomic_uint32_t;
typedef atomic<int64_t> atomic_int64_t;
typedef atomic<uint64_t> atomic_uint64_t;
typedef atomic<intptr_t> atomic_intptr_t;
typedef atomic<uintptr_t> atomic_uintptr_t;
typedef atomic<size_t> atomic_size_t;
typedef atomic<ptrdiff_t> atomic_ptrdiff_t;
typedef atomic<intmax_t> atomic_intmax_t;
typedef atomic<uintmax_t> atomic_uintmax_t;
typedef conditional<false, __cxx_contention_t, long long>::type __libcpp_signed_lock_free;
typedef conditional<false, __cxx_contention_t, unsigned long long>::type __libcpp_unsigned_lock_free;
typedef atomic<__libcpp_signed_lock_free> atomic_signed_lock_free;
typedef atomic<__libcpp_unsigned_lock_free> atomic_unsigned_lock_free;
}
}
namespace std
{
inline namespace __1
{
template <class _Alloc>
class __allocator_destructor
{
    typedef allocator_traits<_Alloc> __alloc_traits;

public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::size_type size_type;

private:
    _Alloc &__alloc_;
    size_type __s_;

public:
    throw()
        : __alloc_(__a), __s_(__s) {}

    void operator()(pointer __p) throw()
    {
        __alloc_traits::deallocate(__alloc_, __p, __s_);
    }
};
template <class _ValueType>
inline _ValueType __libcpp_relaxed_load(_ValueType const *__value)
{
    return __atomic_load_n(__value, 0);
}
template <class _ValueType>
inline _ValueType __libcpp_acquire_load(_ValueType const *__value)
{
    return __atomic_load_n(__value, 2);
}
template <class _Tp>
inline _Tp
__libcpp_atomic_refcount_increment(_Tp &__t) throw()
{
    return __atomic_add_fetch(&__t, 1, 0);
}
template <class _Tp>
inline _Tp
__libcpp_atomic_refcount_decrement(_Tp &__t) throw()
{
    return __atomic_add_fetch(&__t, -1, 4);
}
class bad_weak_ptr
    : public std::exception
{
public:
    bad_weak_ptr() throw() = default;
    bad_weak_ptr(const bad_weak_ptr &) throw() = default;
    virtual ~bad_weak_ptr() throw();
    virtual const char *what() const throw();
};

void __throw_bad_weak_ptr()
{
    throw bad_weak_ptr();
}
template <class _Tp>
class weak_ptr;
class __shared_count
{
    __shared_count(const __shared_count &);
    __shared_count &operator=(const __shared_count &);

protected:
    long __shared_owners_;
    virtual ~__shared_count();

private:
    virtual void __on_zero_shared() throw() = 0;

public:
    explicit __shared_count(long __refs = 0) throw()
        : __shared_owners_(__refs) {}

    void __add_shared() throw()
    {
        __libcpp_atomic_refcount_increment(__shared_owners_);
    }

    bool __release_shared() throw()
    {
        if (__libcpp_atomic_refcount_decrement(__shared_owners_) == -1)
        {
            __on_zero_shared();
            return true;
        }
        return false;
    }

    long use_count() const throw()
    {
        return __libcpp_relaxed_load(&__shared_owners_) + 1;
    }
};
class __shared_weak_count
    : private __shared_count
{
    long __shared_weak_owners_;

public:
    explicit __shared_weak_count(long __refs = 0) throw()
        : __shared_count(__refs),
          __shared_weak_owners_(__refs) {}

protected:
    virtual ~__shared_weak_count();

public:
    void __add_shared() throw()
    {
        __shared_count::__add_shared();
    }

    void __add_weak() throw()
    {
        __libcpp_atomic_refcount_increment(__shared_weak_owners_);
    }

    void __release_shared() throw()
    {
        if (__shared_count::__release_shared())
            __release_weak();
    }
    void __release_weak() throw();

    long use_count() const throw() { return __shared_count::use_count(); }
    __shared_weak_count *lock() throw();
    virtual const void *__get_deleter(const type_info &) const throw();

private:
    virtual void __on_zero_shared_weak() throw() = 0;
};
template <class _Tp, class _Dp, class _Alloc>
class __shared_ptr_pointer
    : public __shared_weak_count
{
    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;

public:
    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)
        : __data_(__compressed_pair<_Tp, _Dp>(__p, std::move(__d)), std::move(__a)) {}
    virtual const void *__get_deleter(const type_info &) const throw();

private:
    virtual void __on_zero_shared() throw();
    virtual void __on_zero_shared_weak() throw();
};
template <class _Tp, class _Dp, class _Alloc>
const void *
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info &__t) const throw()
{
    return __t == typeid(_Dp) ? std::addressof(__data_.first().second()) : __nullptr;
}
template <class _Tp, class _Dp, class _Alloc>
void __shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() throw()
{
    __data_.first().second()(__data_.first().first());
    __data_.first().second().~_Dp();
}
template <class _Tp, class _Dp, class _Alloc>
void __shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() throw()
{
    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;
    typedef allocator_traits<_Al> _ATraits;
    typedef pointer_traits<typename _ATraits::pointer> _PTraits;
    _Al __a(__data_.second());
    __data_.second().~_Alloc();
    __a.deallocate(_PTraits::pointer_to(*this), 1);
}
template <class _Tp, class _Alloc>
struct __shared_ptr_emplace
    : __shared_weak_count
{
    template <class... _Args>

    explicit __shared_ptr_emplace(_Alloc __a, _Args &&...__args)
        : __storage_(std::move(__a))
    {
        ::new ((void *)__get_elem()) _Tp(std::forward<_Args>(__args)...);
    }

    _Alloc *__get_alloc() throw() { return __storage_.__get_alloc(); }

    _Tp *__get_elem() throw() { return __storage_.__get_elem(); }

private:
    virtual void __on_zero_shared() throw()
    {
        __get_elem()->~_Tp();
    }
    virtual void __on_zero_shared_weak() throw()
    {
        using _ControlBlockAlloc = typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type;
        using _ControlBlockPointer = typename allocator_traits<_ControlBlockAlloc>::pointer;
        _ControlBlockAlloc __tmp(*__get_alloc());
        __storage_.~_Storage();
        allocator_traits<_ControlBlockAlloc>::deallocate(__tmp,
                                                         pointer_traits<_ControlBlockPointer>::pointer_to(*this), 1);
    }
    using _CompressedPair = __compressed_pair<_Alloc, _Tp>;
    struct _Storage
    {
        char __blob_[sizeof(_CompressedPair)];
        {
            ::new ((void *)__get_alloc()) _Alloc(std::move(__a));
        }
        {
            __get_alloc()->~_Alloc();
        }
        _Alloc *__get_alloc() throw()
        {
            _CompressedPair *__as_pair = reinterpret_cast<_CompressedPair *>(__blob_);
            typename _CompressedPair::_Base1 *__first = _CompressedPair::__get_first_base(__as_pair);
            _Alloc *__alloc = reinterpret_cast<_Alloc *>(__first);
            return __alloc;
        }
        {
            _CompressedPair *__as_pair = reinterpret_cast<_CompressedPair *>(__blob_);
            typename _CompressedPair::_Base2 *__second = _CompressedPair::__get_second_base(__as_pair);
            _Tp *__elem = reinterpret_cast<_Tp *>(__second);
            return __elem;
        }
    };
    _Static_assert(_Alignof(_Storage) == _Alignof(_CompressedPair), "");
    _Static_assert(sizeof(_Storage) == sizeof(_CompressedPair), "");
    _Storage __storage_;
};
struct __shared_ptr_dummy_rebind_allocator_type;
template <>
class allocator<__shared_ptr_dummy_rebind_allocator_type>
{
public:
    template <class _Other>
    struct rebind
    {
        typedef allocator<_Other> other;
    };
};
template <class _Tp>
class enable_shared_from_this;
template <class _Tp, class _Up>
struct __compatible_with
    : is_convertible<_Tp *, _Up *>
{
};
template <class _Ptr, class = void>
struct __is_deletable : false_type
{
};
template <class _Ptr>
struct __is_deletable<_Ptr, __decltype(delete declval<_Ptr>())> : true_type
{
};
template <class _Ptr, class = void>
struct __is_array_deletable : false_type
{
};
template <class _Ptr>
struct __is_array_deletable<_Ptr, __decltype(delete[] declval<_Ptr>())> : true_type{};
template <class _Dp, class _Pt,
          class = __decltype(declval<_Dp>()(declval<_Pt>()))>
static true_type __well_formed_deleter_test(int);
template <class, class>
static false_type __well_formed_deleter_test(...);
template <class _Dp, class _Pt>
struct __well_formed_deleter : __decltype(__well_formed_deleter_test<_Dp, _Pt>(0))
{
};
template <class _Dp, class _Tp, class _Yp>
struct __shared_ptr_deleter_ctor_reqs
{
    static const bool value = __compatible_with<_Tp, _Yp>::value &&
                              is_move_constructible<_Dp>::value &&
                              __well_formed_deleter<_Dp, _Tp *>::value;
};
template <class _Tp>
class shared_ptr
{
public:
    typedef _Tp element_type;

private:
    element_type *__ptr_;
    __shared_weak_count *__cntrl_;

public:
    shared_ptr() throw()
        : __ptr_(__nullptr),
          __cntrl_(__nullptr)
    {
    }

    shared_ptr(nullptr_t) throw()
        : __ptr_(__nullptr),
          __cntrl_(__nullptr)
    {
    }
    template <class _Yp, class = __enable_if_t<
                             _And<
                                 __compatible_with<_Yp, _Tp>>::value>>
    explicit shared_ptr(_Yp *__p) : __ptr_(__p)
    {
        unique_ptr<_Yp> __hold(__p);
        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
        typedef __shared_ptr_pointer<_Yp *, __shared_ptr_default_delete<_Tp, _Yp>, _AllocT> _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__p, __shared_ptr_default_delete<_Tp, _Yp>(), _AllocT());
        __hold.release();
        __enable_weak_this(__p, __p);
    }
    template <class _Yp, class _Dp, class = __enable_if_t<__shared_ptr_deleter_ctor_reqs<_Dp, _Yp, element_type>::value>>

    shared_ptr(_Yp *__p, _Dp __d)
        : __ptr_(__p)
    {
        try
        {
            typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
            typedef __shared_ptr_pointer<_Yp *, _Dp, _AllocT> _CntrlBlk;
            __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());
            __enable_weak_this(__p, __p);
        }
        catch (...)
        {
            __d(__p);
            throw;
        }
    }
    template <class _Yp, class _Dp, class _Alloc, class = __enable_if_t<__shared_ptr_deleter_ctor_reqs<_Dp, _Yp, element_type>::value>>

    shared_ptr(_Yp *__p, _Dp __d, _Alloc __a)
        : __ptr_(__p)
    {
        try
        {
            typedef __shared_ptr_pointer<_Yp *, _Dp, _Alloc> _CntrlBlk;
            typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
            typedef __allocator_destructor<_A2> _D2;
            _A2 __a2(__a);
            unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
            ::new ((void *)std::addressof(*__hold2.get()))
                _CntrlBlk(__p, __d, __a);
            __cntrl_ = std::addressof(*__hold2.release());
            __enable_weak_this(__p, __p);
        }
        catch (...)
        {
            __d(__p);
            throw;
        }
    }
    template <class _Dp>

    shared_ptr(nullptr_t __p, _Dp __d)
        : __ptr_(__nullptr)
    {
        try
        {
            typedef typename __shared_ptr_default_allocator<_Tp>::type _AllocT;
            typedef __shared_ptr_pointer<nullptr_t, _Dp, _AllocT> _CntrlBlk;
            __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());
        }
        catch (...)
        {
            __d(__p);
            throw;
        }
    }
    template <class _Dp, class _Alloc>

    shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)
        : __ptr_(__nullptr)
    {
        try
        {
            typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;
            typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
            typedef __allocator_destructor<_A2> _D2;
            _A2 __a2(__a);
            unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
            ::new ((void *)std::addressof(*__hold2.get()))
                _CntrlBlk(__p, __d, __a);
            __cntrl_ = std::addressof(*__hold2.release());
        }
        catch (...)
        {
            __d(__p);
            throw;
        }
    }
    template <class _Yp>

    shared_ptr(const shared_ptr<_Yp> &__r, element_type *__p) throw()
        : __ptr_(__p),
          __cntrl_(__r.__cntrl_)
    {
        if (__cntrl_)
            __cntrl_->__add_shared();
    }

    shared_ptr(const shared_ptr &__r) throw()
        : __ptr_(__r.__ptr_),
          __cntrl_(__r.__cntrl_)
    {
        if (__cntrl_)
            __cntrl_->__add_shared();
    }
    template <class _Yp, class = __enable_if_t<__compatible_with<_Yp, _Tp>::value>>

    shared_ptr(const shared_ptr<_Yp> &__r) throw()
        : __ptr_(__r.__ptr_),
          __cntrl_(__r.__cntrl_)
    {
        if (__cntrl_)
            __cntrl_->__add_shared();
    }

    shared_ptr(shared_ptr &&__r) throw()
        : __ptr_(__r.__ptr_),
          __cntrl_(__r.__cntrl_)
    {
        __r.__ptr_ = __nullptr;
        __r.__cntrl_ = __nullptr;
    }
    template <class _Yp, class = __enable_if_t<__compatible_with<_Yp, _Tp>::value>>

    shared_ptr(shared_ptr<_Yp> &&__r) throw()
        : __ptr_(__r.__ptr_),
          __cntrl_(__r.__cntrl_)
    {
        __r.__ptr_ = __nullptr;
        __r.__cntrl_ = __nullptr;
    }
    template <class _Yp, class = __enable_if_t<__compatible_with<_Yp, _Tp>::value>>

    explicit shared_ptr(const weak_ptr<_Yp> &__r)
        : __ptr_(__r.__ptr_),
          __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)
    {
        if (__cntrl_ == __nullptr)
            __throw_bad_weak_ptr();
    }
    template <class _Yp, class = __enable_if_t<is_convertible<_Yp *, element_type *>::value>>

    shared_ptr(auto_ptr<_Yp> &&__r)
        : __ptr_(__r.get())
    {
        typedef __shared_ptr_pointer<_Yp *, default_delete<_Yp>, allocator<_Yp>> _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());
        __enable_weak_this(__r.get(), __r.get());
        __r.release();
    }
    template <class _Yp, class _Dp, class = __enable_if_t<!is_lvalue_reference<_Dp>::value && is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type *>::value>>

    shared_ptr(unique_ptr<_Yp, _Dp> &&__r)
        : __ptr_(__r.get())
    {
        {
            typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
            typedef __shared_ptr_pointer<typename unique_ptr<_Yp, _Dp>::pointer, _Dp, _AllocT> _CntrlBlk;
            __cntrl_ = new _CntrlBlk(__r.get(), std::move(__r.get_deleter()), _AllocT());
            __enable_weak_this(__r.get(), __r.get());
        }
        __r.release();
    }
    template <class _Yp, class _Dp, class = void, class = __enable_if_t<is_lvalue_reference<_Dp>::value && is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type *>::value>>

    shared_ptr(unique_ptr<_Yp, _Dp> &&__r)
        : __ptr_(__r.get())
    {
        {
            typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
            typedef __shared_ptr_pointer<typename unique_ptr<_Yp, _Dp>::pointer,
                                         reference_wrapper<typename remove_reference<_Dp>::type>,
                                         _AllocT>
                _CntrlBlk;
            __cntrl_ = new _CntrlBlk(__r.get(), std::ref(__r.get_deleter()), _AllocT());
            __enable_weak_this(__r.get(), __r.get());
        }
        __r.release();
    }

    ~shared_ptr()
    {
        if (__cntrl_)
            __cntrl_->__release_shared();
    }

    shared_ptr<_Tp> &operator=(const shared_ptr &__r) throw()
    {
        shared_ptr(__r).swap(*this);
        return *this;
    }
    template <class _Yp, class = __enable_if_t<__compatible_with<_Yp, _Tp>::value>>

    shared_ptr<_Tp> &operator=(const shared_ptr<_Yp> &__r) throw()
    {
        shared_ptr(__r).swap(*this);
        return *this;
    }

    shared_ptr<_Tp> &operator=(shared_ptr &&__r) throw()
    {
        shared_ptr(std::move(__r)).swap(*this);
        return *this;
    }
    template <class _Yp, class = __enable_if_t<__compatible_with<_Yp, _Tp>::value>>

    shared_ptr<_Tp> &operator=(shared_ptr<_Yp> &&__r)
    {
        shared_ptr(std::move(__r)).swap(*this);
        return *this;
    }
    template <class _Yp, class = __enable_if_t<
                             !is_array<_Yp>::value &&
                             is_convertible<_Yp *, typename shared_ptr<_Tp>::element_type *>::value>>

    shared_ptr<_Tp> &operator=(auto_ptr<_Yp> &&__r)
    {
        shared_ptr(std::move(__r)).swap(*this);
        return *this;
    }
    template <class _Yp, class _Dp, class = __enable_if_t<is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type *>::value>>

    shared_ptr<_Tp> &operator=(unique_ptr<_Yp, _Dp> &&__r)
    {
        shared_ptr(std::move(__r)).swap(*this);
        return *this;
    }

    void swap(shared_ptr &__r) throw()
    {
        std::swap(__ptr_, __r.__ptr_);
        std::swap(__cntrl_, __r.__cntrl_);
    }

    void reset() throw()
    {
        shared_ptr().swap(*this);
    }
    template <class _Yp, class = __enable_if_t<
                             __compatible_with<_Yp, _Tp>::value>>

    void reset(_Yp *__p)
    {
        shared_ptr(__p).swap(*this);
    }
    template <class _Yp, class _Dp, class = __enable_if_t<__compatible_with<_Yp, _Tp>::value>>

    void reset(_Yp *__p, _Dp __d)
    {
        shared_ptr(__p, __d).swap(*this);
    }
    template <class _Yp, class _Dp, class _Alloc, class = __enable_if_t<__compatible_with<_Yp, _Tp>::value>>

    void reset(_Yp *__p, _Dp __d, _Alloc __a)
    {
        shared_ptr(__p, __d, __a).swap(*this);
    }

    element_type *get() const throw()
    {
        return __ptr_;
    }

    typename add_lvalue_reference<element_type>::type operator*() const throw()
    {
        return *__ptr_;
    }

    element_type *operator->() const throw()
    {
        _Static_assert(!is_array<_Tp>::value, "std::shared_ptr<T>::operator-> is only valid when T is not an array type.");
        return __ptr_;
    }

    long use_count() const throw()
    {
        return __cntrl_ ? __cntrl_->use_count() : 0;
    }

    bool unique() const throw()
    {
        return use_count() == 1;
    }

    explicit operator bool() const throw()
    {
        return get() != __nullptr;
    }
    template <class _Up>

    bool owner_before(shared_ptr<_Up> const &__p) const throw()
    {
        return __cntrl_ < __p.__cntrl_;
    }
    template <class _Up>

    bool owner_before(weak_ptr<_Up> const &__p) const throw()
    {
        return __cntrl_ < __p.__cntrl_;
    }

    bool __owner_equivalent(const shared_ptr &__p) const
    {
        return __cntrl_ == __p.__cntrl_;
    }
    template <class _Dp>

    _Dp *__get_deleter() const throw()
    {
        return static_cast<_Dp *>(__cntrl_
                                      ? const_cast<void *>(__cntrl_->__get_deleter(typeid(_Dp)))
                                      : __nullptr);
    }
    template <class _Yp, class _CntrlBlk>

    static shared_ptr<_Tp> __create_with_control_block(_Yp *__p, _CntrlBlk *__cntrl) throw()
    {
        shared_ptr<_Tp> __r;
        __r.__ptr_ = __p;
        __r.__cntrl_ = __cntrl;
        __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
        return __r;
    }

private:
    template <class _Yp, bool = is_function<_Yp>::value>
    struct __shared_ptr_default_allocator
    {
        typedef allocator<_Yp> type;
    };
    template <class _Yp>
    struct __shared_ptr_default_allocator<_Yp, true>
    {
        typedef allocator<__shared_ptr_dummy_rebind_allocator_type> type;
    };
    template <class _Yp, class _OrigPtr, class = __enable_if_t<is_convertible<_OrigPtr *, const enable_shared_from_this<_Yp> *>::value>>

    void __enable_weak_this(const enable_shared_from_this<_Yp> *__e, _OrigPtr *__ptr) throw()
    {
        typedef typename remove_cv<_Yp>::type _RawYp;
        if (__e && __e->__weak_this_.expired())
        {
            __e->__weak_this_ = shared_ptr<_RawYp>(*this,
                                                   const_cast<_RawYp *>(static_cast<const _Yp *>(__ptr)));
        }
    }
    {
    }
    template <class, class _Yp>
    struct __shared_ptr_default_delete
        : default_delete<_Yp>
    {
    };
    template <class _Yp, class _Un, size_t _Sz>
    struct __shared_ptr_default_delete<_Yp[_Sz], _Un>
        : default_delete<_Yp[]>
    {
    };
    template <class _Yp, class _Un>
    struct __shared_ptr_default_delete<_Yp[], _Un>
        : default_delete<_Yp[]>
    {
    };
    template <class _Up>
    friend class shared_ptr;
    template <class _Up>
    friend class weak_ptr;
};
template <class _Tp, class _Alloc, class... _Args, class = __enable_if_t<!is_array<_Tp>::value>>

shared_ptr<_Tp> allocate_shared(const _Alloc &__a, _Args &&...__args)
{
    using _ControlBlock = __shared_ptr_emplace<_Tp, _Alloc>;
    using _ControlBlockAllocator = typename __allocator_traits_rebind<_Alloc, _ControlBlock>::type;
    __allocation_guard<_ControlBlockAllocator> __guard(__a, 1);
    ::new ((void *)std::addressof(*__guard.__get())) _ControlBlock(__a, std::forward<_Args>(__args)...);
    auto __control_block = __guard.__release_ptr();
    return shared_ptr<_Tp>::__create_with_control_block((*__control_block).__get_elem(), std::addressof(*__control_block));
}
template <class _Tp, class... _Args, class = __enable_if_t<!is_array<_Tp>::value>>

shared_ptr<_Tp> make_shared(_Args &&...__args)
{
    return std::allocate_shared<_Tp>(allocator<_Tp>(), std::forward<_Args>(__args)...);
}
template <class _Tp, class _Up>
inline bool
operator==(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) throw()
{
    return __x.get() == __y.get();
}
template <class _Tp, class _Up>
inline bool
operator!=(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) throw()
{
    return !(__x == __y);
}
template <class _Tp, class _Up>
inline bool
operator<(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) throw()
{
    typedef typename common_type<_Tp *, _Up *>::type _Vp;
    return less<_Vp>()(__x.get(), __y.get());
}
template <class _Tp, class _Up>
inline bool
operator>(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) throw()
{
    return __y < __x;
}
template <class _Tp, class _Up>
inline bool
operator<=(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) throw()
{
    return !(__y < __x);
}
template <class _Tp, class _Up>
inline bool
operator>=(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) throw()
{
    return !(__x < __y);
}
template <class _Tp>
inline bool
operator==(const shared_ptr<_Tp> &__x, nullptr_t) throw()
{
    return !__x;
}
template <class _Tp>
inline bool
operator==(nullptr_t, const shared_ptr<_Tp> &__x) throw()
{
    return !__x;
}
template <class _Tp>
inline bool
operator!=(const shared_ptr<_Tp> &__x, nullptr_t) throw()
{
    return static_cast<bool>(__x);
}
template <class _Tp>
inline bool
operator!=(nullptr_t, const shared_ptr<_Tp> &__x) throw()
{
    return static_cast<bool>(__x);
}
template <class _Tp>
inline bool
operator<(const shared_ptr<_Tp> &__x, nullptr_t) throw()
{
    return less<_Tp *>()(__x.get(), __nullptr);
}
template <class _Tp>
inline bool
operator<(nullptr_t, const shared_ptr<_Tp> &__x) throw()
{
    return less<_Tp *>()(__nullptr, __x.get());
}
template <class _Tp>
inline bool
operator>(const shared_ptr<_Tp> &__x, nullptr_t) throw()
{
    return __nullptr < __x;
}
template <class _Tp>
inline bool
operator>(nullptr_t, const shared_ptr<_Tp> &__x) throw()
{
    return __x < __nullptr;
}
template <class _Tp>
inline bool
operator<=(const shared_ptr<_Tp> &__x, nullptr_t) throw()
{
    return !(__nullptr < __x);
}
template <class _Tp>
inline bool
operator<=(nullptr_t, const shared_ptr<_Tp> &__x) throw()
{
    return !(__x < __nullptr);
}
template <class _Tp>
inline bool
operator>=(const shared_ptr<_Tp> &__x, nullptr_t) throw()
{
    return !(__x < __nullptr);
}
template <class _Tp>
inline bool
operator>=(nullptr_t, const shared_ptr<_Tp> &__x) throw()
{
    return !(__nullptr < __x);
}
template <class _Tp>
inline void
swap(shared_ptr<_Tp> &__x, shared_ptr<_Tp> &__y) throw()
{
    __x.swap(__y);
}
template <class _Tp, class _Up>
inline shared_ptr<_Tp>
static_pointer_cast(const shared_ptr<_Up> &__r) throw()
{
    return shared_ptr<_Tp>(__r,
                           static_cast<
                               typename shared_ptr<_Tp>::element_type *>(__r.get()));
}
template <class _Tp, class _Up>
inline shared_ptr<_Tp>
dynamic_pointer_cast(const shared_ptr<_Up> &__r) throw()
{
    typedef typename shared_ptr<_Tp>::element_type _ET;
    _ET *__p = dynamic_cast<_ET *>(__r.get());
    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();
}
template <class _Tp, class _Up>
shared_ptr<_Tp>
const_pointer_cast(const shared_ptr<_Up> &__r) throw()
{
    typedef typename shared_ptr<_Tp>::element_type _RTp;
    return shared_ptr<_Tp>(__r, const_cast<_RTp *>(__r.get()));
}
template <class _Tp, class _Up>
shared_ptr<_Tp>
reinterpret_pointer_cast(const shared_ptr<_Up> &__r) throw()
{
    return shared_ptr<_Tp>(__r,
                           reinterpret_cast<
                               typename shared_ptr<_Tp>::element_type *>(__r.get()));
}
template <class _Dp, class _Tp>
inline _Dp *
get_deleter(const shared_ptr<_Tp> &__p) throw()
{
    return __p.template __get_deleter<_Dp>();
}
template <class _Tp>
class weak_ptr
{
public:
    typedef _Tp element_type;

private:
    element_type *__ptr_;
    __shared_weak_count *__cntrl_;

public:
    weak_ptr() throw();
    template <class _Yp>
    weak_ptr(shared_ptr<_Yp> const &__r,
             typename enable_if<__compatible_with<_Yp, _Tp>::value, __nat *>::type = 0) throw();

    weak_ptr(weak_ptr const &__r) throw();
    template <class _Yp>
    weak_ptr(weak_ptr<_Yp> const &__r,
             typename enable_if<__compatible_with<_Yp, _Tp>::value, __nat *>::type = 0) throw();

    weak_ptr(weak_ptr &&__r) throw();
    template <class _Yp>
    weak_ptr(weak_ptr<_Yp> &&__r,
             typename enable_if<__compatible_with<_Yp, _Tp>::value, __nat *>::type = 0) throw();
    ~weak_ptr();

    weak_ptr &operator=(weak_ptr const &__r) throw();
    template <class _Yp>
    typename enable_if<
        __compatible_with<_Yp, _Tp>::value,
        weak_ptr &>::type

    operator=(weak_ptr<_Yp> const &__r) throw();

    weak_ptr &operator=(weak_ptr &&__r) throw();
    template <class _Yp>
    typename enable_if<
        __compatible_with<_Yp, _Tp>::value,
        weak_ptr &>::type

    operator=(weak_ptr<_Yp> &&__r) throw();
    template <class _Yp>
    typename enable_if<
        __compatible_with<_Yp, _Tp>::value,
        weak_ptr &>::type

    operator=(shared_ptr<_Yp> const &__r) throw();

    void swap(weak_ptr &__r) throw();

    void reset() throw();

    long use_count() const throw()
    {
        return __cntrl_ ? __cntrl_->use_count() : 0;
    }

    bool expired() const throw()
    {
        return __cntrl_ == __nullptr || __cntrl_->use_count() == 0;
    }
    shared_ptr<_Tp> lock() const throw();
    template <class _Up>

    bool owner_before(const shared_ptr<_Up> &__r) const throw()
    {
        return __cntrl_ < __r.__cntrl_;
    }
    template <class _Up>

    bool owner_before(const weak_ptr<_Up> &__r) const throw()
    {
        return __cntrl_ < __r.__cntrl_;
    }
    template <class _Up>
    friend class weak_ptr;
    template <class _Up>
    friend class shared_ptr;
};
template <class _Tp>
inline weak_ptr<_Tp>::weak_ptr() throw()
    : __ptr_(__nullptr),
      __cntrl_(__nullptr)
{
}
template <class _Tp>
inline weak_ptr<_Tp>::weak_ptr(weak_ptr const &__r) throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}
template <class _Tp>
template <class _Yp>
inline weak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const &__r,
                               typename enable_if<__compatible_with<_Yp, _Tp>::value, __nat *>::type) throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}
template <class _Tp>
template <class _Yp>
inline weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const &__r,
                               typename enable_if<__compatible_with<_Yp, _Tp>::value, __nat *>::type) throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}
template <class _Tp>
inline weak_ptr<_Tp>::weak_ptr(weak_ptr &&__r) throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = __nullptr;
    __r.__cntrl_ = __nullptr;
}
template <class _Tp>
template <class _Yp>
inline weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> &&__r,
                               typename enable_if<__compatible_with<_Yp, _Tp>::value, __nat *>::type) throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = __nullptr;
    __r.__cntrl_ = __nullptr;
}
template <class _Tp>
weak_ptr<_Tp>::~weak_ptr()
{
    if (__cntrl_)
        __cntrl_->__release_weak();
}
template <class _Tp>
inline weak_ptr<_Tp> &
weak_ptr<_Tp>::operator=(weak_ptr const &__r) throw()
{
    weak_ptr(__r).swap(*this);
    return *this;
}
template <class _Tp>
template <class _Yp>
inline
    typename enable_if<
        __compatible_with<_Yp, _Tp>::value,
        weak_ptr<_Tp> &>::type
    weak_ptr<_Tp>::operator=(weak_ptr<_Yp> const &__r) throw()
{
    weak_ptr(__r).swap(*this);
    return *this;
}
template <class _Tp>
inline weak_ptr<_Tp> &
weak_ptr<_Tp>::operator=(weak_ptr &&__r) throw()
{
    weak_ptr(std::move(__r)).swap(*this);
    return *this;
}
template <class _Tp>
template <class _Yp>
inline
    typename enable_if<
        __compatible_with<_Yp, _Tp>::value,
        weak_ptr<_Tp> &>::type
    weak_ptr<_Tp>::operator=(weak_ptr<_Yp> &&__r) throw()
{
    weak_ptr(std::move(__r)).swap(*this);
    return *this;
}
template <class _Tp>
template <class _Yp>
inline
    typename enable_if<
        __compatible_with<_Yp, _Tp>::value,
        weak_ptr<_Tp> &>::type
    weak_ptr<_Tp>::operator=(shared_ptr<_Yp> const &__r) throw()
{
    weak_ptr(__r).swap(*this);
    return *this;
}
template <class _Tp>
inline void
weak_ptr<_Tp>::swap(weak_ptr &__r) throw()
{
    std::swap(__ptr_, __r.__ptr_);
    std::swap(__cntrl_, __r.__cntrl_);
}
template <class _Tp>
inline void
swap(weak_ptr<_Tp> &__x, weak_ptr<_Tp> &__y) throw()
{
    __x.swap(__y);
}
template <class _Tp>
inline void
weak_ptr<_Tp>::reset() throw()
{
    weak_ptr().swap(*this);
}
template <class _Tp>
shared_ptr<_Tp>
weak_ptr<_Tp>::lock() const throw()
{
    shared_ptr<_Tp> __r;
    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;
    if (__r.__cntrl_)
        __r.__ptr_ = __ptr_;
    return __r;
}
template <class _Tp>
struct owner_less;
template <class _Tp>
struct owner_less<shared_ptr<_Tp>>
    : __binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>
{

    bool operator()(shared_ptr<_Tp> const &__x, shared_ptr<_Tp> const &__y) const throw()
    {
        return __x.owner_before(__y);
    }

    bool operator()(shared_ptr<_Tp> const &__x, weak_ptr<_Tp> const &__y) const throw()
    {
        return __x.owner_before(__y);
    }

    bool operator()(weak_ptr<_Tp> const &__x, shared_ptr<_Tp> const &__y) const throw()
    {
        return __x.owner_before(__y);
    }
};
template <class _Tp>
struct owner_less<weak_ptr<_Tp>>
    : __binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>
{

    bool operator()(weak_ptr<_Tp> const &__x, weak_ptr<_Tp> const &__y) const throw()
    {
        return __x.owner_before(__y);
    }

    bool operator()(shared_ptr<_Tp> const &__x, weak_ptr<_Tp> const &__y) const throw()
    {
        return __x.owner_before(__y);
    }

    bool operator()(weak_ptr<_Tp> const &__x, shared_ptr<_Tp> const &__y) const throw()
    {
        return __x.owner_before(__y);
    }
};
template <class _Tp>
class enable_shared_from_this
{
    mutable weak_ptr<_Tp> __weak_this_;

protected:
    enable_shared_from_this() throw() {}

    enable_shared_from_this(enable_shared_from_this const &) throw() {}

    enable_shared_from_this &operator=(enable_shared_from_this const &) throw()
    {
        return *this;
    }

    ~enable_shared_from_this() {}

public:
    shared_ptr<_Tp> shared_from_this()
    {
        return shared_ptr<_Tp>(__weak_this_);
    }

    shared_ptr<_Tp const> shared_from_this() const
    {
        return shared_ptr<const _Tp>(__weak_this_);
    }
    template <class _Up>
    friend class shared_ptr;
};
template <class _Tp>
struct hash;
template <class _Tp>
struct hash<shared_ptr<_Tp>>
{
    typedef shared_ptr<_Tp> argument_type;
    typedef size_t result_type;

    size_t operator()(const shared_ptr<_Tp> &__ptr) const throw()
    {
        return hash<typename shared_ptr<_Tp>::element_type *>()(__ptr.get());
    }
};
template <class _CharT, class _Traits, class _Yp>
inline basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os, shared_ptr<_Yp> const &__p);
class __sp_mut
{
    void *__lx;

public:
    void lock() throw();
    void unlock() throw();

private:
    __sp_mut(void *) throw();
    __sp_mut(const __sp_mut &);
    __sp_mut &operator=(const __sp_mut &);
    friend;
};

__sp_mut &__get_sp_mut(const void *);
template <class _Tp>
inline bool
atomic_is_lock_free(const shared_ptr<_Tp> *)
{
    return false;
}
template <class _Tp>

shared_ptr<_Tp>
atomic_load(const shared_ptr<_Tp> *__p)
{
    __sp_mut &__m = __get_sp_mut(__p);
    __m.lock();
    shared_ptr<_Tp> __q = *__p;
    __m.unlock();
    return __q;
}
template <class _Tp>
inline

    shared_ptr<_Tp>
    atomic_load_explicit(const shared_ptr<_Tp> *__p, memory_order)
{
    return atomic_load(__p);
}
template <class _Tp>

void atomic_store(shared_ptr<_Tp> *__p, shared_ptr<_Tp> __r)
{
    __sp_mut &__m = __get_sp_mut(__p);
    __m.lock();
    __p->swap(__r);
    __m.unlock();
}
template <class _Tp>
inline

    void
    atomic_store_explicit(shared_ptr<_Tp> *__p, shared_ptr<_Tp> __r, memory_order)
{
    atomic_store(__p, __r);
}
template <class _Tp>

shared_ptr<_Tp>
atomic_exchange(shared_ptr<_Tp> *__p, shared_ptr<_Tp> __r)
{
    __sp_mut &__m = __get_sp_mut(__p);
    __m.lock();
    __p->swap(__r);
    __m.unlock();
    return __r;
}
template <class _Tp>
inline

    shared_ptr<_Tp>
    atomic_exchange_explicit(shared_ptr<_Tp> *__p, shared_ptr<_Tp> __r, memory_order)
{
    return atomic_exchange(__p, __r);
}
template <class _Tp>

bool atomic_compare_exchange_strong(shared_ptr<_Tp> *__p, shared_ptr<_Tp> *__v, shared_ptr<_Tp> __w)
{
    shared_ptr<_Tp> __temp;
    __sp_mut &__m = __get_sp_mut(__p);
    __m.lock();
    if (__p->__owner_equivalent(*__v))
    {
        std::swap(__temp, *__p);
        *__p = __w;
        __m.unlock();
        return true;
    }
    std::swap(__temp, *__v);
    *__v = *__p;
    __m.unlock();
    return false;
}
template <class _Tp>
inline

    bool
    atomic_compare_exchange_weak(shared_ptr<_Tp> *__p, shared_ptr<_Tp> *__v, shared_ptr<_Tp> __w)
{
    return atomic_compare_exchange_strong(__p, __v, __w);
}
template <class _Tp>
inline

    bool
    atomic_compare_exchange_strong_explicit(shared_ptr<_Tp> *__p, shared_ptr<_Tp> *__v,
                                            shared_ptr<_Tp> __w, memory_order, memory_order)
{
    return atomic_compare_exchange_strong(__p, __v, __w);
}
template <class _Tp>
inline

    bool
    atomic_compare_exchange_weak_explicit(shared_ptr<_Tp> *__p, shared_ptr<_Tp> *__v,
                                          shared_ptr<_Tp> __w, memory_order, memory_order)
{
    return atomic_compare_exchange_weak(__p, __v, __w);
}
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>

pair<_Tp *, ptrdiff_t>
get_temporary_buffer(ptrdiff_t __n) throw()
{
    pair<_Tp *, ptrdiff_t> __r(0, 0);
    const ptrdiff_t __m = (~ptrdiff_t(0) ^
                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * 8 - 1))) /
                          sizeof(_Tp);
    if (__n > __m)
        __n = __m;
    while (__n > 0)
    {
        if (__is_overaligned_for_new(_Alignof(_Tp)))
        {
            return __r;
        }
        __r.first = static_cast<_Tp *>(::operator new(__n * sizeof(_Tp), nothrow));
        if (__r.first)
        {
            __r.second = __n;
            break;
        }
        __n /= 2;
    }
    return __r;
}
template <class _Tp>
inline void return_temporary_buffer(_Tp *__p) throw()
{
    std::__libcpp_deallocate_unsized((void *)__p, _Alignof(_Tp));
}
struct __return_temporary_buffer
{
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    template <class _Tp>
    ;
}
#pragma GCC diagnostic pop
};
}
}
namespace std
{
inline namespace __1
{
struct __destruct_n
{
private:
    size_t __size_;
    template <class _Tp>

    {
        for (size_t __i = 0; __i < __size_; ++__i, ++__p)
            __p->~_Tp();
    }
    template <class _Tp>

    {}

    {
        ++__size_;
    }

    {}

    {
        __size_ = __s;
    }

    {
    }

public:
        : __size_(__s) {}
        template <class _Tp>

        {
            __incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());
        }
        template <class _Tp>

        {
            __set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());
        }
        template <class _Tp>

        {
            __process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());
        }
};
;
template <typename _Alloc, typename _Traits = allocator_traits<_Alloc>>
struct __noexcept_move_assign_container : public integral_constant<bool,
                                                                   _Traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<_Alloc>::value>
{
};
template <class _Tp, class _Alloc>
struct __temp_value
{
        typedef allocator_traits<_Alloc> _Traits;
        typename aligned_storage<sizeof(_Tp), _Alignof(_Tp)>::type __v;
        _Alloc &__a;
        _Tp *__addr()
        {
            return reinterpret_cast<_Tp *>(std::addressof(__v));
        }
        _Tp &get() { return *__addr(); }
        template <class... _Args>

        __temp_value(_Alloc &__alloc, _Args &&...__args) : __a(__alloc)
        {
            _Traits::construct(__a, __addr(), std::forward<_Args>(__args)...);
        }
        ~__temp_value() { _Traits::destroy(__a, __addr()); }
};
template <typename _Alloc, typename = void, typename = void>
struct __is_allocator : false_type
{
};
template <typename _Alloc>
struct __is_allocator<_Alloc,
                      typename __void_t<typename _Alloc::value_type>::type,
                      typename __void_t<__decltype(declval<_Alloc &>().allocate(size_t(0)))>::type>
    : true_type
{
};
struct __builtin_new_allocator
{
        struct __builtin_new_deleter
        {
            typedef void *pointer_type;
            explicit __builtin_new_deleter(size_t __size, size_t __align)
                : __size_(__size), __align_(__align) {}
            void operator()(void *__p) const throw()
            {
                std::__libcpp_deallocate(__p, __size_, __align_);
            }

        private:
            size_t __size_;
            size_t __align_;
        };
        typedef unique_ptr<void, __builtin_new_deleter> __holder_t;
        static __holder_t __allocate_bytes(size_t __s, size_t __align)
        {
            return __holder_t(std::__libcpp_allocate(__s, __align),
                              __builtin_new_deleter(__s, __align));
        }
        static void __deallocate_bytes(void *__p, size_t __s,
                                       size_t __align) throw()
        {
            std::__libcpp_deallocate(__p, __s, __align);
        }
        template <class _Tp>

        static __holder_t __allocate_type(size_t __n)
        {
            return __allocate_bytes(__n * sizeof(_Tp), _Alignof(_Tp));
        }
        template <class _Tp>

        static void __deallocate_type(void *__p, size_t __n) throw()
        {
            __deallocate_bytes(__p, __n * sizeof(_Tp), _Alignof(_Tp));
        }
};
}
}
extern "C"
{
void __assert_rtn(const char *, const char *, int, const char *);
}

namespace std
{
inline namespace __1
{
template <class _CharT, class _Traits = char_traits<_CharT>>
class basic_string_view;
typedef basic_string_view<char> string_view;
typedef basic_string_view<char16_t> u16string_view;
typedef basic_string_view<char32_t> u32string_view;
typedef basic_string_view<wchar_t> wstring_view;
}
}
namespace std
{
inline namespace __1
{
inline int __libcpp_ctz(unsigned __x) throw() { return __builtin_ctz(__x); }
inline int __libcpp_ctz(unsigned long __x) throw() { return __builtin_ctzl(__x); }
inline int __libcpp_ctz(unsigned long long __x) throw() { return __builtin_ctzll(__x); }
inline int __libcpp_clz(unsigned __x) throw() { return __builtin_clz(__x); }
inline int __libcpp_clz(unsigned long __x) throw() { return __builtin_clzl(__x); }
inline int __libcpp_clz(unsigned long long __x) throw() { return __builtin_clzll(__x); }
inline int __libcpp_clz(__uint128_t __x) throw()
{
        return ((__x >> 64) == 0)
                   ? (64 + __builtin_clzll(static_cast<unsigned long long>(__x)))
                   : __builtin_clzll(static_cast<unsigned long long>(__x >> 64));
}
inline int __libcpp_popcount(unsigned __x) throw() { return __builtin_popcount(__x); }
inline int __libcpp_popcount(unsigned long __x) throw() { return __builtin_popcountl(__x); }
inline int __libcpp_popcount(unsigned long long __x) throw() { return __builtin_popcountll(__x); }
}
}
extern "C"
{
void __assert_rtn(const char *, const char *, int, const char *);
}
namespace std
{
inline namespace __1
{
template <class _Iter, class _Sent, class _BinaryPredicate>
_Iter __adjacent_find(_Iter __first, _Sent __last, _BinaryPredicate &&__pred)
{
        if (__first == __last)
            return __first;
        _Iter __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__first, *__i))
                return __first;
            __first = __i;
        }
        return __i;
}
template <class _ForwardIterator, class _BinaryPredicate>
inline _ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)
{
        return std::__adjacent_find(std::move(__first), std::move(__last), __pred);
}
template <class _ForwardIterator>
inline _ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
{
        typedef typename iterator_traits<_ForwardIterator>::value_type __v;
        return std::adjacent_find(std::move(__first), std::move(__last), __equal_to<__v>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _InputIterator, class _Predicate>
inline bool
all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
        for (; __first != __last; ++__first)
            if (!__pred(*__first))
                return false;
        return true;
}
}
}
namespace std
{
inline namespace __1
{
template <class _InputIterator, class _Predicate>
inline bool
any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
        for (; __first != __last; ++__first)
            if (__pred(*__first))
                return true;
        return false;
}
}
}
namespace std
{
inline namespace __1
{
template <typename _Integral>

typename enable_if<
    is_integral<_Integral>::value,
    _Integral>::type
__half_positive(_Integral __value)
{
        return static_cast<_Integral>(static_cast<typename make_unsigned<_Integral>::type>(__value) / 2);
}
template <typename _Tp>

typename enable_if<
    !is_integral<_Tp>::value,
    _Tp>::type
__half_positive(_Tp __value)
{
        return __value / 2;
}
}
}
namespace std
{
inline namespace __1
{
template <class _AlgPolicy, class _Iter, class _Sent, class _Type, class _Proj, class _Comp>

_Iter __lower_bound_impl(_Iter __first, _Sent __last, const _Type &__value, _Comp &__comp, _Proj &__proj)
{
        auto __len = _IterOps<_AlgPolicy>::distance(__first, __last);
        while (__len != 0)
        {
            auto __l2 = std::__half_positive(__len);
            _Iter __m = __first;
            _IterOps<_AlgPolicy>::advance(__m, __l2);
            if (std::__invoke(__comp, std::__invoke(__proj, *__m), __value))
            {
                __first = ++__m;
                __len -= __l2 + 1;
            }
            else
            {
                __len = __l2;
            }
        }
        return __first;
}
template <class _ForwardIterator, class _Tp, class _Compare>
inline _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value, _Compare __comp)
{
        _Static_assert(__is_callable<_Compare, __decltype(*__first), const _Tp &>::value, "The comparator has to be callable");
        auto __proj = std::__identity();
        return std::__lower_bound_impl<_ClassicAlgPolicy>(__first, __last, __value, __comp, __proj);
}
template <class _ForwardIterator, class _Tp>
inline _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)
{
        return std::lower_bound(__first, __last, __value,
                                __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _ForwardIterator, class _Tp, class _Compare>
inline

    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value, _Compare __comp)
{
        using _Comp_ref = typename __comp_ref_type<_Compare>::type;
        __first = std::lower_bound<_ForwardIterator, _Tp, _Comp_ref>(__first, __last, __value, __comp);
        return __first != __last && !__comp(__value, *__first);
}
template <class _ForwardIterator, class _Tp>
inline

    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)
{
        return std::binary_search(__first, __last, __value,
                                  __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
template <class _AlgPolicy, class _InputIterator, class _OutputIterator,
          __enable_if_t<is_same<_AlgPolicy, _ClassicAlgPolicy>::value, int> = 0>
inline pair<_InputIterator, _OutputIterator>
__copy_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
        auto __ret = std::__copy(
            __unconstrained_reverse_iterator<_InputIterator>(__last),
            __unconstrained_reverse_iterator<_InputIterator>(__first),
            __unconstrained_reverse_iterator<_OutputIterator>(__result));
        return pair<_InputIterator, _OutputIterator>(__ret.first.base(), __ret.second.base());
}
template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline _BidirectionalIterator2
copy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last, _BidirectionalIterator2 __result)
{
        return std::__copy_backward<_ClassicAlgPolicy>(__first, __last, __result).second;
}
}
}
namespace std
{
inline namespace __1
{
template <class _InputIterator, class _OutputIterator, class _Predicate>
inline _OutputIterator
copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result, _Predicate __pred)
{
        for (; __first != __last; ++__first)
        {
            if (__pred(*__first))
            {
                *__result = *__first;
                ++__result;
            }
        }
        return __result;
}
}
}

namespace std
{
inline namespace __1
{
template <class _InputIterator, class _Tp>
inline
    typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp &__value)
{
        typename iterator_traits<_InputIterator>::difference_type __r(0);
        for (; __first != __last; ++__first)
            if (*__first == __value)
                ++__r;
        return __r;
}
}
}
namespace std
{
inline namespace __1
{
template <class _InputIterator, class _Predicate>
inline
    typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
        typename iterator_traits<_InputIterator>::difference_type __r(0);
        for (; __first != __last; ++__first)
            if (__pred(*__first))
                ++__r;
        return __r;
}
}
}
namespace std
{
inline namespace __1
{
template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)
{
        for (; __first1 != __last1; ++__first1, (void)++__first2)
            if (!__pred(*__first1, *__first2))
                return false;
        return true;
}
template <class _InputIterator1, class _InputIterator2>
inline bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
{
        typedef typename iterator_traits<_InputIterator1>::value_type __v1;
        typedef typename iterator_traits<_InputIterator2>::value_type __v2;
        return std::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _AlgPolicy, class _Compare, class _Iter, class _Sent, class _Tp, class _Proj>
_Iter __upper_bound(_Iter __first, _Sent __last, const _Tp &__value, _Compare &&__comp, _Proj &&__proj)
{
        auto __len = _IterOps<_AlgPolicy>::distance(__first, __last);
        while (__len != 0)
        {
            auto __half_len = std::__half_positive(__len);
            auto __mid = _IterOps<_AlgPolicy>::next(__first, __half_len);
            if (std::__invoke(__comp, __value, std::__invoke(__proj, *__mid)))
                __len = __half_len;
            else
            {
                __first = ++__mid;
                __len -= __half_len + 1;
            }
        }
        return __first;
}
template <class _ForwardIterator, class _Tp, class _Compare>
inline _ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value, _Compare __comp)
{
        _Static_assert(is_copy_constructible<_ForwardIterator>::value, "Iterator has to be copy constructible");
        return std::__upper_bound<_ClassicAlgPolicy>(
            std::move(__first), std::move(__last), __value, std::move(__comp), std::__identity());
}
template <class _ForwardIterator, class _Tp>
inline _ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)
{
        return std::upper_bound(
            std::move(__first),
            std::move(__last),
            __value,
            __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _AlgPolicy, class _Compare, class _Iter, class _Sent, class _Tp, class _Proj>
pair<_Iter, _Iter>
__equal_range(_Iter __first, _Sent __last, const _Tp &__value, _Compare &&__comp, _Proj &&__proj)
{
        auto __len = _IterOps<_AlgPolicy>::distance(__first, __last);
        _Iter __end = _IterOps<_AlgPolicy>::next(__first, __last);
        while (__len != 0)
        {
            auto __half_len = std::__half_positive(__len);
            _Iter __mid = _IterOps<_AlgPolicy>::next(__first, __half_len);
            if (std::__invoke(__comp, std::__invoke(__proj, *__mid), __value))
            {
                __first = ++__mid;
                __len -= __half_len + 1;
            }
            else if (std::__invoke(__comp, __value, std::__invoke(__proj, *__mid)))
            {
                __end = __mid;
                __len = __half_len;
            }
            else
            {
                _Iter __mp1 = __mid;
                return pair<_Iter, _Iter>(
                    std::__lower_bound_impl<_AlgPolicy>(__first, __mid, __value, __comp, __proj),
                    std::__upper_bound<_AlgPolicy>(++__mp1, __end, __value, __comp, __proj));
            }
        }
        return pair<_Iter, _Iter>(__first, __first);
}
template <class _ForwardIterator, class _Tp, class _Compare>
pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value, _Compare __comp)
{
        _Static_assert(__is_callable<_Compare, __decltype(*__first), const _Tp &>::value, "The comparator has to be callable");
        _Static_assert(is_copy_constructible<_ForwardIterator>::value, "Iterator has to be copy constructible");
        typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
        return std::__equal_range<_ClassicAlgPolicy>(
            std::move(__first), std::move(__last), __value, static_cast<_Comp_ref>(__comp), std::__identity());
}
template <class _ForwardIterator, class _Tp>
pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)
{
        return std::equal_range(
            std::move(__first),
            std::move(__last),
            __value,
            __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _ForwardIterator, class _Tp>
inline void
__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value, forward_iterator_tag)
{
        for (; __first != __last; ++__first)
            *__first = __value;
}
template <class _RandomAccessIterator, class _Tp>
inline void
__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp &__value, random_access_iterator_tag)
{
        std::fill_n(__first, __last - __first, __value);
}
template <class _ForwardIterator, class _Tp>
inline void
fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)
{
        std::__fill(__first, __last, __value, typename iterator_traits<_ForwardIterator>::iterator_category());
}
}
}
namespace std
{
inline namespace __1
{
template <class _InputIterator, class _Predicate>
inline _InputIterator
find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
        for (; __first != __last; ++__first)
            if (!__pred(*__first))
                break;
        return __first;
}
}
}
namespace std
{
inline namespace __1
{
template <class _InputIterator, class _Function>
inline _Function for_each(_InputIterator __first,
                          _InputIterator __last,
                          _Function __f)
{
        for (; __first != __last; ++__first)
            __f(*__first);
        return __f;
}
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
template <class _ForwardIterator, class _Generator>
inline void
generate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)
{
        for (; __first != __last; ++__first)
            *__first = __gen();
}
}
}
namespace std
{
inline namespace __1
{
template <class _OutputIterator, class _Size, class _Generator>
inline _OutputIterator
generate_n(_OutputIterator __first, _Size __orig_n, _Generator __gen)
{
        typedef __decltype(std::__convert_to_integral(__orig_n)) _IntegralSize;
        _IntegralSize __n = __orig_n;
        for (; __n > 0; ++__first, (void)--__n)
            *__first = __gen();
        return __first;
}
}
}

namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}

namespace std
{
inline namespace __1
{
template <class _Iter1, class _Sent1, class _Iter2, class _Sent2, class _Comp, class _Proj1, class _Proj2>
bool __includes(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
                _Comp &&__comp, _Proj1 &&__proj1, _Proj2 &&__proj2)
{
        for (; __first2 != __last2; ++__first1)
        {
            if (__first1 == __last1 || std::__invoke(
                                           __comp, std::__invoke(__proj2, *__first2), std::__invoke(__proj1, *__first1)))
                return false;
            if (!std::__invoke(__comp, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
                ++__first2;
        }
        return true;
}
template <class _InputIterator1, class _InputIterator2, class _Compare>
inline bool includes(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _Compare __comp)
{
        _Static_assert(__is_callable<_Compare, __decltype(*__first1), __decltype(*__first2)>::value, "Comparator has to be callable");
        typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
        return std::__includes(
            std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2),
            static_cast<_Comp_ref>(__comp), __identity(), __identity());
}
template <class _InputIterator1, class _InputIterator2>
inline bool
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)
{
        return std::includes(
            std::move(__first1),
            std::move(__last1),
            std::move(__first2),
            std::move(__last2),
            __less<typename iterator_traits<_InputIterator1>::value_type,
                   typename iterator_traits<_InputIterator2>::value_type>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _AlgPolicy, class _InputIterator, class _OutputIterator>
inline _OutputIterator
__move_backward_constexpr(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
        while (__first != __last)
            *--__result = _IterOps<_AlgPolicy>::__iter_move(--__last);
        return __result;
}
template <class _AlgPolicy, class _InputIterator, class _OutputIterator>
inline _OutputIterator
__move_backward_impl(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
        return std::__move_backward_constexpr<_AlgPolicy>(__first, __last, __result);
}
template <class _AlgPolicy, class _Tp, class _Up>
inline
    typename enable_if<
        is_same<typename remove_const<_Tp>::type, _Up>::value &&
            is_trivially_move_assignable<_Up>::value,
        _Up *>::type
    __move_backward_impl(_Tp *__first, _Tp *__last, _Up *__result)
{
        const size_t __n = static_cast<size_t>(__last - __first);
        if (__n > 0)
        {
            __result -= __n;
            std::memmove(__result, __first, __n * sizeof(_Up));
        }
        return __result;
}
template <class _AlgPolicy, class _BidirectionalIterator1, class _BidirectionalIterator2>
inline _BidirectionalIterator2
__move_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
                _BidirectionalIterator2 __result)
{
        if (__libcpp_is_constant_evaluated())
        {
            return std::__move_backward_constexpr<_AlgPolicy>(__first, __last, __result);
        }
        else
        {
            return std::__rewrap_iter(__result,
                                      std::__move_backward_impl<_AlgPolicy>(std::__unwrap_iter(__first),
                                                                            std::__unwrap_iter(__last),
                                                                            std::__unwrap_iter(__result)));
        }
}
template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline _BidirectionalIterator2
move_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result)
{
        return std::__move_backward<_ClassicAlgPolicy>(std::move(__first), std::move(__last), std::move(__result));
}
}
}
namespace std
{
inline namespace __1
{
template <class _AlgPolicy, class _ForwardIterator1, class _Sentinel1, class _ForwardIterator2, class _Sentinel2>

pair<_ForwardIterator1, _ForwardIterator2>
__swap_ranges(_ForwardIterator1 __first1, _Sentinel1 __last1, _ForwardIterator2 __first2, _Sentinel2 __last2)
{
        while (__first1 != __last1 && __first2 != __last2)
        {
            _IterOps<_AlgPolicy>::iter_swap(__first1, __first2);
            ++__first1;
            ++__first2;
        }
        return pair<_ForwardIterator1, _ForwardIterator2>(std::move(__first1), std::move(__first2));
}
template <class _AlgPolicy, class _ForwardIterator1, class _Sentinel1, class _ForwardIterator2>

pair<_ForwardIterator1, _ForwardIterator2>
__swap_ranges(_ForwardIterator1 __first1, _Sentinel1 __last1, _ForwardIterator2 __first2)
{
        while (__first1 != __last1)
        {
            _IterOps<_AlgPolicy>::iter_swap(__first1, __first2);
            ++__first1;
            ++__first2;
        }
        return pair<_ForwardIterator1, _ForwardIterator2>(std::move(__first1), std::move(__first2));
}
template <class _ForwardIterator1, class _ForwardIterator2>
inline _ForwardIterator2
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)
{
        return std::__swap_ranges<_ClassicAlgPolicy>(
                   std::move(__first1), std::move(__last1), std::move(__first2))
            .second;
}
}
}
namespace std
{
inline namespace __1
{
template <class _AlgPolicy, class _ForwardIterator>
_ForwardIterator
__rotate_left(_ForwardIterator __first, _ForwardIterator __last)
{
        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
        using _Ops = _IterOps<_AlgPolicy>;
        value_type __tmp = _Ops::__iter_move(__first);
        _ForwardIterator __lm1 = std::__move<_AlgPolicy>(
                                     _Ops::next(__first), __last, __first)
                                     .second;
        *__lm1 = std::move(__tmp);
        return __lm1;
}
template <class _AlgPolicy, class _BidirectionalIterator>
_BidirectionalIterator
__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
        using _Ops = _IterOps<_AlgPolicy>;
        _BidirectionalIterator __lm1 = _Ops::prev(__last);
        value_type __tmp = _Ops::__iter_move(__lm1);
        _BidirectionalIterator __fp1 = std::__move_backward<_AlgPolicy>(__first, __lm1, std::move(__last));
        *__first = std::move(__tmp);
        return __fp1;
}
template <class _AlgPolicy, class _ForwardIterator>
_ForwardIterator
__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
        _ForwardIterator __i = __middle;
        while (true)
        {
            _IterOps<_AlgPolicy>::iter_swap(__first, __i);
            ++__first;
            if (++__i == __last)
                break;
            if (__first == __middle)
                __middle = __i;
        }
        _ForwardIterator __r = __first;
        if (__first != __middle)
        {
            __i = __middle;
            while (true)
            {
                _IterOps<_AlgPolicy>::iter_swap(__first, __i);
                ++__first;
                if (++__i == __last)
                {
                    if (__first == __middle)
                        break;
                    __i = __middle;
                }
                else if (__first == __middle)
                    __middle = __i;
            }
        }
        return __r;
}
template <typename _Integral>
inline _Integral
__algo_gcd(_Integral __x, _Integral __y)
{
        do
        {
            _Integral __t = __x % __y;
            __x = __y;
            __y = __t;
        } while (__y);
        return __x;
}
template <class _AlgPolicy, typename _RandomAccessIterator>
_RandomAccessIterator
__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
        typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
        typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
        using _Ops = _IterOps<_AlgPolicy>;
        const difference_type __m1 = __middle - __first;
        const difference_type __m2 = _Ops::distance(__middle, __last);
        if (__m1 == __m2)
        {
            std::__swap_ranges<_AlgPolicy>(__first, __middle, __middle, __last);
            return __middle;
        }
        const difference_type __g = std::__algo_gcd(__m1, __m2);
        for (_RandomAccessIterator __p = __first + __g; __p != __first;)
        {
            value_type __t(_Ops::__iter_move(--__p));
            _RandomAccessIterator __p1 = __p;
            _RandomAccessIterator __p2 = __p1 + __m1;
            do
            {
                *__p1 = _Ops::__iter_move(__p2);
                __p1 = __p2;
                const difference_type __d = _Ops::distance(__p2, __last);
                if (__m1 < __d)
                    __p2 += __m1;
                else
                    __p2 = __first + (__m1 - __d);
            } while (__p2 != __p);
            *__p1 = std::move(__t);
        }
        return __first + __m2;
}
template <class _AlgPolicy, class _ForwardIterator>
inline _ForwardIterator
__rotate_impl(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,
              std::forward_iterator_tag)
{
        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
        if (is_trivially_move_assignable<value_type>::value)
        {
            if (_IterOps<_AlgPolicy>::next(__first) == __middle)
                return std::__rotate_left<_AlgPolicy>(__first, __last);
        }
        return std::__rotate_forward<_AlgPolicy>(__first, __middle, __last);
}
template <class _AlgPolicy, class _BidirectionalIterator>
inline _BidirectionalIterator
__rotate_impl(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
              bidirectional_iterator_tag)
{
        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
        if (is_trivially_move_assignable<value_type>::value)
        {
            if (_IterOps<_AlgPolicy>::next(__first) == __middle)
                return std::__rotate_left<_AlgPolicy>(__first, __last);
            if (_IterOps<_AlgPolicy>::next(__middle) == __last)
                return std::__rotate_right<_AlgPolicy>(__first, __last);
        }
        return std::__rotate_forward<_AlgPolicy>(__first, __middle, __last);
}
template <class _AlgPolicy, class _RandomAccessIterator>
inline _RandomAccessIterator
__rotate_impl(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
              random_access_iterator_tag)
{
        typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
        if (is_trivially_move_assignable<value_type>::value)
        {
            if (_IterOps<_AlgPolicy>::next(__first) == __middle)
                return std::__rotate_left<_AlgPolicy>(__first, __last);
            if (_IterOps<_AlgPolicy>::next(__middle) == __last)
                return std::__rotate_right<_AlgPolicy>(__first, __last);
            return std::__rotate_gcd<_AlgPolicy>(__first, __middle, __last);
        }
        return std::__rotate_forward<_AlgPolicy>(__first, __middle, __last);
}
template <class _AlgPolicy, class _Iterator, class _Sentinel>

pair<_Iterator, _Iterator>
__rotate(_Iterator __first, _Iterator __middle, _Sentinel __last)
{
        using _Ret = pair<_Iterator, _Iterator>;
        _Iterator __last_iter = _IterOps<_AlgPolicy>::next(__middle, __last);
        if (__first == __middle)
            return _Ret(__last_iter, __last_iter);
        if (__middle == __last)
            return _Ret(std::move(__first), std::move(__last_iter));
        using _IterCategory = typename _IterOps<_AlgPolicy>::template __iterator_category<_Iterator>;
        auto __result = std::__rotate_impl<_AlgPolicy>(
            std::move(__first), std::move(__middle), __last_iter, _IterCategory());
        return _Ret(std::move(__result), std::move(__last_iter));
}
template <class _ForwardIterator>
inline _ForwardIterator
rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
        return std::__rotate<_ClassicAlgPolicy>(
                   std::move(__first), std::move(__middle), std::move(__last))
            .first;
}
}
}
extern "C"
{
void __assert_rtn(const char *, const char *, int, const char *);
}

namespace std
{
inline namespace __1
{
template <class _Predicate>
class __invert
{
    private:
        _Predicate __p_;

    public:
        {
        }

        explicit __invert(_Predicate __p) : __p_(__p) {}
        template <class _T1>

        bool operator()(const _T1 &__x)
        {
            return !__p_(__x);
        }
        template <class _T1, class _T2>

        bool operator()(const _T1 &__x, const _T2 &__y)
        {
            return __p_(__y, __x);
        }
};
template <class _AlgPolicy, class _Compare, class _InputIterator1, class _Sent1,
          class _InputIterator2, class _Sent2, class _OutputIterator>
void __half_inplace_merge(_InputIterator1 __first1, _Sent1 __last1,
                          _InputIterator2 __first2, _Sent2 __last2,
                          _OutputIterator __result, _Compare &&__comp)
{
        for (; __first1 != __last1; ++__result)
        {
            if (__first2 == __last2)
            {
                std::__move<_AlgPolicy>(__first1, __last1, __result);
                return;
            }
            if (__comp(*__first2, *__first1))
            {
                *__result = _IterOps<_AlgPolicy>::__iter_move(__first2);
                ++__first2;
            }
            else
            {
                *__result = _IterOps<_AlgPolicy>::__iter_move(__first1);
                ++__first1;
            }
        }
}
template <class _AlgPolicy, class _Compare, class _BidirectionalIterator>
void __buffered_inplace_merge(
    _BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare &&__comp,
    typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
    typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
    typename iterator_traits<_BidirectionalIterator>::value_type *__buff)
{
        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n &> __h2(__buff, __d);
        if (__len1 <= __len2)
        {
            value_type *__p = __buff;
            for (_BidirectionalIterator __i = __first; __i != __middle; __d.template __incr<value_type>(), (void)++__i, (void)++__p)
                ::new ((void *)__p) value_type(_IterOps<_AlgPolicy>::__iter_move(__i));
            std::__half_inplace_merge<_AlgPolicy>(__buff, __p, __middle, __last, __first, __comp);
        }
        else
        {
            value_type *__p = __buff;
            for (_BidirectionalIterator __i = __middle; __i != __last; __d.template __incr<value_type>(), (void)++__i, (void)++__p)
                ::new ((void *)__p) value_type(_IterOps<_AlgPolicy>::__iter_move(__i));
            typedef __unconstrained_reverse_iterator<_BidirectionalIterator> _RBi;
            typedef __unconstrained_reverse_iterator<value_type *> _Rv;
            typedef __invert<_Compare> _Inverted;
            std::__half_inplace_merge<_AlgPolicy>(_Rv(__p), _Rv(__buff),
                                                  _RBi(__middle), _RBi(__first),
                                                  _RBi(__last), _Inverted(__comp));
        }
}
template <class _AlgPolicy, class _Compare, class _BidirectionalIterator>
void __inplace_merge(
    _BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare &&__comp,
    typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
    typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
    typename iterator_traits<_BidirectionalIterator>::value_type *__buff,
    ptrdiff_t __buff_size)
{
        using _Ops = _IterOps<_AlgPolicy>;
        typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
        while (true)
        {
            if (__len2 == 0)
                return;
            if (__len1 <= __buff_size || __len2 <= __buff_size)
                return std::__buffered_inplace_merge<_AlgPolicy>(__first, __middle, __last, __comp, __len1, __len2, __buff);
            for (; true; ++__first, (void)--__len1)
            {
                if (__len1 == 0)
                    return;
                if (__comp(*__middle, *__first))
                    break;
            }
            _BidirectionalIterator __m1;
            _BidirectionalIterator __m2;
            difference_type __len11;
            difference_type __len21;
            if (__len1 < __len2)
            {
                __len21 = __len2 / 2;
                __m2 = __middle;
                _Ops::advance(__m2, __len21);
                __m1 = std::__upper_bound<_AlgPolicy>(__first, __middle, *__m2, __comp, std::__identity());
                __len11 = _Ops::distance(__first, __m1);
            }
            else
            {
                if (__len1 == 1)
                {
                    _Ops::iter_swap(__first, __middle);
                    return;
                }
                __len11 = __len1 / 2;
                __m1 = __first;
                _Ops::advance(__m1, __len11);
                __m2 = std::lower_bound(__middle, __last, *__m1, __comp);
                __len21 = _Ops::distance(__middle, __m2);
            }
            difference_type __len12 = __len1 - __len11;
            difference_type __len22 = __len2 - __len21;
            __middle = std::__rotate<_AlgPolicy>(__m1, __middle, __m2).first;
            if (__len11 + __len21 < __len12 + __len22)
            {
                std::__inplace_merge<_AlgPolicy>(
                    __first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);
                __first = __middle;
                __middle = __m2;
                __len1 = __len12;
                __len2 = __len22;
            }
            else
            {
                std::__inplace_merge<_AlgPolicy>(
                    __middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);
                __last = __middle;
                __middle = __m1;
                __len1 = __len11;
                __len2 = __len21;
            }
        }
}
template <class _AlgPolicy, class _BidirectionalIterator, class _Compare>

void __inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
                     _Compare &&__comp)
{
        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
        typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
        difference_type __len1 = _IterOps<_AlgPolicy>::distance(__first, __middle);
        difference_type __len2 = _IterOps<_AlgPolicy>::distance(__middle, __last);
        difference_type __buf_size = std::min(__len1, __len2);
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
        pair<value_type *, ptrdiff_t> __buf = std::get_temporary_buffer<value_type>(__buf_size);
#pragma GCC diagnostic pop
        unique_ptr<value_type, __return_temporary_buffer> __h(__buf.first);
        return std::__inplace_merge<_AlgPolicy>(
            std::move(__first), std::move(__middle), std::move(__last), __comp, __len1, __len2, __buf.first, __buf.second);
}
template <class _BidirectionalIterator, class _Compare>
inline void inplace_merge(
    _BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Compare __comp)
{
        typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
        std::__inplace_merge<_ClassicAlgPolicy>(
            std::move(__first), std::move(__middle), std::move(__last), static_cast<_Comp_ref>(__comp));
}
template <class _BidirectionalIterator>
inline void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)
{
        std::inplace_merge(std::move(__first), std::move(__middle), std::move(__last),
                           __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _Compare, class _RandomAccessIterator>
_RandomAccessIterator
__is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare &&__comp)
{
        typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
        difference_type __len = __last - __first;
        difference_type __p = 0;
        difference_type __c = 1;
        _RandomAccessIterator __pp = __first;
        while (__c < __len)
        {
            _RandomAccessIterator __cp = __first + __c;
            if (__comp(*__pp, *__cp))
                return __cp;
            ++__c;
            ++__cp;
            if (__c == __len)
                return __last;
            if (__comp(*__pp, *__cp))
                return __cp;
            ++__p;
            ++__pp;
            __c = 2 * __p + 1;
        }
        return __last;
}
template <class _RandomAccessIterator, class _Compare>
inline _RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
        typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
        return std::__is_heap_until(__first, __last, static_cast<_Comp_ref>(__comp));
}
template <class _RandomAccessIterator>
inline _RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
        return std::__is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _RandomAccessIterator, class _Compare>
inline

    bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
        typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
        return std::__is_heap_until(__first, __last, static_cast<_Comp_ref>(__comp)) == __last;
}
template <class _RandomAccessIterator>
inline

    bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
        return std::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}
}
}

namespace std
{
inline namespace __1
{
template <class _InputIterator, class _Predicate>
bool is_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
        for (; __first != __last; ++__first)
            if (!__pred(*__first))
                break;
        if (__first == __last)
            return true;
        ++__first;
        for (; __first != __last; ++__first)
            if (__pred(*__first))
                return false;
        return true;
}
}
}
namespace std
{
inline namespace __1
{
template <class _Iter1, class _Sent1, class _Iter2, class _Sent2, class = void>
struct _ConstTimeDistance : false_type
{
};
template <class _Iter1, class _Iter2>
struct _ConstTimeDistance<_Iter1, _Iter1, _Iter2, _Iter2, __enable_if_t<is_same<typename iterator_traits<_Iter1>::iterator_category, random_access_iterator_tag>::value && is_same<typename iterator_traits<_Iter2>::iterator_category, random_access_iterator_tag>::value>> : true_type
{
};
template <class _AlgPolicy,
          class _Iter1, class _Sent1, class _Iter2, class _Sent2,
          class _Proj1, class _Proj2, class _Pred>
bool __is_permutation_impl(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
                           _Pred &&__pred, _Proj1 &&__proj1, _Proj2 &&__proj2)
{
        using _D1 = __iter_diff_t<_Iter1>;
        for (auto __i = __first1; __i != __last1; ++__i)
        {
            auto __match = __first1;
            for (; __match != __i; ++__match)
            {
                if (std::__invoke(__pred, std::__invoke(__proj1, *__match), std::__invoke(__proj1, *__i)))
                    break;
            }
            if (__match == __i)
            {
                _D1 __c2 = 0;
                for (auto __j = __first2; __j != __last2; ++__j)
                {
                    if (std::__invoke(__pred, std::__invoke(__proj1, *__i), std::__invoke(__proj2, *__j)))
                        ++__c2;
                }
                if (__c2 == 0)
                    return false;
                _D1 __c1 = 1;
                for (auto __j = _IterOps<_AlgPolicy>::next(__i); __j != __last1; ++__j)
                {
                    if (std::__invoke(__pred, std::__invoke(__proj1, *__i), std::__invoke(__proj1, *__j)))
                        ++__c1;
                }
                if (__c1 != __c2)
                    return false;
            }
        }
        return true;
}
template <class _AlgPolicy, class _ForwardIterator1, class _Sentinel1, class _ForwardIterator2, class _BinaryPredicate>
bool __is_permutation(_ForwardIterator1 __first1, _Sentinel1 __last1, _ForwardIterator2 __first2,
                      _BinaryPredicate &&__pred)
{
        for (; __first1 != __last1; ++__first1, (void)++__first2)
        {
            if (!__pred(*__first1, *__first2))
                break;
        }
        if (__first1 == __last1)
            return true;
        using _D1 = __iter_diff_t<_ForwardIterator1>;
        _D1 __l1 = _IterOps<_AlgPolicy>::distance(__first1, __last1);
        if (__l1 == _D1(1))
            return false;
        auto __last2 = _IterOps<_AlgPolicy>::next(__first2, __l1);
        return std::__is_permutation_impl<_AlgPolicy>(
            std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2),
            __pred, __identity(), __identity());
}
template <class _AlgPolicy,
          class _Iter1, class _Sent1, class _Iter2, class _Sent2,
          class _Proj1, class _Proj2, class _Pred>
bool __is_permutation(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
                      _Pred &&__pred, _Proj1 &&__proj1, _Proj2 &&__proj2,
                      false_type)
{
        while (__first1 != __last1 && __first2 != __last2)
        {
            if (!std::__invoke(__pred, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
                break;
            ++__first1;
            ++__first2;
        }
        if (__first1 == __last1)
            return __first2 == __last2;
        if (__first2 == __last2)
            return false;
        using _D1 = __iter_diff_t<_Iter1>;
        _D1 __l1 = _IterOps<_AlgPolicy>::distance(__first1, __last1);
        using _D2 = __iter_diff_t<_Iter2>;
        _D2 __l2 = _IterOps<_AlgPolicy>::distance(__first2, __last2);
        if (__l1 != __l2)
            return false;
        return std::__is_permutation_impl<_AlgPolicy>(
            std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2),
            __pred, __proj1, __proj2);
}
template <class _AlgPolicy,
          class _Iter1, class _Sent1, class _Iter2, class _Sent2,
          class _Proj1, class _Proj2, class _Pred>
bool __is_permutation(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
                      _Pred &&__pred, _Proj1 &&__proj1, _Proj2 &&__proj2,
                      true_type)
{
        if (std::distance(__first1, __last1) != std::distance(__first2, __last2))
            return false;
        return std::__is_permutation<_AlgPolicy>(
            std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2),
            __pred, __proj1, __proj2,
            false_type());
}
template <class _AlgPolicy,
          class _Iter1, class _Sent1, class _Iter2, class _Sent2,
          class _Proj1, class _Proj2, class _Pred>
bool __is_permutation(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
                      _Pred &&__pred, _Proj1 &&__proj1, _Proj2 &&__proj2)
{
        return std::__is_permutation<_AlgPolicy>(
            std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2),
            __pred, __proj1, __proj2,
            _ConstTimeDistance<_Iter1, _Sent1, _Iter2, _Sent2>());
}
template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
bool is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                    _BinaryPredicate __pred)
{
        _Static_assert(__is_callable<_BinaryPredicate, __decltype(*__first1), __decltype(*__first2)>::value, "The predicate has to be callable");
        return std::__is_permutation<_ClassicAlgPolicy>(
            std::move(__first1), std::move(__last1), std::move(__first2), __pred);
}
template <class _ForwardIterator1, class _ForwardIterator2>
inline bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)
{
        using __v1 = __iter_value_type<_ForwardIterator1>;
        using __v2 = __iter_value_type<_ForwardIterator2>;
        return std::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _Compare, class _ForwardIterator>
_ForwardIterator
__is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
        if (__first != __last)
        {
            _ForwardIterator __i = __first;
            while (++__i != __last)
            {
                if (__comp(*__i, *__first))
                    return __i;
                __first = __i;
            }
        }
        return __last;
}
template <class _ForwardIterator, class _Compare>
inline _ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
        typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
        return std::__is_sorted_until<_Comp_ref>(__first, __last, __comp);
}
template <class _ForwardIterator>
inline _ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
{
        return std::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _ForwardIterator, class _Compare>
inline

    bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
        typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
        return std::__is_sorted_until<_Comp_ref>(__first, __last, __comp) == __last;
}
template <class _ForwardIterator>
inline

    bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last)
{
        return std::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _Compare, class _InputIterator1, class _InputIterator2>
bool __lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                               _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{
        for (; __first2 != __last2; ++__first1, (void)++__first2)
        {
            if (__first1 == __last1 || __comp(*__first1, *__first2))
                return true;
            if (__comp(*__first2, *__first1))
                return false;
        }
        return false;
}
template <class _InputIterator1, class _InputIterator2, class _Compare>
inline

    bool
    lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                            _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{
        typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
        return std::__lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);
}
template <class _InputIterator1, class _InputIterator2>
inline

    bool
    lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                            _InputIterator2 __first2, _InputIterator2 __last2)
{
        return std::lexicographical_compare(__first1, __last1, __first2, __last2,
                                            __less<typename iterator_traits<_InputIterator1>::value_type,
                                                   typename iterator_traits<_InputIterator2>::value_type>());
}
}
}

namespace std
{
inline namespace __1
{
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
void __sift_down(_RandomAccessIterator __first, _Compare &&__comp,
                 typename iterator_traits<_RandomAccessIterator>::difference_type __len,
                 _RandomAccessIterator __start)
{
        using _Ops = _IterOps<_AlgPolicy>;
        typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
        typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
        difference_type __child = __start - __first;
        if (__len < 2 || (__len - 2) / 2 < __child)
            return;
        __child = 2 * __child + 1;
        _RandomAccessIterator __child_i = __first + __child;
        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + difference_type(1))))
        {
            ++__child_i;
            ++__child;
        }
        if (__comp(*__child_i, *__start))
            return;
        value_type __top(_Ops::__iter_move(__start));
        do
        {
            *__start = _Ops::__iter_move(__child_i);
            __start = __child_i;
            if ((__len - 2) / 2 < __child)
                break;
            __child = 2 * __child + 1;
            __child_i = __first + __child;
            if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + difference_type(1))))
            {
                ++__child_i;
                ++__child;
            }
        } while (!__comp(*__child_i, __top));
        *__start = std::move(__top);
}
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
_RandomAccessIterator
__floyd_sift_down(_RandomAccessIterator __first, _Compare &&__comp,
                  typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
        using difference_type = typename iterator_traits<_RandomAccessIterator>::difference_type;
        ((void)0);
        _RandomAccessIterator __hole = __first;
        _RandomAccessIterator __child_i = __first;
        difference_type __child = 0;
        while (true)
        {
            __child_i += difference_type(__child + 1);
            __child = 2 * __child + 1;
            if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + difference_type(1))))
            {
                ++__child_i;
                ++__child;
            }
            *__hole = _IterOps<_AlgPolicy>::__iter_move(__child_i);
            __hole = __child_i;
            if (__child > (__len - 2) / 2)
                return __hole;
        }
}
}
}
namespace std
{
inline namespace __1
{
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
inline void __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare &&__comp)
{
        using _CompRef = typename __comp_ref_type<_Compare>::type;
        _CompRef __comp_ref = __comp;
        using difference_type = typename iterator_traits<_RandomAccessIterator>::difference_type;
        difference_type __n = __last - __first;
        if (__n > 1)
        {
            for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start)
            {
                std::__sift_down<_AlgPolicy>(__first, __comp_ref, __n, __first + __start);
            }
        }
}
template <class _RandomAccessIterator, class _Compare>
inline void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
        std::__make_heap<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __comp);
}
template <class _RandomAccessIterator>
inline void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
        std::make_heap(std::move(__first), std::move(__last),
                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__merge(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
        for (; __first1 != __last1; ++__result)
        {
            if (__first2 == __last2)
                return std::copy(__first1, __last1, __result);
            if (__comp(*__first2, *__first1))
            {
                *__result = *__first2;
                ++__first2;
            }
            else
            {
                *__result = *__first1;
                ++__first1;
            }
        }
        return std::copy(__first2, __last2, __result);
}
template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline _OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
        typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
        return std::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
}
template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline _OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
        typedef typename iterator_traits<_InputIterator1>::value_type __v1;
        typedef typename iterator_traits<_InputIterator2>::value_type __v2;
        return std::merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());
}
}
}

namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
template <class _Comp, class _Proj>
class _MinmaxElementLessFunc
{
        _Comp &__comp_;
        _Proj &__proj_;

    public:
        _MinmaxElementLessFunc(_Comp &__comp, _Proj &__proj) : __comp_(__comp), __proj_(__proj) {}
        template <class _Iter>

        bool operator()(_Iter &__it1, _Iter &__it2)
        {
            return std::__invoke(__comp_, std::__invoke(__proj_, *__it1), std::__invoke(__proj_, *__it2));
        }
};
template <class _Iter, class _Sent, class _Proj, class _Comp>

pair<_Iter, _Iter> __minmax_element_impl(_Iter __first, _Sent __last, _Comp &__comp, _Proj &__proj)
{
        auto __less = _MinmaxElementLessFunc<_Comp, _Proj>(__comp, __proj);
        pair<_Iter, _Iter> __result(__first, __first);
        if (__first == __last || ++__first == __last)
            return __result;
        if (__less(__first, __result.first))
            __result.first = __first;
        else
            __result.second = __first;
        while (++__first != __last)
        {
            _Iter __i = __first;
            if (++__first == __last)
            {
                if (__less(__i, __result.first))
                    __result.first = __i;
                else if (!__less(__i, __result.second))
                    __result.second = __i;
                return __result;
            }
            if (__less(__first, __i))
            {
                if (__less(__first, __result.first))
                    __result.first = __first;
                if (!__less(__i, __result.second))
                    __result.second = __i;
            }
            else
            {
                if (__less(__i, __result.first))
                    __result.first = __i;
                if (!__less(__first, __result.second))
                    __result.second = __first;
            }
        }
        return __result;
}
template <class _ForwardIterator, class _Compare>
pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
        _Static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value, "std::minmax_element requires a ForwardIterator");
        _Static_assert(__is_callable<_Compare, __decltype(*__first), __decltype(*__first)>::value, "The comparator has to be callable");
        auto __proj = __identity();
        return std::__minmax_element_impl(__first, __last, __comp, __proj);
}
template <class _ForwardIterator>
inline pair<_ForwardIterator, _ForwardIterator> minmax_element(_ForwardIterator __first, _ForwardIterator __last)
{
        return std::minmax_element(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _Tp, class _Compare>
inline

    pair<const _Tp &, const _Tp &>
    minmax(const _Tp &__a, const _Tp &__b, _Compare __comp)
{
        return __comp(__b, __a) ? pair<const _Tp &, const _Tp &>(__b, __a) : pair<const _Tp &, const _Tp &>(__a, __b);
}
template <class _Tp>
inline

    pair<const _Tp &, const _Tp &>
    minmax(const _Tp &__a, const _Tp &__b)
{
        return std::minmax(__a, __b, __less<_Tp>());
}
}
}

namespace std
{
inline namespace __1
{
template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)
{
        for (; __first1 != __last1; ++__first1, (void)++__first2)
            if (!__pred(*__first1, *__first2))
                break;
        return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}
template <class _InputIterator1, class _InputIterator2>
inline pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
{
        typedef typename iterator_traits<_InputIterator1>::value_type __v1;
        typedef typename iterator_traits<_InputIterator2>::value_type __v2;
        return std::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _AlgPolicy, class _BidirectionalIterator>
inline void
__reverse_impl(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)
{
        while (__first != __last)
        {
            if (__first == --__last)
                break;
            _IterOps<_AlgPolicy>::iter_swap(__first, __last);
            ++__first;
        }
}
template <class _AlgPolicy, class _RandomAccessIterator>
inline void
__reverse_impl(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)
{
        if (__first != __last)
            for (; __first < --__last; ++__first)
                _IterOps<_AlgPolicy>::iter_swap(__first, __last);
}
template <class _AlgPolicy, class _BidirectionalIterator, class _Sentinel>

void __reverse(_BidirectionalIterator __first, _Sentinel __last)
{
        using _IterCategory = typename _IterOps<_AlgPolicy>::template __iterator_category<_BidirectionalIterator>;
        std::__reverse_impl<_AlgPolicy>(std::move(__first), std::move(__last), _IterCategory());
}
template <class _BidirectionalIterator>
inline void
reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
        std::__reverse<_ClassicAlgPolicy>(std::move(__first), std::move(__last));
}
}
}
namespace std
{
inline namespace __1
{
template <class _AlgPolicy, class _Compare, class _BidirectionalIterator, class _Sentinel>
pair<_BidirectionalIterator, bool>
__next_permutation(_BidirectionalIterator __first, _Sentinel __last, _Compare &&__comp)
{
        using _Result = pair<_BidirectionalIterator, bool>;
        _BidirectionalIterator __last_iter = _IterOps<_AlgPolicy>::next(__first, __last);
        _BidirectionalIterator __i = __last_iter;
        if (__first == __last || __first == --__i)
            return _Result(std::move(__last_iter), false);
        while (true)
        {
            _BidirectionalIterator __ip1 = __i;
            if (__comp(*--__i, *__ip1))
            {
                _BidirectionalIterator __j = __last_iter;
                while (!__comp(*__i, *--__j))
                    ;
                _IterOps<_AlgPolicy>::iter_swap(__i, __j);
                std::__reverse<_AlgPolicy>(__ip1, __last_iter);
                return _Result(std::move(__last_iter), true);
            }
            if (__i == __first)
            {
                std::__reverse<_AlgPolicy>(__first, __last_iter);
                return _Result(std::move(__last_iter), false);
            }
        }
}
template <class _BidirectionalIterator, class _Compare>
inline bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
        using _Comp_ref = typename __comp_ref_type<_Compare>::type;
        return std::__next_permutation<_ClassicAlgPolicy>(
                   std::move(__first), std::move(__last), static_cast<_Comp_ref>(__comp))
            .second;
}
template <class _BidirectionalIterator>
inline bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
        return std::next_permutation(__first, __last,
                                     __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _InputIterator, class _Predicate>
inline bool
none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
        for (; __first != __last; ++__first)
            if (__pred(*__first))
                return false;
        return true;
}
}
}
namespace std
{
inline namespace __1
{
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>

void __sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare &&__comp,
               typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
        using value_type = typename iterator_traits<_RandomAccessIterator>::value_type;
        if (__len > 1)
        {
            __len = (__len - 2) / 2;
            _RandomAccessIterator __ptr = __first + __len;
            if (__comp(*__ptr, *--__last))
            {
                value_type __t(_IterOps<_AlgPolicy>::__iter_move(__last));
                do
                {
                    *__last = _IterOps<_AlgPolicy>::__iter_move(__ptr);
                    __last = __ptr;
                    if (__len == 0)
                        break;
                    __len = (__len - 1) / 2;
                    __ptr = __first + __len;
                } while (__comp(*__ptr, __t));
                *__last = std::move(__t);
            }
        }
}
template <class _AlgPolicy, class _RandomAccessIterator, class _Compare>
inline void __push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare &__comp)
{
        using _CompRef = typename __comp_ref_type<_Compare>::type;
        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __last - __first;
        std::__sift_up<_AlgPolicy, _CompRef>(std::move(__first), std::move(__last), __comp, __len);
}
template <class _RandomAccessIterator, class _Compare>
inline void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
        _Static_assert(std::is_copy_constructible<_RandomAccessIterator>::value, "Iterators must be copy constructible.");
        _Static_assert(std::is_copy_assignable<_RandomAccessIterator>::value, "Iterators must be copy assignable.");
        std::__push_heap<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __comp);
}
template <class _RandomAccessIterator>
inline void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
        std::push_heap(std::move(__first), std::move(__last),
                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
inline void __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare &__comp,
                       typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
        ((void)0);
        using _CompRef = typename __comp_ref_type<_Compare>::type;
        _CompRef __comp_ref = __comp;
        using value_type = typename iterator_traits<_RandomAccessIterator>::value_type;
        if (__len > 1)
        {
            value_type __top = _IterOps<_AlgPolicy>::__iter_move(__first);
            _RandomAccessIterator __hole = std::__floyd_sift_down<_AlgPolicy>(__first, __comp_ref, __len);
            --__last;
            if (__hole == __last)
            {
                *__hole = std::move(__top);
            }
            else
            {
                *__hole = _IterOps<_AlgPolicy>::__iter_move(__last);
                ++__hole;
                *__last = std::move(__top);
                std::__sift_up<_AlgPolicy>(__first, __hole, __comp_ref, __hole - __first);
            }
        }
}
template <class _RandomAccessIterator, class _Compare>
inline void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
        _Static_assert(std::is_copy_constructible<_RandomAccessIterator>::value, "Iterators must be copy constructible.");
        _Static_assert(std::is_copy_assignable<_RandomAccessIterator>::value, "Iterators must be copy assignable.");
        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __last - __first;
        std::__pop_heap<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __comp, __len);
}
template <class _RandomAccessIterator>
inline void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
        std::pop_heap(std::move(__first), std::move(__last),
                      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
inline void __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare &&__comp)
{
        using _CompRef = typename __comp_ref_type<_Compare>::type;
        _CompRef __comp_ref = __comp;
        using difference_type = typename iterator_traits<_RandomAccessIterator>::difference_type;
        for (difference_type __n = __last - __first; __n > 1; --__last, (void)--__n)
            std::__pop_heap<_AlgPolicy>(__first, __last, __comp_ref, __n);
}
template <class _RandomAccessIterator, class _Compare>
inline void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
        _Static_assert(std::is_copy_constructible<_RandomAccessIterator>::value, "Iterators must be copy constructible.");
        _Static_assert(std::is_copy_assignable<_RandomAccessIterator>::value, "Iterators must be copy assignable.");
        std::__sort_heap<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __comp);
}
template <class _RandomAccessIterator>
inline void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
        std::sort_heap(std::move(__first), std::move(__last),
                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _AlgPolicy, class _Iterator, class _Sentinel>

void __debug_randomize_range(_Iterator __first, _Sentinel __last)
{
        (void)__first;
        (void)__last;
}
}
}
namespace std
{
inline namespace __1
{
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator, class _Sentinel>
_RandomAccessIterator __partial_sort_impl(
    _RandomAccessIterator __first, _RandomAccessIterator __middle, _Sentinel __last, _Compare &&__comp)
{
        if (__first == __middle)
        {
            return _IterOps<_AlgPolicy>::next(__middle, __last);
        }
        std::__make_heap<_AlgPolicy>(__first, __middle, __comp);
        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;
        _RandomAccessIterator __i = __middle;
        for (; __i != __last; ++__i)
        {
            if (__comp(*__i, *__first))
            {
                _IterOps<_AlgPolicy>::iter_swap(__i, __first);
                std::__sift_down<_AlgPolicy>(__first, __comp, __len, __first);
            }
        }
        std::__sort_heap<_AlgPolicy>(std::move(__first), std::move(__middle), __comp);
        return __i;
}
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator, class _Sentinel>
_RandomAccessIterator __partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _Sentinel __last,
                                     _Compare &__comp)
{
        if (__first == __middle)
            return _IterOps<_AlgPolicy>::next(__middle, __last);
        std::__debug_randomize_range<_AlgPolicy>(__first, __last);
        using _Comp_ref = typename __comp_ref_type<_Compare>::type;
        auto __last_iter = std::__partial_sort_impl<_AlgPolicy>(__first, __middle, __last, static_cast<_Comp_ref>(__comp));
        std::__debug_randomize_range<_AlgPolicy>(__middle, __last);
        return __last_iter;
}
template <class _RandomAccessIterator, class _Compare>
inline void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
             _Compare __comp)
{
        _Static_assert(std::is_copy_constructible<_RandomAccessIterator>::value, "Iterators must be copy constructible.");
        _Static_assert(std::is_copy_assignable<_RandomAccessIterator>::value, "Iterators must be copy assignable.");
        (void)std::__partial_sort<_ClassicAlgPolicy>(std::move(__first), std::move(__middle), std::move(__last), __comp);
}
template <class _RandomAccessIterator>
inline void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
        std::partial_sort(__first, __middle, __last,
                          __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}
}
}
extern "C"
{
void __assert_rtn(const char *, const char *, int, const char *);
}
namespace std
{
inline namespace __1
{
template <class _PolicyT, class _CompT, class = void>
struct _WrapAlgPolicy
{
        using type = _WrapAlgPolicy;
        using _AlgPolicy = _PolicyT;
        using _Comp = _CompT;
        _Comp &__comp;

        _WrapAlgPolicy(_Comp &__c) : __comp(__c) {}
};
template <class _PolicyT, class _CompT>
struct _WrapAlgPolicy<_PolicyT, _CompT, __enable_if_t<std::is_same<_PolicyT, _ClassicAlgPolicy>::value>>
{
        using type = _CompT;
};
template <class _CompT>
struct _UnwrapAlgPolicy
{
        using _AlgPolicy = _ClassicAlgPolicy;
        using _Comp = _CompT;
        static _Comp __get_comp(_Comp __comp) { return __comp; }
};
template <class... _Ts>
struct _UnwrapAlgPolicy<_WrapAlgPolicy<_Ts...>>
{
        using _Wrapped = _WrapAlgPolicy<_Ts...>;
        using _AlgPolicy = typename _Wrapped::_AlgPolicy;
        using _Comp = typename _Wrapped::_Comp;
        static _Comp __get_comp(_Wrapped &__w) { return __w.__comp; }
};
template <class _AlgPolicy, class _Compare, class _ForwardIterator>
unsigned __sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z,
                 _Compare __c)
{
        using _Ops = _IterOps<_AlgPolicy>;
        unsigned __r = 0;
        if (!__c(*__y, *__x))
        {
            if (!__c(*__z, *__y))
                return __r;
            _Ops::iter_swap(__y, __z);
            __r = 1;
            if (__c(*__y, *__x))
            {
                _Ops::iter_swap(__x, __y);
                __r = 2;
            }
            return __r;
        }
        if (__c(*__z, *__y))
        {
            _Ops::iter_swap(__x, __z);
            __r = 1;
            return __r;
        }
        _Ops::iter_swap(__x, __y);
        __r = 1;
        if (__c(*__z, *__y))
        {
            _Ops::iter_swap(__y, __z);
            __r = 2;
        }
        return __r;
}
template <class _AlgPolicy, class _Compare, class _ForwardIterator>
unsigned __sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3, _ForwardIterator __x4,
                 _Compare __c)
{
        using _Ops = _IterOps<_AlgPolicy>;
        unsigned __r = std::__sort3<_AlgPolicy, _Compare>(__x1, __x2, __x3, __c);
        if (__c(*__x4, *__x3))
        {
            _Ops::iter_swap(__x3, __x4);
            ++__r;
            if (__c(*__x3, *__x2))
            {
                _Ops::iter_swap(__x2, __x3);
                ++__r;
                if (__c(*__x2, *__x1))
                {
                    _Ops::iter_swap(__x1, __x2);
                    ++__r;
                }
            }
        }
        return __r;
}
template <class _WrappedComp, class _ForwardIterator>
unsigned __sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
                 _ForwardIterator __x4, _ForwardIterator __x5, _WrappedComp __wrapped_comp)
{
        using _Unwrap = _UnwrapAlgPolicy<_WrappedComp>;
        using _AlgPolicy = typename _Unwrap::_AlgPolicy;
        using _Ops = _IterOps<_AlgPolicy>;
        using _Compare = typename _Unwrap::_Comp;
        _Compare __c = _Unwrap::__get_comp(__wrapped_comp);
        unsigned __r = std::__sort4<_AlgPolicy, _Compare>(__x1, __x2, __x3, __x4, __c);
        if (__c(*__x5, *__x4))
        {
            _Ops::iter_swap(__x4, __x5);
            ++__r;
            if (__c(*__x4, *__x3))
            {
                _Ops::iter_swap(__x3, __x4);
                ++__r;
                if (__c(*__x3, *__x2))
                {
                    _Ops::iter_swap(__x2, __x3);
                    ++__r;
                    if (__c(*__x2, *__x1))
                    {
                        _Ops::iter_swap(__x1, __x2);
                        ++__r;
                    }
                }
            }
        }
        return __r;
}
template <class _AlgPolicy, class _Compare, class _ForwardIterator>
unsigned __sort5_wrap_policy(
    _ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3, _ForwardIterator __x4, _ForwardIterator __x5,
    _Compare __c)
{
        using _WrappedComp = typename _WrapAlgPolicy<_AlgPolicy, _Compare>::type;
        _WrappedComp __wrapped_comp(__c);
        return std::__sort5<_WrappedComp>(
            std::move(__x1), std::move(__x2), std::move(__x3), std::move(__x4), std::move(__x5), __wrapped_comp);
}
template <class _Tp>
struct __is_simple_comparator : false_type
{
};
template <class _Tp>
struct __is_simple_comparator<__less<_Tp> &> : true_type
{
};
template <class _Tp>
struct __is_simple_comparator<less<_Tp> &> : true_type
{
};
template <class _Tp>
struct __is_simple_comparator<greater<_Tp> &> : true_type
{
};
template <class _Compare, class _Iter, class _Tp = typename iterator_traits<_Iter>::value_type>
using __use_branchless_sort =
    integral_constant<bool, __is_cpp17_contiguous_iterator<_Iter>::value && sizeof(_Tp) <= sizeof(void *) &&
                                is_arithmetic<_Tp>::value && __is_simple_comparator<_Compare>::value>;
template <class _Compare, class _RandomAccessIterator>
inline
{
        using value_type = typename iterator_traits<_RandomAccessIterator>::value_type;
        bool __r = __c(*__x, *__y);
        value_type __tmp = __r ? *__x : *__y;
        *__y = __r ? *__y : *__x;
        *__x = __tmp;
}
template <class _Compare, class _RandomAccessIterator>
inline void __partially_sorted_swap(_RandomAccessIterator __x, _RandomAccessIterator __y,
                                    _RandomAccessIterator __z, _Compare __c)
{
        using value_type = typename iterator_traits<_RandomAccessIterator>::value_type;
        bool __r = __c(*__z, *__x);
        value_type __tmp = __r ? *__z : *__x;
        *__z = __r ? *__x : *__z;
        __r = __c(__tmp, *__y);
        *__x = __r ? *__x : *__y;
        *__y = __r ? *__y : __tmp;
}
template <class, class _Compare, class _RandomAccessIterator>
inline __enable_if_t<__use_branchless_sort<_Compare, _RandomAccessIterator>::value, void>
__sort3_maybe_branchless(_RandomAccessIterator __x1, _RandomAccessIterator __x2, _RandomAccessIterator __x3,
                         _Compare __c)
{
        std::__cond_swap<_Compare>(__x2, __x3, __c);
        std::__partially_sorted_swap<_Compare>(__x1, __x2, __x3, __c);
}
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
inline __enable_if_t<!__use_branchless_sort<_Compare, _RandomAccessIterator>::value, void>
__sort3_maybe_branchless(_RandomAccessIterator __x1, _RandomAccessIterator __x2, _RandomAccessIterator __x3,
                         _Compare __c)
{
        std::__sort3<_AlgPolicy, _Compare>(__x1, __x2, __x3, __c);
}
template <class, class _Compare, class _RandomAccessIterator>
inline __enable_if_t<__use_branchless_sort<_Compare, _RandomAccessIterator>::value, void>
__sort4_maybe_branchless(_RandomAccessIterator __x1, _RandomAccessIterator __x2, _RandomAccessIterator __x3,
                         _RandomAccessIterator __x4, _Compare __c)
{
        std::__cond_swap<_Compare>(__x1, __x3, __c);
        std::__cond_swap<_Compare>(__x2, __x4, __c);
        std::__cond_swap<_Compare>(__x1, __x2, __c);
        std::__cond_swap<_Compare>(__x3, __x4, __c);
        std::__cond_swap<_Compare>(__x2, __x3, __c);
}
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
inline __enable_if_t<!__use_branchless_sort<_Compare, _RandomAccessIterator>::value, void>
__sort4_maybe_branchless(_RandomAccessIterator __x1, _RandomAccessIterator __x2, _RandomAccessIterator __x3,
                         _RandomAccessIterator __x4, _Compare __c)
{
        std::__sort4<_AlgPolicy, _Compare>(__x1, __x2, __x3, __x4, __c);
}
template <class, class _Compare, class _RandomAccessIterator>
inline __enable_if_t<__use_branchless_sort<_Compare, _RandomAccessIterator>::value, void>
__sort5_maybe_branchless(_RandomAccessIterator __x1, _RandomAccessIterator __x2, _RandomAccessIterator __x3,
                         _RandomAccessIterator __x4, _RandomAccessIterator __x5, _Compare __c)
{
        std::__cond_swap<_Compare>(__x1, __x2, __c);
        std::__cond_swap<_Compare>(__x4, __x5, __c);
        std::__partially_sorted_swap<_Compare>(__x3, __x4, __x5, __c);
        std::__cond_swap<_Compare>(__x2, __x5, __c);
        std::__partially_sorted_swap<_Compare>(__x1, __x3, __x4, __c);
        std::__partially_sorted_swap<_Compare>(__x2, __x3, __x4, __c);
}
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
inline __enable_if_t<!__use_branchless_sort<_Compare, _RandomAccessIterator>::value, void>
__sort5_maybe_branchless(_RandomAccessIterator __x1, _RandomAccessIterator __x2, _RandomAccessIterator __x3,
                         _RandomAccessIterator __x4, _RandomAccessIterator __x5, _Compare __c)
{
        std::__sort5_wrap_policy<_AlgPolicy, _Compare>(__x1, __x2, __x3, __x4, __x5, __c);
}
template <class _AlgPolicy, class _Compare, class _BidirectionalIterator>
void __selection_sort(_BidirectionalIterator __first, _BidirectionalIterator __last,
                      _Compare __comp)
{
        _BidirectionalIterator __lm1 = __last;
        for (--__lm1; __first != __lm1; ++__first)
        {
            _BidirectionalIterator __i = std::__min_element<_Compare>(__first, __last, __comp);
            if (__i != __first)
                _IterOps<_AlgPolicy>::iter_swap(__first, __i);
        }
}
template <class _AlgPolicy, class _Compare, class _BidirectionalIterator>
void __insertion_sort(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
        using _Ops = _IterOps<_AlgPolicy>;
        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
        if (__first != __last)
        {
            _BidirectionalIterator __i = __first;
            for (++__i; __i != __last; ++__i)
            {
                _BidirectionalIterator __j = __i;
                value_type __t(_Ops::__iter_move(__j));
                for (_BidirectionalIterator __k = __i; __k != __first && __comp(__t, *--__k); --__j)
                    *__j = _Ops::__iter_move(__k);
                *__j = std::move(__t);
            }
        }
}
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
void __insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
        using _Ops = _IterOps<_AlgPolicy>;
        typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
        typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
        _RandomAccessIterator __j = __first + difference_type(2);
        std::__sort3_maybe_branchless<_AlgPolicy, _Compare>(__first, __first + difference_type(1), __j, __comp);
        for (_RandomAccessIterator __i = __j + difference_type(1); __i != __last; ++__i)
        {
            if (__comp(*__i, *__j))
            {
                value_type __t(_Ops::__iter_move(__i));
                _RandomAccessIterator __k = __j;
                __j = __i;
                do
                {
                    *__j = _Ops::__iter_move(__k);
                    __j = __k;
                } while (__j != __first && __comp(__t, *--__k));
                *__j = std::move(__t);
            }
            __j = __i;
        }
}
template <class _WrappedComp, class _RandomAccessIterator>
bool __insertion_sort_incomplete(
    _RandomAccessIterator __first, _RandomAccessIterator __last, _WrappedComp __wrapped_comp)
{
        using _Unwrap = _UnwrapAlgPolicy<_WrappedComp>;
        using _AlgPolicy = typename _Unwrap::_AlgPolicy;
        using _Ops = _IterOps<_AlgPolicy>;
        using _Compare = typename _Unwrap::_Comp;
        _Compare __comp = _Unwrap::__get_comp(__wrapped_comp);
        typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
        switch (__last - __first)
        {
        case 0:
        case 1:
            return true;
        case 2:
            if (__comp(*--__last, *__first))
                _IterOps<_AlgPolicy>::iter_swap(__first, __last);
            return true;
        case 3:
            std::__sort3_maybe_branchless<_AlgPolicy, _Compare>(__first, __first + difference_type(1), --__last, __comp);
            return true;
        case 4:
            std::__sort4_maybe_branchless<_AlgPolicy, _Compare>(
                __first, __first + difference_type(1), __first + difference_type(2), --__last, __comp);
            return true;
        case 5:
            std::__sort5_maybe_branchless<_AlgPolicy, _Compare>(
                __first, __first + difference_type(1), __first + difference_type(2), __first + difference_type(3),
                --__last, __comp);
            return true;
        }
        typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
        _RandomAccessIterator __j = __first + difference_type(2);
        std::__sort3_maybe_branchless<_AlgPolicy, _Compare>(__first, __first + difference_type(1), __j, __comp);
        const unsigned __limit = 8;
        unsigned __count = 0;
        for (_RandomAccessIterator __i = __j + difference_type(1); __i != __last; ++__i)
        {
            if (__comp(*__i, *__j))
            {
                value_type __t(_Ops::__iter_move(__i));
                _RandomAccessIterator __k = __j;
                __j = __i;
                do
                {
                    *__j = _Ops::__iter_move(__k);
                    __j = __k;
                } while (__j != __first && __comp(__t, *--__k));
                *__j = std::move(__t);
                if (++__count == __limit)
                    return ++__i == __last;
            }
            __j = __i;
        }
        return true;
}
template <class _AlgPolicy, class _Compare, class _BidirectionalIterator>
void __insertion_sort_move(_BidirectionalIterator __first1, _BidirectionalIterator __last1,
                           typename iterator_traits<_BidirectionalIterator>::value_type *__first2, _Compare __comp)
{
        using _Ops = _IterOps<_AlgPolicy>;
        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
        if (__first1 != __last1)
        {
            __destruct_n __d(0);
            unique_ptr<value_type, __destruct_n &> __h(__first2, __d);
            value_type *__last2 = __first2;
            ::new ((void *)__last2) value_type(_Ops::__iter_move(__first1));
            __d.template __incr<value_type>();
            for (++__last2; ++__first1 != __last1; ++__last2)
            {
                value_type *__j2 = __last2;
                value_type *__i2 = __j2;
                if (__comp(*__first1, *--__i2))
                {
                    ::new ((void *)__j2) value_type(std::move(*__i2));
                    __d.template __incr<value_type>();
                    for (--__j2; __i2 != __first2 && __comp(*__first1, *--__i2); --__j2)
                        *__j2 = std::move(*__i2);
                    *__j2 = _Ops::__iter_move(__first1);
                }
                else
                {
                    ::new ((void *)__j2) value_type(_Ops::__iter_move(__first1));
                    __d.template __incr<value_type>();
                }
            }
            __h.release();
        }
}
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
void __introsort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
                 typename iterator_traits<_RandomAccessIterator>::difference_type __depth)
{
        using _Ops = _IterOps<_AlgPolicy>;
        typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
        typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
        const difference_type __limit =
            is_trivially_copy_constructible<value_type>::value && is_trivially_copy_assignable<value_type>::value ? 30 : 6;
        while (true)
        {
        __restart:
            difference_type __len = __last - __first;
            switch (__len)
            {
            case 0:
            case 1:
                return;
            case 2:
                if (__comp(*--__last, *__first))
                    _IterOps<_AlgPolicy>::iter_swap(__first, __last);
                return;
            case 3:
                std::__sort3_maybe_branchless<_AlgPolicy, _Compare>(__first, __first + difference_type(1), --__last, __comp);
                return;
            case 4:
                std::__sort4_maybe_branchless<_AlgPolicy, _Compare>(
                    __first, __first + difference_type(1), __first + difference_type(2), --__last, __comp);
                return;
            case 5:
                std::__sort5_maybe_branchless<_AlgPolicy, _Compare>(
                    __first, __first + difference_type(1), __first + difference_type(2), __first + difference_type(3),
                    --__last, __comp);
                return;
            }
            if (__len <= __limit)
            {
                std::__insertion_sort_3<_AlgPolicy, _Compare>(__first, __last, __comp);
                return;
            }
            if (__depth == 0)
            {
                std::__partial_sort<_AlgPolicy, _Compare>(__first, __last, __last, __comp);
                return;
            }
            --__depth;
            _RandomAccessIterator __m = __first;
            _RandomAccessIterator __lm1 = __last;
            --__lm1;
            unsigned __n_swaps;
            {
                difference_type __delta;
                if (__len >= 1000)
                {
                    __delta = __len / 2;
                    __m += __delta;
                    __delta /= 2;
                    __n_swaps = std::__sort5_wrap_policy<_AlgPolicy, _Compare>(
                        __first, __first + __delta, __m, __m + __delta, __lm1, __comp);
                }
                else
                {
                    __delta = __len / 2;
                    __m += __delta;
                    __n_swaps = std::__sort3<_AlgPolicy, _Compare>(__first, __m, __lm1, __comp);
                }
            }
            _RandomAccessIterator __i = __first;
            _RandomAccessIterator __j = __lm1;
            if (!__comp(*__i, *__m))
            {
                while (true)
                {
                    if (__i == --__j)
                    {
                        ++__i;
                        __j = __last;
                        if (!__comp(*__first, *--__j))
                        {
                            while (true)
                            {
                                if (__i == __j)
                                    return;
                                if (__comp(*__first, *__i))
                                {
                                    _Ops::iter_swap(__i, __j);
                                    ++__n_swaps;
                                    ++__i;
                                    break;
                                }
                                ++__i;
                            }
                        }
                        if (__i == __j)
                            return;
                        while (true)
                        {
                            while (!__comp(*__first, *__i))
                                ++__i;
                            while (__comp(*__first, *--__j))
                                ;
                            if (__i >= __j)
                                break;
                            _Ops::iter_swap(__i, __j);
                            ++__n_swaps;
                            ++__i;
                        }
                        __first = __i;
                        goto __restart;
                    }
                    if (__comp(*__j, *__m))
                    {
                        _Ops::iter_swap(__i, __j);
                        ++__n_swaps;
                        break;
                    }
                }
            }
            ++__i;
            if (__i < __j)
            {
                while (true)
                {
                    while (__comp(*__i, *__m))
                        ++__i;
                    while (!__comp(*--__j, *__m))
                        ;
                    if (__i > __j)
                        break;
                    _Ops::iter_swap(__i, __j);
                    ++__n_swaps;
                    if (__m == __i)
                        __m = __j;
                    ++__i;
                }
            }
            if (__i != __m && __comp(*__m, *__i))
            {
                _Ops::iter_swap(__i, __m);
                ++__n_swaps;
            }
            if (__n_swaps == 0)
            {
                using _WrappedComp = typename _WrapAlgPolicy<_AlgPolicy, _Compare>::type;
                _WrappedComp __wrapped_comp(__comp);
                bool __fs = std::__insertion_sort_incomplete<_WrappedComp>(__first, __i, __wrapped_comp);
                if (std::__insertion_sort_incomplete<_WrappedComp>(__i + difference_type(1), __last, __wrapped_comp))
                {
                    if (__fs)
                        return;
                    __last = __i;
                    continue;
                }
                else
                {
                    if (__fs)
                    {
                        __first = ++__i;
                        continue;
                    }
                }
            }
            if (__i - __first < __last - __i)
            {
                std::__introsort<_AlgPolicy, _Compare>(__first, __i, __comp, __depth);
                __first = ++__i;
            }
            else
            {
                std::__introsort<_AlgPolicy, _Compare>(__i + difference_type(1), __last, __comp, __depth);
                __last = __i;
            }
        }
}
template <typename _Number>
inline
{
        if (__n == 0)
            return 0;
        if (sizeof(__n) <= sizeof(unsigned))
            return sizeof(unsigned) * 8 - 1 - __libcpp_clz(static_cast<unsigned>(__n));
        if (sizeof(__n) <= sizeof(unsigned long))
            return sizeof(unsigned long) * 8 - 1 - __libcpp_clz(static_cast<unsigned long>(__n));
        if (sizeof(__n) <= sizeof(unsigned long long))
            return sizeof(unsigned long long) * 8 - 1 - __libcpp_clz(static_cast<unsigned long long>(__n));
        _Number __log2 = 0;
        while (__n > 1)
        {
            __log2++;
            __n >>= 1;
        }
        return __log2;
}
template <class _WrappedComp, class _RandomAccessIterator>
void __sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _WrappedComp __wrapped_comp)
{
        typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
        difference_type __depth_limit = 2 * __log2i(__last - __first);
        using _Unwrap = _UnwrapAlgPolicy<_WrappedComp>;
        using _AlgPolicy = typename _Unwrap::_AlgPolicy;
        using _Compare = typename _Unwrap::_Comp;
        _Compare __comp = _Unwrap::__get_comp(__wrapped_comp);
        std::__introsort<_AlgPolicy, _Compare>(__first, __last, __comp, __depth_limit);
}
template <class _Compare, class _Tp>
inline
{
        __less<uintptr_t> __comp;
        std::__sort<__less<uintptr_t> &, uintptr_t *>((uintptr_t *)__first, (uintptr_t *)__last, __comp);
}
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
extern template;
template <class _AlgPolicy, class _RandomAccessIterator, class _Comp>
inline void __sort_impl(_RandomAccessIterator __first, _RandomAccessIterator __last, _Comp &__comp)
{
        std::__debug_randomize_range<_AlgPolicy>(__first, __last);
        using _Comp_ref = typename __comp_ref_type<_Comp>::type;
        if (__libcpp_is_constant_evaluated())
        {
            std::__partial_sort<_AlgPolicy>(__first, __last, __last, __comp);
        }
        else
        {
            using _WrappedComp = typename _WrapAlgPolicy<_AlgPolicy, _Comp_ref>::type;
            _Comp_ref __comp_ref(__comp);
            _WrappedComp __wrapped_comp(__comp_ref);
            std::__sort<_WrappedComp>(std::__unwrap_iter(__first), std::__unwrap_iter(__last), __wrapped_comp);
        }
}
template <class _RandomAccessIterator, class _Comp>
inline void sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Comp __comp)
{
        std::__sort_impl<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __comp);
}
template <class _RandomAccessIterator>
inline void sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
        std::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _Compare, class _RandomAccessIterator>
bool __nth_element_find_guard(_RandomAccessIterator &__i, _RandomAccessIterator &__j,
                              _RandomAccessIterator __m, _Compare __comp)
{
        while (true)
        {
            if (__i == --__j)
            {
                return false;
            }
            if (__comp(*__j, *__m))
            {
                return true;
            }
        }
}
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
void __nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
{
        using _Ops = _IterOps<_AlgPolicy>;
        typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
        const difference_type __limit = 7;
        while (true)
        {
            if (__nth == __last)
                return;
            difference_type __len = __last - __first;
            switch (__len)
            {
            case 0:
            case 1:
                return;
            case 2:
                if (__comp(*--__last, *__first))
                    _Ops::iter_swap(__first, __last);
                return;
            case 3:
            {
                _RandomAccessIterator __m = __first;
                std::__sort3<_AlgPolicy, _Compare>(__first, ++__m, --__last, __comp);
                return;
            }
            }
            if (__len <= __limit)
            {
                std::__selection_sort<_AlgPolicy, _Compare>(__first, __last, __comp);
                return;
            }
            _RandomAccessIterator __m = __first + __len / 2;
            _RandomAccessIterator __lm1 = __last;
            unsigned __n_swaps = std::__sort3<_AlgPolicy, _Compare>(__first, __m, --__lm1, __comp);
            _RandomAccessIterator __i = __first;
            _RandomAccessIterator __j = __lm1;
            if (!__comp(*__i, *__m))
            {
                if (std::__nth_element_find_guard<_Compare>(__i, __j, __m, __comp))
                {
                    _Ops::iter_swap(__i, __j);
                    ++__n_swaps;
                }
                else
                {
                    ++__i;
                    __j = __last;
                    if (!__comp(*__first, *--__j))
                    {
                        while (true)
                        {
                            if (__i == __j)
                            {
                                return;
                            }
                            else if (__comp(*__first, *__i))
                            {
                                _Ops::iter_swap(__i, __j);
                                ++__n_swaps;
                                ++__i;
                                break;
                            }
                            ++__i;
                        }
                    }
                    if (__i == __j)
                    {
                        return;
                    }
                    while (true)
                    {
                        while (!__comp(*__first, *__i))
                            ++__i;
                        while (__comp(*__first, *--__j))
                            ;
                        if (__i >= __j)
                            break;
                        _Ops::iter_swap(__i, __j);
                        ++__n_swaps;
                        ++__i;
                    }
                    if (__nth < __i)
                    {
                        return;
                    }
                    __first = __i;
                    continue;
                }
            }
            ++__i;
            if (__i < __j)
            {
                while (true)
                {
                    while (__comp(*__i, *__m))
                        ++__i;
                    while (!__comp(*--__j, *__m))
                        ;
                    if (__i >= __j)
                        break;
                    _Ops::iter_swap(__i, __j);
                    ++__n_swaps;
                    if (__m == __i)
                        __m = __j;
                    ++__i;
                }
            }
            if (__i != __m && __comp(*__m, *__i))
            {
                _Ops::iter_swap(__i, __m);
                ++__n_swaps;
            }
            if (__nth == __i)
                return;
            if (__n_swaps == 0)
            {
                if (__nth < __i)
                {
                    __j = __m = __first;
                    while (true)
                    {
                        if (++__j == __i)
                        {
                            return;
                        }
                        if (__comp(*__j, *__m))
                        {
                            break;
                        }
                        __m = __j;
                    }
                }
                else
                {
                    __j = __m = __i;
                    while (true)
                    {
                        if (++__j == __last)
                        {
                            return;
                        }
                        if (__comp(*__j, *__m))
                        {
                            break;
                        }
                        __m = __j;
                    }
                }
            }
            if (__nth < __i)
            {
                __last = __i;
            }
            else
            {
                __first = ++__i;
            }
        }
}
template <class _AlgPolicy, class _RandomAccessIterator, class _Compare>
inline void __nth_element_impl(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last,
                               _Compare &__comp)
{
        if (__nth == __last)
            return;
        std::__debug_randomize_range<_AlgPolicy>(__first, __last);
        using _Comp_ref = typename __comp_ref_type<_Compare>::type;
        std::__nth_element<_AlgPolicy, _Comp_ref>(__first, __nth, __last, __comp);
        std::__debug_randomize_range<_AlgPolicy>(__first, __nth);
        if (__nth != __last)
        {
            std::__debug_randomize_range<_AlgPolicy>(++__nth, __last);
        }
}
template <class _RandomAccessIterator, class _Compare>
inline void nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last,
                        _Compare __comp)
{
        std::__nth_element_impl<_ClassicAlgPolicy>(std::move(__first), std::move(__nth), std::move(__last), __comp);
}
template <class _RandomAccessIterator>
inline void nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)
{
        std::nth_element(std::move(__first), std::move(__nth), std::move(__last), __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}
}
}

namespace std
{
inline namespace __1
{
template <class _Pred, class _Proj>
struct _ProjectedPred
{
        _Pred &__pred;
        _Proj &__proj;
        _ProjectedPred(_Pred &__pred_arg, _Proj &__proj_arg) : __pred(__pred_arg), __proj(__proj_arg) {}
        template <class _Tp>
        typename __invoke_of<_Pred &,
                             __decltype(std::__invoke(std::declval<_Proj &>(), std::declval<_Tp>()))>::type
        operator()(_Tp &&__v) const
        {
            return std::__invoke(__pred, std::__invoke(__proj, std::forward<_Tp>(__v)));
        }
        template <class _T1, class _T2>
        typename __invoke_of<_Pred &,
                             __decltype(std::__invoke(std::declval<_Proj &>(), std::declval<_T1>())),
                             __decltype(std::__invoke(std::declval<_Proj &>(), std::declval<_T2>()))>::type
        operator()(_T1 &&__lhs, _T2 &&__rhs) const
        {
            return std::__invoke(__pred,
                                 std::__invoke(__proj, std::forward<_T1>(__lhs)),
                                 std::__invoke(__proj, std::forward<_T2>(__rhs)));
        }
};
template <class _Pred, class _Proj, class = void>
struct __can_use_pristine_comp : false_type
{
};
template <class _Pred, class _Proj>
struct __can_use_pristine_comp<_Pred, _Proj, __enable_if_t<!is_member_pointer<typename decay<_Pred>::type>::value && (is_same<typename decay<_Proj>::type, __identity>::value)>> : true_type
{
};
template <class _Pred, class _Proj>
static __enable_if_t<
    !__can_use_pristine_comp<_Pred, _Proj>::value,
    _ProjectedPred<_Pred, _Proj>>
__make_projected(_Pred &__pred, _Proj &__proj)
{
        return _ProjectedPred<_Pred, _Proj>(__pred, __proj);
}
template <class _Pred, class _Proj>
static __enable_if_t<
    __can_use_pristine_comp<_Pred, _Proj>::value,
    _Pred &>
__make_projected(_Pred &__pred, _Proj &)
{
        return __pred;
}
}
}
namespace std
{
inline namespace __1
{
template <class _AlgPolicy, class _Compare,
          class _InputIterator, class _Sentinel1, class _RandomAccessIterator, class _Sentinel2,
          class _Proj1, class _Proj2>
pair<_InputIterator, _RandomAccessIterator>
__partial_sort_copy(_InputIterator __first, _Sentinel1 __last,
                    _RandomAccessIterator __result_first, _Sentinel2 __result_last,
                    _Compare &&__comp, _Proj1 &&__proj1, _Proj2 &&__proj2)
{
        _RandomAccessIterator __r = __result_first;
        auto &&__projected_comp = std::__make_projected(__comp, __proj2);
        if (__r != __result_last)
        {
            for (; __first != __last && __r != __result_last; ++__first, (void)++__r)
                *__r = *__first;
            std::__make_heap<_AlgPolicy>(__result_first, __r, __projected_comp);
            typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;
            for (; __first != __last; ++__first)
                if (std::__invoke(__comp, std::__invoke(__proj1, *__first), std::__invoke(__proj2, *__result_first)))
                {
                    *__result_first = *__first;
                    std::__sift_down<_AlgPolicy>(__result_first, __projected_comp, __len, __result_first);
                }
            std::__sort_heap<_AlgPolicy>(__result_first, __r, __projected_comp);
        }
        return pair<_InputIterator, _RandomAccessIterator>(
            _IterOps<_AlgPolicy>::next(std::move(__first), std::move(__last)), std::move(__r));
}
template <class _InputIterator, class _RandomAccessIterator, class _Compare>
inline _RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
{
        _Static_assert(__is_callable<_Compare, __decltype(*__first), __decltype(*__result_first)>::value, "Comparator has to be callable");
        using _Comp_ref = typename __comp_ref_type<_Compare>::type;
        auto __result = std::__partial_sort_copy<_ClassicAlgPolicy>(__first, __last, __result_first, __result_last,
                                                                    static_cast<_Comp_ref>(__comp), __identity(), __identity());
        return __result.second;
}
template <class _InputIterator, class _RandomAccessIterator>
inline _RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)
{
        return std::partial_sort_copy(__first, __last, __result_first, __result_last,
                                      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _Predicate, class _AlgPolicy, class _ForwardIterator, class _Sentinel>
pair<_ForwardIterator, _ForwardIterator>
__partition_impl(_ForwardIterator __first, _Sentinel __last, _Predicate __pred, forward_iterator_tag)
{
        while (true)
        {
            if (__first == __last)
                return std::make_pair(std::move(__first), std::move(__first));
            if (!__pred(*__first))
                break;
            ++__first;
        }
        _ForwardIterator __p = __first;
        while (++__p != __last)
        {
            if (__pred(*__p))
            {
                _IterOps<_AlgPolicy>::iter_swap(__first, __p);
                ++__first;
            }
        }
        return std::make_pair(std::move(__first), std::move(__p));
}
template <class _Predicate, class _AlgPolicy, class _BidirectionalIterator, class _Sentinel>
pair<_BidirectionalIterator, _BidirectionalIterator>
__partition_impl(_BidirectionalIterator __first, _Sentinel __sentinel, _Predicate __pred,
                 bidirectional_iterator_tag)
{
        _BidirectionalIterator __original_last = _IterOps<_AlgPolicy>::next(__first, __sentinel);
        _BidirectionalIterator __last = __original_last;
        while (true)
        {
            while (true)
            {
                if (__first == __last)
                    return std::make_pair(std::move(__first), std::move(__original_last));
                if (!__pred(*__first))
                    break;
                ++__first;
            }
            do
            {
                if (__first == --__last)
                    return std::make_pair(std::move(__first), std::move(__original_last));
            } while (!__pred(*__last));
            _IterOps<_AlgPolicy>::iter_swap(__first, __last);
            ++__first;
        }
}
template <class _AlgPolicy, class _ForwardIterator, class _Sentinel, class _Predicate, class _IterCategory>
inline pair<_ForwardIterator, _ForwardIterator> __partition(
    _ForwardIterator __first, _Sentinel __last, _Predicate &&__pred, _IterCategory __iter_category)
{
        return std::__partition_impl<__uncvref_t<_Predicate> &, _AlgPolicy>(
            std::move(__first), std::move(__last), __pred, __iter_category);
}
template <class _ForwardIterator, class _Predicate>
inline _ForwardIterator
partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
        using _IterCategory = typename iterator_traits<_ForwardIterator>::iterator_category;
        auto __result = std::__partition<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __pred, _IterCategory());
        return __result.first;
}
}
}
namespace std
{
inline namespace __1
{
template <class _InputIterator, class _OutputIterator1,
          class _OutputIterator2, class _Predicate>
pair<_OutputIterator1, _OutputIterator2>
partition_copy(_InputIterator __first, _InputIterator __last,
               _OutputIterator1 __out_true, _OutputIterator2 __out_false,
               _Predicate __pred)
{
        for (; __first != __last; ++__first)
        {
            if (__pred(*__first))
            {
                *__out_true = *__first;
                ++__out_true;
            }
            else
            {
                *__out_false = *__first;
                ++__out_false;
            }
        }
        return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
}
}
}
namespace std
{
inline namespace __1
{
template <class _ForwardIterator, class _Predicate>
_ForwardIterator
partition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
        typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
        difference_type __len = std::distance(__first, __last);
        while (__len != 0)
        {
            difference_type __l2 = std::__half_positive(__len);
            _ForwardIterator __m = __first;
            std::advance(__m, __l2);
            if (__pred(*__m))
            {
                __first = ++__m;
                __len -= __l2 + 1;
            }
            else
                __len = __l2;
        }
        return __first;
}
}
}

namespace std
{
inline namespace __1
{
template <class _AlgPolicy, class _Compare, class _BidirectionalIterator, class _Sentinel>
pair<_BidirectionalIterator, bool>
__prev_permutation(_BidirectionalIterator __first, _Sentinel __last, _Compare &&__comp)
{
        using _Result = pair<_BidirectionalIterator, bool>;
        _BidirectionalIterator __last_iter = _IterOps<_AlgPolicy>::next(__first, __last);
        _BidirectionalIterator __i = __last_iter;
        if (__first == __last || __first == --__i)
            return _Result(std::move(__last_iter), false);
        while (true)
        {
            _BidirectionalIterator __ip1 = __i;
            if (__comp(*__ip1, *--__i))
            {
                _BidirectionalIterator __j = __last_iter;
                while (!__comp(*--__j, *__i))
                    ;
                _IterOps<_AlgPolicy>::iter_swap(__i, __j);
                std::__reverse<_AlgPolicy>(__ip1, __last_iter);
                return _Result(std::move(__last_iter), true);
            }
            if (__i == __first)
            {
                std::__reverse<_AlgPolicy>(__first, __last_iter);
                return _Result(std::move(__last_iter), false);
            }
        }
}
template <class _BidirectionalIterator, class _Compare>
inline bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
        using _Comp_ref = typename __comp_ref_type<_Compare>::type;
        return std::__prev_permutation<_ClassicAlgPolicy>(
                   std::move(__first), std::move(__last), static_cast<_Comp_ref>(__comp))
            .second;
}
template <class _BidirectionalIterator>
inline bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
        return std::prev_permutation(__first, __last,
                                     __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}
}
}

namespace std
{
inline namespace __1
{
}
}

namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
template <class _InputIterator, class _OutputIterator, class _Predicate>
inline _OutputIterator
remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)
{
        for (; __first != __last; ++__first)
        {
            if (!__pred(*__first))
            {
                *__result = *__first;
                ++__result;
            }
        }
        return __result;
}
}
}
namespace std
{
inline namespace __1
{
template <class>
struct __libcpp_random_is_valid_inttype : false_type
{
};
template <>
struct __libcpp_random_is_valid_inttype<int8_t> : true_type
{
};
template <>
struct __libcpp_random_is_valid_inttype<short> : true_type
{
};
template <>
struct __libcpp_random_is_valid_inttype<int> : true_type
{
};
template <>
struct __libcpp_random_is_valid_inttype<long> : true_type
{
};
template <>
struct __libcpp_random_is_valid_inttype<long long> : true_type
{
};
template <>
struct __libcpp_random_is_valid_inttype<uint8_t> : true_type
{
};
template <>
struct __libcpp_random_is_valid_inttype<unsigned short> : true_type
{
};
template <>
struct __libcpp_random_is_valid_inttype<unsigned int> : true_type
{
};
template <>
struct __libcpp_random_is_valid_inttype<unsigned long> : true_type
{
};
template <>
struct __libcpp_random_is_valid_inttype<unsigned long long> : true_type
{
};
template <>
struct __libcpp_random_is_valid_inttype<__int128_t> : true_type
{
};
template <>
struct __libcpp_random_is_valid_inttype<__uint128_t> : true_type
{
};
template <class, class = void>
struct __libcpp_random_is_valid_urng : false_type
{
};
template <class _Gp>
struct __libcpp_random_is_valid_urng<_Gp, __enable_if_t<
                                              is_unsigned<typename _Gp::result_type>::value &&
                                              _IsSame<__decltype(declval<_Gp &>()()), typename _Gp::result_type>::value>> : true_type
{
};
}
}
namespace std
{
inline namespace __1
{
template <class _UIntType, _UIntType _Xp, size_t _Rp>
struct __log2_imp;
template <unsigned long long _Xp, size_t _Rp>
struct __log2_imp<unsigned long long, _Xp, _Rp>
{
        static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp
                                                                           : __log2_imp<unsigned long long, _Xp, _Rp - 1>::value;
};
template <unsigned long long _Xp>
struct __log2_imp<unsigned long long, _Xp, 0>
{
        static const size_t value = 0;
};
template <size_t _Rp>
struct __log2_imp<unsigned long long, 0, _Rp>
{
        static const size_t value = _Rp + 1;
};
template <__uint128_t _Xp, size_t _Rp>
struct __log2_imp<__uint128_t, _Xp, _Rp>
{
        static const size_t value = (_Xp >> 64)
                                        ? (64 + __log2_imp<unsigned long long, (_Xp >> 64), 63>::value)
                                        : __log2_imp<unsigned long long, _Xp, 63>::value;
};
template <class _UIntType, _UIntType _Xp>
struct __log2
{
        static const size_t value = __log2_imp<
            typename conditional<
                sizeof(_UIntType) <= sizeof(unsigned long long),
                unsigned long long,
                __uint128_t>::type,
            _Xp, sizeof(_UIntType) * 8 - 1>::value;
};
}
}
namespace std
{
inline namespace __1
{
}
}

namespace std
{
inline namespace __1
{
template <class _Tp>

_Tp __rotr(_Tp __t, unsigned int __cnt) throw()
{
        _Static_assert(__libcpp_is_unsigned_integer<_Tp>::value, "__rotr requires an unsigned integer type");
        const unsigned int __dig = numeric_limits<_Tp>::digits;
        if ((__cnt % __dig) == 0)
            return __t;
        return (__t >> (__cnt % __dig)) | (__t << (__dig - (__cnt % __dig)));
}
template <class _Tp>

int __countl_zero(_Tp __t) throw()
{
        _Static_assert(__libcpp_is_unsigned_integer<_Tp>::value, "__countl_zero requires an unsigned integer type");
        if (__t == 0)
            return numeric_limits<_Tp>::digits;
        if (sizeof(_Tp) <= sizeof(unsigned int))
            return std::__libcpp_clz(static_cast<unsigned int>(__t)) - (numeric_limits<unsigned int>::digits - numeric_limits<_Tp>::digits);
        else if (sizeof(_Tp) <= sizeof(unsigned long))
            return std::__libcpp_clz(static_cast<unsigned long>(__t)) - (numeric_limits<unsigned long>::digits - numeric_limits<_Tp>::digits);
        else if (sizeof(_Tp) <= sizeof(unsigned long long))
            return std::__libcpp_clz(static_cast<unsigned long long>(__t)) - (numeric_limits<unsigned long long>::digits - numeric_limits<_Tp>::digits);
        else
        {
            int __ret = 0;
            int __iter = 0;
            const unsigned int __ulldigits = numeric_limits<unsigned long long>::digits;
            while (true)
            {
                __t = std::__rotr(__t, __ulldigits);
                if ((__iter = std::__countl_zero(static_cast<unsigned long long>(__t))) != __ulldigits)
                    break;
                __ret += __iter;
            }
            return __ret + __iter;
        }
}
}
}

namespace std
{
inline namespace __1
{
template <class _Engine, class _UIntType>
class __independent_bits_engine
{
    public:
        typedef _UIntType result_type;

    private:
        typedef typename _Engine::result_type _Engine_result_type;
        typedef typename conditional<
            sizeof(_Engine_result_type) <= sizeof(result_type),
            result_type,
            _Engine_result_type>::type _Working_result_type;
        _Engine &__e_;
        size_t __w_;
        size_t __w0_;
        size_t __n_;
        size_t __n0_;
        _Working_result_type __y0_;
        _Working_result_type __y1_;
        _Engine_result_type __mask0_;
        _Engine_result_type __mask1_;
        static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min + _Working_result_type(1);
        static const size_t __m = __log2<_Working_result_type, _Rp>::value;
        static const size_t _WDt = numeric_limits<_Working_result_type>::digits;
        static const size_t _EDt = numeric_limits<_Engine_result_type>::digits;

    public:
        __independent_bits_engine(_Engine &__e, size_t __w);
        result_type operator()() { return __eval(integral_constant<bool, _Rp != 0>()); }

    private:
        result_type __eval(false_type);
        result_type __eval(true_type);
};
template <class _Engine, class _UIntType>
__independent_bits_engine<_Engine, _UIntType>::__independent_bits_engine(_Engine &__e, size_t __w)
    : __e_(__e),
      __w_(__w)
{
        __n_ = __w_ / __m + (__w_ % __m != 0);
        __w0_ = __w_ / __n_;
        if (_Rp == 0)
            __y0_ = _Rp;
        else if (__w0_ < _WDt)
            __y0_ = (_Rp >> __w0_) << __w0_;
        else
            __y0_ = 0;
        if (_Rp - __y0_ > __y0_ / __n_)
        {
            ++__n_;
            __w0_ = __w_ / __n_;
            if (__w0_ < _WDt)
                __y0_ = (_Rp >> __w0_) << __w0_;
            else
                __y0_ = 0;
        }
        __n0_ = __n_ - __w_ % __n_;
        if (__w0_ < _WDt - 1)
            __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);
        else
            __y1_ = 0;
        __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) : _Engine_result_type(0);
        __mask1_ = __w0_ < _EDt - 1 ? _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) : _Engine_result_type(~0);
}
template <class _Engine, class _UIntType>
inline _UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)
{
        return static_cast<result_type>(__e_() & __mask0_);
}
template <class _Engine, class _UIntType>
_UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)
{
        const size_t _WRt = numeric_limits<result_type>::digits;
        result_type _Sp = 0;
        for (size_t __k = 0; __k < __n0_; ++__k)
        {
            _Engine_result_type __u;
            do
            {
                __u = __e_() - _Engine::min();
            } while (__u >= __y0_);
            if (__w0_ < _WRt)
                _Sp <<= __w0_;
            else
                _Sp = 0;
            _Sp += __u & __mask0_;
        }
        for (size_t __k = __n0_; __k < __n_; ++__k)
        {
            _Engine_result_type __u;
            do
            {
                __u = __e_() - _Engine::min();
            } while (__u >= __y1_);
            if (__w0_ < _WRt - 1)
                _Sp <<= __w0_ + 1;
            else
                _Sp = 0;
            _Sp += __u & __mask1_;
        }
        return _Sp;
}
template <class _IntType = int>
class uniform_int_distribution
{
        _Static_assert(__libcpp_random_is_valid_inttype<_IntType>::value, "IntType must be a supported integer type");

    public:
        typedef _IntType result_type;
        class param_type
        {
            result_type __a_;
            result_type __b_;

        public:
            typedef uniform_int_distribution distribution_type;
            explicit param_type(result_type __a = 0,
                                result_type __b = numeric_limits<result_type>::max())
                : __a_(__a), __b_(__b) {}
            result_type a() const { return __a_; }
            result_type b() const { return __b_; }
            friend bool operator==(const param_type &__x, const param_type &__y)
            {
                return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;
            }
            friend bool operator!=(const param_type &__x, const param_type &__y)
            {
                return !(__x == __y);
            }
        };

    private:
        param_type __p_;

    public:
        explicit uniform_int_distribution(
            result_type __a = 0,
            result_type __b = numeric_limits<result_type>::max())
            : __p_(param_type(__a, __b)) {}
        explicit uniform_int_distribution(const param_type &__p) : __p_(__p) {}
        void reset() {}
        template <class _URNG>
        result_type operator()(_URNG &__g)
        {
            return (*this)(__g, __p_);
        }
        template <class _URNG>
        result_type operator()(_URNG &__g, const param_type &__p);
        result_type a() const { return __p_.a(); }
        result_type b() const { return __p_.b(); }
        param_type param() const { return __p_; }
        void param(const param_type &__p) { __p_ = __p; }
        result_type min() const { return a(); }
        result_type max() const { return b(); }
        friend bool operator==(const uniform_int_distribution &__x,
                               const uniform_int_distribution &__y)
        {
            return __x.__p_ == __y.__p_;
        }
        friend bool operator!=(const uniform_int_distribution &__x,
                               const uniform_int_distribution &__y)
        {
            return !(__x == __y);
        }
};
template <class _IntType>
template <class _URNG>
typename uniform_int_distribution<_IntType>::result_type
uniform_int_distribution<_IntType>::operator()(_URNG &__g, const param_type &__p)

{
        _Static_assert(__libcpp_random_is_valid_urng<_URNG>::value, "");
        typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t), uint32_t,
                                     typename make_unsigned<result_type>::type>::type _UIntType;
        const _UIntType _Rp = _UIntType(__p.b()) - _UIntType(__p.a()) + _UIntType(1);
        if (_Rp == 1)
            return __p.a();
        const size_t _Dt = numeric_limits<_UIntType>::digits;
        typedef __independent_bits_engine<_URNG, _UIntType> _Eng;
        if (_Rp == 0)
            return static_cast<result_type>(_Eng(__g, _Dt)());
        size_t __w = _Dt - __countl_zero(_Rp) - 1;
        if ((_Rp & (numeric_limits<_UIntType>::max() >> (_Dt - __w))) != 0)
            ++__w;
        _Eng __e(__g, __w);
        _UIntType __u;
        do
        {
            __u = __e();
        } while (__u >= _Rp);
        return static_cast<result_type>(__u + __p.a());
}
template <class _CharT, class _Traits, class _IT>
basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os,
           const uniform_int_distribution<_IT> &__x)
{
        __save_flags<_CharT, _Traits> __lx(__os);
        typedef basic_ostream<_CharT, _Traits> _Ostream;
        __os.flags(_Ostream::dec | _Ostream::left);
        _CharT __sp = __os.widen(' ');
        __os.fill(__sp);
        return __os << __x.a() << __sp << __x.b();
}
template <class _CharT, class _Traits, class _IT>
basic_istream<_CharT, _Traits> &
operator>>(basic_istream<_CharT, _Traits> &__is,
           uniform_int_distribution<_IT> &__x)
{
        typedef uniform_int_distribution<_IT> _Eng;
        typedef typename _Eng::result_type result_type;
        typedef typename _Eng::param_type param_type;
        __save_flags<_CharT, _Traits> __lx(__is);
        typedef basic_istream<_CharT, _Traits> _Istream;
        __is.flags(_Istream::dec | _Istream::skipws);
        result_type __a;
        result_type __b;
        __is >> __a >> __b;
        if (!__is.fail())
            __x.param(param_type(__a, __b));
        return __is;
}
}
}

namespace std
{
inline namespace __1
{
template <class _AlgPolicy,
          class _PopulationIterator, class _PopulationSentinel, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>

_SampleIterator __sample(_PopulationIterator __first,
                         _PopulationSentinel __last, _SampleIterator __output_iter,
                         _Distance __n,
                         _UniformRandomNumberGenerator &__g,
                         input_iterator_tag)
{
        _Distance __k = 0;
        for (; __first != __last && __k < __n; ++__first, (void)++__k)
            __output_iter[__k] = *__first;
        _Distance __sz = __k;
        for (; __first != __last; ++__first, (void)++__k)
        {
            _Distance __r = uniform_int_distribution<_Distance>(0, __k)(__g);
            if (__r < __sz)
                __output_iter[__r] = *__first;
        }
        return __output_iter + std::min(__n, __k);
}
template <class _AlgPolicy,
          class _PopulationIterator, class _PopulationSentinel, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>

_SampleIterator __sample(_PopulationIterator __first,
                         _PopulationSentinel __last, _SampleIterator __output_iter,
                         _Distance __n,
                         _UniformRandomNumberGenerator &__g,
                         forward_iterator_tag)
{
        _Distance __unsampled_sz = _IterOps<_AlgPolicy>::distance(__first, __last);
        for (__n = std::min(__n, __unsampled_sz); __n != 0; ++__first)
        {
            _Distance __r = uniform_int_distribution<_Distance>(0, --__unsampled_sz)(__g);
            if (__r < __n)
            {
                *__output_iter++ = *__first;
                --__n;
            }
        }
        return __output_iter;
}
template <class _AlgPolicy,
          class _PopulationIterator, class _PopulationSentinel, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>

_SampleIterator __sample(_PopulationIterator __first,
                         _PopulationSentinel __last, _SampleIterator __output_iter,
                         _Distance __n, _UniformRandomNumberGenerator &__g)
{
        ((void)0);
        using _PopIterCategory = typename _IterOps<_AlgPolicy>::template __iterator_category<_PopulationIterator>;
        using _Difference = typename _IterOps<_AlgPolicy>::template __difference_type<_PopulationIterator>;
        using _CommonType = typename common_type<_Distance, _Difference>::type;
        return std::__sample<_AlgPolicy>(
            std::move(__first), std::move(__last), std::move(__output_iter), _CommonType(__n),
            __g, _PopIterCategory());
}
}
}

namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
template <class _AlgPolicy, class _Pred, class _Iter, class _Sent, class _SizeT, class _Type, class _Proj>

pair<_Iter, _Iter> __search_n_forward_impl(_Iter __first, _Sent __last,
                                           _SizeT __count,
                                           const _Type &__value,
                                           _Pred &__pred,
                                           _Proj &__proj)
{
        if (__count <= 0)
            return std::make_pair(__first, __first);
        while (true)
        {
            while (true)
            {
                if (__first == __last)
                {
                    _IterOps<_AlgPolicy>::__advance_to(__first, __last);
                    return std::make_pair(__first, __first);
                }
                if (std::__invoke(__pred, std::__invoke(__proj, *__first), __value))
                    break;
                ++__first;
            }
            _Iter __m = __first;
            _SizeT __c(0);
            while (true)
            {
                if (++__c == __count)
                    return std::make_pair(__first, ++__m);
                if (++__m == __last)
                {
                    _IterOps<_AlgPolicy>::__advance_to(__first, __last);
                    return std::make_pair(__first, __first);
                }
                if (!std::__invoke(__pred, std::__invoke(__proj, *__m), __value))
                {
                    __first = __m;
                    ++__first;
                    break;
                }
            }
        }
}
template <class _AlgPolicy, class _Pred, class _Iter, class _Sent, class _SizeT, class _Type, class _Proj, class _DiffT>

std::pair<_Iter, _Iter> __search_n_random_access_impl(_Iter __first, _Sent __last,
                                                      _SizeT __count,
                                                      const _Type &__value,
                                                      _Pred &__pred,
                                                      _Proj &__proj,
                                                      _DiffT __size1)
{
        using difference_type = typename iterator_traits<_Iter>::difference_type;
        if (__count == 0)
            return std::make_pair(__first, __first);
        if (__size1 < static_cast<_DiffT>(__count))
        {
            _IterOps<_AlgPolicy>::__advance_to(__first, __last);
            return std::make_pair(__first, __first);
        }
        const auto __s = __first + __size1 - difference_type(__count - 1);
        while (true)
        {
            while (true)
            {
                if (__first >= __s)
                {
                    _IterOps<_AlgPolicy>::__advance_to(__first, __last);
                    return std::make_pair(__first, __first);
                }
                if (std::__invoke(__pred, std::__invoke(__proj, *__first), __value))
                    break;
                ++__first;
            }
            auto __m = __first;
            _SizeT __c(0);
            while (true)
            {
                if (++__c == __count)
                    return std::make_pair(__first, __first + _DiffT(__count));
                ++__m;
                if (!std::__invoke(__pred, std::__invoke(__proj, *__m), __value))
                {
                    __first = __m;
                    ++__first;
                    break;
                }
            }
        }
}
template <class _Iter, class _Sent,
          class _DiffT,
          class _Type,
          class _Pred,
          class _Proj>

pair<_Iter, _Iter> __search_n_impl(_Iter __first, _Sent __last,
                                   _DiffT __count,
                                   const _Type &__value,
                                   _Pred &__pred,
                                   _Proj &__proj,
                                   __enable_if_t<__is_cpp17_random_access_iterator<_Iter>::value> * = __nullptr)
{
        return std::__search_n_random_access_impl<_ClassicAlgPolicy>(__first, __last,
                                                                     __count,
                                                                     __value,
                                                                     __pred,
                                                                     __proj,
                                                                     __last - __first);
}
template <class _Iter1, class _Sent1,
          class _DiffT,
          class _Type,
          class _Pred,
          class _Proj>

pair<_Iter1, _Iter1> __search_n_impl(_Iter1 __first, _Sent1 __last,
                                     _DiffT __count,
                                     const _Type &__value,
                                     _Pred &__pred,
                                     _Proj &__proj,
                                     __enable_if_t<__is_cpp17_forward_iterator<_Iter1>::value && !__is_cpp17_random_access_iterator<_Iter1>::value> * = __nullptr)
{
        return std::__search_n_forward_impl<_ClassicAlgPolicy>(__first, __last,
                                                               __count,
                                                               __value,
                                                               __pred,
                                                               __proj);
}
template <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>
inline _ForwardIterator search_n(_ForwardIterator __first, _ForwardIterator __last,
                                 _Size __count,
                                 const _Tp &__value,
                                 _BinaryPredicate __pred)
{
        _Static_assert(__is_callable<_BinaryPredicate, __decltype(*__first), const _Tp &>::value, "BinaryPredicate has to be callable");
        auto __proj = __identity();
        return std::__search_n_impl(__first, __last, std::__convert_to_integral(__count), __value, __pred, __proj).first;
}
template <class _ForwardIterator, class _Size, class _Tp>
inline _ForwardIterator search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp &__value)
{
        typedef typename iterator_traits<_ForwardIterator>::value_type __v;
        return std::search_n(__first, __last, std::__convert_to_integral(__count), __value, __equal_to<__v, _Tp>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _Comp, class _InIter1, class _Sent1, class _InIter2, class _Sent2, class _OutIter>
pair<__uncvref_t<_InIter1>, __uncvref_t<_OutIter>>
__set_difference(
    _InIter1 &&__first1, _Sent1 &&__last1, _InIter2 &&__first2, _Sent2 &&__last2, _OutIter &&__result, _Comp &&__comp)
{
        while (__first1 != __last1 && __first2 != __last2)
        {
            if (__comp(*__first1, *__first2))
            {
                *__result = *__first1;
                ++__first1;
                ++__result;
            }
            else if (__comp(*__first2, *__first1))
            {
                ++__first2;
            }
            else
            {
                ++__first1;
                ++__first2;
            }
        }
        return std::__copy(std::move(__first1), std::move(__last1), std::move(__result));
}
template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline _OutputIterator set_difference(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result,
    _Compare __comp)
{
        typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
        return std::__set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp).second;
}
template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline _OutputIterator set_difference(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result)
{
        return std::__set_difference(
                   __first1,
                   __last1,
                   __first2,
                   __last2,
                   __result,
                   __less<typename iterator_traits<_InputIterator1>::value_type,
                          typename iterator_traits<_InputIterator2>::value_type>())
            .second;
}
}
}
namespace std
{
inline namespace __1
{
template <class _InIter1, class _InIter2, class _OutIter>
struct __set_intersection_result
{
        _InIter1 __in1_;
        _InIter2 __in2_;
        _OutIter __out_;

        __set_intersection_result(_InIter1 &&__in_iter1, _InIter2 &&__in_iter2, _OutIter &&__out_iter)
            : __in1_(std::move(__in_iter1)), __in2_(std::move(__in_iter2)), __out_(std::move(__out_iter)) {}
};
template <class _AlgPolicy, class _Compare, class _InIter1, class _Sent1, class _InIter2, class _Sent2, class _OutIter>
__set_intersection_result<_InIter1, _InIter2, _OutIter>
__set_intersection(
    _InIter1 __first1, _Sent1 __last1, _InIter2 __first2, _Sent2 __last2, _OutIter __result, _Compare &&__comp)
{
        while (__first1 != __last1 && __first2 != __last2)
        {
            if (__comp(*__first1, *__first2))
                ++__first1;
            else
            {
                if (!__comp(*__first2, *__first1))
                {
                    *__result = *__first1;
                    ++__result;
                    ++__first1;
                }
                ++__first2;
            }
        }
        return __set_intersection_result<_InIter1, _InIter2, _OutIter>(
            _IterOps<_AlgPolicy>::next(std::move(__first1), std::move(__last1)),
            _IterOps<_AlgPolicy>::next(std::move(__first2), std::move(__last2)),
            std::move(__result));
}
template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline _OutputIterator set_intersection(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result,
    _Compare __comp)
{
        typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
        return std::__set_intersection<_ClassicAlgPolicy, _Comp_ref>(
                   std::move(__first1),
                   std::move(__last1),
                   std::move(__first2),
                   std::move(__last2),
                   std::move(__result),
                   __comp)
            .__out_;
}
template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline _OutputIterator set_intersection(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result)
{
        return std::__set_intersection<_ClassicAlgPolicy>(
                   std::move(__first1),
                   std::move(__last1),
                   std::move(__first2),
                   std::move(__last2),
                   std::move(__result),
                   __less<typename iterator_traits<_InputIterator1>::value_type,
                          typename iterator_traits<_InputIterator2>::value_type>())
            .__out_;
}
}
}
namespace std
{
inline namespace __1
{
template <class _InIter1, class _InIter2, class _OutIter>
struct __set_symmetric_difference_result
{
        _InIter1 __in1_;
        _InIter2 __in2_;
        _OutIter __out_;

        __set_symmetric_difference_result(_InIter1 &&__in_iter1, _InIter2 &&__in_iter2, _OutIter &&__out_iter)
            : __in1_(std::move(__in_iter1)), __in2_(std::move(__in_iter2)), __out_(std::move(__out_iter)) {}
};
template <class _Compare, class _InIter1, class _Sent1, class _InIter2, class _Sent2, class _OutIter>
__set_symmetric_difference_result<_InIter1, _InIter2, _OutIter>
__set_symmetric_difference(
    _InIter1 __first1, _Sent1 __last1, _InIter2 __first2, _Sent2 __last2, _OutIter __result, _Compare &&__comp)
{
        while (__first1 != __last1)
        {
            if (__first2 == __last2)
            {
                auto __ret1 = std::__copy_impl(std::move(__first1), std::move(__last1), std::move(__result));
                return __set_symmetric_difference_result<_InIter1, _InIter2, _OutIter>(
                    std::move(__ret1.first), std::move(__first2), std::move((__ret1.second)));
            }
            if (__comp(*__first1, *__first2))
            {
                *__result = *__first1;
                ++__result;
                ++__first1;
            }
            else
            {
                if (__comp(*__first2, *__first1))
                {
                    *__result = *__first2;
                    ++__result;
                }
                else
                {
                    ++__first1;
                }
                ++__first2;
            }
        }
        auto __ret2 = std::__copy_impl(std::move(__first2), std::move(__last2), std::move(__result));
        return __set_symmetric_difference_result<_InIter1, _InIter2, _OutIter>(
            std::move(__first1), std::move(__ret2.first), std::move((__ret2.second)));
}
template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
_OutputIterator set_symmetric_difference(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result,
    _Compare __comp)
{
        typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
        return std::__set_symmetric_difference<_Comp_ref>(
                   std::move(__first1),
                   std::move(__last1),
                   std::move(__first2),
                   std::move(__last2),
                   std::move(__result),
                   __comp)
            .__out_;
}
template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator set_symmetric_difference(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result)
{
        return std::set_symmetric_difference(
            std::move(__first1),
            std::move(__last1),
            std::move(__first2),
            std::move(__last2),
            std::move(__result),
            __less<typename iterator_traits<_InputIterator1>::value_type,
                   typename iterator_traits<_InputIterator2>::value_type>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _InIter1, class _InIter2, class _OutIter>
struct __set_union_result
{
        _InIter1 __in1_;
        _InIter2 __in2_;
        _OutIter __out_;

        __set_union_result(_InIter1 &&__in_iter1, _InIter2 &&__in_iter2, _OutIter &&__out_iter)
            : __in1_(std::move(__in_iter1)), __in2_(std::move(__in_iter2)), __out_(std::move(__out_iter)) {}
};
template <class _Compare, class _InIter1, class _Sent1, class _InIter2, class _Sent2, class _OutIter>
__set_union_result<_InIter1, _InIter2, _OutIter> __set_union(
    _InIter1 __first1, _Sent1 __last1, _InIter2 __first2, _Sent2 __last2, _OutIter __result, _Compare &&__comp)
{
        for (; __first1 != __last1; ++__result)
        {
            if (__first2 == __last2)
            {
                auto __ret1 = std::__copy_impl(std::move(__first1), std::move(__last1), std::move(__result));
                return __set_union_result<_InIter1, _InIter2, _OutIter>(
                    std::move(__ret1.first), std::move(__first2), std::move((__ret1.second)));
            }
            if (__comp(*__first2, *__first1))
            {
                *__result = *__first2;
                ++__first2;
            }
            else
            {
                if (!__comp(*__first1, *__first2))
                {
                    ++__first2;
                }
                *__result = *__first1;
                ++__first1;
            }
        }
        auto __ret2 = std::__copy_impl(std::move(__first2), std::move(__last2), std::move(__result));
        return __set_union_result<_InIter1, _InIter2, _OutIter>(
            std::move(__first1), std::move(__ret2.first), std::move((__ret2.second)));
}
template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
_OutputIterator set_union(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result,
    _Compare __comp)
{
        typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
        return std::__set_union<_Comp_ref>(
                   std::move(__first1),
                   std::move(__last1),
                   std::move(__first2),
                   std::move(__last2),
                   std::move(__result),
                   __comp)
            .__out_;
}
template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator set_union(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result)
{
        return std::set_union(
            std::move(__first1),
            std::move(__last1),
            std::move(__first2),
            std::move(__last2),
            std::move(__result),
            __less<typename iterator_traits<_InputIterator1>::value_type,
                   typename iterator_traits<_InputIterator2>::value_type>());
}
}
}

namespace std
{
inline namespace __1
{
class __libcpp_debug_randomizer
{
    public:
        __libcpp_debug_randomizer()
        {
            __state = __seed();
            __inc = __state + 0xda3e39cb94b95bdbULL;
            __inc = (__inc << 1) | 1;
        }
        typedef uint_fast32_t result_type;
        static const result_type _Min = 0;
        static const result_type _Max = 0xFFFFFFFF;
        {
            uint_fast64_t __oldstate = __state;
            __state = __oldstate * 6364136223846793005ULL + __inc;
            return __oldstate >> 32;
        }
        static { return _Min; }
        static { return _Max; }

    private:
        uint_fast64_t __state;
        uint_fast64_t __inc;
        {
            static char __x;
            return reinterpret_cast<uintptr_t>(&__x);
        }
};
class __rs_default;
;
class __rs_default
{
        static unsigned __c_;
        __rs_default();

    public:
        typedef uint_fast32_t result_type;
        static const result_type _Min = 0;
        static const result_type _Max = 0xFFFFFFFF;
        __rs_default(const __rs_default &);
        ~__rs_default();
        result_type operator()();
        static result_type min() { return _Min; }
        static result_type max() { return _Max; }
        friend;
};
;
template <class _RandomAccessIterator>
void random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
        typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
        typedef uniform_int_distribution<ptrdiff_t> _Dp;
        typedef typename _Dp::param_type _Pp;
        difference_type __d = __last - __first;
        if (__d > 1)
        {
            _Dp __uid;
            __rs_default __g = __rs_get();
            for (--__last, (void)--__d; __first < __last; ++__first, (void)--__d)
            {
                difference_type __i = __uid(__g, _Pp(0, __d));
                if (__i != difference_type(0))
                    swap(*__first, *(__first + __i));
            }
        }
}
template <class _RandomAccessIterator, class _RandomNumberGenerator>
void random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
                    _RandomNumberGenerator &__rand)
{
        typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
        difference_type __d = __last - __first;
        if (__d > 1)
        {
            for (--__last; __first < __last; ++__first, (void)--__d)
            {
                difference_type __i = __rand(__d);
                if (__i != difference_type(0))
                    swap(*__first, *(__first + __i));
            }
        }
}
template <class _AlgPolicy, class _RandomAccessIterator, class _Sentinel, class _UniformRandomNumberGenerator>
_RandomAccessIterator __shuffle(
    _RandomAccessIterator __first, _Sentinel __last_sentinel, _UniformRandomNumberGenerator &&__g)
{
        typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
        typedef uniform_int_distribution<ptrdiff_t> _Dp;
        typedef typename _Dp::param_type _Pp;
        auto __original_last = _IterOps<_AlgPolicy>::next(__first, __last_sentinel);
        auto __last = __original_last;
        difference_type __d = __last - __first;
        if (__d > 1)
        {
            _Dp __uid;
            for (--__last, (void)--__d; __first < __last; ++__first, (void)--__d)
            {
                difference_type __i = __uid(__g, _Pp(0, __d));
                if (__i != difference_type(0))
                    _IterOps<_AlgPolicy>::iter_swap(__first, __first + __i);
            }
        }
        return __original_last;
}
template <class _RandomAccessIterator, class _UniformRandomNumberGenerator>
void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
             _UniformRandomNumberGenerator &&__g)
{
        (void)std::__shuffle<_ClassicAlgPolicy>(
            std::move(__first), std::move(__last), std::forward<_UniformRandomNumberGenerator>(__g));
}
}
}
extern "C"
{
void __assert_rtn(const char *, const char *, int, const char *);
}
namespace std
{
inline namespace __1
{
template <class _AlgPolicy, class _Predicate, class _ForwardIterator, class _Distance, class _Pair>
_ForwardIterator
__stable_partition_impl(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                        _Distance __len, _Pair __p, forward_iterator_tag __fit)
{
        using _Ops = _IterOps<_AlgPolicy>;
        if (__len == 1)
            return __first;
        if (__len == 2)
        {
            _ForwardIterator __m = __first;
            if (__pred(*++__m))
            {
                _Ops::iter_swap(__first, __m);
                return __m;
            }
            return __first;
        }
        if (__len <= __p.second)
        {
            typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
            __destruct_n __d(0);
            unique_ptr<value_type, __destruct_n &> __h(__p.first, __d);
            value_type *__t = __p.first;
            ::new ((void *)__t) value_type(_Ops::__iter_move(__first));
            __d.template __incr<value_type>();
            ++__t;
            _ForwardIterator __i = __first;
            while (++__i != __last)
            {
                if (__pred(*__i))
                {
                    *__first = _Ops::__iter_move(__i);
                    ++__first;
                }
                else
                {
                    ::new ((void *)__t) value_type(_Ops::__iter_move(__i));
                    __d.template __incr<value_type>();
                    ++__t;
                }
            }
            __i = __first;
            for (value_type *__t2 = __p.first; __t2 < __t; ++__t2, (void)++__i)
                *__i = _Ops::__iter_move(__t2);
            return __first;
        }
        _ForwardIterator __m = __first;
        _Distance __len2 = __len / 2;
        _Ops::advance(__m, __len2);
        _ForwardIterator __first_false = std::__stable_partition_impl<_AlgPolicy, _Predicate &>(
            __first, __m, __pred, __len2, __p, __fit);
        _ForwardIterator __m1 = __m;
        _ForwardIterator __second_false = __last;
        _Distance __len_half = __len - __len2;
        while (__pred(*__m1))
        {
            if (++__m1 == __last)
                goto __second_half_done;
            --__len_half;
        }
        __second_false = std::__stable_partition_impl<_AlgPolicy, _Predicate &>(
            __m1, __last, __pred, __len_half, __p, __fit);
__second_half_done:
        return std::__rotate<_AlgPolicy>(__first_false, __m, __second_false).first;
}
template <class _AlgPolicy, class _Predicate, class _ForwardIterator>
_ForwardIterator
__stable_partition_impl(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                        forward_iterator_tag)
{
        const unsigned __alloc_limit = 3;
        while (true)
        {
            if (__first == __last)
                return __first;
            if (!__pred(*__first))
                break;
            ++__first;
        }
        typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
        difference_type __len = _IterOps<_AlgPolicy>::distance(__first, __last);
        pair<value_type *, ptrdiff_t> __p(0, 0);
        unique_ptr<value_type, __return_temporary_buffer> __h;
        if (__len >= __alloc_limit)
        {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
            __p = std::get_temporary_buffer<value_type>(__len);
#pragma GCC diagnostic pop
            __h.reset(__p.first);
        }
        return std::__stable_partition_impl<_AlgPolicy, _Predicate &>(
            std::move(__first), std::move(__last), __pred, __len, __p, forward_iterator_tag());
}
template <class _AlgPolicy, class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>
_BidirectionalIterator
__stable_partition_impl(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                        _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)
{
        using _Ops = _IterOps<_AlgPolicy>;
        if (__len == 2)
        {
            _Ops::iter_swap(__first, __last);
            return __last;
        }
        if (__len == 3)
        {
            _BidirectionalIterator __m = __first;
            if (__pred(*++__m))
            {
                _Ops::iter_swap(__first, __m);
                _Ops::iter_swap(__m, __last);
                return __last;
            }
            _Ops::iter_swap(__m, __last);
            _Ops::iter_swap(__first, __m);
            return __m;
        }
        if (__len <= __p.second)
        {
            typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
            __destruct_n __d(0);
            unique_ptr<value_type, __destruct_n &> __h(__p.first, __d);
            value_type *__t = __p.first;
            ::new ((void *)__t) value_type(_Ops::__iter_move(__first));
            __d.template __incr<value_type>();
            ++__t;
            _BidirectionalIterator __i = __first;
            while (++__i != __last)
            {
                if (__pred(*__i))
                {
                    *__first = _Ops::__iter_move(__i);
                    ++__first;
                }
                else
                {
                    ::new ((void *)__t) value_type(_Ops::__iter_move(__i));
                    __d.template __incr<value_type>();
                    ++__t;
                }
            }
            *__first = _Ops::__iter_move(__i);
            __i = ++__first;
            for (value_type *__t2 = __p.first; __t2 < __t; ++__t2, (void)++__i)
                *__i = _Ops::__iter_move(__t2);
            return __first;
        }
        _BidirectionalIterator __m = __first;
        _Distance __len2 = __len / 2;
        _Ops::advance(__m, __len2);
        _BidirectionalIterator __m1 = __m;
        _BidirectionalIterator __first_false = __first;
        _Distance __len_half = __len2;
        while (!__pred(*--__m1))
        {
            if (__m1 == __first)
                goto __first_half_done;
            --__len_half;
        }
        __first_false = std::__stable_partition_impl<_AlgPolicy, _Predicate &>(
            __first, __m1, __pred, __len_half, __p, __bit);
__first_half_done:
        __m1 = __m;
        _BidirectionalIterator __second_false = __last;
        ++__second_false;
        __len_half = __len - __len2;
        while (__pred(*__m1))
        {
            if (++__m1 == __last)
                goto __second_half_done;
            --__len_half;
        }
        __second_false = std::__stable_partition_impl<_AlgPolicy, _Predicate &>(
            __m1, __last, __pred, __len_half, __p, __bit);
__second_half_done:
        return std::__rotate<_AlgPolicy>(__first_false, __m, __second_false).first;
}
template <class _AlgPolicy, class _Predicate, class _BidirectionalIterator>
_BidirectionalIterator
__stable_partition_impl(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                        bidirectional_iterator_tag)
{
        typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
        const difference_type __alloc_limit = 4;
        while (true)
        {
            if (__first == __last)
                return __first;
            if (!__pred(*__first))
                break;
            ++__first;
        }
        do
        {
            if (__first == --__last)
                return __first;
        } while (!__pred(*__last));
        difference_type __len = _IterOps<_AlgPolicy>::distance(__first, __last) + 1;
        pair<value_type *, ptrdiff_t> __p(0, 0);
        unique_ptr<value_type, __return_temporary_buffer> __h;
        if (__len >= __alloc_limit)
        {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
            __p = std::get_temporary_buffer<value_type>(__len);
#pragma GCC diagnostic pop
            __h.reset(__p.first);
        }
        return std::__stable_partition_impl<_AlgPolicy, _Predicate &>(
            std::move(__first), std::move(__last), __pred, __len, __p, bidirectional_iterator_tag());
}
template <class _AlgPolicy, class _Predicate, class _ForwardIterator, class _IterCategory>

_ForwardIterator __stable_partition(
    _ForwardIterator __first, _ForwardIterator __last, _Predicate &&__pred, _IterCategory __iter_category)
{
        return std::__stable_partition_impl<_AlgPolicy, __uncvref_t<_Predicate> &>(
            std::move(__first), std::move(__last), __pred, __iter_category);
}
template <class _ForwardIterator, class _Predicate>
inline _ForwardIterator
stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
        using _IterCategory = typename iterator_traits<_ForwardIterator>::iterator_category;
        return std::__stable_partition<_ClassicAlgPolicy, _Predicate &>(
            std::move(__first), std::move(__last), __pred, _IterCategory());
}
}
}
extern "C"
{
void __assert_rtn(const char *, const char *, int, const char *);
}
namespace std
{
inline namespace __1
{
template <class _AlgPolicy, class _Compare, class _InputIterator1, class _InputIterator2>
void __merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,
                            _InputIterator2 __first2, _InputIterator2 __last2,
                            typename iterator_traits<_InputIterator1>::value_type *__result, _Compare __comp)
{
        using _Ops = _IterOps<_AlgPolicy>;
        typedef typename iterator_traits<_InputIterator1>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n &> __h(__result, __d);
        for (; true; ++__result)
        {
            if (__first1 == __last1)
            {
                for (; __first2 != __last2; ++__first2, (void)++__result, __d.template __incr<value_type>())
                    ::new ((void *)__result) value_type(_Ops::__iter_move(__first2));
                __h.release();
                return;
            }
            if (__first2 == __last2)
            {
                for (; __first1 != __last1; ++__first1, (void)++__result, __d.template __incr<value_type>())
                    ::new ((void *)__result) value_type(_Ops::__iter_move(__first1));
                __h.release();
                return;
            }
            if (__comp(*__first2, *__first1))
            {
                ::new ((void *)__result) value_type(_Ops::__iter_move(__first2));
                __d.template __incr<value_type>();
                ++__first2;
            }
            else
            {
                ::new ((void *)__result) value_type(_Ops::__iter_move(__first1));
                __d.template __incr<value_type>();
                ++__first1;
            }
        }
}
template <class _AlgPolicy, class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
void __merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,
                         _InputIterator2 __first2, _InputIterator2 __last2,
                         _OutputIterator __result, _Compare __comp)
{
        using _Ops = _IterOps<_AlgPolicy>;
        for (; __first1 != __last1; ++__result)
        {
            if (__first2 == __last2)
            {
                for (; __first1 != __last1; ++__first1, (void)++__result)
                    *__result = _Ops::__iter_move(__first1);
                return;
            }
            if (__comp(*__first2, *__first1))
            {
                *__result = _Ops::__iter_move(__first2);
                ++__first2;
            }
            else
            {
                *__result = _Ops::__iter_move(__first1);
                ++__first1;
            }
        }
        for (; __first2 != __last2; ++__first2, (void)++__result)
            *__result = _Ops::__iter_move(__first2);
}
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
void __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,
                   typename iterator_traits<_RandomAccessIterator>::value_type *__buff, ptrdiff_t __buff_size);
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
void __stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,
                        typename iterator_traits<_RandomAccessIterator>::difference_type __len,
                        typename iterator_traits<_RandomAccessIterator>::value_type *__first2)
{
        using _Ops = _IterOps<_AlgPolicy>;
        typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
        switch (__len)
        {
        case 0:
            return;
        case 1:
            ::new ((void *)__first2) value_type(_Ops::__iter_move(__first1));
            return;
        case 2:
            __destruct_n __d(0);
            unique_ptr<value_type, __destruct_n &> __h2(__first2, __d);
            if (__comp(*--__last1, *__first1))
            {
                ::new ((void *)__first2) value_type(_Ops::__iter_move(__last1));
                __d.template __incr<value_type>();
                ++__first2;
                ::new ((void *)__first2) value_type(_Ops::__iter_move(__first1));
            }
            else
            {
                ::new ((void *)__first2) value_type(_Ops::__iter_move(__first1));
                __d.template __incr<value_type>();
                ++__first2;
                ::new ((void *)__first2) value_type(_Ops::__iter_move(__last1));
            }
            __h2.release();
            return;
        }
        if (__len <= 8)
        {
            std::__insertion_sort_move<_AlgPolicy, _Compare>(__first1, __last1, __first2, __comp);
            return;
        }
        typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
        _RandomAccessIterator __m = __first1 + __l2;
        std::__stable_sort<_AlgPolicy, _Compare>(__first1, __m, __comp, __l2, __first2, __l2);
        std::__stable_sort<_AlgPolicy, _Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);
        std::__merge_move_construct<_AlgPolicy, _Compare>(__first1, __m, __m, __last1, __first2, __comp);
}
template <class _Tp>
struct __stable_sort_switch
{
        static const unsigned value = 128 * is_trivially_copy_assignable<_Tp>::value;
};
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
void __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,
                   typename iterator_traits<_RandomAccessIterator>::value_type *__buff, ptrdiff_t __buff_size)
{
        typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
        typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
        switch (__len)
        {
        case 0:
        case 1:
            return;
        case 2:
            if (__comp(*--__last, *__first))
                _IterOps<_AlgPolicy>::iter_swap(__first, __last);
            return;
        }
        if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))
        {
            std::__insertion_sort<_AlgPolicy, _Compare>(__first, __last, __comp);
            return;
        }
        typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
        _RandomAccessIterator __m = __first + __l2;
        if (__len <= __buff_size)
        {
            __destruct_n __d(0);
            unique_ptr<value_type, __destruct_n &> __h2(__buff, __d);
            std::__stable_sort_move<_AlgPolicy, _Compare>(__first, __m, __comp, __l2, __buff);
            __d.__set(__l2, (value_type *)__nullptr);
            std::__stable_sort_move<_AlgPolicy, _Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);
            __d.__set(__len, (value_type *)__nullptr);
            std::__merge_move_assign<_AlgPolicy, _Compare>(
                __buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);
            return;
        }
        std::__stable_sort<_AlgPolicy, _Compare>(__first, __m, __comp, __l2, __buff, __buff_size);
        std::__stable_sort<_AlgPolicy, _Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);
        std::__inplace_merge<_AlgPolicy>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);
}
template <class _AlgPolicy, class _RandomAccessIterator, class _Compare>
inline void __stable_sort_impl(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare &__comp)
{
        using value_type = typename iterator_traits<_RandomAccessIterator>::value_type;
        using difference_type = typename iterator_traits<_RandomAccessIterator>::difference_type;
        difference_type __len = __last - __first;
        pair<value_type *, ptrdiff_t> __buf(0, 0);
        unique_ptr<value_type, __return_temporary_buffer> __h;
        if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))
        {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
            __buf = std::get_temporary_buffer<value_type>(__len);
#pragma GCC diagnostic pop
            __h.reset(__buf.first);
        }
        using _Comp_ref = typename __comp_ref_type<_Compare>::type;
        std::__stable_sort<_AlgPolicy, _Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);
}
template <class _RandomAccessIterator, class _Compare>
inline void stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
        std::__stable_sort_impl<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __comp);
}
template <class _RandomAccessIterator>
inline void stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
        std::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}
}
}
namespace std
{
inline namespace __1
{
template <class _AlgPolicy, class _Iter, class _Sent, class _BinaryPredicate>
std::pair<_Iter, _Iter>
__unique(_Iter __first, _Sent __last, _BinaryPredicate &&__pred)
{
        __first = std::__adjacent_find(__first, __last, __pred);
        if (__first != __last)
        {
            _Iter __i = __first;
            for (++__i; ++__i != __last;)
                if (!__pred(*__first, *__i))
                    *++__first = _IterOps<_AlgPolicy>::__iter_move(__i);
            ++__first;
            return std::pair<_Iter, _Iter>(std::move(__first), std::move(__i));
        }
        return std::pair<_Iter, _Iter>(__first, __first);
}
template <class _ForwardIterator, class _BinaryPredicate>
_ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)
{
        return std::__unique<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __pred).first;
}
template <class _ForwardIterator>
inline _ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last)
{
        typedef typename iterator_traits<_ForwardIterator>::value_type __v;
        return std::unique(__first, __last, __equal_to<__v>());
}
}
}
namespace std
{
inline namespace __1
{
namespace __unique_copy_tags
{
        struct __reread_from_input_tag
        {
        };
        struct __reread_from_output_tag
        {
        };
        struct __read_from_tmp_value_tag
        {
        };
}
template <class _AlgPolicy, class _BinaryPredicate, class _InputIterator, class _Sent, class _OutputIterator>
pair<_InputIterator, _OutputIterator>
__unique_copy(_InputIterator __first,
              _Sent __last,
              _OutputIterator __result,
              _BinaryPredicate &&__pred,
              __unique_copy_tags::__read_from_tmp_value_tag)
{
        if (__first != __last)
        {
            typename _IterOps<_AlgPolicy>::template __value_type<_InputIterator> __t(*__first);
            *__result = __t;
            ++__result;
            while (++__first != __last)
            {
                if (!__pred(__t, *__first))
                {
                    __t = *__first;
                    *__result = __t;
                    ++__result;
                }
            }
        }
        return pair<_InputIterator, _OutputIterator>(std::move(__first), std::move(__result));
}
template <class _AlgPolicy, class _BinaryPredicate, class _ForwardIterator, class _Sent, class _OutputIterator>
pair<_ForwardIterator, _OutputIterator>
__unique_copy(_ForwardIterator __first,
              _Sent __last,
              _OutputIterator __result,
              _BinaryPredicate &&__pred,
              __unique_copy_tags::__reread_from_input_tag)
{
        if (__first != __last)
        {
            _ForwardIterator __i = __first;
            *__result = *__i;
            ++__result;
            while (++__first != __last)
            {
                if (!__pred(*__i, *__first))
                {
                    *__result = *__first;
                    ++__result;
                    __i = __first;
                }
            }
        }
        return pair<_ForwardIterator, _OutputIterator>(std::move(__first), std::move(__result));
}
template <class _AlgPolicy, class _BinaryPredicate, class _InputIterator, class _Sent, class _InputAndOutputIterator>
pair<_InputIterator, _InputAndOutputIterator>
__unique_copy(_InputIterator __first,
              _Sent __last,
              _InputAndOutputIterator __result,
              _BinaryPredicate &&__pred,
              __unique_copy_tags::__reread_from_output_tag)
{
        if (__first != __last)
        {
            *__result = *__first;
            while (++__first != __last)
                if (!__pred(*__result, *__first))
                    *++__result = *__first;
            ++__result;
        }
        return pair<_InputIterator, _InputAndOutputIterator>(std::move(__first), std::move(__result));
}
template <class _InputIterator, class _OutputIterator, class _BinaryPredicate>
inline _OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)
{
        using __algo_tag = typename conditional<
            is_base_of<forward_iterator_tag, typename iterator_traits<_InputIterator>::iterator_category>::value,
            __unique_copy_tags::__reread_from_input_tag,
            typename conditional<
                is_base_of<forward_iterator_tag, typename iterator_traits<_OutputIterator>::iterator_category>::value &&
                    is_same<typename iterator_traits<_InputIterator>::value_type,
                            typename iterator_traits<_OutputIterator>::value_type>::value,
                __unique_copy_tags::__reread_from_output_tag,
                __unique_copy_tags::__read_from_tmp_value_tag>::type>::type;
        return std::__unique_copy<_ClassicAlgPolicy>(
                   std::move(__first), std::move(__last), std::move(__result), __pred, __algo_tag())
            .second;
}
template <class _InputIterator, class _OutputIterator>
inline _OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
        typedef typename iterator_traits<_InputIterator>::value_type __v;
        return std::unique_copy(std::move(__first), std::move(__last), std::move(__result), __equal_to<__v>());
}
}
}

namespace std
{
inline namespace __1
{
template <class _InputIterator, class _OutputIterator, class _Tp>
inline _OutputIterator
remove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp &__value)
{
        for (; __first != __last; ++__first)
        {
            if (!(*__first == __value))
            {
                *__result = *__first;
                ++__result;
            }
        }
        return __result;
}
}
}
namespace std
{
inline namespace __1
{
template <class _ForwardIterator, class _Tp>
inline void
replace(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__old_value, const _Tp &__new_value)
{
        for (; __first != __last; ++__first)
            if (*__first == __old_value)
                *__first = __new_value;
}
}
}
namespace std
{
inline namespace __1
{
template <class _InputIterator, class _OutputIterator, class _Tp>
inline _OutputIterator
replace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
             const _Tp &__old_value, const _Tp &__new_value)
{
        for (; __first != __last; ++__first, (void)++__result)
            if (*__first == __old_value)
                *__result = __new_value;
            else
                *__result = *__first;
        return __result;
}
}
}
namespace std
{
inline namespace __1
{
template <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>
inline _OutputIterator
replace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
                _Predicate __pred, const _Tp &__new_value)
{
        for (; __first != __last; ++__first, (void)++__result)
            if (__pred(*__first))
                *__result = __new_value;
            else
                *__result = *__first;
        return __result;
}
}
}
namespace std
{
inline namespace __1
{
template <class _ForwardIterator, class _Predicate, class _Tp>
inline void
replace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp &__new_value)
{
        for (; __first != __last; ++__first)
            if (__pred(*__first))
                *__first = __new_value;
}
}
}

namespace std
{
inline namespace __1
{
template <class _BidirectionalIterator, class _OutputIterator>
inline _OutputIterator
reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
        for (; __first != __last; ++__result)
            *__result = *--__last;
        return __result;
}
}
}

namespace std
{
inline namespace __1
{
template <class _ForwardIterator, class _OutputIterator>
inline _OutputIterator
rotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)
{
        return std::copy(__first, __middle, std::copy(__middle, __last, __result));
}
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
template <class _InputIterator, class _OutputIterator, class _UnaryOperation>
inline _OutputIterator
transform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)
{
        for (; __first != __last; ++__first, (void)++__result)
            *__result = __op(*__first);
        return __result;
}
template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>
inline _OutputIterator
transform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
          _OutputIterator __result, _BinaryOperation __binary_op)
{
        for (; __first1 != __last1; ++__first1, (void)++__first2, ++__result)
            *__result = __binary_op(*__first1, *__first2);
        return __result;
}
}
}
namespace std
{
inline namespace __1
{
template <class _Predicate>
class binary_negate
    : public __binary_function<typename _Predicate::first_argument_type,
                               typename _Predicate::second_argument_type,
                               bool>
{
        _Predicate __pred_;

    public:
        explicit binary_negate(const _Predicate &__pred) : __pred_(__pred) {}

        bool operator()(const typename _Predicate::first_argument_type &__x,
                        const typename _Predicate::second_argument_type &__y) const
        {
            return !__pred_(__x, __y);
        }
};
template <class _Predicate>
inline binary_negate<_Predicate>
not2(const _Predicate &__pred) { return binary_negate<_Predicate>(__pred); }
}
}
namespace std
{
inline namespace __1
{
template <class _Tp>
struct is_bind_expression : _If<
                                _IsSame<_Tp, __uncvref_t<_Tp>>::value,
                                false_type,
                                is_bind_expression<__uncvref_t<_Tp>>>
{
};
template <class _Tp>
struct is_placeholder : _If<
                            _IsSame<_Tp, __uncvref_t<_Tp>>::value,
                            integral_constant<int, 0>,
                            is_placeholder<__uncvref_t<_Tp>>>
{
};
namespace placeholders
{
        template <int _Np>
        struct __ph
        {
        };
        extern const __ph<1> _1;
        extern const __ph<2> _2;
        extern const __ph<3> _3;
        extern const __ph<4> _4;
        extern const __ph<5> _5;
        extern const __ph<6> _6;
        extern const __ph<7> _7;
        extern const __ph<8> _8;
        extern const __ph<9> _9;
        extern const __ph<10> _10;
}
template <int _Np>
struct is_placeholder<placeholders::__ph<_Np>>
    : public integral_constant<int, _Np>
{
};
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
}
}
namespace std
{
inline namespace __1
{
template <class __Operation>
class binder1st
    : public __unary_function<typename __Operation::second_argument_type, typename __Operation::result_type>
{
    protected:
        __Operation op;
        typename __Operation::first_argument_type value;

    public:
        binder1st(const __Operation &__x,
                  const typename __Operation::first_argument_type __y)
            : op(__x), value(__y){}

              (typename __Operation::second_argument_type & __x) const
        {
            return op(value, __x);
        }

        (const typename __Operation::second_argument_type &__x) const
        {
            return op(value, __x);
        }
};
template <class __Operation, class _Tp>
inline binder1st<__Operation>
bind1st(const __Operation &__op, const _Tp &__x)
{
        return binder1st<__Operation>(__op, __x);
}
}
}
namespace std
{
inline namespace __1
{
template <class __Operation>
class binder2nd
    : public __unary_function<typename __Operation::first_argument_type, typename __Operation::result_type>
{
    protected:
        __Operation op;
        typename __Operation::second_argument_type value;

    public:
        binder2nd(const __Operation &__x, const typename __Operation::second_argument_type __y)
            : op(__x), value(__y){}

              (typename __Operation::first_argument_type & __x) const
        {
            return op(__x, value);
        }

        (const typename __Operation::first_argument_type &__x) const
        {
            return op(__x, value);
        }
};
template <class __Operation, class _Tp>
inline binder2nd<__Operation>
bind2nd(const __Operation &__op, const _Tp &__x)
{
        return binder2nd<__Operation>(__op, __x);
}
}
}
namespace std
{
inline namespace __1
{
template <class _Tp, size_t _Size>
struct array
{
        typedef array __self;
        typedef _Tp value_type;
        typedef value_type &reference;
        typedef const value_type &const_reference;
        typedef value_type *iterator;
        typedef const value_type *const_iterator;
        typedef value_type *pointer;
        typedef const value_type *const_pointer;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef std::reverse_iterator<iterator> reverse_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
        _Tp __elems_[_Size];

        void fill(const value_type &__u)
        {
            std::fill_n(data(), _Size, __u);
        }

        void swap(array &__a)
        {
            std::swap_ranges(data(), data() + _Size, __a.data());
        }

        iterator begin() throw() { return iterator(data()); }

        const_iterator begin() const throw() { return const_iterator(data()); }

        iterator end() throw() { return iterator(data() + _Size); }

        const_iterator end() const throw() { return const_iterator(data() + _Size); }

        reverse_iterator rbegin() throw() { return reverse_iterator(end()); }

        const_reverse_iterator rbegin() const throw() { return const_reverse_iterator(end()); }

        reverse_iterator rend() throw() { return reverse_iterator(begin()); }

        const_reverse_iterator rend() const throw() { return const_reverse_iterator(begin()); }

        const_iterator cbegin() const throw() { return begin(); }

        const_iterator cend() const throw() { return end(); }

        const_reverse_iterator crbegin() const throw() { return rbegin(); }

        const_reverse_iterator crend() const throw() { return rend(); }

        size_type size() const throw() { return _Size; }

        size_type max_size() const throw() { return _Size; }

        bool empty() const throw() { return _Size == 0; }

        reference operator[](size_type __n) throw()
        {
            ((void)0);
            return __elems_[__n];
        }

        const_reference operator[](size_type __n) const throw()
        {
            ((void)0);
            return __elems_[__n];
        }
        reference at(size_type __n)
        {
            if (__n >= _Size)
                __throw_out_of_range("array::at");
            return __elems_[__n];
        }
        const_reference at(size_type __n) const
        {
            if (__n >= _Size)
                __throw_out_of_range("array::at");
            return __elems_[__n];
        }
        [0];
}
    [0];
}
[_Size - 1];
}
[_Size - 1];
}

value_type *data() throw() { return __elems_; }

const value_type *data() const throw() { return __elems_; }
}
;
template <class _Tp>
struct array<_Tp, 0>
{
typedef array __self;
typedef _Tp value_type;
typedef value_type &reference;
typedef const value_type &const_reference;
typedef value_type *iterator;
typedef const value_type *const_iterator;
typedef value_type *pointer;
typedef const value_type *const_pointer;
typedef size_t size_type;
typedef ptrdiff_t difference_type;
typedef std::reverse_iterator<iterator> reverse_iterator;
typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
typedef typename conditional<is_const<_Tp>::value, const char,
                             char>::type _CharType;
struct _ArrayInStructT
{
_Tp __data_[1];
};
    ];

    value_type *data() throw() { return __nullptr; }

    const value_type *data() const throw() { return __nullptr; }

    void fill(const value_type &)
    {
_Static_assert(!is_const<_Tp>::value, "cannot fill zero-sized array of type 'const T'");
    }

    void swap(array &) throw()
    {
_Static_assert(!is_const<_Tp>::value, "cannot swap zero-sized array of type 'const T'");
    }

    iterator begin() throw() { return iterator(data()); }

    const_iterator begin() const throw() { return const_iterator(data()); }

    iterator end() throw() { return iterator(data()); }

    const_iterator end() const throw() { return const_iterator(data()); }

    reverse_iterator rbegin() throw() { return reverse_iterator(end()); }

    const_reverse_iterator rbegin() const throw() { return const_reverse_iterator(end()); }

    reverse_iterator rend() throw() { return reverse_iterator(begin()); }

    const_reverse_iterator rend() const throw() { return const_reverse_iterator(begin()); }

    const_iterator cbegin() const throw() { return begin(); }

    const_iterator cend() const throw() { return end(); }

    const_reverse_iterator crbegin() const throw() { return rbegin(); }

    const_reverse_iterator crend() const throw() { return rend(); }

    size_type size() const throw() { return 0; }

    size_type max_size() const throw() { return 0; }

    bool empty() const throw() { return true; }

    reference operator[](size_type) throw()
    {
((void)0);
__libcpp_unreachable();
    }

    const_reference operator[](size_type) const throw()
    {
((void)0);
__libcpp_unreachable();
    }

    reference at(size_type)
    {
__throw_out_of_range("array<T, 0>::at");
__libcpp_unreachable();
    }

    const_reference at(size_type) const
    {
__throw_out_of_range("array<T, 0>::at");
__libcpp_unreachable();
    }

    reference front() throw()
    {
((void)0);
__libcpp_unreachable();
    }

    const_reference front() const throw()
    {
((void)0);
__libcpp_unreachable();
    }

    reference back() throw()
    {
((void)0);
__libcpp_unreachable();
    }

    const_reference back() const throw()
    {
((void)0);
__libcpp_unreachable();
    }
};
template <class _Tp, size_t _Size>
inline bool
operator==(const array<_Tp, _Size> &__x, const array<_Tp, _Size> &__y)
{
    return std::equal(__x.begin(), __x.end(), __y.begin());
}
template <class _Tp, size_t _Size>
inline bool
operator!=(const array<_Tp, _Size> &__x, const array<_Tp, _Size> &__y)
{
    return !(__x == __y);
}
template <class _Tp, size_t _Size>
inline bool
operator<(const array<_Tp, _Size> &__x, const array<_Tp, _Size> &__y)
{
    return std::lexicographical_compare(__x.begin(), __x.end(),
                                        __y.begin(), __y.end());
}
template <class _Tp, size_t _Size>
inline bool
operator>(const array<_Tp, _Size> &__x, const array<_Tp, _Size> &__y)
{
    return __y < __x;
}
template <class _Tp, size_t _Size>
inline bool
operator<=(const array<_Tp, _Size> &__x, const array<_Tp, _Size> &__y)
{
    return !(__y < __x);
}
template <class _Tp, size_t _Size>
inline bool
operator>=(const array<_Tp, _Size> &__x, const array<_Tp, _Size> &__y)
{
    return !(__x < __y);
}
template <class _Tp, size_t _Size>
inline __enable_if_t<_Size == 0 || __is_swappable<_Tp>::value, void>
swap(array<_Tp, _Size> &__x, array<_Tp, _Size> &__y)
{
    __x.swap(__y);
}
template <class _Tp, size_t _Size>
struct tuple_size<array<_Tp, _Size>>
    : public integral_constant<size_t, _Size>
{
};
template <size_t _Ip, class _Tp, size_t _Size>
struct tuple_element<_Ip, array<_Tp, _Size>>
{
    _Static_assert(_Ip < _Size, "Index out of bounds in std::tuple_element<> (std::array)");
    typedef _Tp type;
};
template <size_t _Ip, class _Tp, size_t _Size>
inline _Tp &
get(array<_Tp, _Size> &__a) throw()
{
    _Static_assert(_Ip < _Size, "Index out of bounds in std::get<> (std::array)");
    return __a.__elems_[_Ip];
}
template <size_t _Ip, class _Tp, size_t _Size>
inline const _Tp &
get(const array<_Tp, _Size> &__a) throw()
{
    _Static_assert(_Ip < _Size, "Index out of bounds in std::get<> (const std::array)");
    return __a.__elems_[_Ip];
}
template <size_t _Ip, class _Tp, size_t _Size>
inline _Tp &&
get(array<_Tp, _Size> &&__a) throw()
{
    _Static_assert(_Ip < _Size, "Index out of bounds in std::get<> (std::array &&)");
    return std::move(__a.__elems_[_Ip]);
}
template <size_t _Ip, class _Tp, size_t _Size>
inline const _Tp &&
get(const array<_Tp, _Size> &&__a) throw()
{
    _Static_assert(_Ip < _Size, "Index out of bounds in std::get<> (const std::array &&)");
    return std::move(__a.__elems_[_Ip]);
}
}
}
namespace std
{
    inline namespace __1
    {
    }
}

extern "C"
{
    void __assert_rtn(const char *, const char *, int, const char *);
}
namespace std
{
    inline namespace __1
    {
template <class _Key, class _Tp>
struct __hash_value_type;
template <class _Tp>
struct __is_hash_value_type_imp : false_type
{
};
template <class _Key, class _Value>
struct __is_hash_value_type_imp<__hash_value_type<_Key, _Value>> : true_type
{
};
template <class... _Args>
struct __is_hash_value_type : false_type
{
};
template <class _One>
struct __is_hash_value_type<_One> : __is_hash_value_type_imp<__uncvref_t<_One>>
{
};

size_t __next_prime(size_t __n);
template <class _NodePtr>
struct __hash_node_base
{
        typedef typename pointer_traits<_NodePtr>::element_type __node_type;
        typedef __hash_node_base __first_node;
        typedef typename __rebind_pointer<_NodePtr, __first_node>::type __node_base_pointer;
        typedef _NodePtr __node_pointer;
        typedef typename conditional<
            is_pointer<__node_pointer>::value,
            __node_base_pointer,
            __node_pointer>::type __next_pointer;
        __next_pointer __next_;

        __next_pointer __ptr() throw()
        {
            return static_cast<__next_pointer>(
                pointer_traits<__node_base_pointer>::pointer_to(*this));
        }

        __node_pointer __upcast() throw()
        {
            return static_cast<__node_pointer>(
                pointer_traits<__node_base_pointer>::pointer_to(*this));
        }

        size_t __hash() const throw()
        {
            return static_cast<__node_type const &>(*this).__hash_;
        }
        {
        }
};
template <class _Tp, class _VoidPtr>
struct __hash_node
    : public __hash_node_base<
          typename __rebind_pointer<_VoidPtr, __hash_node<_Tp, _VoidPtr>>::type>
{
        typedef _Tp __node_value_type;
        size_t __hash_;
        __node_value_type __value_;
};
inline bool
__is_hash_power2(size_t __bc)
{
        return __bc > 2 && !(__bc & (__bc - 1));
}
inline size_t
__constrain_hash(size_t __h, size_t __bc)
{
        return !(__bc & (__bc - 1)) ? __h & (__bc - 1) : (__h < __bc ? __h : __h % __bc);
}
inline size_t
__next_hash_pow2(size_t __n)
{
        return __n < 2 ? __n : (size_t(1) << (numeric_limits<size_t>::digits - __libcpp_clz(__n - 1)));
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
class __hash_table;
template <class _NodePtr>
class __hash_iterator;
template <class _ConstNodePtr>
class __hash_const_iterator;
template <class _NodePtr>
class __hash_local_iterator;
template <class _ConstNodePtr>
class __hash_const_local_iterator;
template <class _HashIterator>
class __hash_map_iterator;
template <class _HashIterator>
class __hash_map_const_iterator;
template <class _Tp>
struct __hash_key_value_types
{
        _Static_assert(!is_reference<_Tp>::value && !is_const<_Tp>::value, "");
        typedef _Tp key_type;
        typedef _Tp __node_value_type;
        typedef _Tp __container_value_type;
        static const bool __is_map = false;

        static key_type const &__get_key(_Tp const &__v)
        {
            return __v;
        }

        static __container_value_type const &__get_value(__node_value_type const &__v)
        {
            return __v;
        }

        static __container_value_type *__get_ptr(__node_value_type &__n)
        {
            return std::addressof(__n);
        }

        static __container_value_type &&__move(__node_value_type &__v)
        {
            return std::move(__v);
        }
};
template <class _Key, class _Tp>
struct __hash_key_value_types<__hash_value_type<_Key, _Tp>>
{
        typedef _Key key_type;
        typedef _Tp mapped_type;
        typedef __hash_value_type<_Key, _Tp> __node_value_type;
        typedef pair<const _Key, _Tp> __container_value_type;
        typedef __container_value_type __map_value_type;
        static const bool __is_map = true;

        static key_type const &__get_key(__container_value_type const &__v)
        {
            return __v.first;
        }
        template <class _Up>

        static __enable_if_t<__is_same_uncvref<_Up, __node_value_type>::value, __container_value_type const &>
        __get_value(_Up &__t)
        {
            return __t.__get_value();
        }
        template <class _Up>

        static __enable_if_t<__is_same_uncvref<_Up, __container_value_type>::value, __container_value_type const &>
        __get_value(_Up &__t)
        {
            return __t;
        }

        static __container_value_type *__get_ptr(__node_value_type &__n)
        {
            return std::addressof(__n.__get_value());
        }

        static pair<key_type &&, mapped_type &&> __move(__node_value_type &__v)
        {
            return __v.__move();
        }
};
template <class _Tp, class _AllocPtr, class _KVTypes = __hash_key_value_types<_Tp>,
          bool = _KVTypes::__is_map>
struct __hash_map_pointer_types
{
};
template <class _Tp, class _AllocPtr, class _KVTypes>
struct __hash_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true>
{
        typedef typename _KVTypes::__map_value_type _Mv;
        typedef typename __rebind_pointer<_AllocPtr, _Mv>::type
            __map_value_type_pointer;
        typedef typename __rebind_pointer<_AllocPtr, const _Mv>::type
            __const_map_value_type_pointer;
};
template <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type>
struct __hash_node_types;
template <class _NodePtr, class _Tp, class _VoidPtr>
struct __hash_node_types<_NodePtr, __hash_node<_Tp, _VoidPtr>>
    : public __hash_key_value_types<_Tp>, __hash_map_pointer_types<_Tp, _VoidPtr>
{
        typedef __hash_key_value_types<_Tp> __base;

    public:
        typedef ptrdiff_t difference_type;
        typedef size_t size_type;
        typedef typename __rebind_pointer<_NodePtr, void>::type __void_pointer;
        typedef typename pointer_traits<_NodePtr>::element_type __node_type;
        typedef _NodePtr __node_pointer;
        typedef __hash_node_base<__node_pointer> __node_base_type;
        typedef typename __rebind_pointer<_NodePtr, __node_base_type>::type
            __node_base_pointer;
        typedef typename __node_base_type::__next_pointer __next_pointer;
        typedef _Tp __node_value_type;
        typedef typename __rebind_pointer<_VoidPtr, __node_value_type>::type
            __node_value_type_pointer;
        typedef typename __rebind_pointer<_VoidPtr, const __node_value_type>::type
            __const_node_value_type_pointer;

    private:
        _Static_assert(!is_const<__node_type>::value, "_NodePtr should never be a pointer to const");
        _Static_assert((is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value), "_VoidPtr does not point to unqualified void type");
        _Static_assert((is_same<typename __rebind_pointer<_VoidPtr, __node_type>::type, _NodePtr>::value), "_VoidPtr does not rebind to _NodePtr.");
};
template <class _HashIterator>
struct __hash_node_types_from_iterator;
template <class _NodePtr>
struct __hash_node_types_from_iterator<__hash_iterator<_NodePtr>> : __hash_node_types<_NodePtr>
{
};
template <class _NodePtr>
struct __hash_node_types_from_iterator<__hash_const_iterator<_NodePtr>> : __hash_node_types<_NodePtr>
{
};
template <class _NodePtr>
struct __hash_node_types_from_iterator<__hash_local_iterator<_NodePtr>> : __hash_node_types<_NodePtr>
{
};
template <class _NodePtr>
struct __hash_node_types_from_iterator<__hash_const_local_iterator<_NodePtr>> : __hash_node_types<_NodePtr>
{
};
template <class _NodeValueTp, class _VoidPtr>
struct __make_hash_node_types
{
        typedef __hash_node<_NodeValueTp, _VoidPtr> _NodeTp;
        typedef typename __rebind_pointer<_VoidPtr, _NodeTp>::type _NodePtr;
        typedef __hash_node_types<_NodePtr> type;
};
template <class _NodePtr>
class __hash_iterator
{
        typedef __hash_node_types<_NodePtr> _NodeTypes;
        typedef _NodePtr __node_pointer;
        typedef typename _NodeTypes::__next_pointer __next_pointer;
        __next_pointer __node_;

    public:
        typedef forward_iterator_tag iterator_category;
        typedef typename _NodeTypes::__node_value_type value_type;
        typedef typename _NodeTypes::difference_type difference_type;
        typedef value_type &reference;
        typedef typename _NodeTypes::__node_value_type_pointer pointer;
        {
            std::__debug_db_insert_i(this);
        }

        reference operator*() const
        {
            ((void)0);
            return __node_->__upcast()->__value_;
        }

        pointer operator->() const
        {
            ((void)0);
            return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);
        }

        __hash_iterator &operator++()
        {
            ((void)0);
            __node_ = __node_->__next_;
            return *this;
        }

        __hash_iterator operator++(int)
        {
            __hash_iterator __t(*this);
            ++(*this);
            return __t;
        }
        friend bool operator==(const __hash_iterator &__x, const __hash_iterator &__y)
        {
            return __x.__node_ == __y.__node_;
        }
        friend bool operator!=(const __hash_iterator &__x, const __hash_iterator &__y)
        {
            return !(__x == __y);
        }

    private:
        explicit __hash_iterator(__next_pointer __node, const void *__c) throw()
            : __node_(__node)
        {
            (void)__c;
        }
        template <class, class, class, class>
        friend class __hash_table;
        template <class>
        friend class __hash_const_iterator;
        template <class>
        friend class __hash_map_iterator;
        template <class, class, class, class, class>
        friend class unordered_map;
        template <class, class, class, class, class>
        friend class unordered_multimap;
};
template <class _NodePtr>
class __hash_const_iterator
{
        _Static_assert(!is_const<typename pointer_traits<_NodePtr>::element_type>::value, "");
        typedef __hash_node_types<_NodePtr> _NodeTypes;
        typedef _NodePtr __node_pointer;
        typedef typename _NodeTypes::__next_pointer __next_pointer;
        __next_pointer __node_;

    public:
        typedef __hash_iterator<_NodePtr> __non_const_iterator;
        typedef forward_iterator_tag iterator_category;
        typedef typename _NodeTypes::__node_value_type value_type;
        typedef typename _NodeTypes::difference_type difference_type;
        typedef const value_type &reference;
        typedef typename _NodeTypes::__const_node_value_type_pointer pointer;
        {
            std::__debug_db_insert_i(this);
        }

        __hash_const_iterator(const __non_const_iterator &__x) throw()
            : __node_(__x.__node_)
        {
        }

        reference operator*() const
        {
            ((void)0);
            return __node_->__upcast()->__value_;
        }

        pointer operator->() const
        {
            ((void)0);
            return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);
        }

        __hash_const_iterator &operator++()
        {
            ((void)0);
            __node_ = __node_->__next_;
            return *this;
        }

        __hash_const_iterator operator++(int)
        {
            __hash_const_iterator __t(*this);
            ++(*this);
            return __t;
        }
        friend bool operator==(const __hash_const_iterator &__x, const __hash_const_iterator &__y)
        {
            return __x.__node_ == __y.__node_;
        }
        friend bool operator!=(const __hash_const_iterator &__x, const __hash_const_iterator &__y)
        {
            return !(__x == __y);
        }

    private:
        explicit __hash_const_iterator(__next_pointer __node, const void *__c) throw()
            : __node_(__node)
        {
            (void)__c;
        }
        template <class, class, class, class>
        friend class __hash_table;
        template <class>
        friend class __hash_map_const_iterator;
        template <class, class, class, class, class>
        friend class unordered_map;
        template <class, class, class, class, class>
        friend class unordered_multimap;
};
template <class _NodePtr>
class __hash_local_iterator
{
        typedef __hash_node_types<_NodePtr> _NodeTypes;
        typedef _NodePtr __node_pointer;
        typedef typename _NodeTypes::__next_pointer __next_pointer;
        __next_pointer __node_;
        size_t __bucket_;
        size_t __bucket_count_;

    public:
        typedef forward_iterator_tag iterator_category;
        typedef typename _NodeTypes::__node_value_type value_type;
        typedef typename _NodeTypes::difference_type difference_type;
        typedef value_type &reference;
        typedef typename _NodeTypes::__node_value_type_pointer pointer;
        {
            std::__debug_db_insert_i(this);
        }

        reference operator*() const
        {
            ((void)0);
            return __node_->__upcast()->__value_;
        }

        pointer operator->() const
        {
            ((void)0);
            return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);
        }

        __hash_local_iterator &operator++()
        {
            ((void)0);
            __node_ = __node_->__next_;
            if (__node_ != __nullptr && __constrain_hash(__node_->__hash(), __bucket_count_) != __bucket_)
                __node_ = __nullptr;
            return *this;
        }

        __hash_local_iterator operator++(int)
        {
            __hash_local_iterator __t(*this);
            ++(*this);
            return __t;
        }
        friend bool operator==(const __hash_local_iterator &__x, const __hash_local_iterator &__y)
        {
            return __x.__node_ == __y.__node_;
        }
        friend bool operator!=(const __hash_local_iterator &__x, const __hash_local_iterator &__y)
        {
            return !(__x == __y);
        }

    private:
        explicit __hash_local_iterator(__next_pointer __node, size_t __bucket,
                                       size_t __bucket_count, const void *__c) throw()
            : __node_(__node),
              __bucket_(__bucket),
              __bucket_count_(__bucket_count)
        {
            (void)__c;
            if (__node_ != __nullptr)
                __node_ = __node_->__next_;
        }
        template <class, class, class, class>
        friend class __hash_table;
        template <class>
        friend class __hash_const_local_iterator;
        template <class>
        friend class __hash_map_iterator;
};
template <class _ConstNodePtr>
class __hash_const_local_iterator
{
        typedef __hash_node_types<_ConstNodePtr> _NodeTypes;
        typedef _ConstNodePtr __node_pointer;
        typedef typename _NodeTypes::__next_pointer __next_pointer;
        __next_pointer __node_;
        size_t __bucket_;
        size_t __bucket_count_;
        typedef pointer_traits<__node_pointer> __pointer_traits;
        typedef typename __pointer_traits::element_type __node;
        typedef typename remove_const<__node>::type __non_const_node;
        typedef typename __rebind_pointer<__node_pointer, __non_const_node>::type
            __non_const_node_pointer;

    public:
        typedef __hash_local_iterator<__non_const_node_pointer>
            __non_const_iterator;
        typedef forward_iterator_tag iterator_category;
        typedef typename _NodeTypes::__node_value_type value_type;
        typedef typename _NodeTypes::difference_type difference_type;
        typedef const value_type &reference;
        typedef typename _NodeTypes::__const_node_value_type_pointer pointer;
        {
            std::__debug_db_insert_i(this);
        }

        __hash_const_local_iterator(const __non_const_iterator &__x) throw()
            : __node_(__x.__node_),
              __bucket_(__x.__bucket_),
              __bucket_count_(__x.__bucket_count_)
        {
        }

        reference operator*() const
        {
            ((void)0);
            return __node_->__upcast()->__value_;
        }

        pointer operator->() const
        {
            ((void)0);
            return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);
        }

        __hash_const_local_iterator &operator++()
        {
            ((void)0);
            __node_ = __node_->__next_;
            if (__node_ != __nullptr && __constrain_hash(__node_->__hash(), __bucket_count_) != __bucket_)
                __node_ = __nullptr;
            return *this;
        }

        __hash_const_local_iterator operator++(int)
        {
            __hash_const_local_iterator __t(*this);
            ++(*this);
            return __t;
        }
        friend bool operator==(const __hash_const_local_iterator &__x, const __hash_const_local_iterator &__y)
        {
            return __x.__node_ == __y.__node_;
        }
        friend bool operator!=(const __hash_const_local_iterator &__x, const __hash_const_local_iterator &__y)
        {
            return !(__x == __y);
        }

    private:
        explicit __hash_const_local_iterator(__next_pointer __node_ptr, size_t __bucket,
                                             size_t __bucket_count, const void *__c) throw()
            : __node_(__node_ptr),
              __bucket_(__bucket),
              __bucket_count_(__bucket_count)
        {
            (void)__c;
            if (__node_ != __nullptr)
                __node_ = __node_->__next_;
        }
        template <class, class, class, class>
        friend class __hash_table;
        template <class>
        friend class __hash_map_const_iterator;
};
template <class _Alloc>
class __bucket_list_deallocator
{
        typedef _Alloc allocator_type;
        typedef allocator_traits<allocator_type> __alloc_traits;
        typedef typename __alloc_traits::size_type size_type;
        __compressed_pair<size_type, allocator_type> __data_;

    public:
        typedef typename __alloc_traits::pointer pointer;

        __bucket_list_deallocator()
            : __data_(0, __default_init_tag()) {}

        __bucket_list_deallocator(const allocator_type &__a, size_type __size)
            : __data_(__size, __a) {}

        __bucket_list_deallocator(__bucket_list_deallocator &&__x)
            : __data_(std::move(__x.__data_))
        {
            __x.size() = 0;
        }

        size_type &size() throw() { return __data_.first(); }

        size_type size() const throw() { return __data_.first(); }

        allocator_type &__alloc() throw() { return __data_.second(); }

        const allocator_type &__alloc() const throw() { return __data_.second(); }

        void operator()(pointer __p) throw()
        {
            __alloc_traits::deallocate(__alloc(), __p, size());
        }
};
template <class _Alloc>
class __hash_map_node_destructor;
template <class _Alloc>
class __hash_node_destructor
{
        typedef _Alloc allocator_type;
        typedef allocator_traits<allocator_type> __alloc_traits;

    public:
        typedef typename __alloc_traits::pointer pointer;

    private:
        typedef __hash_node_types<pointer> _NodeTypes;
        allocator_type &__na_;

    public:
        bool __value_constructed;
        __hash_node_destructor(__hash_node_destructor const &) = default;
        __hash_node_destructor &operator=(const __hash_node_destructor &) = delete;

        explicit __hash_node_destructor(allocator_type &__na,
                                        bool __constructed = false) throw()
            : __na_(__na),
              __value_constructed(__constructed)
        {
        }

        void operator()(pointer __p) throw()
        {
            if (__value_constructed)
                __alloc_traits::destroy(__na_, _NodeTypes::__get_ptr(__p->__value_));
            if (__p)
                __alloc_traits::deallocate(__na_, __p, 1);
        }
        template <class>
        friend class __hash_map_node_destructor;
};
template <class _Key, class _Hash, class _Equal>
struct __enforce_unordered_container_requirements
{
        typedef int type;
};
template <class _Key, class _Hash, class _Equal>
typename __enforce_unordered_container_requirements<_Key, _Hash, _Equal>::type
__diagnose_unordered_container_requirements(int);
template <class _Key, class _Hash, class _Equal>
int __diagnose_unordered_container_requirements(void *);
template <class _Tp, class _Hash, class _Equal, class _Alloc>
class __hash_table
{
    public:
        typedef _Tp value_type;
        typedef _Hash hasher;
        typedef _Equal key_equal;
        typedef _Alloc allocator_type;

    private:
        typedef allocator_traits<allocator_type> __alloc_traits;
        typedef typename __make_hash_node_types<value_type, typename __alloc_traits::void_pointer>::type
            _NodeTypes;

    public:
        typedef typename _NodeTypes::__node_value_type __node_value_type;
        typedef typename _NodeTypes::__container_value_type __container_value_type;
        typedef typename _NodeTypes::key_type key_type;
        typedef value_type &reference;
        typedef const value_type &const_reference;
        typedef typename __alloc_traits::pointer pointer;
        typedef typename __alloc_traits::const_pointer const_pointer;
        typedef typename __alloc_traits::size_type size_type;
        typedef typename _NodeTypes::difference_type difference_type;

    public:
        typedef typename _NodeTypes::__node_type __node;
        typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;
        typedef allocator_traits<__node_allocator> __node_traits;
        typedef typename _NodeTypes::__void_pointer __void_pointer;
        typedef typename _NodeTypes::__node_pointer __node_pointer;
        typedef typename _NodeTypes::__node_pointer __node_const_pointer;
        typedef typename _NodeTypes::__node_base_type __first_node;
        typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
        typedef typename _NodeTypes::__next_pointer __next_pointer;

    private:
        _Static_assert((is_same<__node_pointer, typename __node_traits::pointer>::value), "Allocator does not rebind pointers in a sane manner.");
        typedef typename __rebind_alloc_helper<__node_traits, __first_node>::type
            __node_base_allocator;
        typedef allocator_traits<__node_base_allocator> __node_base_traits;
        _Static_assert((is_same<__node_base_pointer, typename __node_base_traits::pointer>::value), "Allocator does not rebind pointers in a sane manner.");

    private:
        typedef typename __rebind_alloc_helper<__node_traits, __next_pointer>::type __pointer_allocator;
        typedef __bucket_list_deallocator<__pointer_allocator> __bucket_list_deleter;
        typedef unique_ptr<__next_pointer[], __bucket_list_deleter> __bucket_list;
        typedef allocator_traits<__pointer_allocator> __pointer_alloc_traits;
        typedef typename __bucket_list_deleter::pointer __node_pointer_pointer;
        __bucket_list __bucket_list_;
        __compressed_pair<__first_node, __node_allocator> __p1_;
        __compressed_pair<size_type, hasher> __p2_;
        __compressed_pair<float, key_equal> __p3_;

        size_type &size() throw() { return __p2_.first(); }

    public:
        size_type size() const throw() { return __p2_.first(); }

        hasher &hash_function() throw() { return __p2_.second(); }

        const hasher &hash_function() const throw() { return __p2_.second(); }

        float &max_load_factor() throw() { return __p3_.first(); }

        float max_load_factor() const throw() { return __p3_.first(); }

        key_equal &key_eq() throw() { return __p3_.second(); }

        const key_equal &key_eq() const throw() { return __p3_.second(); }

        __node_allocator &__node_alloc() throw() { return __p1_.second(); }

        const __node_allocator &__node_alloc() const throw()
        {
            return __p1_.second();
        }

    public:
        typedef __hash_iterator<__node_pointer> iterator;
        typedef __hash_const_iterator<__node_pointer> const_iterator;
        typedef __hash_local_iterator<__node_pointer> local_iterator;
        typedef __hash_const_local_iterator<__node_pointer> const_local_iterator;

        __hash_table();

        __hash_table(const hasher &__hf, const key_equal &__eql);
        __hash_table(const hasher &__hf, const key_equal &__eql,
                     const allocator_type &__a);
        explicit __hash_table(const allocator_type &__a);
        __hash_table(const __hash_table &__u);
        __hash_table(const __hash_table &__u, const allocator_type &__a);
        __hash_table(__hash_table &&__u);
        __hash_table(__hash_table &&__u, const allocator_type &__a);
        ~__hash_table();
        __hash_table &operator=(const __hash_table &__u);

        __hash_table &operator=(__hash_table &&__u);
        template <class _InputIterator>
        void __assign_unique(_InputIterator __first, _InputIterator __last);
        template <class _InputIterator>
        void __assign_multi(_InputIterator __first, _InputIterator __last);

        size_type max_size() const throw()
        {
            return std::min<size_type>(
                __node_traits::max_size(__node_alloc()),
                numeric_limits<difference_type>::max());
        }

    private:
        __next_pointer __node_insert_multi_prepare(size_t __cp_hash,
                                                   value_type &__cp_val);

        void __node_insert_multi_perform(__node_pointer __cp,
                                         __next_pointer __pn) throw();

        __next_pointer __node_insert_unique_prepare(size_t __nd_hash,
                                                    value_type &__nd_val);

        void __node_insert_unique_perform(__node_pointer __ptr) throw();

    public:
        pair<iterator, bool> __node_insert_unique(__node_pointer __nd);

        iterator __node_insert_multi(__node_pointer __nd);

        iterator __node_insert_multi(const_iterator __p,
                                     __node_pointer __nd);
        template <class _Key, class... _Args>

        pair<iterator, bool> __emplace_unique_key_args(_Key const &__k, _Args &&...__args);
        template <class... _Args>

        pair<iterator, bool> __emplace_unique_impl(_Args &&...__args);
        template <class _Pp>

        pair<iterator, bool> __emplace_unique(_Pp &&__x)
        {
            return __emplace_unique_extract_key(std::forward<_Pp>(__x),
                                                __can_extract_key<_Pp, key_type>());
        }
        template <class _First, class _Second>

        __enable_if_t<__can_extract_map_key<_First, key_type, __container_value_type>::value, pair<iterator, bool>>
        __emplace_unique(_First &&__f, _Second &&__s)
        {
            return __emplace_unique_key_args(__f, std::forward<_First>(__f),
                                             std::forward<_Second>(__s));
        }
        template <class... _Args>

        pair<iterator, bool> __emplace_unique(_Args &&...__args)
        {
            return __emplace_unique_impl(std::forward<_Args>(__args)...);
        }
        template <class _Pp>

        pair<iterator, bool>
        __emplace_unique_extract_key(_Pp &&__x, __extract_key_fail_tag)
        {
            return __emplace_unique_impl(std::forward<_Pp>(__x));
        }
        template <class _Pp>

        pair<iterator, bool>
        __emplace_unique_extract_key(_Pp &&__x, __extract_key_self_tag)
        {
            return __emplace_unique_key_args(__x, std::forward<_Pp>(__x));
        }
        template <class _Pp>

        pair<iterator, bool>
        __emplace_unique_extract_key(_Pp &&__x, __extract_key_first_tag)
        {
            return __emplace_unique_key_args(__x.first, std::forward<_Pp>(__x));
        }
        template <class... _Args>

        iterator __emplace_multi(_Args &&...__args);
        template <class... _Args>

        iterator __emplace_hint_multi(const_iterator __p, _Args &&...__args);

        pair<iterator, bool>
        __insert_unique(__container_value_type &&__x)
        {
            return __emplace_unique_key_args(_NodeTypes::__get_key(__x), std::move(__x));
        }
        template <class _Pp, class = __enable_if_t<!__is_same_uncvref<_Pp, __container_value_type>::value>>

        pair<iterator, bool> __insert_unique(_Pp &&__x)
        {
            return __emplace_unique(std::forward<_Pp>(__x));
        }
        template <class _Pp>

        iterator __insert_multi(_Pp &&__x)
        {
            return __emplace_multi(std::forward<_Pp>(__x));
        }
        template <class _Pp>

        iterator __insert_multi(const_iterator __p, _Pp &&__x)
        {
            return __emplace_hint_multi(__p, std::forward<_Pp>(__x));
        }

        pair<iterator, bool> __insert_unique(const __container_value_type &__x)
        {
            return __emplace_unique_key_args(_NodeTypes::__get_key(__x), __x);
        }
        void clear() throw();
        ;
};
    }

    {
__rehash_unique(static_cast<size_type>(ceil(__n / max_load_factor())));
    }

    {
__rehash_multi(static_cast<size_type>(ceil(__n / max_load_factor())));
    }

    size_type bucket_count() const throw()
    {
return __bucket_list_.get_deleter().size();
    }

    iterator begin() throw();

    iterator end() throw();

    const_iterator begin() const throw();

    const_iterator end() const throw();
    template <class _Key>

    size_type bucket(const _Key &__k) const
    {
((void)0);
return __constrain_hash(hash_function()(__k), bucket_count());
    }
    template <class _Key>
    iterator find(const _Key &__x);
    template <class _Key>
    const_iterator find(const _Key &__x) const;
    typedef __hash_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;
    iterator erase(const_iterator __p);
    iterator erase(const_iterator __first, const_iterator __last);
    template <class _Key>
    size_type __erase_unique(const _Key &__k);
    template <class _Key>
    size_type __erase_multi(const _Key &__k);
    __node_holder remove(const_iterator __p) throw();
    template <class _Key>

    size_type __count_unique(const _Key &__k) const;
    template <class _Key>
    size_type __count_multi(const _Key &__k) const;
    template <class _Key>
    pair<iterator, iterator>
    __equal_range_unique(const _Key &__k);
    template <class _Key>
    pair<const_iterator, const_iterator>
    __equal_range_unique(const _Key &__k) const;
    template <class _Key>
    pair<iterator, iterator>
    __equal_range_multi(const _Key &__k);
    template <class _Key>
    pair<const_iterator, const_iterator>
    __equal_range_multi(const _Key &__k) const;
    void swap(__hash_table &__u);

    size_type max_bucket_count() const throw()
    {
return max_size();
    }
    size_type bucket_size(size_type __n) const;

    {
size_type __bc = bucket_count();
return __bc != 0 ? (float)size() / __bc : 0.f;
    }

    {
((void)0);
max_load_factor() = std::max(__mlf, load_factor());
    }

    local_iterator
    begin(size_type __n)
    {
((void)0);
return local_iterator(__bucket_list_[__n], __n, bucket_count(), this);
    }

    local_iterator
    end(size_type __n)
    {
((void)0);
return local_iterator(__nullptr, __n, bucket_count(), this);
    }

    const_local_iterator
    cbegin(size_type __n) const
    {
((void)0);
return const_local_iterator(__bucket_list_[__n], __n, bucket_count(), this);
    }

    const_local_iterator
    cend(size_type __n) const
    {
((void)0);
return const_local_iterator(__nullptr, __n, bucket_count(), this);
    }

private:
    template <bool _UniqueKeys>
    void __rehash(size_type __n);
    template <bool _UniqueKeys>
    void __do_rehash(size_type __n);
    template <class... _Args>
    __node_holder __construct_node(_Args &&...__args);
    template <class _First, class... _Rest>
    __node_holder __construct_node_hash(size_t __hash, _First &&__f, _Rest &&...__rest);

    void __copy_assign_alloc(const __hash_table &__u)
    {
__copy_assign_alloc(__u, integral_constant<bool,
                                           __node_traits::propagate_on_container_copy_assignment::value>());
    }
    void __copy_assign_alloc(const __hash_table &__u, true_type);

    void __copy_assign_alloc(const __hash_table &, false_type) {}
    void __move_assign(__hash_table &__u, false_type);
    void __move_assign(__hash_table &__u, true_type);

    void __move_assign_alloc(__hash_table &__u)
    {
__move_assign_alloc(__u, integral_constant<bool,
                                           __node_traits::propagate_on_container_move_assignment::value>());
    }

    void __move_assign_alloc(__hash_table &__u, true_type)
    {
__bucket_list_.get_deleter().__alloc() =
    std::move(__u.__bucket_list_.get_deleter().__alloc());
__node_alloc() = std::move(__u.__node_alloc());
    }

    void __move_assign_alloc(__hash_table &, false_type) throw() {}
    void __deallocate_node(__next_pointer __np) throw();
    __next_pointer __detach() throw();
    template <class, class, class, class, class>
    friend class unordered_map;
    template <class, class, class, class, class>
    friend class unordered_multimap;
};
template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline __hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table()
    : __p2_(0, __default_init_tag()),
      __p3_(1.0f, __default_init_tag())
{
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline __hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const hasher &__hf,
                                                              const key_equal &__eql)
    : __bucket_list_(__nullptr, __bucket_list_deleter()),
      __p1_(),
      __p2_(0, __hf),
      __p3_(1.0f, __eql)
{
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const hasher &__hf,
                                                       const key_equal &__eql,
                                                       const allocator_type &__a)
    : __bucket_list_(__nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),
      __p1_(__default_init_tag(), __node_allocator(__a)),
      __p2_(0, __hf),
      __p3_(1.0f, __eql)
{
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const allocator_type &__a)
    : __bucket_list_(__nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),
      __p1_(__default_init_tag(), __node_allocator(__a)),
      __p2_(0, __default_init_tag()),
      __p3_(1.0f, __default_init_tag())
{
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const __hash_table &__u)
    : __bucket_list_(__nullptr,
                     __bucket_list_deleter(allocator_traits<__pointer_allocator>::
                                               select_on_container_copy_construction(
                                                   __u.__bucket_list_.get_deleter().__alloc()),
                                           0)),
      __p1_(__default_init_tag(), allocator_traits<__node_allocator>::
                                      select_on_container_copy_construction(__u.__node_alloc())),
      __p2_(0, __u.hash_function()),
      __p3_(__u.__p3_)
{
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const __hash_table &__u,
                                                       const allocator_type &__a)
    : __bucket_list_(__nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),
      __p1_(__default_init_tag(), __node_allocator(__a)),
      __p2_(0, __u.hash_function()),
      __p3_(__u.__p3_)
{
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(__hash_table &&__u)
    : __bucket_list_(std::move(__u.__bucket_list_)),
      __p1_(std::move(__u.__p1_)),
      __p2_(std::move(__u.__p2_)),
      __p3_(std::move(__u.__p3_))
{
    if (size() > 0)
    {
__bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =
    __p1_.first().__ptr();
__u.__p1_.first().__next_ = __nullptr;
__u.size() = 0;
    }
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(__hash_table &&__u,
                                                       const allocator_type &__a)
    : __bucket_list_(__nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),
      __p1_(__default_init_tag(), __node_allocator(__a)),
      __p2_(0, std::move(__u.hash_function())),
      __p3_(std::move(__u.__p3_))
{
    if (__a == allocator_type(__u.__node_alloc()))
    {
__bucket_list_.reset(__u.__bucket_list_.release());
__bucket_list_.get_deleter().size() = __u.__bucket_list_.get_deleter().size();
__u.__bucket_list_.get_deleter().size() = 0;
if (__u.size() > 0)
{
        __p1_.first().__next_ = __u.__p1_.first().__next_;
        __u.__p1_.first().__next_ = __nullptr;
        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =
            __p1_.first().__ptr();
        size() = __u.size();
        __u.size() = 0;
}
    }
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::~__hash_table()
{
    _Static_assert((is_copy_constructible<key_equal>::value), "Predicate must be copy-constructible.");
    _Static_assert((is_copy_constructible<hasher>::value), "Hasher must be copy-constructible.");
    __deallocate_node(__p1_.first().__next_);
    std::__debug_db_erase_c(this);
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
void __hash_table<_Tp, _Hash, _Equal, _Alloc>::__copy_assign_alloc(
    const __hash_table &__u, true_type)
{
    if (__node_alloc() != __u.__node_alloc())
    {
clear();
__bucket_list_.reset();
__bucket_list_.get_deleter().size() = 0;
    }
    __bucket_list_.get_deleter().__alloc() = __u.__bucket_list_.get_deleter().__alloc();
    __node_alloc() = __u.__node_alloc();
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc> &
__hash_table<_Tp, _Hash, _Equal, _Alloc>::operator=(const __hash_table &__u)
{
    if (this != std::addressof(__u))
    {
__copy_assign_alloc(__u);
hash_function() = __u.hash_function();
key_eq() = __u.key_eq();
max_load_factor() = __u.max_load_factor();
__assign_multi(__u.begin(), __u.end());
    }
    return *this;
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
void __hash_table<_Tp, _Hash, _Equal, _Alloc>::__deallocate_node(__next_pointer __np) throw()
{
    __node_allocator &__na = __node_alloc();
    while (__np != __nullptr)
    {
__next_pointer __next = __np->__next_;
__node_pointer __real_np = __np->__upcast();
__node_traits::destroy(__na, _NodeTypes::__get_ptr(__real_np->__value_));
__node_traits::deallocate(__na, __real_np, 1);
__np = __next;
    }
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__next_pointer
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__detach() throw()
{
    size_type __bc = bucket_count();
    for (size_type __i = 0; __i < __bc; ++__i)
__bucket_list_[__i] = __nullptr;
    size() = 0;
    __next_pointer __cache = __p1_.first().__next_;
    __p1_.first().__next_ = __nullptr;
    return __cache;
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
void __hash_table<_Tp, _Hash, _Equal, _Alloc>::__move_assign(
    __hash_table &__u, true_type)
{
    clear();
    __bucket_list_.reset(__u.__bucket_list_.release());
    __bucket_list_.get_deleter().size() = __u.__bucket_list_.get_deleter().size();
    __u.__bucket_list_.get_deleter().size() = 0;
    __move_assign_alloc(__u);
    size() = __u.size();
    hash_function() = std::move(__u.hash_function());
    max_load_factor() = __u.max_load_factor();
    key_eq() = std::move(__u.key_eq());
    __p1_.first().__next_ = __u.__p1_.first().__next_;
    if (size() > 0)
    {
__bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =
    __p1_.first().__ptr();
__u.__p1_.first().__next_ = __nullptr;
__u.size() = 0;
    }
    std::__debug_db_swap(this, std::addressof(__u));
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
void __hash_table<_Tp, _Hash, _Equal, _Alloc>::__move_assign(
    __hash_table &__u, false_type)
{
    if (__node_alloc() == __u.__node_alloc())
__move_assign(__u, true_type());
    else
    {
hash_function() = std::move(__u.hash_function());
key_eq() = std::move(__u.key_eq());
max_load_factor() = __u.max_load_factor();
if (bucket_count() != 0)
{
        __next_pointer __cache = __detach();
        try
        {
            const_iterator __i = __u.begin();
            while (__cache != __nullptr && __u.size() != 0)
            {
                __cache->__upcast()->__value_ =
                    std::move(__u.remove(__i++)->__value_);
                __next_pointer __next = __cache->__next_;
                __node_insert_multi(__cache->__upcast());
                __cache = __next;
            }
        }
        catch (...)
        {
            __deallocate_node(__cache);
            throw;
        }
        __deallocate_node(__cache);
}
const_iterator __i = __u.begin();
while (__u.size() != 0)
{
        __node_holder __h = __construct_node(_NodeTypes::__move(__u.remove(__i++)->__value_));
        __node_insert_multi(__h.get());
        __h.release();
}
    }
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline __hash_table<_Tp, _Hash, _Equal, _Alloc> &
__hash_table<_Tp, _Hash, _Equal, _Alloc>::operator=(__hash_table &&__u)
{
    __move_assign(__u, integral_constant<bool,
                                         __node_traits::propagate_on_container_move_assignment::value>());
    return *this;
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _InputIterator>
void __hash_table<_Tp, _Hash, _Equal, _Alloc>::__assign_unique(_InputIterator __first,
                                                               _InputIterator __last)
{
    typedef iterator_traits<_InputIterator> _ITraits;
    typedef typename _ITraits::value_type _ItValueType;
    _Static_assert((is_same<_ItValueType, __container_value_type>::value), "__assign_unique may only be called with the containers value type");
    if (bucket_count() != 0)
    {
__next_pointer __cache = __detach();
try
{
        for (; __cache != __nullptr && __first != __last; ++__first)
        {
            __cache->__upcast()->__value_ = *__first;
            __next_pointer __next = __cache->__next_;
            __node_insert_unique(__cache->__upcast());
            __cache = __next;
        }
}
catch (...)
{
        __deallocate_node(__cache);
        throw;
}
__deallocate_node(__cache);
    }
    for (; __first != __last; ++__first)
__insert_unique(*__first);
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _InputIterator>
void __hash_table<_Tp, _Hash, _Equal, _Alloc>::__assign_multi(_InputIterator __first,
                                                              _InputIterator __last)
{
    typedef iterator_traits<_InputIterator> _ITraits;
    typedef typename _ITraits::value_type _ItValueType;
    _Static_assert((is_same<_ItValueType, __container_value_type>::value || is_same<_ItValueType, __node_value_type>::value), "__assign_multi may only be called with the containers value type"
                                                                                                                              " or the nodes value type");
    if (bucket_count() != 0)
    {
__next_pointer __cache = __detach();
try
{
        for (; __cache != __nullptr && __first != __last; ++__first)
        {
            __cache->__upcast()->__value_ = *__first;
            __next_pointer __next = __cache->__next_;
            __node_insert_multi(__cache->__upcast());
            __cache = __next;
        }
}
catch (...)
{
        __deallocate_node(__cache);
        throw;
}
__deallocate_node(__cache);
    }
    for (; __first != __last; ++__first)
__insert_multi(_NodeTypes::__get_value(*__first));
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline
    typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
    __hash_table<_Tp, _Hash, _Equal, _Alloc>::begin() throw()
{
    return iterator(__p1_.first().__next_, this);
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline
    typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
    __hash_table<_Tp, _Hash, _Equal, _Alloc>::end() throw()
{
    return iterator(__nullptr, this);
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline
    typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator
    __hash_table<_Tp, _Hash, _Equal, _Alloc>::begin() const throw()
{
    return const_iterator(__p1_.first().__next_, this);
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline
    typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator
    __hash_table<_Tp, _Hash, _Equal, _Alloc>::end() const throw()
{
    return const_iterator(__nullptr, this);
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
void __hash_table<_Tp, _Hash, _Equal, _Alloc>::clear() throw()
{
    if (size() > 0)
    {
__deallocate_node(__p1_.first().__next_);
__p1_.first().__next_ = __nullptr;
size_type __bc = bucket_count();
for (size_type __i = 0; __i < __bc; ++__i)
        __bucket_list_[__i] = __nullptr;
size() = 0;
    }
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>

typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__next_pointer
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_unique_prepare(
    size_t __hash, value_type &__value)
{
    size_type __bc = bucket_count();
    if (__bc != 0)
    {
size_t __chash = __constrain_hash(__hash, __bc);
__next_pointer __ndptr = __bucket_list_[__chash];
if (__ndptr != __nullptr)
{
        for (__ndptr = __ndptr->__next_; __ndptr != __nullptr &&
                                         __constrain_hash(__ndptr->__hash(), __bc) == __chash;
             __ndptr = __ndptr->__next_)
        {
            if (key_eq()(__ndptr->__upcast()->__value_, __value))
                return __ndptr;
        }
}
    }
    if (size() + 1 > __bc * max_load_factor() || __bc == 0)
    {
__rehash_unique(std::max<size_type>(2 * __bc + !__is_hash_power2(__bc),
                                    size_type(ceil(float(size() + 1) / max_load_factor()))));
    }
    return __nullptr;
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>

void __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_unique_perform(
    __node_pointer __nd) throw()
{
    size_type __bc = bucket_count();
    size_t __chash = __constrain_hash(__nd->__hash(), __bc);
    __next_pointer __pn = __bucket_list_[__chash];
    if (__pn == __nullptr)
    {
__pn = __p1_.first().__ptr();
__nd->__next_ = __pn->__next_;
__pn->__next_ = __nd->__ptr();
__bucket_list_[__chash] = __pn;
if (__nd->__next_ != __nullptr)
        __bucket_list_[__constrain_hash(__nd->__next_->__hash(), __bc)] = __nd->__ptr();
    }
    else
    {
__nd->__next_ = __pn->__next_;
__pn->__next_ = __nd->__ptr();
    }
    ++size();
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_unique(__node_pointer __nd)
{
    __nd->__hash_ = hash_function()(__nd->__value_);
    __next_pointer __existing_node =
        __node_insert_unique_prepare(__nd->__hash(), __nd->__value_);
    bool __inserted = false;
    if (__existing_node == __nullptr)
    {
__node_insert_unique_perform(__nd);
__existing_node = __nd->__ptr();
__inserted = true;
    }
    return pair<iterator, bool>(iterator(__existing_node, this), __inserted);
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__next_pointer
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi_prepare(
    size_t __cp_hash, value_type &__cp_val)
{
    size_type __bc = bucket_count();
    if (size() + 1 > __bc * max_load_factor() || __bc == 0)
    {
__rehash_multi(std::max<size_type>(2 * __bc + !__is_hash_power2(__bc),
                                   size_type(ceil(float(size() + 1) / max_load_factor()))));
__bc = bucket_count();
    }
    size_t __chash = __constrain_hash(__cp_hash, __bc);
    __next_pointer __pn = __bucket_list_[__chash];
    if (__pn != __nullptr)
    {
for (bool __found = false; __pn->__next_ != __nullptr &&
                           __constrain_hash(__pn->__next_->__hash(), __bc) == __chash;
     __pn = __pn->__next_)
{
        if (__found != (__pn->__next_->__hash() == __cp_hash &&
                        key_eq()(__pn->__next_->__upcast()->__value_, __cp_val)))
        {
            if (!__found)
                __found = true;
            else
                break;
        }
}
    }
    return __pn;
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
void __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi_perform(
    __node_pointer __cp, __next_pointer __pn) throw()
{
    size_type __bc = bucket_count();
    size_t __chash = __constrain_hash(__cp->__hash_, __bc);
    if (__pn == __nullptr)
    {
__pn = __p1_.first().__ptr();
__cp->__next_ = __pn->__next_;
__pn->__next_ = __cp->__ptr();
__bucket_list_[__chash] = __pn;
if (__cp->__next_ != __nullptr)
        __bucket_list_[__constrain_hash(__cp->__next_->__hash(), __bc)] = __cp->__ptr();
    }
    else
    {
__cp->__next_ = __pn->__next_;
__pn->__next_ = __cp->__ptr();
if (__cp->__next_ != __nullptr)
{
        size_t __nhash = __constrain_hash(__cp->__next_->__hash(), __bc);
        if (__nhash != __chash)
            __bucket_list_[__nhash] = __cp->__ptr();
}
    }
    ++size();
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi(__node_pointer __cp)
{
    __cp->__hash_ = hash_function()(__cp->__value_);
    __next_pointer __pn = __node_insert_multi_prepare(__cp->__hash(), __cp->__value_);
    __node_insert_multi_perform(__cp, __pn);
    return iterator(__cp->__ptr(), this);
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi(
    const_iterator __p, __node_pointer __cp)
{
    ((void)0);
    if (__p != end() && key_eq()(*__p, __cp->__value_))
    {
__next_pointer __np = __p.__node_;
__cp->__hash_ = __np->__hash();
size_type __bc = bucket_count();
if (size() + 1 > __bc * max_load_factor() || __bc == 0)
{
        __rehash_multi(std::max<size_type>(2 * __bc + !__is_hash_power2(__bc),
                                           size_type(ceil(float(size() + 1) / max_load_factor()))));
        __bc = bucket_count();
}
size_t __chash = __constrain_hash(__cp->__hash_, __bc);
__next_pointer __pp = __bucket_list_[__chash];
while (__pp->__next_ != __np)
        __pp = __pp->__next_;
__cp->__next_ = __np;
__pp->__next_ = static_cast<__next_pointer>(__cp);
++size();
return iterator(static_cast<__next_pointer>(__cp), this);
    }
    return __node_insert_multi(__cp);
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key, class... _Args>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_unique_key_args(_Key const &__k, _Args &&...__args)
{
    size_t __hash = hash_function()(__k);
    size_type __bc = bucket_count();
    bool __inserted = false;
    __next_pointer __nd;
    size_t __chash;
    if (__bc != 0)
    {
__chash = __constrain_hash(__hash, __bc);
__nd = __bucket_list_[__chash];
if (__nd != __nullptr)
{
        for (__nd = __nd->__next_; __nd != __nullptr &&
                                   (__nd->__hash() == __hash || __constrain_hash(__nd->__hash(), __bc) == __chash);
             __nd = __nd->__next_)
        {
            if (key_eq()(__nd->__upcast()->__value_, __k))
                goto __done;
        }
}
    }
    {
__node_holder __h = __construct_node_hash(__hash, std::forward<_Args>(__args)...);
if (size() + 1 > __bc * max_load_factor() || __bc == 0)
{
        __rehash_unique(std::max<size_type>(2 * __bc + !__is_hash_power2(__bc),
                                            size_type(ceil(float(size() + 1) / max_load_factor()))));
        __bc = bucket_count();
        __chash = __constrain_hash(__hash, __bc);
}
__next_pointer __pn = __bucket_list_[__chash];
if (__pn == __nullptr)
{
        __pn = __p1_.first().__ptr();
        __h->__next_ = __pn->__next_;
        __pn->__next_ = __h.get()->__ptr();
        __bucket_list_[__chash] = __pn;
        if (__h->__next_ != __nullptr)
            __bucket_list_[__constrain_hash(__h->__next_->__hash(), __bc)] = __h.get()->__ptr();
}
else
{
        __h->__next_ = __pn->__next_;
        __pn->__next_ = static_cast<__next_pointer>(__h.get());
}
__nd = static_cast<__next_pointer>(__h.release());
++size();
__inserted = true;
    }
__done:
    return pair<iterator, bool>(iterator(__nd, this), __inserted);
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class... _Args>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_unique_impl(_Args &&...__args)
{
    __node_holder __h = __construct_node(std::forward<_Args>(__args)...);
    pair<iterator, bool> __r = __node_insert_unique(__h.get());
    if (__r.second)
__h.release();
    return __r;
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class... _Args>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_multi(_Args &&...__args)
{
    __node_holder __h = __construct_node(std::forward<_Args>(__args)...);
    iterator __r = __node_insert_multi(__h.get());
    __h.release();
    return __r;
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class... _Args>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_hint_multi(
    const_iterator __p, _Args &&...__args)
{
    ((void)0);
    __node_holder __h = __construct_node(std::forward<_Args>(__args)...);
    iterator __r = __node_insert_multi(__p, __h.get());
    __h.release();
    return __r;
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <bool _UniqueKeys>
void __hash_table<_Tp, _Hash, _Equal, _Alloc>::__rehash(size_type __n)

{
    if (__n == 1)
__n = 2;
    else if (__n & (__n - 1))
__n = __next_prime(__n);
    size_type __bc = bucket_count();
    if (__n > __bc)
__do_rehash<_UniqueKeys>(__n);
    else if (__n < __bc)
    {
__n = std::max<size_type>(
    __n,
    __is_hash_power2(__bc) ? __next_hash_pow2(size_t(ceil(float(size()) / max_load_factor()))) : __next_prime(size_t(ceil(float(size()) / max_load_factor()))));
if (__n < __bc)
        __do_rehash<_UniqueKeys>(__n);
    }
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <bool _UniqueKeys>
void __hash_table<_Tp, _Hash, _Equal, _Alloc>::__do_rehash(size_type __nbc)
{
    std::__debug_db_invalidate_all(this);
    __pointer_allocator &__npa = __bucket_list_.get_deleter().__alloc();
    __bucket_list_.reset(__nbc > 0 ? __pointer_alloc_traits::allocate(__npa, __nbc) : __nullptr);
    __bucket_list_.get_deleter().size() = __nbc;
    if (__nbc > 0)
    {
for (size_type __i = 0; __i < __nbc; ++__i)
        __bucket_list_[__i] = __nullptr;
__next_pointer __pp = __p1_.first().__ptr();
__next_pointer __cp = __pp->__next_;
if (__cp != __nullptr)
{
        size_type __chash = __constrain_hash(__cp->__hash(), __nbc);
        __bucket_list_[__chash] = __pp;
        size_type __phash = __chash;
        for (__pp = __cp, void(), __cp = __cp->__next_; __cp != __nullptr;
             __cp = __pp->__next_)
        {
            __chash = __constrain_hash(__cp->__hash(), __nbc);
            if (__chash == __phash)
                __pp = __cp;
            else
            {
                if (__bucket_list_[__chash] == __nullptr)
                {
                    __bucket_list_[__chash] = __pp;
                    __pp = __cp;
                    __phash = __chash;
                }
                else
                {
                    __next_pointer __np = __cp;
                    if (!_UniqueKeys)
                    {
                        for (; __np->__next_ != __nullptr &&
                               key_eq()(__cp->__upcast()->__value_,
                                        __np->__next_->__upcast()->__value_);
                             __np = __np->__next_)
                            ;
                    }
                    __pp->__next_ = __np->__next_;
                    __np->__next_ = __bucket_list_[__chash]->__next_;
                    __bucket_list_[__chash]->__next_ = __cp;
                }
            }
        }
}
    }
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::find(const _Key &__k)
{
    size_t __hash = hash_function()(__k);
    size_type __bc = bucket_count();
    if (__bc != 0)
    {
size_t __chash = __constrain_hash(__hash, __bc);
__next_pointer __nd = __bucket_list_[__chash];
if (__nd != __nullptr)
{
        for (__nd = __nd->__next_; __nd != __nullptr &&
                                   (__nd->__hash() == __hash || __constrain_hash(__nd->__hash(), __bc) == __chash);
             __nd = __nd->__next_)
        {
            if ((__nd->__hash() == __hash) && key_eq()(__nd->__upcast()->__value_, __k))
                return iterator(__nd, this);
        }
}
    }
    return end();
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::find(const _Key &__k) const
{
    size_t __hash = hash_function()(__k);
    size_type __bc = bucket_count();
    if (__bc != 0)
    {
size_t __chash = __constrain_hash(__hash, __bc);
__next_pointer __nd = __bucket_list_[__chash];
if (__nd != __nullptr)
{
        for (__nd = __nd->__next_; __nd != __nullptr &&
                                   (__hash == __nd->__hash() || __constrain_hash(__nd->__hash(), __bc) == __chash);
             __nd = __nd->__next_)
        {
            if ((__nd->__hash() == __hash) && key_eq()(__nd->__upcast()->__value_, __k))
                return const_iterator(__nd, this);
        }
}
    }
    return end();
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class... _Args>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node(_Args &&...__args)
{
    _Static_assert(!__is_hash_value_type<_Args...>::value, "Construct cannot be called with a hash value type");
    __node_allocator &__na = __node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), std::forward<_Args>(__args)...);
    __h.get_deleter().__value_constructed = true;
    __h->__hash_ = hash_function()(__h->__value_);
    __h->__next_ = __nullptr;
    return __h;
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _First, class... _Rest>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node_hash(
    size_t __hash, _First &&__f, _Rest &&...__rest)
{
    _Static_assert(!__is_hash_value_type<_First, _Rest...>::value, "Construct cannot be called with a hash value type");
    __node_allocator &__na = __node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_),
                             std::forward<_First>(__f),
                             std::forward<_Rest>(__rest)...);
    __h.get_deleter().__value_constructed = true;
    __h->__hash_ = __hash;
    __h->__next_ = __nullptr;
    return __h;
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::erase(const_iterator __p)
{
    __next_pointer __np = __p.__node_;
    ((void)0);
    ((void)0);
    iterator __r(__np, this);
    ++__r;
    remove(__p);
    return __r;
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::erase(const_iterator __first,
                                                const_iterator __last)
{
    ((void)0);
    ((void)0);
    for (const_iterator __p = __first; __first != __last; __p = __first)
    {
++__first;
erase(__p);
    }
    __next_pointer __np = __last.__node_;
    return iterator(__np, this);
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__erase_unique(const _Key &__k)
{
    iterator __i = find(__k);
    if (__i == end())
return 0;
    erase(__i);
    return 1;
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__erase_multi(const _Key &__k)
{
    size_type __r = 0;
    iterator __i = find(__k);
    if (__i != end())
    {
iterator __e = end();
do
{
        erase(__i++);
        ++__r;
} while (__i != __e && key_eq()(*__i, __k));
    }
    return __r;
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder
__hash_table<_Tp, _Hash, _Equal, _Alloc>::remove(const_iterator __p) throw()
{
    __next_pointer __cn = __p.__node_;
    size_type __bc = bucket_count();
    size_t __chash = __constrain_hash(__cn->__hash(), __bc);
    __next_pointer __pn = __bucket_list_[__chash];
    for (; __pn->__next_ != __cn; __pn = __pn->__next_)
;
    if (__pn == __p1_.first().__ptr() || __constrain_hash(__pn->__hash(), __bc) != __chash)
    {
if (__cn->__next_ == __nullptr || __constrain_hash(__cn->__next_->__hash(), __bc) != __chash)
        __bucket_list_[__chash] = __nullptr;
    }
    if (__cn->__next_ != __nullptr)
    {
size_t __nhash = __constrain_hash(__cn->__next_->__hash(), __bc);
if (__nhash != __chash)
        __bucket_list_[__nhash] = __pn;
    }
    __pn->__next_ = __cn->__next_;
    __cn->__next_ = __nullptr;
    --size();
    return __node_holder(__cn->__upcast(), _Dp(__node_alloc(), true));
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
inline
    typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
    __hash_table<_Tp, _Hash, _Equal, _Alloc>::__count_unique(const _Key &__k) const
{
    return static_cast<size_type>(find(__k) != end());
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__count_multi(const _Key &__k) const
{
    size_type __r = 0;
    const_iterator __i = find(__k);
    if (__i != end())
    {
const_iterator __e = end();
do
{
        ++__i;
        ++__r;
} while (__i != __e && key_eq()(*__i, __k));
    }
    return __r;
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator,
     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_unique(
    const _Key &__k)
{
    iterator __i = find(__k);
    iterator __j = __i;
    if (__i != end())
++__j;
    return pair<iterator, iterator>(__i, __j);
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator,
     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_unique(
    const _Key &__k) const
{
    const_iterator __i = find(__k);
    const_iterator __j = __i;
    if (__i != end())
++__j;
    return pair<const_iterator, const_iterator>(__i, __j);
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator,
     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_multi(
    const _Key &__k)
{
    iterator __i = find(__k);
    iterator __j = __i;
    if (__i != end())
    {
iterator __e = end();
do
{
        ++__j;
} while (__j != __e && key_eq()(*__j, __k));
    }
    return pair<iterator, iterator>(__i, __j);
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator,
     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_multi(
    const _Key &__k) const
{
    const_iterator __i = find(__k);
    const_iterator __j = __i;
    if (__i != end())
    {
const_iterator __e = end();
do
{
        ++__j;
} while (__j != __e && key_eq()(*__j, __k));
    }
    return pair<const_iterator, const_iterator>(__i, __j);
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
void __hash_table<_Tp, _Hash, _Equal, _Alloc>::swap(__hash_table &__u)
{
    ((void)0);
    {
__node_pointer_pointer __npp = __bucket_list_.release();
__bucket_list_.reset(__u.__bucket_list_.release());
__u.__bucket_list_.reset(__npp);
    }
    std::swap(__bucket_list_.get_deleter().size(), __u.__bucket_list_.get_deleter().size());
    std::__swap_allocator(__bucket_list_.get_deleter().__alloc(),
                          __u.__bucket_list_.get_deleter().__alloc());
    std::__swap_allocator(__node_alloc(), __u.__node_alloc());
    std::swap(__p1_.first().__next_, __u.__p1_.first().__next_);
    __p2_.swap(__u.__p2_);
    __p3_.swap(__u.__p3_);
    if (size() > 0)
__bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =
    __p1_.first().__ptr();
    if (__u.size() > 0)
__u.__bucket_list_[__constrain_hash(__u.__p1_.first().__next_->__hash(), __u.bucket_count())] =
    __u.__p1_.first().__ptr();
    std::__debug_db_swap(this, std::addressof(__u));
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::bucket_size(size_type __n) const
{
    ((void)0);
    __next_pointer __np = __bucket_list_[__n];
    size_type __bc = bucket_count();
    size_type __r = 0;
    if (__np != __nullptr)
    {
for (__np = __np->__next_; __np != __nullptr &&
                           __constrain_hash(__np->__hash(), __bc) == __n;
     __np = __np->__next_, (void)++__r)
        ;
    }
    return __r;
}
template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline void
swap(__hash_table<_Tp, _Hash, _Equal, _Alloc> &__x,
     __hash_table<_Tp, _Hash, _Equal, _Alloc> &__y)
{
    __x.swap(__y);
}
}
}
extern "C"
{
    void __assert_rtn(const char *, const char *, int, const char *);
}
extern "C"
{
    void __assert_rtn(const char *, const char *, int, const char *);
}
namespace std
{
    class bad_optional_access
        : public exception
    {
public:
virtual ~bad_optional_access() throw();
virtual const char *what() const throw();
    };
}
namespace std
{
    inline namespace __1
    {
    }
}
namespace std
{
    inline namespace __1
    {
template <class _Key, class _Cp, class _Hash, class _Pred,
          bool = is_empty<_Hash>::value && !__libcpp_is_final<_Hash>::value>
class __unordered_map_hasher
    : private _Hash
{
    public:
        __unordered_map_hasher()
            : _Hash() {}

        __unordered_map_hasher(const _Hash &__h)
            : _Hash(__h) {}

        const _Hash &hash_function() const throw() { return *this; }

        size_t operator()(const _Cp &__x) const
        {
            return static_cast<const _Hash &>(*this)(__x.__get_value().first);
        }

        size_t operator()(const _Key &__x) const
        {
            return static_cast<const _Hash &>(*this)(__x);
        }

        void swap(__unordered_map_hasher &__y)
        {
            using std::swap;
            swap(static_cast<_Hash &>(*this), static_cast<_Hash &>(__y));
        }
};
template <class _Key, class _Cp, class _Hash, class _Pred>
class __unordered_map_hasher<_Key, _Cp, _Hash, _Pred, false>
{
        _Hash __hash_;

    public:
        __unordered_map_hasher()
            : __hash_() {}

        __unordered_map_hasher(const _Hash &__h)
            : __hash_(__h) {}

        const _Hash &hash_function() const throw() { return __hash_; }

        size_t operator()(const _Cp &__x) const
        {
            return __hash_(__x.__get_value().first);
        }

        size_t operator()(const _Key &__x) const
        {
            return __hash_(__x);
        }

        void swap(__unordered_map_hasher &__y)
        {
            using std::swap;
            swap(__hash_, __y.__hash_);
        }
};
template <class _Key, class _Cp, class _Hash, class _Pred, bool __b>
inline void
swap(__unordered_map_hasher<_Key, _Cp, _Hash, _Pred, __b> &__x,
     __unordered_map_hasher<_Key, _Cp, _Hash, _Pred, __b> &__y)
{
        __x.swap(__y);
}
template <class _Key, class _Cp, class _Pred, class _Hash,
          bool = is_empty<_Pred>::value && !__libcpp_is_final<_Pred>::value>
class __unordered_map_equal
    : private _Pred
{
    public:
        __unordered_map_equal()
            : _Pred() {}

        __unordered_map_equal(const _Pred &__p)
            : _Pred(__p) {}

        const _Pred &key_eq() const throw() { return *this; }

        bool operator()(const _Cp &__x, const _Cp &__y) const
        {
            return static_cast<const _Pred &>(*this)(__x.__get_value().first, __y.__get_value().first);
        }

        bool operator()(const _Cp &__x, const _Key &__y) const
        {
            return static_cast<const _Pred &>(*this)(__x.__get_value().first, __y);
        }

        bool operator()(const _Key &__x, const _Cp &__y) const
        {
            return static_cast<const _Pred &>(*this)(__x, __y.__get_value().first);
        }

        void swap(__unordered_map_equal &__y)
        {
            using std::swap;
            swap(static_cast<_Pred &>(*this), static_cast<_Pred &>(__y));
        }
};
template <class _Key, class _Cp, class _Pred, class _Hash>
class __unordered_map_equal<_Key, _Cp, _Pred, _Hash, false>
{
        _Pred __pred_;

    public:
        __unordered_map_equal()
            : __pred_() {}

        __unordered_map_equal(const _Pred &__p)
            : __pred_(__p) {}

        const _Pred &key_eq() const throw() { return __pred_; }

        bool operator()(const _Cp &__x, const _Cp &__y) const
        {
            return __pred_(__x.__get_value().first, __y.__get_value().first);
        }

        bool operator()(const _Cp &__x, const _Key &__y) const
        {
            return __pred_(__x.__get_value().first, __y);
        }

        bool operator()(const _Key &__x, const _Cp &__y) const
        {
            return __pred_(__x, __y.__get_value().first);
        }

        void swap(__unordered_map_equal &__y)
        {
            using std::swap;
            swap(__pred_, __y.__pred_);
        }
};
template <class _Key, class _Cp, class _Pred, class _Hash, bool __b>
inline void
swap(__unordered_map_equal<_Key, _Cp, _Pred, _Hash, __b> &__x,
     __unordered_map_equal<_Key, _Cp, _Pred, _Hash, __b> &__y)
{
        __x.swap(__y);
}
template <class _Alloc>
class __hash_map_node_destructor
{
        typedef _Alloc allocator_type;
        typedef allocator_traits<allocator_type> __alloc_traits;

    public:
        typedef typename __alloc_traits::pointer pointer;

    private:
        allocator_type &__na_;
        __hash_map_node_destructor &operator=(const __hash_map_node_destructor &);

    public:
        bool __first_constructed;
        bool __second_constructed;

        explicit __hash_map_node_destructor(allocator_type &__na) throw()
            : __na_(__na),
              __first_constructed(false),
              __second_constructed(false)
        {
        }

        __hash_map_node_destructor(const __hash_node_destructor<allocator_type> &__x)
            : __na_(__x.__na_),
              __first_constructed(__x.__value_constructed),
              __second_constructed(__x.__value_constructed)
        {
            const_cast<bool &>(__x.__value_constructed) = false;
        }

        void operator()(pointer __p) throw()
        {
            if (__second_constructed)
                __alloc_traits::destroy(__na_, std::addressof(__p->__value_.__get_value().second));
            if (__first_constructed)
                __alloc_traits::destroy(__na_, std::addressof(__p->__value_.__get_value().first));
            if (__p)
                __alloc_traits::deallocate(__na_, __p, 1);
        }
};
template <class _Key, class _Tp>
struct __hash_value_type
{
        typedef _Key key_type;
        typedef _Tp mapped_type;
        typedef pair<const key_type, mapped_type> value_type;

    private:
        value_type __cc;

    public:
        value_type &__get_value() { return __cc; }

        const value_type &__get_value() const { return __cc; }

    private:
        ~__hash_value_type();
};
template <class _HashIterator>
class __hash_map_iterator
{
        _HashIterator __i_;
        typedef __hash_node_types_from_iterator<_HashIterator> _NodeTypes;

    public:
        typedef forward_iterator_tag iterator_category;
        typedef typename _NodeTypes::__map_value_type value_type;
        typedef typename _NodeTypes::difference_type difference_type;
        typedef value_type &reference;
        typedef typename _NodeTypes::__map_value_type_pointer pointer;

        __hash_map_iterator() throw() {}

        __hash_map_iterator(_HashIterator __i) throw() : __i_(__i) {}

        reference operator*() const { return __i_->__get_value(); }

        pointer operator->() const { return pointer_traits<pointer>::pointer_to(__i_->__get_value()); }

        __hash_map_iterator &operator++()
        {
            ++__i_;
            return *this;
        }

        __hash_map_iterator operator++(int)
        {
            __hash_map_iterator __t(*this);
            ++(*this);
            return __t;
        }
        friend bool operator==(const __hash_map_iterator &__x, const __hash_map_iterator &__y)
        {
            return __x.__i_ == __y.__i_;
        }
        friend bool operator!=(const __hash_map_iterator &__x, const __hash_map_iterator &__y)
        {
            return __x.__i_ != __y.__i_;
        }
        template <class, class, class, class, class>
        friend class unordered_map;
        template <class, class, class, class, class>
        friend class unordered_multimap;
        template <class>
        friend class __hash_const_iterator;
        template <class>
        friend class __hash_const_local_iterator;
        template <class>
        friend class __hash_map_const_iterator;
};
template <class _HashIterator>
class __hash_map_const_iterator
{
        _HashIterator __i_;
        typedef __hash_node_types_from_iterator<_HashIterator> _NodeTypes;

    public:
        typedef forward_iterator_tag iterator_category;
        typedef typename _NodeTypes::__map_value_type value_type;
        typedef typename _NodeTypes::difference_type difference_type;
        typedef const value_type &reference;
        typedef typename _NodeTypes::__const_map_value_type_pointer pointer;

        __hash_map_const_iterator() throw() {}

        __hash_map_const_iterator(_HashIterator __i) throw() : __i_(__i) {}

        __hash_map_const_iterator(
            __hash_map_iterator<typename _HashIterator::__non_const_iterator> __i) throw()
            : __i_(__i.__i_) {}

        reference operator*() const { return __i_->__get_value(); }

        pointer operator->() const { return pointer_traits<pointer>::pointer_to(__i_->__get_value()); }

        __hash_map_const_iterator &operator++()
        {
            ++__i_;
            return *this;
        }

        __hash_map_const_iterator operator++(int)
        {
            __hash_map_const_iterator __t(*this);
            ++(*this);
            return __t;
        }
        friend bool operator==(const __hash_map_const_iterator &__x, const __hash_map_const_iterator &__y)
        {
            return __x.__i_ == __y.__i_;
        }
        friend bool operator!=(const __hash_map_const_iterator &__x, const __hash_map_const_iterator &__y)
        {
            return __x.__i_ != __y.__i_;
        }
        template <class, class, class, class, class>
        friend class unordered_map;
        template <class, class, class, class, class>
        friend class unordered_multimap;
        template <class>
        friend class __hash_const_iterator;
        template <class>
        friend class __hash_const_local_iterator;
};
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
class unordered_multimap;
template <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = equal_to<_Key>,
          class _Alloc = allocator<pair<const _Key, _Tp>>>
class unordered_map
{
    public:
        typedef _Key key_type;
        typedef _Tp mapped_type;
        typedef __type_identity_t<_Hash> hasher;
        typedef __type_identity_t<_Pred> key_equal;
        typedef __type_identity_t<_Alloc> allocator_type;
        typedef pair<const key_type, mapped_type> value_type;
        typedef value_type &reference;
        typedef const value_type &const_reference;
        _Static_assert((is_same<value_type, typename allocator_type::value_type>::value), "Invalid allocator::value_type");

    private:
        typedef __hash_value_type<key_type, mapped_type> __value_type;
        typedef __unordered_map_hasher<key_type, __value_type, hasher, key_equal> __hasher;
        typedef __unordered_map_equal<key_type, __value_type, key_equal, hasher> __key_equal;
        typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                               __value_type>::type __allocator_type;
        typedef __hash_table<__value_type, __hasher,
                             __key_equal, __allocator_type>
            __table;
        __table __table_;
        typedef typename __table::_NodeTypes _NodeTypes;
        typedef typename __table::__node_pointer __node_pointer;
        typedef typename __table::__node_const_pointer __node_const_pointer;
        typedef typename __table::__node_traits __node_traits;
        typedef typename __table::__node_allocator __node_allocator;
        typedef typename __table::__node __node;
        typedef __hash_map_node_destructor<__node_allocator> _Dp;
        typedef unique_ptr<__node, _Dp> __node_holder;
        typedef allocator_traits<allocator_type> __alloc_traits;
        _Static_assert((is_same<typename __table::__container_value_type, value_type>::value), "");
        _Static_assert((is_same<typename __table::__node_value_type, __value_type>::value), "");

    public:
        typedef typename __alloc_traits::pointer pointer;
        typedef typename __alloc_traits::const_pointer const_pointer;
        typedef typename __table::size_type size_type;
        typedef typename __table::difference_type difference_type;
        typedef __hash_map_iterator<typename __table::iterator> iterator;
        typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;
        typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;
        typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;
        template <class _Key2, class _Tp2, class _Hash2, class _Pred2, class _Alloc2>
        friend class unordered_map;
        template <class _Key2, class _Tp2, class _Hash2, class _Pred2, class _Alloc2>
        friend class unordered_multimap;

        unordered_map()
        {
            std::__debug_db_insert_c(this);
        }
        explicit unordered_map(size_type __n, const hasher &__hf = hasher(),
                               const key_equal &__eql = key_equal());
        unordered_map(size_type __n, const hasher &__hf,
                      const key_equal &__eql,
                      const allocator_type &__a);
        template <class _InputIterator>
        unordered_map(_InputIterator __first, _InputIterator __last);
        template <class _InputIterator>
        unordered_map(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher &__hf = hasher(),
                      const key_equal &__eql = key_equal());
        template <class _InputIterator>
        unordered_map(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher &__hf,
                      const key_equal &__eql,
                      const allocator_type &__a);

        explicit unordered_map(const allocator_type &__a);
        unordered_map(const unordered_map &__u);
        unordered_map(const unordered_map &__u, const allocator_type &__a);

        ~unordered_map()
        {
            _Static_assert(sizeof(__diagnose_unordered_container_requirements<_Key, _Hash, _Pred>(0)), "");
        }

        unordered_map &operator=(const unordered_map &__u)
        {
            if (this != std::addressof(__u))
            {
                __table_.clear();
                __table_.hash_function() = __u.__table_.hash_function();
                __table_.key_eq() = __u.__table_.key_eq();
                __table_.max_load_factor() = __u.__table_.max_load_factor();
                __table_.__copy_assign_alloc(__u.__table_);
                insert(__u.begin(), __u.end());
            }
            return *this;
        }

        allocator_type get_allocator() const throw()
        {
            return allocator_type(__table_.__node_alloc());
        }

        bool empty() const throw() { return __table_.size() == 0; }

        size_type size() const throw() { return __table_.size(); }

        size_type max_size() const throw() { return __table_.max_size(); }

        iterator begin() throw() { return __table_.begin(); }

        iterator end() throw() { return __table_.end(); }

        const_iterator begin() const throw() { return __table_.begin(); }

        const_iterator end() const throw() { return __table_.end(); }

        const_iterator cbegin() const throw() { return __table_.begin(); }

        const_iterator cend() const throw() { return __table_.end(); }

        pair<iterator, bool> insert(const value_type &__x)
        {
            return __table_.__insert_unique(__x);
        }
        iterator insert(const_iterator __p, const value_type &__x)
        {
            ((void)0);
            ((void)__p);
            return insert(__x).first;
        }
        template <class _InputIterator>

        void insert(_InputIterator __first, _InputIterator __last);

        iterator erase(const_iterator __p) { return __table_.erase(__p.__i_); }

        iterator erase(iterator __p) { return __table_.erase(__p.__i_); }

        size_type erase(const key_type &__k) { return __table_.__erase_unique(__k); }

        iterator erase(const_iterator __first, const_iterator __last)
        {
            return __table_.erase(__first.__i_, __last.__i_);
        }

        void clear() throw() { __table_.clear(); }

        void swap(unordered_map &__u)
        {
            __table_.swap(__u.__table_);
        }

        hasher hash_function() const
        {
            return __table_.hash_function().hash_function();
        }

        key_equal key_eq() const
        {
            return __table_.key_eq().key_eq();
        }

        iterator find(const key_type &__k) { return __table_.find(__k); }

        const_iterator find(const key_type &__k) const { return __table_.find(__k); }

        size_type count(const key_type &__k) const { return __table_.__count_unique(__k); }

        pair<iterator, iterator> equal_range(const key_type &__k)
        {
            return __table_.__equal_range_unique(__k);
        }

        pair<const_iterator, const_iterator> equal_range(const key_type &__k) const
        {
            return __table_.__equal_range_unique(__k);
        }
        mapped_type &operator[](const key_type &__k);
        mapped_type &at(const key_type &__k);
        const mapped_type &at(const key_type &__k) const;

        size_type bucket_count() const throw() { return __table_.bucket_count(); }

        size_type max_bucket_count() const throw() { return __table_.max_bucket_count(); }

        size_type bucket_size(size_type __n) const
        {
            return __table_.bucket_size(__n);
        }

        size_type bucket(const key_type &__k) const { return __table_.bucket(__k); }

        local_iterator begin(size_type __n) { return __table_.begin(__n); }

        local_iterator end(size_type __n) { return __table_.end(__n); }

        const_local_iterator begin(size_type __n) const { return __table_.cbegin(__n); }

        const_local_iterator end(size_type __n) const { return __table_.cend(__n); }

        const_local_iterator cbegin(size_type __n) const { return __table_.cbegin(__n); }

        const_local_iterator cend(size_type __n) const { return __table_.cend(__n); }

        float load_factor() const throw() { return __table_.load_factor(); }

        float max_load_factor() const throw() { return __table_.max_load_factor(); }

        void max_load_factor(float __mlf) { __table_.max_load_factor(__mlf); }

        void rehash(size_type __n) { __table_.__rehash_unique(__n); }

        void reserve(size_type __n) { __table_.__reserve_unique(__n); }

    private:
        __node_holder __construct_node_with_key(const key_type &__k);
};
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
    size_type __n, const hasher &__hf, const key_equal &__eql)
    : __table_(__hf, __eql)
{
        std::__debug_db_insert_c(this);
        __table_.__rehash_unique(__n);
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
    size_type __n, const hasher &__hf, const key_equal &__eql,
    const allocator_type &__a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a))
{
        std::__debug_db_insert_c(this);
        __table_.__rehash_unique(__n);
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
    const allocator_type &__a)
    : __table_(typename __table::allocator_type(__a))
{
        std::__debug_db_insert_c(this);
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
    _InputIterator __first, _InputIterator __last)
{
        std::__debug_db_insert_c(this);
        insert(__first, __last);
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
    _InputIterator __first, _InputIterator __last, size_type __n,
    const hasher &__hf, const key_equal &__eql)
    : __table_(__hf, __eql)
{
        std::__debug_db_insert_c(this);
        __table_.__rehash_unique(__n);
        insert(__first, __last);
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
    _InputIterator __first, _InputIterator __last, size_type __n,
    const hasher &__hf, const key_equal &__eql, const allocator_type &__a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a))
{
        std::__debug_db_insert_c(this);
        __table_.__rehash_unique(__n);
        insert(__first, __last);
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
    const unordered_map &__u)
    : __table_(__u.__table_)
{
        std::__debug_db_insert_c(this);
        __table_.__rehash_unique(__u.bucket_count());
        insert(__u.begin(), __u.end());
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
    const unordered_map &__u, const allocator_type &__a)
    : __table_(__u.__table_, typename __table::allocator_type(__a))
{
        std::__debug_db_insert_c(this);
        __table_.__rehash_unique(__u.bucket_count());
        insert(__u.begin(), __u.end());
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
inline void
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,
                                                       _InputIterator __last)
{
        for (; __first != __last; ++__first)
            __table_.__insert_unique(*__first);
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node_with_key(const key_type &__k)
{
        __node_allocator &__na = __table_.__node_alloc();
        __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
        __node_traits::construct(__na, std::addressof(__h->__value_.__get_value().first), __k);
        __h.get_deleter().__first_constructed = true;
        __node_traits::construct(__na, std::addressof(__h->__value_.__get_value().second));
        __h.get_deleter().__second_constructed = true;
        return __h;
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
_Tp &unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type &__k)
{
        iterator __i = find(__k);
        if (__i != end())
            return __i->second;
        __node_holder __h = __construct_node_with_key(__k);
        pair<iterator, bool> __r = __table_.__node_insert_unique(__h.get());
        __h.release();
        return __r.first->second;
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
_Tp &unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type &__k)
{
        iterator __i = find(__k);
        if (__i == end())
            __throw_out_of_range("unordered_map::at: key not found");
        return __i->second;
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
const _Tp &
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type &__k) const
{
        const_iterator __i = find(__k);
        if (__i == end())
            __throw_out_of_range("unordered_map::at: key not found");
        return __i->second;
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline void
swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &__x,
     unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &__y)
{
        __x.swap(__y);
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
bool operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &__x,
                const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &__y)
{
        if (__x.size() != __y.size())
            return false;
        typedef typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator
            const_iterator;
        for (const_iterator __i = __x.begin(), __ex = __x.end(), __ey = __y.end();
             __i != __ex; ++__i)
        {
            const_iterator __j = __y.find(__i->first);
            if (__j == __ey || !(*__i == *__j))
                return false;
        }
        return true;
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline bool
operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &__x,
           const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &__y)
{
        return !(__x == __y);
}
template <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = equal_to<_Key>,
          class _Alloc = allocator<pair<const _Key, _Tp>>>
class unordered_multimap
{
    public:
        typedef _Key key_type;
        typedef _Tp mapped_type;
        typedef __type_identity_t<_Hash> hasher;
        typedef __type_identity_t<_Pred> key_equal;
        typedef __type_identity_t<_Alloc> allocator_type;
        typedef pair<const key_type, mapped_type> value_type;
        typedef value_type &reference;
        typedef const value_type &const_reference;
        _Static_assert((is_same<value_type, typename allocator_type::value_type>::value), "Invalid allocator::value_type");

    private:
        typedef __hash_value_type<key_type, mapped_type> __value_type;
        typedef __unordered_map_hasher<key_type, __value_type, hasher, key_equal> __hasher;
        typedef __unordered_map_equal<key_type, __value_type, key_equal, hasher> __key_equal;
        typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                               __value_type>::type __allocator_type;
        typedef __hash_table<__value_type, __hasher,
                             __key_equal, __allocator_type>
            __table;
        __table __table_;
        typedef typename __table::_NodeTypes _NodeTypes;
        typedef typename __table::__node_traits __node_traits;
        typedef typename __table::__node_allocator __node_allocator;
        typedef typename __table::__node __node;
        typedef __hash_map_node_destructor<__node_allocator> _Dp;
        typedef unique_ptr<__node, _Dp> __node_holder;
        typedef allocator_traits<allocator_type> __alloc_traits;
        _Static_assert((is_same<typename __node_traits::size_type, typename __alloc_traits::size_type>::value), "Allocator uses different size_type for different types");

    public:
        typedef typename __alloc_traits::pointer pointer;
        typedef typename __alloc_traits::const_pointer const_pointer;
        typedef typename __table::size_type size_type;
        typedef typename __table::difference_type difference_type;
        typedef __hash_map_iterator<typename __table::iterator> iterator;
        typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;
        typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;
        typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;
        template <class _Key2, class _Tp2, class _Hash2, class _Pred2, class _Alloc2>
        friend class unordered_map;
        template <class _Key2, class _Tp2, class _Hash2, class _Pred2, class _Alloc2>
        friend class unordered_multimap;

        unordered_multimap()
        {
            std::__debug_db_insert_c(this);
        }
        explicit unordered_multimap(size_type __n, const hasher &__hf = hasher(),
                                    const key_equal &__eql = key_equal());
        unordered_multimap(size_type __n, const hasher &__hf,
                           const key_equal &__eql,
                           const allocator_type &__a);
        template <class _InputIterator>
        unordered_multimap(_InputIterator __first, _InputIterator __last);
        template <class _InputIterator>
        unordered_multimap(_InputIterator __first, _InputIterator __last,
                           size_type __n, const hasher &__hf = hasher(),
                           const key_equal &__eql = key_equal());
        template <class _InputIterator>
        unordered_multimap(_InputIterator __first, _InputIterator __last,
                           size_type __n, const hasher &__hf,
                           const key_equal &__eql,
                           const allocator_type &__a);

        explicit unordered_multimap(const allocator_type &__a);
        unordered_multimap(const unordered_multimap &__u);
        unordered_multimap(const unordered_multimap &__u, const allocator_type &__a);

        ~unordered_multimap()
        {
            _Static_assert(sizeof(__diagnose_unordered_container_requirements<_Key, _Hash, _Pred>(0)), "");
        }

        unordered_multimap &operator=(const unordered_multimap &__u)
        {
            if (this != std::addressof(__u))
            {
                __table_.clear();
                __table_.hash_function() = __u.__table_.hash_function();
                __table_.key_eq() = __u.__table_.key_eq();
                __table_.max_load_factor() = __u.__table_.max_load_factor();
                __table_.__copy_assign_alloc(__u.__table_);
                insert(__u.begin(), __u.end());
            }
            return *this;
        }

        allocator_type get_allocator() const throw()
        {
            return allocator_type(__table_.__node_alloc());
        }

        bool empty() const throw() { return __table_.size() == 0; }

        size_type size() const throw() { return __table_.size(); }

        size_type max_size() const throw() { return __table_.max_size(); }

        iterator begin() throw() { return __table_.begin(); }

        iterator end() throw() { return __table_.end(); }

        const_iterator begin() const throw() { return __table_.begin(); }

        const_iterator end() const throw() { return __table_.end(); }

        const_iterator cbegin() const throw() { return __table_.begin(); }

        const_iterator cend() const throw() { return __table_.end(); }

        iterator insert(const value_type &__x) { return __table_.__insert_multi(__x); }

        iterator insert(const_iterator __p, const value_type &__x)
        {
            return __table_.__insert_multi(__p.__i_, __x);
        }
        template <class _InputIterator>

        void insert(_InputIterator __first, _InputIterator __last);

        iterator erase(const_iterator __p) { return __table_.erase(__p.__i_); }

        iterator erase(iterator __p) { return __table_.erase(__p.__i_); }

        size_type erase(const key_type &__k) { return __table_.__erase_multi(__k); }

        iterator erase(const_iterator __first, const_iterator __last)
        {
            return __table_.erase(__first.__i_, __last.__i_);
        }

        void clear() throw() { __table_.clear(); }

        void swap(unordered_multimap &__u)
        {
            __table_.swap(__u.__table_);
        }

        hasher hash_function() const
        {
            return __table_.hash_function().hash_function();
        }

        key_equal key_eq() const
        {
            return __table_.key_eq().key_eq();
        }

        iterator find(const key_type &__k) { return __table_.find(__k); }

        const_iterator find(const key_type &__k) const { return __table_.find(__k); }

        size_type count(const key_type &__k) const { return __table_.__count_multi(__k); }

        pair<iterator, iterator> equal_range(const key_type &__k)
        {
            return __table_.__equal_range_multi(__k);
        }

        pair<const_iterator, const_iterator> equal_range(const key_type &__k) const
        {
            return __table_.__equal_range_multi(__k);
        }

        size_type bucket_count() const throw() { return __table_.bucket_count(); }

        size_type max_bucket_count() const throw()
        {
            return __table_.max_bucket_count();
        }

        size_type bucket_size(size_type __n) const
        {
            return __table_.bucket_size(__n);
        }

        size_type bucket(const key_type &__k) const { return __table_.bucket(__k); }

        local_iterator begin(size_type __n) { return __table_.begin(__n); }

        local_iterator end(size_type __n) { return __table_.end(__n); }

        const_local_iterator begin(size_type __n) const { return __table_.cbegin(__n); }

        const_local_iterator end(size_type __n) const { return __table_.cend(__n); }

        const_local_iterator cbegin(size_type __n) const { return __table_.cbegin(__n); }

        const_local_iterator cend(size_type __n) const { return __table_.cend(__n); }

        float load_factor() const throw() { return __table_.load_factor(); }

        float max_load_factor() const throw() { return __table_.max_load_factor(); }

        void max_load_factor(float __mlf) { __table_.max_load_factor(__mlf); }

        void rehash(size_type __n) { __table_.__rehash_multi(__n); }

        void reserve(size_type __n) { __table_.__reserve_multi(__n); }
};
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
    size_type __n, const hasher &__hf, const key_equal &__eql)
    : __table_(__hf, __eql)
{
        std::__debug_db_insert_c(this);
        __table_.__rehash_multi(__n);
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
    size_type __n, const hasher &__hf, const key_equal &__eql,
    const allocator_type &__a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a))
{
        std::__debug_db_insert_c(this);
        __table_.__rehash_multi(__n);
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
    _InputIterator __first, _InputIterator __last)
{
        std::__debug_db_insert_c(this);
        insert(__first, __last);
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
    _InputIterator __first, _InputIterator __last, size_type __n,
    const hasher &__hf, const key_equal &__eql)
    : __table_(__hf, __eql)
{
        std::__debug_db_insert_c(this);
        __table_.__rehash_multi(__n);
        insert(__first, __last);
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
    _InputIterator __first, _InputIterator __last, size_type __n,
    const hasher &__hf, const key_equal &__eql, const allocator_type &__a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a))
{
        std::__debug_db_insert_c(this);
        __table_.__rehash_multi(__n);
        insert(__first, __last);
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
    const allocator_type &__a)
    : __table_(typename __table::allocator_type(__a))
{
        std::__debug_db_insert_c(this);
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
    const unordered_multimap &__u)
    : __table_(__u.__table_)
{
        std::__debug_db_insert_c(this);
        __table_.__rehash_multi(__u.bucket_count());
        insert(__u.begin(), __u.end());
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
    const unordered_multimap &__u, const allocator_type &__a)
    : __table_(__u.__table_, typename __table::allocator_type(__a))
{
        std::__debug_db_insert_c(this);
        __table_.__rehash_multi(__u.bucket_count());
        insert(__u.begin(), __u.end());
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
inline void
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,
                                                            _InputIterator __last)
{
        for (; __first != __last; ++__first)
            __table_.__insert_multi(*__first);
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline void
swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &__x,
     unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &__y)
{
        __x.swap(__y);
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
bool operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &__x,
                const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &__y)
{
        if (__x.size() != __y.size())
            return false;
        typedef typename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator
            const_iterator;
        typedef pair<const_iterator, const_iterator> _EqRng;
        for (const_iterator __i = __x.begin(), __ex = __x.end(); __i != __ex;)
        {
            _EqRng __xeq = __x.equal_range(__i->first);
            _EqRng __yeq = __y.equal_range(__i->first);
            if (std::distance(__xeq.first, __xeq.second) !=
                    std::distance(__yeq.first, __yeq.second) ||
                !std::is_permutation(__xeq.first, __xeq.second, __yeq.first))
                return false;
            __i = __xeq.second;
        }
        return true;
}
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline bool
operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &__x,
           const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &__y)
{
        return !(__x == __y);
}
    }
}
namespace std
{
    inline namespace __1
    {
template <class _Cp, bool _IsConst, typename _Cp::__storage_type = 0>
class __bit_iterator;
template <class _Cp>
class __bit_const_reference;
template <class _Tp>
struct __has_storage_type
{
        static const bool value = false;
};
template <class _Cp, bool = __has_storage_type<_Cp>::value>
class __bit_reference
{
        typedef typename _Cp::__storage_type __storage_type;
        typedef typename _Cp::__storage_pointer __storage_pointer;
        __storage_pointer __seg_;
        __storage_type __mask_;
        friend typename _Cp::__self;
        friend class __bit_const_reference<_Cp>;
        friend class __bit_iterator<_Cp, false>;

    public:
        __bit_reference(const __bit_reference &) = default;

        {
            return static_cast<bool>(*__seg_ & __mask_);
        }

        {
            return !static_cast<bool>(*this);
        }

        __bit_reference &operator=(bool __x) throw()
        {
            if (__x)
                *__seg_ |= __mask_;
            else
                *__seg_ &= ~__mask_;
            return *this;
        }

        __bit_reference &operator=(const __bit_reference &__x) throw()
        {
            return operator=(static_cast<bool>(__x));
        }
        {
            *__seg_ ^= __mask_;
        }

        {
            return __bit_iterator<_Cp, false>(__seg_, static_cast<unsigned>(__libcpp_ctz(__mask_)));
        }

    private:
        explicit __bit_reference(__storage_pointer __s, __storage_type __m) throw()
            : __seg_(__s), __mask_(__m) {}
};
template <class _Cp>
class __bit_reference<_Cp, false>
{
};
template <class _Cp>
inline void
swap(__bit_reference<_Cp> __x, __bit_reference<_Cp> __y) throw()
{
        bool __t = __x;
        __x = __y;
        __y = __t;
}
template <class _Cp, class _Dp>
inline void
swap(__bit_reference<_Cp> __x, __bit_reference<_Dp> __y) throw()
{
        bool __t = __x;
        __x = __y;
        __y = __t;
}
template <class _Cp>
inline void
swap(__bit_reference<_Cp> __x, bool &__y) throw()
{
        bool __t = __x;
        __x = __y;
        __y = __t;
}
template <class _Cp>
inline void
swap(bool &__x, __bit_reference<_Cp> __y) throw()
{
        bool __t = __x;
        __x = __y;
        __y = __t;
}
template <class _Cp>
class __bit_const_reference
{
        typedef typename _Cp::__storage_type __storage_type;
        typedef typename _Cp::__const_storage_pointer __storage_pointer;
        __storage_pointer __seg_;
        __storage_type __mask_;
        friend typename _Cp::__self;
        friend class __bit_iterator<_Cp, true>;

    public:
        __bit_const_reference(const __bit_const_reference &) = default;

        __bit_const_reference(const __bit_reference<_Cp> &__x) throw()
            : __seg_(__x.__seg_), __mask_(__x.__mask_){}

        {
            return static_cast<bool>(*__seg_ & __mask_);
        }

        {
            return __bit_iterator<_Cp, true>(__seg_, static_cast<unsigned>(__libcpp_ctz(__mask_)));
        }

    private:
        explicit __bit_const_reference(__storage_pointer __s, __storage_type __m) throw()
            : __seg_(__s), __mask_(__m) {}
        __bit_const_reference &operator=(const __bit_const_reference &) = delete;
};
template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
        typedef __bit_iterator<_Cp, _IsConst> _It;
        typedef typename _It::__storage_type __storage_type;
        const int __bits_per_word = _It::__bits_per_word;
        if (__first.__ctz_ != 0)
        {
            __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
            __storage_type __dn = std::min(__clz_f, __n);
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b = *__first.__seg_ & __m;
            if (__b)
                return _It(__first.__seg_, static_cast<unsigned>(std::__libcpp_ctz(__b)));
            if (__n == __dn)
                return __first + __n;
            __n -= __dn;
            ++__first.__seg_;
        }
        for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
            if (*__first.__seg_)
                return _It(__first.__seg_, static_cast<unsigned>(std::__libcpp_ctz(*__first.__seg_)));
        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first.__seg_ & __m;
            if (__b)
                return _It(__first.__seg_, static_cast<unsigned>(std::__libcpp_ctz(__b)));
        }
        return _It(__first.__seg_, static_cast<unsigned>(__n));
}
template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
        typedef __bit_iterator<_Cp, _IsConst> _It;
        typedef typename _It::__storage_type __storage_type;
        const int __bits_per_word = _It::__bits_per_word;
        if (__first.__ctz_ != 0)
        {
            __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
            __storage_type __dn = std::min(__clz_f, __n);
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b = ~*__first.__seg_ & __m;
            if (__b)
                return _It(__first.__seg_, static_cast<unsigned>(std::__libcpp_ctz(__b)));
            if (__n == __dn)
                return __first + __n;
            __n -= __dn;
            ++__first.__seg_;
        }
        for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        {
            __storage_type __b = ~*__first.__seg_;
            if (__b)
                return _It(__first.__seg_, static_cast<unsigned>(std::__libcpp_ctz(__b)));
        }
        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = ~*__first.__seg_ & __m;
            if (__b)
                return _It(__first.__seg_, static_cast<unsigned>(std::__libcpp_ctz(__b)));
        }
        return _It(__first.__seg_, static_cast<unsigned>(__n));
}
template <class _Cp, bool _IsConst, class _Tp>
inline __bit_iterator<_Cp, _IsConst>
find(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp &__value)
{
        if (static_cast<bool>(__value))
            return std::__find_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
        return std::__find_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
}
template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
        typedef __bit_iterator<_Cp, _IsConst> _It;
        typedef typename _It::__storage_type __storage_type;
        typedef typename _It::difference_type difference_type;
        const int __bits_per_word = _It::__bits_per_word;
        difference_type __r = 0;
        if (__first.__ctz_ != 0)
        {
            __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
            __storage_type __dn = std::min(__clz_f, __n);
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __r = std::__libcpp_popcount(*__first.__seg_ & __m);
            __n -= __dn;
            ++__first.__seg_;
        }
        for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
            __r += std::__libcpp_popcount(*__first.__seg_);
        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __r += std::__libcpp_popcount(*__first.__seg_ & __m);
        }
        return __r;
}
template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
        typedef __bit_iterator<_Cp, _IsConst> _It;
        typedef typename _It::__storage_type __storage_type;
        typedef typename _It::difference_type difference_type;
        const int __bits_per_word = _It::__bits_per_word;
        difference_type __r = 0;
        if (__first.__ctz_ != 0)
        {
            __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
            __storage_type __dn = std::min(__clz_f, __n);
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __r = std::__libcpp_popcount(~*__first.__seg_ & __m);
            __n -= __dn;
            ++__first.__seg_;
        }
        for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
            __r += std::__libcpp_popcount(~*__first.__seg_);
        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __r += std::__libcpp_popcount(~*__first.__seg_ & __m);
        }
        return __r;
}
template <class _Cp, bool _IsConst, class _Tp>
inline
    typename __bit_iterator<_Cp, _IsConst>::difference_type
    count(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp &__value)
{
        if (static_cast<bool>(__value))
            return std::__count_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
        return std::__count_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
}
template <class _Cp>
void __fill_n_false(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
{
        typedef __bit_iterator<_Cp, false> _It;
        typedef typename _It::__storage_type __storage_type;
        const int __bits_per_word = _It::__bits_per_word;
        if (__first.__ctz_ != 0)
        {
            __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
            __storage_type __dn = std::min(__clz_f, __n);
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            *__first.__seg_ &= ~__m;
            __n -= __dn;
            ++__first.__seg_;
        }
        __storage_type __nw = __n / __bits_per_word;
        std::fill_n(std::__to_address(__first.__seg_), __nw, 0);
        __n -= __nw * __bits_per_word;
        if (__n > 0)
        {
            __first.__seg_ += __nw;
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            *__first.__seg_ &= ~__m;
        }
}
template <class _Cp>
void __fill_n_true(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
{
        typedef __bit_iterator<_Cp, false> _It;
        typedef typename _It::__storage_type __storage_type;
        const int __bits_per_word = _It::__bits_per_word;
        if (__first.__ctz_ != 0)
        {
            __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
            __storage_type __dn = std::min(__clz_f, __n);
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            *__first.__seg_ |= __m;
            __n -= __dn;
            ++__first.__seg_;
        }
        __storage_type __nw = __n / __bits_per_word;
        std::fill_n(std::__to_address(__first.__seg_), __nw, static_cast<__storage_type>(-1));
        __n -= __nw * __bits_per_word;
        if (__n > 0)
        {
            __first.__seg_ += __nw;
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            *__first.__seg_ |= __m;
        }
}
template <class _Cp>
inline void
fill_n(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n, bool __value)
{
        if (__n > 0)
        {
            if (__value)
                std::__fill_n_true(__first, __n);
            else
                std::__fill_n_false(__first, __n);
        }
}
template <class _Cp>
inline void
fill(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __last, bool __value)
{
        std::fill_n(__first, static_cast<typename _Cp::size_type>(__last - __first), __value);
}
template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
               __bit_iterator<_Cp, false> __result)
{
        typedef __bit_iterator<_Cp, _IsConst> _In;
        typedef typename _In::difference_type difference_type;
        typedef typename _In::__storage_type __storage_type;
        const int __bits_per_word = _In::__bits_per_word;
        difference_type __n = __last - __first;
        if (__n > 0)
        {
            if (__first.__ctz_ != 0)
            {
                unsigned __clz = __bits_per_word - __first.__ctz_;
                difference_type __dn = std::min(static_cast<difference_type>(__clz), __n);
                __n -= __dn;
                __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
                __storage_type __b = *__first.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b;
                __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
                __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
                ++__first.__seg_;
            }
            __storage_type __nw = __n / __bits_per_word;
            std::copy_n(std::__to_address(__first.__seg_), __nw, std::__to_address(__result.__seg_));
            __n -= __nw * __bits_per_word;
            __result.__seg_ += __nw;
            if (__n > 0)
            {
                __first.__seg_ += __nw;
                __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
                __storage_type __b = *__first.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b;
                __result.__ctz_ = static_cast<unsigned>(__n);
            }
        }
        return __result;
}
template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                 __bit_iterator<_Cp, false> __result)
{
        typedef __bit_iterator<_Cp, _IsConst> _In;
        typedef typename _In::difference_type difference_type;
        typedef typename _In::__storage_type __storage_type;
        const int __bits_per_word = _In::__bits_per_word;
        difference_type __n = __last - __first;
        if (__n > 0)
        {
            if (__first.__ctz_ != 0)
            {
                unsigned __clz_f = __bits_per_word - __first.__ctz_;
                difference_type __dn = std::min(static_cast<difference_type>(__clz_f), __n);
                __n -= __dn;
                __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
                __storage_type __b = *__first.__seg_ & __m;
                unsigned __clz_r = __bits_per_word - __result.__ctz_;
                __storage_type __ddn = std::min<__storage_type>(__dn, __clz_r);
                __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
                *__result.__seg_ &= ~__m;
                if (__result.__ctz_ > __first.__ctz_)
                    *__result.__seg_ |= __b << (__result.__ctz_ - __first.__ctz_);
                else
                    *__result.__seg_ |= __b >> (__first.__ctz_ - __result.__ctz_);
                __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
                __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
                __dn -= __ddn;
                if (__dn > 0)
                {
                    __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b >> (__first.__ctz_ + __ddn);
                    __result.__ctz_ = static_cast<unsigned>(__dn);
                }
                ++__first.__seg_;
            }
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __m = ~__storage_type(0) << __result.__ctz_;
            for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)
            {
                __storage_type __b = *__first.__seg_;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b << __result.__ctz_;
                ++__result.__seg_;
                *__result.__seg_ &= __m;
                *__result.__seg_ |= __b >> __clz_r;
            }
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                __storage_type __b = *__first.__seg_ & __m;
                __storage_type __dn = std::min(__n, static_cast<difference_type>(__clz_r));
                __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b << __result.__ctz_;
                __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
                __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
                __n -= __dn;
                if (__n > 0)
                {
                    __m = ~__storage_type(0) >> (__bits_per_word - __n);
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b >> __dn;
                    __result.__ctz_ = static_cast<unsigned>(__n);
                }
            }
        }
        return __result;
}
template <class _Cp, bool _IsConst>
inline __bit_iterator<_Cp, false>
copy(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
        if (__first.__ctz_ == __result.__ctz_)
            return std::__copy_aligned(__first, __last, __result);
        return std::__copy_unaligned(__first, __last, __result);
}
template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                        __bit_iterator<_Cp, false> __result)
{
        typedef __bit_iterator<_Cp, _IsConst> _In;
        typedef typename _In::difference_type difference_type;
        typedef typename _In::__storage_type __storage_type;
        const int __bits_per_word = _In::__bits_per_word;
        difference_type __n = __last - __first;
        if (__n > 0)
        {
            if (__last.__ctz_ != 0)
            {
                difference_type __dn = std::min(static_cast<difference_type>(__last.__ctz_), __n);
                __n -= __dn;
                unsigned __clz = __bits_per_word - __last.__ctz_;
                __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz);
                __storage_type __b = *__last.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b;
                __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +
                                                         __result.__ctz_) %
                                                        __bits_per_word);
            }
            __storage_type __nw = __n / __bits_per_word;
            __result.__seg_ -= __nw;
            __last.__seg_ -= __nw;
            std::copy_n(std::__to_address(__last.__seg_), __nw, std::__to_address(__result.__seg_));
            __n -= __nw * __bits_per_word;
            if (__n > 0)
            {
                __storage_type __m = ~__storage_type(0) << (__bits_per_word - __n);
                __storage_type __b = *--__last.__seg_ & __m;
                *--__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b;
                __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
            }
        }
        return __result;
}
template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                          __bit_iterator<_Cp, false> __result)
{
        typedef __bit_iterator<_Cp, _IsConst> _In;
        typedef typename _In::difference_type difference_type;
        typedef typename _In::__storage_type __storage_type;
        const int __bits_per_word = _In::__bits_per_word;
        difference_type __n = __last - __first;
        if (__n > 0)
        {
            if (__last.__ctz_ != 0)
            {
                difference_type __dn = std::min(static_cast<difference_type>(__last.__ctz_), __n);
                __n -= __dn;
                unsigned __clz_l = __bits_per_word - __last.__ctz_;
                __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_l);
                __storage_type __b = *__last.__seg_ & __m;
                unsigned __clz_r = __bits_per_word - __result.__ctz_;
                __storage_type __ddn = std::min(__dn, static_cast<difference_type>(__result.__ctz_));
                if (__ddn > 0)
                {
                    __m = (~__storage_type(0) << (__result.__ctz_ - __ddn)) & (~__storage_type(0) >> __clz_r);
                    *__result.__seg_ &= ~__m;
                    if (__result.__ctz_ > __last.__ctz_)
                        *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
                    else
                        *__result.__seg_ |= __b >> (__last.__ctz_ - __result.__ctz_);
                    __result.__ctz_ = static_cast<unsigned>(((-__ddn & (__bits_per_word - 1)) +
                                                             __result.__ctz_) %
                                                            __bits_per_word);
                    __dn -= __ddn;
                }
                if (__dn > 0)
                {
                    --__result.__seg_;
                    __result.__ctz_ = static_cast<unsigned>(-__dn & (__bits_per_word - 1));
                    __m = ~__storage_type(0) << __result.__ctz_;
                    *__result.__seg_ &= ~__m;
                    __last.__ctz_ -= __dn + __ddn;
                    *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
                }
            }
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __m = ~__storage_type(0) >> __clz_r;
            for (; __n >= __bits_per_word; __n -= __bits_per_word)
            {
                __storage_type __b = *--__last.__seg_;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b >> __clz_r;
                *--__result.__seg_ &= __m;
                *__result.__seg_ |= __b << __result.__ctz_;
            }
            if (__n > 0)
            {
                __m = ~__storage_type(0) << (__bits_per_word - __n);
                __storage_type __b = *--__last.__seg_ & __m;
                __clz_r = __bits_per_word - __result.__ctz_;
                __storage_type __dn = std::min(__n, static_cast<difference_type>(__result.__ctz_));
                __m = (~__storage_type(0) << (__result.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_r);
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b >> (__bits_per_word - __result.__ctz_);
                __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +
                                                         __result.__ctz_) %
                                                        __bits_per_word);
                __n -= __dn;
                if (__n > 0)
                {
                    --__result.__seg_;
                    __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
                    __m = ~__storage_type(0) << __result.__ctz_;
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b << (__result.__ctz_ - (__bits_per_word - __n - __dn));
                }
            }
        }
        return __result;
}
template <class _Cp, bool _IsConst>
inline __bit_iterator<_Cp, false>
copy_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
        if (__last.__ctz_ == __result.__ctz_)
            return std::__copy_backward_aligned(__first, __last, __result);
        return std::__copy_backward_unaligned(__first, __last, __result);
}
template <class _Cp, bool _IsConst>
inline __bit_iterator<_Cp, false>
move(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
        return std::copy(__first, __last, __result);
}
template <class _Cp, bool _IsConst>
inline __bit_iterator<_Cp, false>
move_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
        return std::copy_backward(__first, __last, __result);
}
template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_aligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,
                      __bit_iterator<__C2, false> __result)
{
        typedef __bit_iterator<__C1, false> _I1;
        typedef typename _I1::difference_type difference_type;
        typedef typename _I1::__storage_type __storage_type;
        const int __bits_per_word = _I1::__bits_per_word;
        difference_type __n = __last - __first;
        if (__n > 0)
        {
            if (__first.__ctz_ != 0)
            {
                unsigned __clz = __bits_per_word - __first.__ctz_;
                difference_type __dn = std::min(static_cast<difference_type>(__clz), __n);
                __n -= __dn;
                __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
                __storage_type __b1 = *__first.__seg_ & __m;
                *__first.__seg_ &= ~__m;
                __storage_type __b2 = *__result.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b1;
                *__first.__seg_ |= __b2;
                __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
                __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
                ++__first.__seg_;
            }
            for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_, ++__result.__seg_)
                swap(*__first.__seg_, *__result.__seg_);
            if (__n > 0)
            {
                __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
                __storage_type __b1 = *__first.__seg_ & __m;
                *__first.__seg_ &= ~__m;
                __storage_type __b2 = *__result.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b1;
                *__first.__seg_ |= __b2;
                __result.__ctz_ = static_cast<unsigned>(__n);
            }
        }
        return __result;
}
template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_unaligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,
                        __bit_iterator<__C2, false> __result)
{
        typedef __bit_iterator<__C1, false> _I1;
        typedef typename _I1::difference_type difference_type;
        typedef typename _I1::__storage_type __storage_type;
        const int __bits_per_word = _I1::__bits_per_word;
        difference_type __n = __last - __first;
        if (__n > 0)
        {
            if (__first.__ctz_ != 0)
            {
                unsigned __clz_f = __bits_per_word - __first.__ctz_;
                difference_type __dn = std::min(static_cast<difference_type>(__clz_f), __n);
                __n -= __dn;
                __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
                __storage_type __b1 = *__first.__seg_ & __m;
                *__first.__seg_ &= ~__m;
                unsigned __clz_r = __bits_per_word - __result.__ctz_;
                __storage_type __ddn = std::min<__storage_type>(__dn, __clz_r);
                __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
                __storage_type __b2 = *__result.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                if (__result.__ctz_ > __first.__ctz_)
                {
                    unsigned __s = __result.__ctz_ - __first.__ctz_;
                    *__result.__seg_ |= __b1 << __s;
                    *__first.__seg_ |= __b2 >> __s;
                }
                else
                {
                    unsigned __s = __first.__ctz_ - __result.__ctz_;
                    *__result.__seg_ |= __b1 >> __s;
                    *__first.__seg_ |= __b2 << __s;
                }
                __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
                __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
                __dn -= __ddn;
                if (__dn > 0)
                {
                    __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                    __b2 = *__result.__seg_ & __m;
                    *__result.__seg_ &= ~__m;
                    unsigned __s = __first.__ctz_ + __ddn;
                    *__result.__seg_ |= __b1 >> __s;
                    *__first.__seg_ |= __b2 << __s;
                    __result.__ctz_ = static_cast<unsigned>(__dn);
                }
                ++__first.__seg_;
            }
            __storage_type __m = ~__storage_type(0) << __result.__ctz_;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)
            {
                __storage_type __b1 = *__first.__seg_;
                __storage_type __b2 = *__result.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b1 << __result.__ctz_;
                *__first.__seg_ = __b2 >> __result.__ctz_;
                ++__result.__seg_;
                __b2 = *__result.__seg_ & ~__m;
                *__result.__seg_ &= __m;
                *__result.__seg_ |= __b1 >> __clz_r;
                *__first.__seg_ |= __b2 << __clz_r;
            }
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                __storage_type __b1 = *__first.__seg_ & __m;
                *__first.__seg_ &= ~__m;
                __storage_type __dn = std::min<__storage_type>(__n, __clz_r);
                __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
                __storage_type __b2 = *__result.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b1 << __result.__ctz_;
                *__first.__seg_ |= __b2 >> __result.__ctz_;
                __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
                __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
                __n -= __dn;
                if (__n > 0)
                {
                    __m = ~__storage_type(0) >> (__bits_per_word - __n);
                    __b2 = *__result.__seg_ & __m;
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b1 >> __dn;
                    *__first.__seg_ |= __b2 << __dn;
                    __result.__ctz_ = static_cast<unsigned>(__n);
                }
            }
        }
        return __result;
}
template <class __C1, class __C2>
inline __bit_iterator<__C2, false>
swap_ranges(__bit_iterator<__C1, false> __first1, __bit_iterator<__C1, false> __last1,
            __bit_iterator<__C2, false> __first2)
{
        if (__first1.__ctz_ == __first2.__ctz_)
            return std::__swap_ranges_aligned(__first1, __last1, __first2);
        return std::__swap_ranges_unaligned(__first1, __last1, __first2);
}
template <class _Cp>
struct __bit_array
{
        typedef typename _Cp::difference_type difference_type;
        typedef typename _Cp::__storage_type __storage_type;
        typedef typename _Cp::__storage_pointer __storage_pointer;
        typedef typename _Cp::iterator iterator;
        static const unsigned __bits_per_word = _Cp::__bits_per_word;
        static const unsigned _Np = 4;
        difference_type __size_;
        __storage_type __word_[_Np];

        {
            return static_cast<difference_type>(_Np * __bits_per_word);
        }
        {
            if (__libcpp_is_constant_evaluated())
            {
                for (size_t __i = 0; __i != __bit_array<_Cp>::_Np; ++__i)
                    std::__construct_at(__word_ + __i, 0);
            }
        }

        {
            return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]), 0);
        }

        {
            return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]) + __size_ / __bits_per_word,
                            static_cast<unsigned>(__size_ % __bits_per_word));
        }
};
template <class _Cp>
__bit_iterator<_Cp, false>
rotate(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __middle, __bit_iterator<_Cp, false> __last)
{
        typedef __bit_iterator<_Cp, false> _I1;
        typedef typename _I1::difference_type difference_type;
        difference_type __d1 = __middle - __first;
        difference_type __d2 = __last - __middle;
        _I1 __r = __first + __d2;
        while (__d1 != 0 && __d2 != 0)
        {
            if (__d1 <= __d2)
            {
                if (__d1 <= __bit_array<_Cp>::capacity())
                {
                    __bit_array<_Cp> __b(__d1);
                    std::copy(__first, __middle, __b.begin());
                    std::copy(__b.begin(), __b.end(), std::copy(__middle, __last, __first));
                    break;
                }
                else
                {
                    __bit_iterator<_Cp, false> __mp = std::swap_ranges(__first, __middle, __middle);
                    __first = __middle;
                    __middle = __mp;
                    __d2 -= __d1;
                }
            }
            else
            {
                if (__d2 <= __bit_array<_Cp>::capacity())
                {
                    __bit_array<_Cp> __b(__d2);
                    std::copy(__middle, __last, __b.begin());
                    std::copy_backward(__b.begin(), __b.end(), std::copy_backward(__first, __middle, __last));
                    break;
                }
                else
                {
                    __bit_iterator<_Cp, false> __mp = __first + __d2;
                    std::swap_ranges(__first, __mp, __middle);
                    __first = __mp;
                    __d1 -= __d2;
                }
            }
        }
        return __r;
}
template <class _Cp, bool _IC1, bool _IC2>
bool __equal_unaligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
                       __bit_iterator<_Cp, _IC2> __first2)
{
        typedef __bit_iterator<_Cp, _IC1> _It;
        typedef typename _It::difference_type difference_type;
        typedef typename _It::__storage_type __storage_type;
        const int __bits_per_word = _It::__bits_per_word;
        difference_type __n = __last1 - __first1;
        if (__n > 0)
        {
            if (__first1.__ctz_ != 0)
            {
                unsigned __clz_f = __bits_per_word - __first1.__ctz_;
                difference_type __dn = std::min(static_cast<difference_type>(__clz_f), __n);
                __n -= __dn;
                __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
                __storage_type __b = *__first1.__seg_ & __m;
                unsigned __clz_r = __bits_per_word - __first2.__ctz_;
                __storage_type __ddn = std::min<__storage_type>(__dn, __clz_r);
                __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
                if (__first2.__ctz_ > __first1.__ctz_)
                {
                    if ((*__first2.__seg_ & __m) != (__b << (__first2.__ctz_ - __first1.__ctz_)))
                        return false;
                }
                else
                {
                    if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ - __first2.__ctz_)))
                        return false;
                }
                __first2.__seg_ += (__ddn + __first2.__ctz_) / __bits_per_word;
                __first2.__ctz_ = static_cast<unsigned>((__ddn + __first2.__ctz_) % __bits_per_word);
                __dn -= __ddn;
                if (__dn > 0)
                {
                    __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                    if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ + __ddn)))
                        return false;
                    __first2.__ctz_ = static_cast<unsigned>(__dn);
                }
                ++__first1.__seg_;
            }
            unsigned __clz_r = __bits_per_word - __first2.__ctz_;
            __storage_type __m = ~__storage_type(0) << __first2.__ctz_;
            for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_)
            {
                __storage_type __b = *__first1.__seg_;
                if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                    return false;
                ++__first2.__seg_;
                if ((*__first2.__seg_ & ~__m) != (__b >> __clz_r))
                    return false;
            }
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                __storage_type __b = *__first1.__seg_ & __m;
                __storage_type __dn = std::min(__n, static_cast<difference_type>(__clz_r));
                __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
                if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                    return false;
                __first2.__seg_ += (__dn + __first2.__ctz_) / __bits_per_word;
                __first2.__ctz_ = static_cast<unsigned>((__dn + __first2.__ctz_) % __bits_per_word);
                __n -= __dn;
                if (__n > 0)
                {
                    __m = ~__storage_type(0) >> (__bits_per_word - __n);
                    if ((*__first2.__seg_ & __m) != (__b >> __dn))
                        return false;
                }
            }
        }
        return true;
}
template <class _Cp, bool _IC1, bool _IC2>
bool __equal_aligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
                     __bit_iterator<_Cp, _IC2> __first2)
{
        typedef __bit_iterator<_Cp, _IC1> _It;
        typedef typename _It::difference_type difference_type;
        typedef typename _It::__storage_type __storage_type;
        const int __bits_per_word = _It::__bits_per_word;
        difference_type __n = __last1 - __first1;
        if (__n > 0)
        {
            if (__first1.__ctz_ != 0)
            {
                unsigned __clz = __bits_per_word - __first1.__ctz_;
                difference_type __dn = std::min(static_cast<difference_type>(__clz), __n);
                __n -= __dn;
                __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
                if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                    return false;
                ++__first2.__seg_;
                ++__first1.__seg_;
            }
            for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_, ++__first2.__seg_)
                if (*__first2.__seg_ != *__first1.__seg_)
                    return false;
            if (__n > 0)
            {
                __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
                if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                    return false;
            }
        }
        return true;
}
template <class _Cp, bool _IC1, bool _IC2>
inline bool
equal(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2)
{
        if (__first1.__ctz_ == __first2.__ctz_)
            return std::__equal_aligned(__first1, __last1, __first2);
        return std::__equal_unaligned(__first1, __last1, __first2);
}
template <class _Cp, bool _IsConst,
          typename _Cp::__storage_type>
class __bit_iterator
{
    public:
        typedef typename _Cp::difference_type difference_type;
        typedef bool value_type;
        typedef __bit_iterator pointer;
        typedef typename conditional<_IsConst, __bit_const_reference<_Cp>, __bit_reference<_Cp>>::type reference;
        typedef random_access_iterator_tag iterator_category;

    private:
        typedef typename _Cp::__storage_type __storage_type;
        typedef typename conditional<_IsConst, typename _Cp::__const_storage_pointer,
                                     typename _Cp::__storage_pointer>::type __storage_pointer;
        static const unsigned __bits_per_word = _Cp::__bits_per_word;
        __storage_pointer __seg_;
        unsigned __ctz_;

    public:
        {
        }

        __bit_iterator(const __bit_iterator<_Cp, false> &__it) throw()
            : __seg_(__it.__seg_), __ctz_(__it.__ctz_) {}

        __bit_iterator &operator=(const _If<_IsConst, struct __private_nat, __bit_iterator> &__it)
        {
            __seg_ = __it.__seg_;
            __ctz_ = __it.__ctz_;
            return *this;
        }
        {
            return typename conditional<_IsConst, __bit_const_reference<_Cp>, __bit_reference<_Cp>>::type(__seg_, __storage_type(1) << __ctz_);
        }

        {
            if (__ctz_ != __bits_per_word - 1)
                ++__ctz_;
            else
            {
                __ctz_ = 0;
                ++__seg_;
            }
            return *this;
        }

        {
            __bit_iterator __tmp = *this;
            ++(*this);
            return __tmp;
        }

        {
            if (__ctz_ != 0)
                --__ctz_;
            else
            {
                __ctz_ = __bits_per_word - 1;
                --__seg_;
            }
            return *this;
        }

        {
            __bit_iterator __tmp = *this;
            --(*this);
            return __tmp;
        }

        {
            if (__n >= 0)
                __seg_ += (__n + __ctz_) / __bits_per_word;
            else
                __seg_ += static_cast<difference_type>(__n - __bits_per_word + __ctz_ + 1) / static_cast<difference_type>(__bits_per_word);
            __n &= (__bits_per_word - 1);
            __ctz_ = static_cast<unsigned>((__n + __ctz_) % __bits_per_word);
            return *this;
        }

        {
            return *this += -__n;
        }
        const
        {
            __bit_iterator __t(*this);
            __t += __n;
            return __t;
        }
        const
        {
            __bit_iterator __t(*this);
            __t -= __n;
            return __t;
        }

        friend __bit_iterator operator+(difference_type __n, const __bit_iterator &__it) { return __it + __n; }

        friend difference_type operator-(const __bit_iterator &__x, const __bit_iterator &__y)
        {
            return (__x.__seg_ - __y.__seg_) * __bits_per_word + __x.__ctz_ - __y.__ctz_;
        };
}

{
        return __x.__seg_ == __y.__seg_ && __x.__ctz_ == __y.__ctz_;
}

{
        return !(__x == __y);
}

{
        return __x.__seg_ < __y.__seg_ || (__x.__seg_ == __y.__seg_ && __x.__ctz_ < __y.__ctz_);
}

{
        return __y < __x;
}

{
        return !(__y < __x);
}

{
        return !(__x < __y);
}

private:
explicit __bit_iterator(__storage_pointer __s, unsigned __ctz) throw()
    : __seg_(__s), __ctz_(__ctz) {}
friend typename _Cp::__self;
friend class __bit_reference<_Cp>;
friend class __bit_const_reference<_Cp>;
friend class __bit_iterator<_Cp, true>;
template <class _Dp>
friend struct __bit_array;
template <class _Dp>
friend void __fill_n_false(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
template <class _Dp>
friend void __fill_n_true(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
template <class _Dp, bool _IC>
friend __bit_iterator<_Dp, false> __copy_aligned(__bit_iterator<_Dp, _IC> __first,
                                                 __bit_iterator<_Dp, _IC> __last,
                                                 __bit_iterator<_Dp, false> __result);
template <class _Dp, bool _IC>
friend __bit_iterator<_Dp, false> __copy_unaligned(__bit_iterator<_Dp, _IC> __first,
                                                   __bit_iterator<_Dp, _IC> __last,
                                                   __bit_iterator<_Dp, false> __result);
template <class _Dp, bool _IC>
friend __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first,
                                       __bit_iterator<_Dp, _IC> __last,
                                       __bit_iterator<_Dp, false> __result);
template <class _Dp, bool _IC>
friend __bit_iterator<_Dp, false> __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first,
                                                          __bit_iterator<_Dp, _IC> __last,
                                                          __bit_iterator<_Dp, false> __result);
template <class _Dp, bool _IC>
friend __bit_iterator<_Dp, false> __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first,
                                                            __bit_iterator<_Dp, _IC> __last,
                                                            __bit_iterator<_Dp, false> __result);
template <class _Dp, bool _IC>
friend __bit_iterator<_Dp, false> copy_backward(__bit_iterator<_Dp, _IC> __first,
                                                __bit_iterator<_Dp, _IC> __last,
                                                __bit_iterator<_Dp, false> __result);
template <class __C1, class __C2>
friend __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false>,
                                                         __bit_iterator<__C1, false>,
                                                         __bit_iterator<__C2, false>);
template <class __C1, class __C2>
friend __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false>,
                                                           __bit_iterator<__C1, false>,
                                                           __bit_iterator<__C2, false>);
template <class __C1, class __C2>
friend __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>,
                                               __bit_iterator<__C1, false>,
                                               __bit_iterator<__C2, false>);
template <class _Dp>
friend __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>,
                                         __bit_iterator<_Dp, false>,
                                         __bit_iterator<_Dp, false>);
template <class _Dp, bool _IC1, bool _IC2>
friend bool __equal_aligned(__bit_iterator<_Dp, _IC1>,
                            __bit_iterator<_Dp, _IC1>,
                            __bit_iterator<_Dp, _IC2>);
template <class _Dp, bool _IC1, bool _IC2>
friend bool __equal_unaligned(__bit_iterator<_Dp, _IC1>,
                              __bit_iterator<_Dp, _IC1>,
                              __bit_iterator<_Dp, _IC2>);
template <class _Dp, bool _IC1, bool _IC2>
friend bool equal(__bit_iterator<_Dp, _IC1>,
                  __bit_iterator<_Dp, _IC1>,
                  __bit_iterator<_Dp, _IC2>);
template <class _Dp, bool _IC>
friend __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
template <class _Dp, bool _IC>
friend __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
template <class _Dp, bool _IC>
friend typename __bit_iterator<_Dp, _IC>::difference_type
    __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
template <class _Dp, bool _IC>
friend typename __bit_iterator<_Dp, _IC>::difference_type
    __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
    };
}
}
extern "C"
{
    void __assert_rtn(const char *, const char *, int, const char *);
}
namespace std
{
    inline namespace __1
    {
template <class _Tp, class _Allocator = allocator<_Tp>>
struct __split_buffer
{
    private:
        __split_buffer(const __split_buffer &);
        __split_buffer &operator=(const __split_buffer &);

    public:
        typedef _Tp value_type;
        typedef _Allocator allocator_type;
        typedef typename remove_reference<allocator_type>::type __alloc_rr;
        typedef allocator_traits<__alloc_rr> __alloc_traits;
        typedef value_type &reference;
        typedef const value_type &const_reference;
        typedef typename __alloc_traits::size_type size_type;
        typedef typename __alloc_traits::difference_type difference_type;
        typedef typename __alloc_traits::pointer pointer;
        typedef typename __alloc_traits::const_pointer const_pointer;
        typedef pointer iterator;
        typedef const_pointer const_iterator;
        pointer __first_;
        pointer __begin_;
        pointer __end_;
        __compressed_pair<pointer, allocator_type> __end_cap_;
        typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;
        typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;
        ;
};
    };
};
}

__split_buffer();

explicit __split_buffer(__alloc_rr &__a);

explicit __split_buffer(const __alloc_rr &__a);
__split_buffer(size_type __cap, size_type __start, __alloc_rr &__a);
~__split_buffer();
__split_buffer(__split_buffer &&__c);
__split_buffer(__split_buffer &&__c, const __alloc_rr &__a);
__split_buffer &operator=(__split_buffer &&__c);
{
    return __begin_;
}
{
    return __begin_;
}
{
    return __end_;
}
{
    return __end_;
}

void clear() throw()
{
    __destruct_at_end(__begin_);
};
}
const { return __end_ == __begin_; };
}
;
}
;
}
{
    return *__begin_;
}
const { return *__begin_; };
}
;
}
void reserve(size_type __n);
void shrink_to_fit() throw();
void push_front(const_reference __x);
;
void push_front(value_type &&__x);
void push_back(value_type &&__x);
template <class... _Args>
void emplace_back(_Args &&...__args);
;
}
;
}
void __construct_at_end(size_type __n);
void __construct_at_end(size_type __n, const_reference __x);
template <class _InputIter>
__enable_if_t<__is_exactly_cpp17_input_iterator<_InputIter>::value>
__construct_at_end(_InputIter __first, _InputIter __last);
template <class _ForwardIterator>
__enable_if_t<__is_cpp17_forward_iterator<_ForwardIterator>::value>
__construct_at_end(_ForwardIterator __first, _ForwardIterator __last);

{
    __destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());
}

void __destruct_at_begin(pointer __new_begin, false_type);

void __destruct_at_begin(pointer __new_begin, true_type);

void __destruct_at_end(pointer __new_last) throw()
{
    __destruct_at_end(__new_last, false_type());
}

void __destruct_at_end(pointer __new_last, false_type) throw();

void __destruct_at_end(pointer __new_last, true_type) throw();
void swap(__split_buffer &__x);
bool __invariants() const;

private:
void __move_assign_alloc(__split_buffer &__c, true_type)
{
    __alloc() = std::move(__c.__alloc());
}

void __move_assign_alloc(__split_buffer &, false_type) throw()
{
}
struct _ConstructTransaction
{
    explicit _ConstructTransaction(pointer *__p, size_type __n) throw()
        : __pos_(*__p), __end_(*__p + __n), __dest_(__p)
    {
    }
    ~_ConstructTransaction()
    {
*__dest_ = __pos_;
    }
    pointer __pos_;
    const pointer __end_;

private:
    pointer *__dest_;
};
}
;
template <class _Tp, class _Allocator>
bool __split_buffer<_Tp, _Allocator>::__invariants() const
{
    if (__first_ == __nullptr)
    {
if (__begin_ != __nullptr)
        return false;
if (__end_ != __nullptr)
        return false;
if (__end_cap() != __nullptr)
        return false;
    }
    else
    {
if (__begin_ < __first_)
        return false;
if (__end_ < __begin_)
        return false;
if (__end_cap() < __end_)
        return false;
    }
    return true;
}
template <class _Tp, class _Allocator>
void __split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n)
{
    _ConstructTransaction __tx(&this->__end_, __n);
    for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_)
    {
__alloc_traits::construct(this->__alloc(), std::__to_address(__tx.__pos_));
    }
}
template <class _Tp, class _Allocator>
void __split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)
{
    _ConstructTransaction __tx(&this->__end_, __n);
    for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_)
    {
__alloc_traits::construct(this->__alloc(),
                          std::__to_address(__tx.__pos_), __x);
    }
}
template <class _Tp, class _Allocator>
template <class _InputIter>
__enable_if_t<__is_exactly_cpp17_input_iterator<_InputIter>::value>
__split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first, _InputIter __last)
{
    __alloc_rr &__a = this->__alloc();
    for (; __first != __last; ++__first)
    {
if (__end_ == __end_cap())
{
        size_type __old_cap = __end_cap() - __first_;
        size_type __new_cap = std::max<size_type>(2 * __old_cap, 8);
        __split_buffer __buf(__new_cap, 0, __a);
        for (pointer __p = __begin_; __p != __end_; ++__p, (void)++__buf.__end_)
            __alloc_traits::construct(__buf.__alloc(),
                                      std::__to_address(__buf.__end_), std::move(*__p));
        swap(__buf);
}
__alloc_traits::construct(__a, std::__to_address(this->__end_), *__first);
++this->__end_;
    }
}
template <class _Tp, class _Allocator>
template <class _ForwardIterator>
__enable_if_t<__is_cpp17_forward_iterator<_ForwardIterator>::value>
__split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)
{
    _ConstructTransaction __tx(&this->__end_, std::distance(__first, __last));
    for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_, (void)++__first)
    {
__alloc_traits::construct(this->__alloc(),
                          std::__to_address(__tx.__pos_), *__first);
    }
}
template <class _Tp, class _Allocator>
inline void
__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, false_type)
{
    while (__begin_ != __new_begin)
__alloc_traits::destroy(__alloc(), std::__to_address(__begin_++));
}
template <class _Tp, class _Allocator>
inline void
__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, true_type)
{
    __begin_ = __new_begin;
}
template <class _Tp, class _Allocator>
inline void
__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, false_type) throw()
{
    while (__new_last != __end_)
__alloc_traits::destroy(__alloc(), std::__to_address(--__end_));
}
template <class _Tp, class _Allocator>
inline void
__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, true_type) throw()
{
    __end_ = __new_last;
}
template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::__split_buffer(size_type __cap, size_type __start, __alloc_rr &__a)
    : __end_cap_(__nullptr, __a)
{
    if (__cap == 0)
    {
__first_ = __nullptr;
    }
    else
    {
auto __allocation = std::__allocate_at_least(__alloc(), __cap);
__first_ = __allocation.ptr;
__cap = __allocation.count;
    }
    __begin_ = __end_ = __first_ + __start;
    __end_cap() = __first_ + __cap;
}
template <class _Tp, class _Allocator>
inline __split_buffer<_Tp, _Allocator>::__split_buffer()
    : __first_(__nullptr), __begin_(__nullptr), __end_(__nullptr), __end_cap_(__nullptr, __default_init_tag())
{
}
template <class _Tp, class _Allocator>
inline __split_buffer<_Tp, _Allocator>::__split_buffer(__alloc_rr &__a)
    : __first_(__nullptr), __begin_(__nullptr), __end_(__nullptr), __end_cap_(__nullptr, __a)
{
}
template <class _Tp, class _Allocator>
inline __split_buffer<_Tp, _Allocator>::__split_buffer(const __alloc_rr &__a)
    : __first_(__nullptr), __begin_(__nullptr), __end_(__nullptr), __end_cap_(__nullptr, __a)
{
}
template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::~__split_buffer()
{
    clear();
    if (__first_)
__alloc_traits::deallocate(__alloc(), __first_, capacity());
}
template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer &&__c)
    : __first_(std::move(__c.__first_)),
      __begin_(std::move(__c.__begin_)),
      __end_(std::move(__c.__end_)),
      __end_cap_(std::move(__c.__end_cap_))
{
    __c.__first_ = __nullptr;
    __c.__begin_ = __nullptr;
    __c.__end_ = __nullptr;
    __c.__end_cap() = __nullptr;
}
template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer &&__c, const __alloc_rr &__a)
    : __end_cap_(__nullptr, __a)
{
    if (__a == __c.__alloc())
    {
__first_ = __c.__first_;
__begin_ = __c.__begin_;
__end_ = __c.__end_;
__end_cap() = __c.__end_cap();
__c.__first_ = __nullptr;
__c.__begin_ = __nullptr;
__c.__end_ = __nullptr;
__c.__end_cap() = __nullptr;
    }
    else
    {
auto __allocation = std::__allocate_at_least(__alloc(), __c.size());
__first_ = __allocation.ptr;
__begin_ = __end_ = __first_;
__end_cap() = __first_ + __allocation.count;
typedef move_iterator<iterator> _Ip;
__construct_at_end(_Ip(__c.begin()), _Ip(__c.end()));
    }
}
template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator> &
__split_buffer<_Tp, _Allocator>::operator=(__split_buffer &&__c)
{
    clear();
    shrink_to_fit();
    __first_ = __c.__first_;
    __begin_ = __c.__begin_;
    __end_ = __c.__end_;
    __end_cap() = __c.__end_cap();
    __move_assign_alloc(__c,
                        integral_constant<bool,
                                          __alloc_traits::propagate_on_container_move_assignment::value>());
    __c.__first_ = __c.__begin_ = __c.__end_ = __c.__end_cap() = __nullptr;
    return *this;
}
template <class _Tp, class _Allocator>
void __split_buffer<_Tp, _Allocator>::swap(__split_buffer &__x)
{
    std::swap(__first_, __x.__first_);
    std::swap(__begin_, __x.__begin_);
    std::swap(__end_, __x.__end_);
    std::swap(__end_cap(), __x.__end_cap());
    std::__swap_allocator(__alloc(), __x.__alloc());
}
template <class _Tp, class _Allocator>
void __split_buffer<_Tp, _Allocator>::reserve(size_type __n)
{
    if (__n < capacity())
    {
__split_buffer<value_type, __alloc_rr &> __t(__n, 0, __alloc());
__t.__construct_at_end(move_iterator<pointer>(__begin_),
                       move_iterator<pointer>(__end_));
std::swap(__first_, __t.__first_);
std::swap(__begin_, __t.__begin_);
std::swap(__end_, __t.__end_);
std::swap(__end_cap(), __t.__end_cap());
    }
}
template <class _Tp, class _Allocator>
void __split_buffer<_Tp, _Allocator>::shrink_to_fit() throw()
{
    if (capacity() > size())
    {
try
{
        __split_buffer<value_type, __alloc_rr &> __t(size(), 0, __alloc());
        __t.__construct_at_end(move_iterator<pointer>(__begin_),
                               move_iterator<pointer>(__end_));
        __t.__end_ = __t.__begin_ + (__end_ - __begin_);
        std::swap(__first_, __t.__first_);
        std::swap(__begin_, __t.__begin_);
        std::swap(__end_, __t.__end_);
        std::swap(__end_cap(), __t.__end_cap());
}
catch (...)
{
}
    }
}
template <class _Tp, class _Allocator>
void __split_buffer<_Tp, _Allocator>::push_front(const_reference __x)
{
    if (__begin_ == __first_)
    {
if (__end_ < __end_cap())
{
        difference_type __d = __end_cap() - __end_;
        __d = (__d + 1) / 2;
        __begin_ = std::move_backward(__begin_, __end_, __end_ + __d);
        __end_ += __d;
}
else
{
        size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
        __split_buffer<value_type, __alloc_rr &> __t(__c, (__c + 3) / 4, __alloc());
        __t.__construct_at_end(move_iterator<pointer>(__begin_),
                               move_iterator<pointer>(__end_));
        std::swap(__first_, __t.__first_);
        std::swap(__begin_, __t.__begin_);
        std::swap(__end_, __t.__end_);
        std::swap(__end_cap(), __t.__end_cap());
}
    }
    __alloc_traits::construct(__alloc(), std::__to_address(__begin_ - 1), __x);
    --__begin_;
}
template <class _Tp, class _Allocator>
void __split_buffer<_Tp, _Allocator>::push_front(value_type &&__x)
{
    if (__begin_ == __first_)
    {
if (__end_ < __end_cap())
{
        difference_type __d = __end_cap() - __end_;
        __d = (__d + 1) / 2;
        __begin_ = std::move_backward(__begin_, __end_, __end_ + __d);
        __end_ += __d;
}
else
{
        size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
        __split_buffer<value_type, __alloc_rr &> __t(__c, (__c + 3) / 4, __alloc());
        __t.__construct_at_end(move_iterator<pointer>(__begin_),
                               move_iterator<pointer>(__end_));
        std::swap(__first_, __t.__first_);
        std::swap(__begin_, __t.__begin_);
        std::swap(__end_, __t.__end_);
        std::swap(__end_cap(), __t.__end_cap());
}
    }
    __alloc_traits::construct(__alloc(), std::__to_address(__begin_ - 1),
                              std::move(__x));
    --__begin_;
}
template <class _Tp, class _Allocator>
inline void
__split_buffer<_Tp, _Allocator>::push_back(const_reference __x)
{
    if (__end_ == __end_cap())
    {
if (__begin_ > __first_)
{
        difference_type __d = __begin_ - __first_;
        __d = (__d + 1) / 2;
        __end_ = std::move(__begin_, __end_, __begin_ - __d);
        __begin_ -= __d;
}
else
{
        size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
        __split_buffer<value_type, __alloc_rr &> __t(__c, __c / 4, __alloc());
        __t.__construct_at_end(move_iterator<pointer>(__begin_),
                               move_iterator<pointer>(__end_));
        std::swap(__first_, __t.__first_);
        std::swap(__begin_, __t.__begin_);
        std::swap(__end_, __t.__end_);
        std::swap(__end_cap(), __t.__end_cap());
}
    }
    __alloc_traits::construct(__alloc(), std::__to_address(__end_), __x);
    ++__end_;
}
template <class _Tp, class _Allocator>
void __split_buffer<_Tp, _Allocator>::push_back(value_type &&__x)
{
    if (__end_ == __end_cap())
    {
if (__begin_ > __first_)
{
        difference_type __d = __begin_ - __first_;
        __d = (__d + 1) / 2;
        __end_ = std::move(__begin_, __end_, __begin_ - __d);
        __begin_ -= __d;
}
else
{
        size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
        __split_buffer<value_type, __alloc_rr &> __t(__c, __c / 4, __alloc());
        __t.__construct_at_end(move_iterator<pointer>(__begin_),
                               move_iterator<pointer>(__end_));
        std::swap(__first_, __t.__first_);
        std::swap(__begin_, __t.__begin_);
        std::swap(__end_, __t.__end_);
        std::swap(__end_cap(), __t.__end_cap());
}
    }
    __alloc_traits::construct(__alloc(), std::__to_address(__end_),
                              std::move(__x));
    ++__end_;
}
template <class _Tp, class _Allocator>
template <class... _Args>
void __split_buffer<_Tp, _Allocator>::emplace_back(_Args &&...__args)
{
    if (__end_ == __end_cap())
    {
if (__begin_ > __first_)
{
        difference_type __d = __begin_ - __first_;
        __d = (__d + 1) / 2;
        __end_ = std::move(__begin_, __end_, __begin_ - __d);
        __begin_ -= __d;
}
else
{
        size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
        __split_buffer<value_type, __alloc_rr &> __t(__c, __c / 4, __alloc());
        __t.__construct_at_end(move_iterator<pointer>(__begin_),
                               move_iterator<pointer>(__end_));
        std::swap(__first_, __t.__first_);
        std::swap(__begin_, __t.__begin_);
        std::swap(__end_, __t.__end_);
        std::swap(__end_cap(), __t.__end_cap());
}
    }
    __alloc_traits::construct(__alloc(), std::__to_address(__end_),
                              std::forward<_Args>(__args)...);
    ++__end_;
}
template <class _Tp, class _Allocator>
inline void
swap(__split_buffer<_Tp, _Allocator> &__x, __split_buffer<_Tp, _Allocator> &__y)
{
    __x.swap(__y);
}
}
}
extern "C"
{
    void __assert_rtn(const char *, const char *, int, const char *);
}
namespace std
{
    inline namespace __1
    {
template <class _Tp, class _Allocator>
class vector
{
    private:
        typedef allocator<_Tp> __default_allocator_type;

    public:
        typedef vector __self;
        typedef _Tp value_type;
        typedef _Allocator allocator_type;
        typedef allocator_traits<allocator_type> __alloc_traits;
        typedef value_type &reference;
        typedef const value_type &const_reference;
        typedef typename __alloc_traits::size_type size_type;
        typedef typename __alloc_traits::difference_type difference_type;
        typedef typename __alloc_traits::pointer pointer;
        typedef typename __alloc_traits::const_pointer const_pointer;
        typedef __wrap_iter<pointer> iterator;
        typedef __wrap_iter<const_pointer> const_iterator;
        typedef std::reverse_iterator<iterator> reverse_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
        _Static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");

        vector()
        {
            std::__debug_db_insert_c(this);
        }

        : __end_cap_(__nullptr, __a)
        {
            std::__debug_db_insert_c(this);
        }
        explicit vector(size_type __n);
        vector(size_type __n, const value_type &__x);
        template <class = __enable_if_t<__is_allocator<_Allocator>::value>>
        vector(size_type __n, const value_type &__x, const allocator_type &__a)
            : __end_cap_(__nullptr, __a)
        {
            std::__debug_db_insert_c(this);
            if (__n > 0)
            {
                __vallocate(__n);
                __construct_at_end(__n, __x);
            }
        }
        template <class _InputIterator>
        vector(_InputIterator __first,
               typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value &&
                                      is_constructible<
                                          value_type,
                                          typename iterator_traits<_InputIterator>::reference>::value,
                                  _InputIterator>::type __last);
        template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last, const allocator_type &__a,
               typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value &&
                                  is_constructible<
                                      value_type,
                                      typename iterator_traits<_InputIterator>::reference>::value>::type * = 0);
        template <class _ForwardIterator>
        vector(_ForwardIterator __first,
               typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value &&
                                      is_constructible<
                                          value_type,
                                          typename iterator_traits<_ForwardIterator>::reference>::value,
                                  _ForwardIterator>::type __last);
        template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type &__a,
               typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value &&
                                  is_constructible<
                                      value_type,
                                      typename iterator_traits<_ForwardIterator>::reference>::value>::type * = 0);

        ~vector()
        {
            __annotate_delete();
            std::__debug_db_erase_c(this);
            if (this->__begin_ != __nullptr)
            {
                __clear();
                __alloc_traits::deallocate(__alloc(), this->__begin_, capacity());
            }
        }
        vector(const vector &__x);
        vector(const vector &__x, const __type_identity_t<allocator_type> &__a);

        vector &operator=(const vector &__x);

        vector(vector &&__x);

        vector(vector &&__x, const __type_identity_t<allocator_type> &__a);

        vector &operator=(vector &&__x);
        template <class _InputIterator>
        typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value &&
                               is_constructible<
                                   value_type,
                                   typename iterator_traits<_InputIterator>::reference>::value,
                           void>::type
        assign(_InputIterator __first, _InputIterator __last);
        template <class _ForwardIterator>
        typename enable_if<
            __is_cpp17_forward_iterator<_ForwardIterator>::value &&
                is_constructible<
                    value_type,
                    typename iterator_traits<_ForwardIterator>::reference>::value,
            void>::type
        assign(_ForwardIterator __first, _ForwardIterator __last);
        void assign(size_type __n, const_reference __u);

        allocator_type get_allocator() const throw()
        {
            return this->__alloc();
        };
        ;
        ;
        ;

        reverse_iterator rbegin() throw()
        {
            return reverse_iterator(end());
        }

        const_reverse_iterator rbegin() const throw()
        {
            return const_reverse_iterator(end());
        }

        reverse_iterator rend() throw()
        {
            return reverse_iterator(begin());
        }

        const_reverse_iterator rend() const throw()
        {
            return const_reverse_iterator(begin());
        }

        const_iterator cbegin() const throw()
        {
            return begin();
        }

        const_iterator cend() const throw()
        {
            return end();
        }

        const_reverse_iterator crbegin() const throw()
        {
            return rbegin();
        }

        const_reverse_iterator crend() const throw()
        {
            return rend();
        }

        size_type size() const throw()
        {
            return static_cast<size_type>(this->__end_ - this->__begin_);
        }

        size_type capacity() const throw()
        {
            return static_cast<size_type>(__end_cap() - this->__begin_);
        }

        bool empty() const throw()
        {
            return this->__begin_ == this->__end_;
        }
        size_type max_size() const throw();
        void reserve(size_type __n);
        void shrink_to_fit() throw();
        ;
        ;
        reference at(size_type __n);
        const_reference at(size_type __n) const;

        {
            ((void)0);
            return *this->__begin_;
        }

        {
            ((void)0);
            return *this->__begin_;
        }

        {
            ((void)0);
            return *(this->__end_ - 1);
        }

        {
            ((void)0);
            return *(this->__end_ - 1);
        }

        value_type *data() throw()
        {
            return std::__to_address(this->__begin_);
        }

        const value_type *data() const throw()
        {
            return std::__to_address(this->__begin_);
        };
        ;
        template <class... _Args>

        void emplace_back(_Args &&...__args);

        void pop_back();
        iterator insert(const_iterator __position, const_reference __x);
        iterator insert(const_iterator __position, value_type &&__x);
        template <class... _Args>
        iterator emplace(const_iterator __position, _Args &&...__args);
        iterator insert(const_iterator __position, size_type __n, const_reference __x);
        template <class _InputIterator>
        typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value &&
                               is_constructible<
                                   value_type,
                                   typename iterator_traits<_InputIterator>::reference>::value,
                           iterator>::type
        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);
        template <class _ForwardIterator>
        typename enable_if<
            __is_cpp17_forward_iterator<_ForwardIterator>::value &&
                is_constructible<
                    value_type,
                    typename iterator_traits<_ForwardIterator>::reference>::value,
            iterator>::type
        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);
        ;
        iterator erase(const_iterator __first, const_iterator __last);

        void clear() throw()
        {
            size_type __old_size = size();
            __clear();
            __annotate_shrink(__old_size);
            std::__debug_db_invalidate_all(this);
        }
        void resize(size_type __sz);
        void resize(size_type __sz, const_reference __x);
        void swap(vector &);
        bool __invariants() const;

    private:
        pointer __begin_ = __nullptr;
        pointer __end_ = __nullptr;
        __compressed_pair<pointer, allocator_type> __end_cap_ =
            __compressed_pair<pointer, allocator_type>(__nullptr, __default_init_tag());
        ;
        {
            if (__n > max_size())
                __throw_length_error();
            auto __allocation = std::__allocate_at_least(__alloc(), __n);
            __begin_ = __allocation.ptr;
            __end_ = __allocation.ptr;
            __end_cap() = __begin_ + __allocation.count;
            __annotate_new(0);
        }
        void __vdeallocate() throw();
        const;
        void __construct_at_end(size_type __n);

        void __construct_at_end(size_type __n, const_reference __x);
        template <class _ForwardIterator>
        typename enable_if<
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            void>::type
        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n);
        void __append(size_type __n);
        void __append(size_type __n, const_reference __x);

        iterator __make_iter(pointer __p) throw();

        const_iterator __make_iter(const_pointer __p) const throw();
        void __swap_out_circular_buffer(__split_buffer<value_type, allocator_type &> &__v);
        pointer __swap_out_circular_buffer(__split_buffer<value_type, allocator_type &> &__v, pointer __p);
        void __move_range(pointer __from_s, pointer __from_e, pointer __to);
        void __move_assign(vector &__c, true_type);
        void __move_assign(vector &__c, false_type);

        void __destruct_at_end(pointer __new_last) throw()
        {
            if (!__libcpp_is_constant_evaluated())
                __invalidate_iterators_past(__new_last);
            size_type __old_size = size();
            __base_destruct_at_end(__new_last);
            __annotate_shrink(__old_size);
        }
        template <class _Up>

        inline void __push_back_slow_path(_Up &&__x);
        template <class... _Args>

        inline void __emplace_back_slow_path(_Args &&...__args);

        void __annotate_contiguous_container(const void *, const void *, const void *,
                                             const void *) const throw() {}

        void __annotate_new(size_type __current_size) const throw()
        {
            __annotate_contiguous_container(data(), data() + capacity(),
                                            data() + capacity(), data() + __current_size);
        }

        void __annotate_delete() const throw()
        {
            __annotate_contiguous_container(data(), data() + capacity(),
                                            data() + size(), data() + capacity());
        }

        void __annotate_increase(size_type __n) const throw()
        {
            __annotate_contiguous_container(data(), data() + capacity(),
                                            data() + size(), data() + size() + __n);
        }

        void __annotate_shrink(size_type __old_size) const throw()
        {
            __annotate_contiguous_container(data(), data() + capacity(),
                                            data() + __old_size, data() + size());
        }
        struct _ConstructTransaction
        {
            explicit _ConstructTransaction(vector &__v, size_type __n)
                : __v_(__v), __pos_(__v.__end_), __new_end_(__v.__end_ + __n)
            {
            }
            ~_ConstructTransaction()
            {
                __v_.__end_ = __pos_;
            }
            vector &__v_;
            pointer __pos_;
            const_pointer const __new_end_;

        private:
            _ConstructTransaction(_ConstructTransaction const &) = delete;
            _ConstructTransaction &operator=(_ConstructTransaction const &) = delete;
        };
        template <class... _Args>

        void __construct_one_at_end(_Args &&...__args)
        {
            _ConstructTransaction __tx(*this, 1);
            __alloc_traits::construct(this->__alloc(), std::__to_address(__tx.__pos_),
                                      std::forward<_Args>(__args)...);
            ++__tx.__pos_;
        }

        allocator_type &__alloc() throw()
        {
            return this->__end_cap_.second();
        }

        const allocator_type &__alloc() const throw()
        {
            return this->__end_cap_.second();
        }

        pointer &__end_cap() throw()
        {
            return this->__end_cap_.first();
        }

        const pointer &__end_cap() const throw()
        {
            return this->__end_cap_.first();
        }

        void __clear() throw() { __base_destruct_at_end(this->__begin_); }

        void __base_destruct_at_end(pointer __new_last) throw()
        {
            pointer __soon_to_be_end = this->__end_;
            while (__new_last != __soon_to_be_end)
                __alloc_traits::destroy(__alloc(), std::__to_address(--__soon_to_be_end));
            this->__end_ = __new_last;
        }

        void __copy_assign_alloc(const vector &__c)
        {
            __copy_assign_alloc(__c, integral_constant<bool,
                                                       __alloc_traits::propagate_on_container_copy_assignment::value>());
        }

        void __move_assign_alloc(vector &__c)
        {
            __move_assign_alloc(__c, integral_constant<bool,
                                                       __alloc_traits::propagate_on_container_move_assignment::value>());
        }

        void __throw_length_error() const
        {
            std::__throw_length_error("vector");
        }

        void __throw_out_of_range() const
        {
            std::__throw_out_of_range("vector");
        }

        void __copy_assign_alloc(const vector &__c, true_type)
        {
            if (__alloc() != __c.__alloc())
            {
                __clear();
                __alloc_traits::deallocate(__alloc(), this->__begin_, capacity());
                this->__begin_ = this->__end_ = __end_cap() = __nullptr;
            }
            __alloc() = __c.__alloc();
        }

        void __copy_assign_alloc(const vector &, false_type)
        {
        }

        void __move_assign_alloc(vector &__c, true_type)
        {
            __alloc() = std::move(__c.__alloc());
        }

        void __move_assign_alloc(vector &, false_type) throw()
        {
        }
};
template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type &> &__v)
{
        __annotate_delete();
        using _RevIter = std::reverse_iterator<pointer>;
        __v.__begin_ = std::__uninitialized_allocator_move_if_noexcept(
                           __alloc(), _RevIter(__end_), _RevIter(__begin_), _RevIter(__v.__begin_))
                           .base();
        std::swap(this->__begin_, __v.__begin_);
        std::swap(this->__end_, __v.__end_);
        std::swap(this->__end_cap(), __v.__end_cap());
        __v.__first_ = __v.__begin_;
        __annotate_new(size());
        std::__debug_db_invalidate_all(this);
}
template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::pointer
vector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type &> &__v, pointer __p)
{
        __annotate_delete();
        pointer __r = __v.__begin_;
        using _RevIter = std::reverse_iterator<pointer>;
        __v.__begin_ = std::__uninitialized_allocator_move_if_noexcept(
                           __alloc(), _RevIter(__p), _RevIter(__begin_), _RevIter(__v.__begin_))
                           .base();
        __v.__end_ = std::__uninitialized_allocator_move_if_noexcept(__alloc(), __p, __end_, __v.__end_);
        std::swap(this->__begin_, __v.__begin_);
        std::swap(this->__end_, __v.__end_);
        std::swap(this->__end_cap(), __v.__end_cap());
        __v.__first_ = __v.__begin_;
        __annotate_new(size());
        std::__debug_db_invalidate_all(this);
        return __r;
}
template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::__vdeallocate() throw()
{
        if (this->__begin_ != __nullptr)
        {
            clear();
            __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());
            this->__begin_ = this->__end_ = this->__end_cap() = __nullptr;
        }
}
template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::size_type
vector<_Tp, _Allocator>::max_size() const throw()
{
        return std::min<size_type>(__alloc_traits::max_size(this->__alloc()),
                                   numeric_limits<difference_type>::max());
}
template <class _Tp, class _Allocator>
inline
    typename vector<_Tp, _Allocator>::size_type
    vector<_Tp, _Allocator>::__recommend(size_type __new_size) const
{
        const size_type __ms = max_size();
        if (__new_size > __ms)
            this->__throw_length_error();
        const size_type __cap = capacity();
        if (__cap >= __ms / 2)
            return __ms;
        return std::max<size_type>(2 * __cap, __new_size);
}
template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::__construct_at_end(size_type __n)
{
        _ConstructTransaction __tx(*this, __n);
        const_pointer __new_end = __tx.__new_end_;
        for (pointer __pos = __tx.__pos_; __pos != __new_end; __tx.__pos_ = ++__pos)
        {
            __alloc_traits::construct(this->__alloc(), std::__to_address(__pos));
        }
}
template <class _Tp, class _Allocator>
inline void
vector<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)
{
        _ConstructTransaction __tx(*this, __n);
        const_pointer __new_end = __tx.__new_end_;
        for (pointer __pos = __tx.__pos_; __pos != __new_end; __tx.__pos_ = ++__pos)
        {
            __alloc_traits::construct(this->__alloc(), std::__to_address(__pos), __x);
        }
}
template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    void>::type
vector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n)
{
        _ConstructTransaction __tx(*this, __n);
        __tx.__pos_ = std::__uninitialized_allocator_copy(__alloc(), __first, __last, __tx.__pos_);
}
template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::__append(size_type __n)
{
        if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)
            this->__construct_at_end(__n);
        else
        {
            allocator_type &__a = this->__alloc();
            __split_buffer<value_type, allocator_type &> __v(__recommend(size() + __n), size(), __a);
            __v.__construct_at_end(__n);
            __swap_out_circular_buffer(__v);
        }
}
template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::__append(size_type __n, const_reference __x)
{
        if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)
            this->__construct_at_end(__n, __x);
        else
        {
            allocator_type &__a = this->__alloc();
            __split_buffer<value_type, allocator_type &> __v(__recommend(size() + __n), size(), __a);
            __v.__construct_at_end(__n, __x);
            __swap_out_circular_buffer(__v);
        }
}
template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n)
{
        std::__debug_db_insert_c(this);
        if (__n > 0)
        {
            __vallocate(__n);
            __construct_at_end(__n);
        }
}
template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n, const value_type &__x)
{
        std::__debug_db_insert_c(this);
        if (__n > 0)
        {
            __vallocate(__n);
            __construct_at_end(__n, __x);
        }
}
template <class _Tp, class _Allocator>
template <class _InputIterator>
vector<_Tp, _Allocator>::vector(_InputIterator __first,
                                typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value &&
                                                       is_constructible<
                                                           value_type,
                                                           typename iterator_traits<_InputIterator>::reference>::value,
                                                   _InputIterator>::type __last)
{
        std::__debug_db_insert_c(this);
        for (; __first != __last; ++__first)
            emplace_back(*__first);
}
template <class _Tp, class _Allocator>
template <class _InputIterator>
vector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type &__a,
                                typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value &&
                                                   is_constructible<
                                                       value_type,
                                                       typename iterator_traits<_InputIterator>::reference>::value>::type *)
    : __end_cap_(__nullptr, __a)
{
        std::__debug_db_insert_c(this);
        for (; __first != __last; ++__first)
            emplace_back(*__first);
}
template <class _Tp, class _Allocator>
template <class _ForwardIterator>
vector<_Tp, _Allocator>::vector(_ForwardIterator __first,
                                typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value &&
                                                       is_constructible<
                                                           value_type,
                                                           typename iterator_traits<_ForwardIterator>::reference>::value,
                                                   _ForwardIterator>::type __last)
{
        std::__debug_db_insert_c(this);
        size_type __n = static_cast<size_type>(std::distance(__first, __last));
        if (__n > 0)
        {
            __vallocate(__n);
            __construct_at_end(__first, __last, __n);
        }
}
template <class _Tp, class _Allocator>
template <class _ForwardIterator>
vector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type &__a,
                                typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value &&
                                                   is_constructible<
                                                       value_type,
                                                       typename iterator_traits<_ForwardIterator>::reference>::value>::type *)
    : __end_cap_(__nullptr, __a)
{
        std::__debug_db_insert_c(this);
        size_type __n = static_cast<size_type>(std::distance(__first, __last));
        if (__n > 0)
        {
            __vallocate(__n);
            __construct_at_end(__first, __last, __n);
        }
}
template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(const vector &__x)
    : __end_cap_(__nullptr, __alloc_traits::select_on_container_copy_construction(__x.__alloc()))
{
        std::__debug_db_insert_c(this);
        size_type __n = __x.size();
        if (__n > 0)
        {
            __vallocate(__n);
            __construct_at_end(__x.__begin_, __x.__end_, __n);
        }
}
template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(const vector &__x, const __type_identity_t<allocator_type> &__a)
    : __end_cap_(__nullptr, __a)
{
        std::__debug_db_insert_c(this);
        size_type __n = __x.size();
        if (__n > 0)
        {
            __vallocate(__n);
            __construct_at_end(__x.__begin_, __x.__end_, __n);
        }
}
template <class _Tp, class _Allocator>
inline vector<_Tp, _Allocator>::vector(vector &&__x)
    : __end_cap_(__nullptr, std::move(__x.__alloc()))
{
        std::__debug_db_insert_c(this);
        std::__debug_db_swap(this, std::addressof(__x));
        this->__begin_ = __x.__begin_;
        this->__end_ = __x.__end_;
        this->__end_cap() = __x.__end_cap();
        __x.__begin_ = __x.__end_ = __x.__end_cap() = __nullptr;
}
template <class _Tp, class _Allocator>
inline vector<_Tp, _Allocator>::vector(vector &&__x, const __type_identity_t<allocator_type> &__a)
    : __end_cap_(__nullptr, __a)
{
        std::__debug_db_insert_c(this);
        if (__a == __x.__alloc())
        {
            this->__begin_ = __x.__begin_;
            this->__end_ = __x.__end_;
            this->__end_cap() = __x.__end_cap();
            __x.__begin_ = __x.__end_ = __x.__end_cap() = __nullptr;
            std::__debug_db_swap(this, std::addressof(__x));
        }
        else
        {
            typedef move_iterator<iterator> _Ip;
            assign(_Ip(__x.begin()), _Ip(__x.end()));
        }
}
template <class _Tp, class _Allocator>
inline vector<_Tp, _Allocator> &
vector<_Tp, _Allocator>::operator=(vector &&__x)
{
        __move_assign(__x, integral_constant<bool,
                                             __alloc_traits::propagate_on_container_move_assignment::value>());
        return *this;
}
template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::__move_assign(vector &__c, false_type)
{
        if (__alloc() != __c.__alloc())
        {
            typedef move_iterator<iterator> _Ip;
            assign(_Ip(__c.begin()), _Ip(__c.end()));
        }
        else
            __move_assign(__c, true_type());
}
template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::__move_assign(vector &__c, true_type)
{
        __vdeallocate();
        __move_assign_alloc(__c);
        this->__begin_ = __c.__begin_;
        this->__end_ = __c.__end_;
        this->__end_cap() = __c.__end_cap();
        __c.__begin_ = __c.__end_ = __c.__end_cap() = __nullptr;
        std::__debug_db_swap(this, std::addressof(__c));
}
template <class _Tp, class _Allocator>
inline vector<_Tp, _Allocator> &
vector<_Tp, _Allocator>::operator=(const vector &__x)
{
        if (this != std::addressof(__x))
        {
            __copy_assign_alloc(__x);
            assign(__x.__begin_, __x.__end_);
        }
        return *this;
}
template <class _Tp, class _Allocator>
template <class _InputIterator>
typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value &&
                       is_constructible<
                           _Tp,
                           typename iterator_traits<_InputIterator>::reference>::value,
                   void>::type
vector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
        clear();
        for (; __first != __last; ++__first)
            emplace_back(*__first);
}
template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if<
    __is_cpp17_forward_iterator<_ForwardIterator>::value &&
        is_constructible<
            _Tp,
            typename iterator_traits<_ForwardIterator>::reference>::value,
    void>::type
vector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
        size_type __new_size = static_cast<size_type>(std::distance(__first, __last));
        if (__new_size <= capacity())
        {
            _ForwardIterator __mid = __last;
            bool __growing = false;
            if (__new_size > size())
            {
                __growing = true;
                __mid = __first;
                std::advance(__mid, size());
            }
            pointer __m = std::copy(__first, __mid, this->__begin_);
            if (__growing)
                __construct_at_end(__mid, __last, __new_size - size());
            else
                this->__destruct_at_end(__m);
        }
        else
        {
            __vdeallocate();
            __vallocate(__recommend(__new_size));
            __construct_at_end(__first, __last, __new_size);
        }
        std::__debug_db_invalidate_all(this);
}
template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::assign(size_type __n, const_reference __u)
{
        if (__n <= capacity())
        {
            size_type __s = size();
            std::fill_n(this->__begin_, std::min(__n, __s), __u);
            if (__n > __s)
                __construct_at_end(__n - __s, __u);
            else
                this->__destruct_at_end(this->__begin_ + __n);
        }
        else
        {
            __vdeallocate();
            __vallocate(__recommend(static_cast<size_type>(__n)));
            __construct_at_end(__n, __u);
        }
        std::__debug_db_invalidate_all(this);
}
template <class _Tp, class _Allocator>
inline
    typename vector<_Tp, _Allocator>::iterator
    vector<_Tp, _Allocator>::begin() throw()
{
        return iterator(this, this->__begin_);
}
template <class _Tp, class _Allocator>
inline
    typename vector<_Tp, _Allocator>::const_iterator
    vector<_Tp, _Allocator>::begin() const throw()
{
        return const_iterator(this, this->__begin_);
}
template <class _Tp, class _Allocator>
inline
    typename vector<_Tp, _Allocator>::iterator
    vector<_Tp, _Allocator>::end() throw()
{
        return iterator(this, this->__end_);
}
template <class _Tp, class _Allocator>
inline
    typename vector<_Tp, _Allocator>::const_iterator
    vector<_Tp, _Allocator>::end() const throw()
{
        return const_iterator(this, this->__end_);
}
template <class _Tp, class _Allocator>
inline
    typename vector<_Tp, _Allocator>::reference
    vector<_Tp, _Allocator>::operator[](size_type __n) throw()
{
        ((void)0);
        return this->__begin_[__n];
}
template <class _Tp, class _Allocator>
inline
    typename vector<_Tp, _Allocator>::const_reference
    vector<_Tp, _Allocator>::operator[](size_type __n) const throw()
{
        ((void)0);
        return this->__begin_[__n];
}
template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::reference
vector<_Tp, _Allocator>::at(size_type __n)
{
        if (__n >= size())
            this->__throw_out_of_range();
        return this->__begin_[__n];
}
template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::const_reference
vector<_Tp, _Allocator>::at(size_type __n) const
{
        if (__n >= size())
            this->__throw_out_of_range();
        return this->__begin_[__n];
}
template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::reserve(size_type __n)
{
        if (__n > capacity())
        {
            if (__n > max_size())
                this->__throw_length_error();
            allocator_type &__a = this->__alloc();
            __split_buffer<value_type, allocator_type &> __v(__n, size(), __a);
            __swap_out_circular_buffer(__v);
        }
}
template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::shrink_to_fit() throw()
{
        if (capacity() > size())
        {
            try
            {
                allocator_type &__a = this->__alloc();
                __split_buffer<value_type, allocator_type &> __v(size(), size(), __a);
                __swap_out_circular_buffer(__v);
            }
            catch (...)
            {
            }
        }
}
template <class _Tp, class _Allocator>
template <class _Up>
void vector<_Tp, _Allocator>::__push_back_slow_path(_Up &&__x)
{
        allocator_type &__a = this->__alloc();
        __split_buffer<value_type, allocator_type &> __v(__recommend(size() + 1), size(), __a);
        __alloc_traits::construct(__a, std::__to_address(__v.__end_), std::forward<_Up>(__x));
        __v.__end_++;
        __swap_out_circular_buffer(__v);
}
template <class _Tp, class _Allocator>
inline void
vector<_Tp, _Allocator>::push_back(const_reference __x)
{
        if (this->__end_ != this->__end_cap())
        {
            __construct_one_at_end(__x);
        }
        else
            __push_back_slow_path(__x);
}
template <class _Tp, class _Allocator>
inline void
vector<_Tp, _Allocator>::push_back(value_type &&__x)
{
        if (this->__end_ < this->__end_cap())
        {
            __construct_one_at_end(std::move(__x));
        }
        else
            __push_back_slow_path(std::move(__x));
}
template <class _Tp, class _Allocator>
template <class... _Args>
void vector<_Tp, _Allocator>::__emplace_back_slow_path(_Args &&...__args)
{
        allocator_type &__a = this->__alloc();
        __split_buffer<value_type, allocator_type &> __v(__recommend(size() + 1), size(), __a);
        __alloc_traits::construct(__a, std::__to_address(__v.__end_), std::forward<_Args>(__args)...);
        __v.__end_++;
        __swap_out_circular_buffer(__v);
}
template <class _Tp, class _Allocator>
template <class... _Args>
inline void
vector<_Tp, _Allocator>::emplace_back(_Args &&...__args)
{
        if (this->__end_ < this->__end_cap())
        {
            __construct_one_at_end(std::forward<_Args>(__args)...);
        }
        else
            __emplace_back_slow_path(std::forward<_Args>(__args)...);
}
template <class _Tp, class _Allocator>
inline void
vector<_Tp, _Allocator>::pop_back()
{
        ((void)0);
        this->__destruct_at_end(this->__end_ - 1);
}
template <class _Tp, class _Allocator>
inline
    typename vector<_Tp, _Allocator>::iterator
    vector<_Tp, _Allocator>::erase(const_iterator __position)
{
        ((void)0);
        ((void)0);
        difference_type __ps = __position - cbegin();
        pointer __p = this->__begin_ + __ps;
        this->__destruct_at_end(std::move(__p + 1, this->__end_, __p));
        if (!__libcpp_is_constant_evaluated())
            this->__invalidate_iterators_past(__p - 1);
        iterator __r = iterator(this, __p);
        return __r;
}
template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last)
{
        ((void)0);
        ((void)0);
        ((void)0);
        pointer __p = this->__begin_ + (__first - begin());
        if (__first != __last)
        {
            this->__destruct_at_end(std::move(__p + (__last - __first), this->__end_, __p));
            if (!__libcpp_is_constant_evaluated())
                this->__invalidate_iterators_past(__p - 1);
        }
        iterator __r = iterator(this, __p);
        return __r;
}
template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to)
{
        pointer __old_last = this->__end_;
        difference_type __n = __old_last - __to;
        {
            pointer __i = __from_s + __n;
            _ConstructTransaction __tx(*this, __from_e - __i);
            for (pointer __pos = __tx.__pos_; __i < __from_e;
                 ++__i, (void)++__pos, __tx.__pos_ = __pos)
            {
                __alloc_traits::construct(this->__alloc(),
                                          std::__to_address(__pos),
                                          std::move(*__i));
            }
        }
        std::move_backward(__from_s, __from_s + __n, __old_last);
}
template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x)
{
        ((void)0);
        pointer __p = this->__begin_ + (__position - begin());
        if (!__libcpp_is_constant_evaluated() && this->__end_ < this->__end_cap())
        {
            if (__p == this->__end_)
            {
                __construct_one_at_end(__x);
            }
            else
            {
                __move_range(__p, this->__end_, __p + 1);
                const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
                if (__p <= __xr && __xr < this->__end_)
                    ++__xr;
                *__p = *__xr;
            }
        }
        else
        {
            allocator_type &__a = this->__alloc();
            __split_buffer<value_type, allocator_type &> __v(__recommend(size() + 1), __p - this->__begin_, __a);
            __v.push_back(__x);
            __p = __swap_out_circular_buffer(__v, __p);
        }
        return iterator(this, __p);
}
template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, value_type &&__x)
{
        ((void)0);
        pointer __p = this->__begin_ + (__position - begin());
        if (this->__end_ < this->__end_cap())
        {
            if (__p == this->__end_)
            {
                __construct_one_at_end(std::move(__x));
            }
            else
            {
                __move_range(__p, this->__end_, __p + 1);
                *__p = std::move(__x);
            }
        }
        else
        {
            allocator_type &__a = this->__alloc();
            __split_buffer<value_type, allocator_type &> __v(__recommend(size() + 1), __p - this->__begin_, __a);
            __v.push_back(std::move(__x));
            __p = __swap_out_circular_buffer(__v, __p);
        }
        return iterator(this, __p);
}
template <class _Tp, class _Allocator>
template <class... _Args>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::emplace(const_iterator __position, _Args &&...__args)
{
        ((void)0);
        pointer __p = this->__begin_ + (__position - begin());
        if (this->__end_ < this->__end_cap())
        {
            if (__p == this->__end_)
            {
                __construct_one_at_end(std::forward<_Args>(__args)...);
            }
            else
            {
                __temp_value<value_type, _Allocator> __tmp(this->__alloc(), std::forward<_Args>(__args)...);
                __move_range(__p, this->__end_, __p + 1);
                *__p = std::move(__tmp.get());
            }
        }
        else
        {
            allocator_type &__a = this->__alloc();
            __split_buffer<value_type, allocator_type &> __v(__recommend(size() + 1), __p - this->__begin_, __a);
            __v.emplace_back(std::forward<_Args>(__args)...);
            __p = __swap_out_circular_buffer(__v, __p);
        }
        return iterator(this, __p);
}
template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x)
{
        ((void)0);
        pointer __p = this->__begin_ + (__position - begin());
        if (__n > 0)
        {
            if (!__libcpp_is_constant_evaluated() && __n <= static_cast<size_type>(this->__end_cap() - this->__end_))
            {
                size_type __old_n = __n;
                pointer __old_last = this->__end_;
                if (__n > static_cast<size_type>(this->__end_ - __p))
                {
                    size_type __cx = __n - (this->__end_ - __p);
                    __construct_at_end(__cx, __x);
                    __n -= __cx;
                }
                if (__n > 0)
                {
                    __move_range(__p, __old_last, __p + __old_n);
                    const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
                    if (__p <= __xr && __xr < this->__end_)
                        __xr += __old_n;
                    std::fill_n(__p, __n, *__xr);
                }
            }
            else
            {
                allocator_type &__a = this->__alloc();
                __split_buffer<value_type, allocator_type &> __v(__recommend(size() + __n), __p - this->__begin_, __a);
                __v.__construct_at_end(__n, __x);
                __p = __swap_out_circular_buffer(__v, __p);
            }
        }
        return iterator(this, __p);
}
template <class _Tp, class _Allocator>
template <class _InputIterator>
typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value &&
                       is_constructible<
                           _Tp,
                           typename iterator_traits<_InputIterator>::reference>::value,
                   typename vector<_Tp, _Allocator>::iterator>::type
vector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)
{
        ((void)0);
        difference_type __off = __position - begin();
        pointer __p = this->__begin_ + __off;
        allocator_type &__a = this->__alloc();
        pointer __old_last = this->__end_;
        for (; this->__end_ != this->__end_cap() && __first != __last; ++__first)
        {
            __construct_one_at_end(*__first);
        }
        __split_buffer<value_type, allocator_type &> __v(__a);
        if (__first != __last)
        {
            try
            {
                __v.__construct_at_end(__first, __last);
                difference_type __old_size = __old_last - this->__begin_;
                difference_type __old_p = __p - this->__begin_;
                reserve(__recommend(size() + __v.size()));
                __p = this->__begin_ + __old_p;
                __old_last = this->__begin_ + __old_size;
            }
            catch (...)
            {
                erase(iterator(this, __old_last), end());
                throw;
            }
        }
        __p = std::rotate(__p, __old_last, this->__end_);
        insert(iterator(this, __p), std::make_move_iterator(__v.begin()),
               std::make_move_iterator(__v.end()));
        return begin() + __off;
}
template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if<
    __is_cpp17_forward_iterator<_ForwardIterator>::value &&
        is_constructible<
            _Tp,
            typename iterator_traits<_ForwardIterator>::reference>::value,
    typename vector<_Tp, _Allocator>::iterator>::type
vector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)
{
        ((void)0);
        pointer __p = this->__begin_ + (__position - begin());
        difference_type __n = std::distance(__first, __last);
        if (__n > 0)
        {
            if (__n <= this->__end_cap() - this->__end_)
            {
                size_type __old_n = __n;
                pointer __old_last = this->__end_;
                _ForwardIterator __m = __last;
                difference_type __dx = this->__end_ - __p;
                if (__n > __dx)
                {
                    __m = __first;
                    difference_type __diff = this->__end_ - __p;
                    std::advance(__m, __diff);
                    __construct_at_end(__m, __last, __n - __diff);
                    __n = __dx;
                }
                if (__n > 0)
                {
                    __move_range(__p, __old_last, __p + __old_n);
                    std::copy(__first, __m, __p);
                }
            }
            else
            {
                allocator_type &__a = this->__alloc();
                __split_buffer<value_type, allocator_type &> __v(__recommend(size() + __n), __p - this->__begin_, __a);
                __v.__construct_at_end(__first, __last);
                __p = __swap_out_circular_buffer(__v, __p);
            }
        }
        return iterator(this, __p);
}
template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::resize(size_type __sz)
{
        size_type __cs = size();
        if (__cs < __sz)
            this->__append(__sz - __cs);
        else if (__cs > __sz)
            this->__destruct_at_end(this->__begin_ + __sz);
}
template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x)
{
        size_type __cs = size();
        if (__cs < __sz)
            this->__append(__sz - __cs, __x);
        else if (__cs > __sz)
            this->__destruct_at_end(this->__begin_ + __sz);
}
template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::swap(vector &__x)
{
        ((void)0);
        std::swap(this->__begin_, __x.__begin_);
        std::swap(this->__end_, __x.__end_);
        std::swap(this->__end_cap(), __x.__end_cap());
        std::__swap_allocator(this->__alloc(), __x.__alloc(),
                              integral_constant<bool, __alloc_traits::propagate_on_container_swap::value>());
        std::__debug_db_swap(this, std::addressof(__x));
}
template <class _Tp, class _Allocator>
bool vector<_Tp, _Allocator>::__invariants() const
{
        if (this->__begin_ == __nullptr)
        {
            if (this->__end_ != __nullptr || this->__end_cap() != __nullptr)
                return false;
        }
        else
        {
            if (this->__begin_ > this->__end_)
                return false;
            if (this->__begin_ == this->__end_cap())
                return false;
            if (this->__end_ > this->__end_cap())
                return false;
        }
        return true;
}
template <class _Tp, class _Allocator>
inline void
vector<_Tp, _Allocator>::__invalidate_iterators_past(pointer __new_last)
{
        ((void)__new_last);
}
template <class _Allocator>
class vector<bool, _Allocator>;
template <class _Allocator>
struct hash<vector<bool, _Allocator>>;
template <class _Allocator>
struct __has_storage_type<vector<bool, _Allocator>>
{
        static const bool value = true;
};
template <class _Allocator>
class vector<bool, _Allocator>
{
    public:
        typedef vector __self;
        typedef bool value_type;
        typedef _Allocator allocator_type;
        typedef allocator_traits<allocator_type> __alloc_traits;
        typedef typename __alloc_traits::size_type size_type;
        typedef typename __alloc_traits::difference_type difference_type;
        typedef size_type __storage_type;
        typedef __bit_iterator<vector, false> pointer;
        typedef __bit_iterator<vector, true> const_pointer;
        typedef pointer iterator;
        typedef const_pointer const_iterator;
        typedef std::reverse_iterator<iterator> reverse_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    private:
        typedef typename __rebind_alloc_helper<__alloc_traits, __storage_type>::type __storage_allocator;
        typedef allocator_traits<__storage_allocator> __storage_traits;
        typedef typename __storage_traits::pointer __storage_pointer;
        typedef typename __storage_traits::const_pointer __const_storage_pointer;
        __storage_pointer __begin_;
        size_type __size_;
        __compressed_pair<size_type, __storage_allocator> __cap_alloc_;

    public:
        typedef __bit_reference<vector> reference;
        typedef __bit_const_reference<vector> const_reference;

    private:
        size_type &__cap() throw()
        {
            return __cap_alloc_.first();
        }

        const size_type &__cap() const throw()
        {
            return __cap_alloc_.first();
        }

        __storage_allocator &__alloc() throw()
        {
            return __cap_alloc_.second();
        }

        const __storage_allocator &__alloc() const throw()
        {
            return __cap_alloc_.second();
        }
        static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

        static size_type __internal_cap_to_external(size_type __n) throw()
        {
            return __n * __bits_per_word;
        }

        static size_type __external_cap_to_internal(size_type __n) throw()
        {
            return (__n - 1) / __bits_per_word + 1;
        }

    public:
        vector();

        ;
        ~vector();
        explicit vector(size_type __n);
        vector(size_type __n, const value_type &__v);
        vector(size_type __n, const value_type &__v, const allocator_type &__a);
        template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
               typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value>::type * = 0);
        template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last, const allocator_type &__a,
               typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value>::type * = 0);
        template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last,
               typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value>::type * = 0);
        template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type &__a,
               typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value>::type * = 0);
        vector(const vector &__v);
        vector(const vector &__v, const allocator_type &__a);
        vector &operator=(const vector &__v);

        vector(vector &&__v);
        vector(vector &&__v, const __type_identity_t<allocator_type> &__a);

        vector &operator=(vector &&__v);
        template <class _InputIterator>
        typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value,
                           void>::type
        assign(_InputIterator __first, _InputIterator __last);
        template <class _ForwardIterator>
        typename enable_if<
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            void>::type
        assign(_ForwardIterator __first, _ForwardIterator __last);
        void assign(size_type __n, const value_type &__x);

        {
            return allocator_type(this->__alloc());
        }
        size_type max_size() const throw();

        size_type capacity() const throw()
        {
            return __internal_cap_to_external(__cap());
        }

        size_type size() const throw()
        {
            return __size_;
        }

        bool empty() const throw()
        {
            return __size_ == 0;
        }
        void reserve(size_type __n);
        void shrink_to_fit() throw();

        iterator begin() throw()
        {
            return __make_iter(0);
        }

        const_iterator begin() const throw()
        {
            return __make_iter(0);
        }

        iterator end() throw()
        {
            return __make_iter(__size_);
        }

        const_iterator end() const throw()
        {
            return __make_iter(__size_);
        }

        reverse_iterator rbegin() throw()
        {
            return reverse_iterator(end());
        }

        const_reverse_iterator rbegin() const throw()
        {
            return const_reverse_iterator(end());
        }

        reverse_iterator rend() throw()
        {
            return reverse_iterator(begin());
        }

        const_reverse_iterator rend() const throw()
        {
            return const_reverse_iterator(begin());
        }

        const_iterator cbegin() const throw()
        {
            return __make_iter(0);
        }

        const_iterator cend() const throw()
        {
            return __make_iter(__size_);
        }

        const_reverse_iterator crbegin() const throw()
        {
            return rbegin();
        }

        const_reverse_iterator crend() const throw()
        {
            return rend();
        };
};
    }
    reference at(size_type __n);
    const_reference at(size_type __n) const;
    ;
};
}
;
}
;
}
void push_back(const value_type &__x);
{
    --__size_;
}
iterator insert(const_iterator __position, const value_type &__x);
iterator insert(const_iterator __position, size_type __n, const value_type &__x);
template <class _InputIterator>
typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value,
                   iterator>::type
insert(const_iterator __position, _InputIterator __first, _InputIterator __last);
template <class _ForwardIterator>
typename enable_if<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    iterator>::type
insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);
;
iterator erase(const_iterator __first, const_iterator __last);

void clear() throw() { __size_ = 0; }
void swap(vector &);
static void swap(reference __x, reference __y) throw() { std::swap(__x, __y); }
void resize(size_type __sz, value_type __x = false);
void flip() throw();
bool __invariants() const;

private:
void __throw_length_error() const
{
    std::__throw_length_error("vector");
}

void __throw_out_of_range() const
{
    std::__throw_out_of_range("vector");
}
{
    if (__n > max_size())
__throw_length_error();
    auto __allocation = std::__allocate_at_least(__alloc(), __external_cap_to_internal(__n));
    __begin_ = __allocation.ptr;
    __size_ = 0;
    __cap() = __allocation.count;
    if (__libcpp_is_constant_evaluated())
    {
for (size_type __i = 0; __i != __cap(); ++__i)
        std::__construct_at(std::__to_address(__begin_) + __i);
    }
}
void __vdeallocate() throw();

static size_type __align_it(size_type __new_size) throw()
{
    return (__new_size + (__bits_per_word - 1)) & ~((size_type)__bits_per_word - 1);
}
const;
;
template <class _ForwardIterator>
typename enable_if<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    void>::type
__construct_at_end(_ForwardIterator __first, _ForwardIterator __last);
void __append(size_type __n, const_reference __x);

reference __make_ref(size_type __pos) throw()
{
    return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);
}

const_reference __make_ref(size_type __pos) const throw()
{
    return __bit_const_reference<vector>(__begin_ + __pos / __bits_per_word,
                                         __storage_type(1) << __pos % __bits_per_word);
}

iterator __make_iter(size_type __pos) throw()
{
    return iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));
}

const_iterator __make_iter(size_type __pos) const throw()
{
    return const_iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));
}

iterator __const_iterator_cast(const_iterator __p) throw()
{
    return begin() + (__p - cbegin());
}

void __copy_assign_alloc(const vector &__v)
{
    __copy_assign_alloc(__v, integral_constant<bool,
                                               __storage_traits::propagate_on_container_copy_assignment::value>());
}

void __copy_assign_alloc(const vector &__c, true_type)
{
    if (__alloc() != __c.__alloc())
__vdeallocate();
    __alloc() = __c.__alloc();
}

void __copy_assign_alloc(const vector &, false_type)
{
}
void __move_assign(vector &__c, false_type);
void __move_assign(vector &__c, true_type);

void __move_assign_alloc(vector &__c)
{
    __move_assign_alloc(__c, integral_constant<bool,
                                               __storage_traits::propagate_on_container_move_assignment::value>());
}

void __move_assign_alloc(vector &__c, true_type)
{
    __alloc() = std::move(__c.__alloc());
}

void __move_assign_alloc(vector &, false_type) throw()
{
}
size_t __hash_code() const throw();
friend class __bit_reference<vector>;
friend class __bit_const_reference<vector>;
friend class __bit_iterator<vector, false>;
friend class __bit_iterator<vector, true>;
friend struct __bit_array<vector>;
friend struct hash<vector>;
}
;
template <class _Allocator>
void vector<bool, _Allocator>::__vdeallocate() throw()
{
    if (this->__begin_ != __nullptr)
    {
__storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());
std::__debug_db_invalidate_all(this);
this->__begin_ = __nullptr;
this->__size_ = this->__cap() = 0;
    }
}
template <class _Allocator>
typename vector<bool, _Allocator>::size_type
vector<bool, _Allocator>::max_size() const throw()
{
    size_type __amax = __storage_traits::max_size(__alloc());
    size_type __nmax = numeric_limits<size_type>::max() / 2;
    if (__nmax / __bits_per_word <= __amax)
return __nmax;
    return __internal_cap_to_external(__amax);
}
template <class _Allocator>
inline
    typename vector<bool, _Allocator>::size_type
    vector<bool, _Allocator>::__recommend(size_type __new_size) const
{
    const size_type __ms = max_size();
    if (__new_size > __ms)
this->__throw_length_error();
    const size_type __cap = capacity();
    if (__cap >= __ms / 2)
return __ms;
    return std::max(2 * __cap, __align_it(__new_size));
}
template <class _Allocator>
inline void
vector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x)
{
    size_type __old_size = this->__size_;
    this->__size_ += __n;
    if (__old_size == 0 || ((__old_size - 1) / __bits_per_word) != ((this->__size_ - 1) / __bits_per_word))
    {
if (this->__size_ <= __bits_per_word)
        this->__begin_[0] = __storage_type(0);
else
        this->__begin_[(this->__size_ - 1) / __bits_per_word] = __storage_type(0);
    }
    std::fill_n(__make_iter(__old_size), __n, __x);
}
template <class _Allocator>
template <class _ForwardIterator>
typename enable_if<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    void>::type
vector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __old_size = this->__size_;
    this->__size_ += std::distance(__first, __last);
    if (__old_size == 0 || ((__old_size - 1) / __bits_per_word) != ((this->__size_ - 1) / __bits_per_word))
    {
if (this->__size_ <= __bits_per_word)
        this->__begin_[0] = __storage_type(0);
else
        this->__begin_[(this->__size_ - 1) / __bits_per_word] = __storage_type(0);
    }
    std::copy(__first, __last, __make_iter(__old_size));
}
template <class _Allocator>
inline vector<bool, _Allocator>::vector()
    : __begin_(__nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
}
template <class _Allocator>
inline vector<bool, _Allocator>::vector(const allocator_type &__a)
    : __begin_(__nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
}
template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n)
    : __begin_(__nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
    if (__n > 0)
    {
__vallocate(__n);
__construct_at_end(__n, false);
    }
}
template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n, const value_type &__x)
    : __begin_(__nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
    if (__n > 0)
    {
__vallocate(__n);
__construct_at_end(__n, __x);
    }
}
template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n, const value_type &__x, const allocator_type &__a)
    : __begin_(__nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    if (__n > 0)
    {
__vallocate(__n);
__construct_at_end(__n, __x);
    }
}
template <class _Allocator>
template <class _InputIterator>
vector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last,
                                 typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value>::type *)
    : __begin_(__nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
    try
    {
for (; __first != __last; ++__first)
        push_back(*__first);
    }
    catch (...)
    {
if (__begin_ != __nullptr)
        __storage_traits::deallocate(__alloc(), __begin_, __cap());
std::__debug_db_invalidate_all(this);
throw;
    }
}
template <class _Allocator>
template <class _InputIterator>
vector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type &__a,
                                 typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value>::type *)
    : __begin_(__nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    try
    {
for (; __first != __last; ++__first)
        push_back(*__first);
    }
    catch (...)
    {
if (__begin_ != __nullptr)
        __storage_traits::deallocate(__alloc(), __begin_, __cap());
std::__debug_db_invalidate_all(this);
throw;
    }
}
template <class _Allocator>
template <class _ForwardIterator>
vector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last,
                                 typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value>::type *)
    : __begin_(__nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
    size_type __n = static_cast<size_type>(std::distance(__first, __last));
    if (__n > 0)
    {
__vallocate(__n);
__construct_at_end(__first, __last);
    }
}
template <class _Allocator>
template <class _ForwardIterator>
vector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type &__a,
                                 typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value>::type *)
    : __begin_(__nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    size_type __n = static_cast<size_type>(std::distance(__first, __last));
    if (__n > 0)
    {
__vallocate(__n);
__construct_at_end(__first, __last);
    }
}
template <class _Allocator>
vector<bool, _Allocator>::~vector()
{
    if (__begin_ != __nullptr)
__storage_traits::deallocate(__alloc(), __begin_, __cap());
    std::__debug_db_invalidate_all(this);
}
template <class _Allocator>
vector<bool, _Allocator>::vector(const vector &__v)
    : __begin_(__nullptr),
      __size_(0),
      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc()))
{
    if (__v.size() > 0)
    {
__vallocate(__v.size());
__construct_at_end(__v.begin(), __v.end());
    }
}
template <class _Allocator>
vector<bool, _Allocator>::vector(const vector &__v, const allocator_type &__a)
    : __begin_(__nullptr),
      __size_(0),
      __cap_alloc_(0, __a)
{
    if (__v.size() > 0)
    {
__vallocate(__v.size());
__construct_at_end(__v.begin(), __v.end());
    }
}
template <class _Allocator>
vector<bool, _Allocator> &
vector<bool, _Allocator>::operator=(const vector &__v)
{
    if (this != std::addressof(__v))
    {
__copy_assign_alloc(__v);
if (__v.__size_)
{
        if (__v.__size_ > capacity())
        {
            __vdeallocate();
            __vallocate(__v.__size_);
        }
        std::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), __begin_);
}
__size_ = __v.__size_;
    }
    return *this;
}
template <class _Allocator>
inline
    : __begin_(__v.__begin_),
      __size_(__v.__size_),
      __cap_alloc_(std::move(__v.__cap_alloc_))
{
    __v.__begin_ = __nullptr;
    __v.__size_ = 0;
    __v.__cap() = 0;
}
template <class _Allocator>
vector<bool, _Allocator>::vector(vector &&__v, const __type_identity_t<allocator_type> &__a)
    : __begin_(__nullptr),
      __size_(0),
      __cap_alloc_(0, __a)
{
    if (__a == allocator_type(__v.__alloc()))
    {
this->__begin_ = __v.__begin_;
this->__size_ = __v.__size_;
this->__cap() = __v.__cap();
__v.__begin_ = __nullptr;
__v.__cap() = __v.__size_ = 0;
    }
    else if (__v.size() > 0)
    {
__vallocate(__v.size());
__construct_at_end(__v.begin(), __v.end());
    }
}
template <class _Allocator>
inline vector<bool, _Allocator> &
vector<bool, _Allocator>::operator=(vector &&__v)
{
    __move_assign(__v, integral_constant<bool,
                                         __storage_traits::propagate_on_container_move_assignment::value>());
    return *this;
}
template <class _Allocator>
void vector<bool, _Allocator>::__move_assign(vector &__c, false_type)
{
    if (__alloc() != __c.__alloc())
assign(__c.begin(), __c.end());
    else
__move_assign(__c, true_type());
}
template <class _Allocator>
void vector<bool, _Allocator>::__move_assign(vector &__c, true_type)
{
    __vdeallocate();
    __move_assign_alloc(__c);
    this->__begin_ = __c.__begin_;
    this->__size_ = __c.__size_;
    this->__cap() = __c.__cap();
    __c.__begin_ = __nullptr;
    __c.__cap() = __c.__size_ = 0;
}
template <class _Allocator>
void vector<bool, _Allocator>::assign(size_type __n, const value_type &__x)
{
    __size_ = 0;
    if (__n > 0)
    {
size_type __c = capacity();
if (__n <= __c)
        __size_ = __n;
else
{
        vector __v(get_allocator());
        __v.reserve(__recommend(__n));
        __v.__size_ = __n;
        swap(__v);
}
std::fill_n(begin(), __n, __x);
    }
    std::__debug_db_invalidate_all(this);
}
template <class _Allocator>
template <class _InputIterator>
typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value,
                   void>::type
vector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
    clear();
    for (; __first != __last; ++__first)
push_back(*__first);
}
template <class _Allocator>
template <class _ForwardIterator>
typename enable_if<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    void>::type
vector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
    clear();
    difference_type __ns = std::distance(__first, __last);
    ((void)0);
    const size_t __n = static_cast<size_type>(__ns);
    if (__n)
    {
if (__n > capacity())
{
        __vdeallocate();
        __vallocate(__n);
}
__construct_at_end(__first, __last);
    }
}
template <class _Allocator>
void vector<bool, _Allocator>::reserve(size_type __n)
{
    if (__n > capacity())
    {
if (__n > max_size())
        this->__throw_length_error();
vector __v(this->get_allocator());
__v.__vallocate(__n);
__v.__construct_at_end(this->begin(), this->end());
swap(__v);
std::__debug_db_invalidate_all(this);
    }
}
template <class _Allocator>
void vector<bool, _Allocator>::shrink_to_fit() throw()
{
    if (__external_cap_to_internal(size()) > __cap())
    {
try
{
        vector(*this, allocator_type(__alloc())).swap(*this);
}
catch (...)
{
}
    }
}
template <class _Allocator>
typename vector<bool, _Allocator>::reference
vector<bool, _Allocator>::at(size_type __n)
{
    if (__n >= size())
this->__throw_out_of_range();
    return (*this)[__n];
}
template <class _Allocator>
typename vector<bool, _Allocator>::const_reference
vector<bool, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
this->__throw_out_of_range();
    return (*this)[__n];
}
template <class _Allocator>
void vector<bool, _Allocator>::push_back(const value_type &__x)
{
    if (this->__size_ == this->capacity())
reserve(__recommend(this->__size_ + 1));
    ++this->__size_;
    back() = __x;
}
template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, const value_type &__x)
{
    iterator __r;
    if (size() < capacity())
    {
const_iterator __old_end = end();
++__size_;
std::copy_backward(__position, __old_end, end());
__r = __const_iterator_cast(__position);
    }
    else
    {
vector __v(get_allocator());
__v.reserve(__recommend(__size_ + 1));
__v.__size_ = __size_ + 1;
__r = std::copy(cbegin(), __position, __v.begin());
std::copy_backward(__position, cend(), __v.end());
swap(__v);
    }
    *__r = __x;
    return __r;
}
template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, size_type __n, const value_type &__x)
{
    iterator __r;
    size_type __c = capacity();
    if (__n <= __c && size() <= __c - __n)
    {
const_iterator __old_end = end();
__size_ += __n;
std::copy_backward(__position, __old_end, end());
__r = __const_iterator_cast(__position);
    }
    else
    {
vector __v(get_allocator());
__v.reserve(__recommend(__size_ + __n));
__v.__size_ = __size_ + __n;
__r = std::copy(cbegin(), __position, __v.begin());
std::copy_backward(__position, cend(), __v.end());
swap(__v);
    }
    std::fill_n(__r, __n, __x);
    return __r;
}
template <class _Allocator>
template <class _InputIterator>
typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value,
                   typename vector<bool, _Allocator>::iterator>::type
vector<bool, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)
{
    difference_type __off = __position - begin();
    iterator __p = __const_iterator_cast(__position);
    iterator __old_end = end();
    for (; size() != capacity() && __first != __last; ++__first)
    {
++this->__size_;
back() = *__first;
    }
    vector __v(get_allocator());
    if (__first != __last)
    {
try
{
        __v.assign(__first, __last);
        difference_type __old_size = static_cast<difference_type>(__old_end - begin());
        difference_type __old_p = __p - begin();
        reserve(__recommend(size() + __v.size()));
        __p = begin() + __old_p;
        __old_end = begin() + __old_size;
}
catch (...)
{
        erase(__old_end, end());
        throw;
}
    }
    __p = std::rotate(__p, __old_end, end());
    insert(__p, __v.begin(), __v.end());
    return begin() + __off;
}
template <class _Allocator>
template <class _ForwardIterator>
typename enable_if<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    typename vector<bool, _Allocator>::iterator>::type
vector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)
{
    const difference_type __n_signed = std::distance(__first, __last);
    ((void)0);
    const size_type __n = static_cast<size_type>(__n_signed);
    iterator __r;
    size_type __c = capacity();
    if (__n <= __c && size() <= __c - __n)
    {
const_iterator __old_end = end();
__size_ += __n;
std::copy_backward(__position, __old_end, end());
__r = __const_iterator_cast(__position);
    }
    else
    {
vector __v(get_allocator());
__v.reserve(__recommend(__size_ + __n));
__v.__size_ = __size_ + __n;
__r = std::copy(cbegin(), __position, __v.begin());
std::copy_backward(__position, cend(), __v.end());
swap(__v);
    }
    std::copy(__first, __last, __r);
    return __r;
}
template <class _Allocator>
inline
    typename vector<bool, _Allocator>::iterator
    vector<bool, _Allocator>::erase(const_iterator __position)
{
    iterator __r = __const_iterator_cast(__position);
    std::copy(__position + 1, this->cend(), __r);
    --__size_;
    return __r;
}
template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last)
{
    iterator __r = __const_iterator_cast(__first);
    difference_type __d = __last - __first;
    std::copy(__last, this->cend(), __r);
    __size_ -= __d;
    return __r;
}
template <class _Allocator>
void vector<bool, _Allocator>::swap(vector &__x)
{
    std::swap(this->__begin_, __x.__begin_);
    std::swap(this->__size_, __x.__size_);
    std::swap(this->__cap(), __x.__cap());
    std::__swap_allocator(this->__alloc(), __x.__alloc(),
                          integral_constant<bool, __alloc_traits::propagate_on_container_swap::value>());
}
template <class _Allocator>
void vector<bool, _Allocator>::resize(size_type __sz, value_type __x)
{
    size_type __cs = size();
    if (__cs < __sz)
    {
iterator __r;
size_type __c = capacity();
size_type __n = __sz - __cs;
if (__n <= __c && __cs <= __c - __n)
{
        __r = end();
        __size_ += __n;
}
else
{
        vector __v(get_allocator());
        __v.reserve(__recommend(__size_ + __n));
        __v.__size_ = __size_ + __n;
        __r = std::copy(cbegin(), cend(), __v.begin());
        swap(__v);
}
std::fill_n(__r, __n, __x);
    }
    else
__size_ = __sz;
}
template <class _Allocator>
void vector<bool, _Allocator>::flip() throw()
{
    size_type __n = __size_;
    __storage_pointer __p = __begin_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
*__p = ~*__p;
    if (__n > 0)
    {
__storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
__storage_type __b = *__p & __m;
*__p &= ~__m;
*__p |= ~__b & __m;
    }
}
template <class _Allocator>
bool vector<bool, _Allocator>::__invariants() const
{
    if (this->__begin_ == __nullptr)
    {
if (this->__size_ != 0 || this->__cap() != 0)
        return false;
    }
    else
    {
if (this->__cap() == 0)
        return false;
if (this->__size_ > this->capacity())
        return false;
    }
    return true;
}
template <class _Allocator>
size_t
vector<bool, _Allocator>::__hash_code() const throw()
{
    size_t __h = 0;
    size_type __n = __size_;
    __storage_pointer __p = __begin_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
__h ^= *__p;
    if (__n > 0)
    {
const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
__h ^= *__p & __m;
    }
    return __h;
}
template <class _Allocator>
struct hash<vector<bool, _Allocator>>
    : public __unary_function<vector<bool, _Allocator>, size_t>
{

    size_t operator()(const vector<bool, _Allocator> &__vec) const throw()
    {
return __vec.__hash_code();
    }
};
template <class _Tp, class _Allocator>
inline bool
operator==(const vector<_Tp, _Allocator> &__x, const vector<_Tp, _Allocator> &__y)
{
    const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();
    return __sz == __y.size() && std::equal(__x.begin(), __x.end(), __y.begin());
}
template <class _Tp, class _Allocator>
inline bool
operator!=(const vector<_Tp, _Allocator> &__x, const vector<_Tp, _Allocator> &__y)
{
    return !(__x == __y);
}
template <class _Tp, class _Allocator>
inline bool
operator<(const vector<_Tp, _Allocator> &__x, const vector<_Tp, _Allocator> &__y)
{
    return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}
template <class _Tp, class _Allocator>
inline bool
operator>(const vector<_Tp, _Allocator> &__x, const vector<_Tp, _Allocator> &__y)
{
    return __y < __x;
}
template <class _Tp, class _Allocator>
inline bool
operator>=(const vector<_Tp, _Allocator> &__x, const vector<_Tp, _Allocator> &__y)
{
    return !(__x < __y);
}
template <class _Tp, class _Allocator>
inline bool
operator<=(const vector<_Tp, _Allocator> &__x, const vector<_Tp, _Allocator> &__y)
{
    return !(__y < __x);
}
template <class _Tp, class _Allocator>
inline void
swap(vector<_Tp, _Allocator> &__x, vector<_Tp, _Allocator> &__y)
{
    __x.swap(__y);
}
}
}
namespace std
{
    inline namespace __1
    {
    }
}
namespace std
{
    inline namespace __1
    {
    }
}
extern "C"
{
    void __assert_rtn(const char *, const char *, int, const char *);
}
namespace std
{
    inline namespace __1
    {
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wweak-vtables"
class bad_function_call
    : public exception
{
    public:
        virtual ~bad_function_call() throw() {}
};
#pragma clang diagnostic pop

void __throw_bad_function_call()
{
        throw bad_function_call();
}
template <class _Fp>
class function;
namespace __function
{
        template <class _Rp>
        struct __maybe_derive_from_unary_function
        {
        };
        template <class _Rp, class _A1>
        struct __maybe_derive_from_unary_function<_Rp(_A1)>
            : public __unary_function<_A1, _Rp>
        {
        };
        template <class _Rp>
        struct __maybe_derive_from_binary_function
        {
        };
        template <class _Rp, class _A1, class _A2>
        struct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>
            : public __binary_function<_A1, _A2, _Rp>
        {
        };
        template <class _Fp>

        bool __not_null(_Fp const &)
        {
            return true;
        }
        template <class _Fp>

        bool __not_null(_Fp *__ptr)
        {
            return __ptr;
        }
        template <class _Ret, class _Class>

        bool __not_null(_Ret _Class::*__ptr)
        {
            return __ptr;
        }
        template <class _Fp>

        bool __not_null(function<_Fp> const &__f)
        {
            return !!__f;
        }
        template <class _Rp, class... _Args>

        bool __not_null(_Rp (^__p)(_Args...))
        {
            return __p;
        }
}
    }
}
namespace std
{
    inline namespace __1
    {
template <class _Tp>
class __mem_fn : public __weak_result_type<_Tp>
{
    public:
        typedef _Tp type;

    private:
        type __f_;

    public:
        __mem_fn(type __f) throw() : __f_(__f) {}
        template <class... _ArgTypes>

        typename __invoke_return<type, _ArgTypes...>::type
        operator()(_ArgTypes &&...__args) const
        {
            return std::__invoke(__f_, std::forward<_ArgTypes>(__args)...);
        }
};
template <class _Rp, class _Tp>
inline __mem_fn<_Rp _Tp::*>
mem_fn(_Rp _Tp::*__pm) throw()
{
        return __mem_fn<_Rp _Tp::*>(__pm);
}
    }
}
namespace std
{
    inline namespace __1
    {
template <class _Sp, class _Tp>
class mem_fun_t
    : public __unary_function<_Tp *, _Sp>
{
        _Sp (_Tp::*__p_)();

    public:
        : __p_(__p) {}
        const
        {
            return (__p->*__p_)();
        }
};
template <class _Sp, class _Tp, class _Ap>
class mem_fun1_t
    : public __binary_function<_Tp *, _Ap, _Sp>
{
        _Sp (_Tp::*__p_)(_Ap);

    public:
        : __p_(__p) {}
        const
        {
            return (__p->*__p_)(__x);
        }
};
template <class _Sp, class _Tp>
inline mem_fun_t<_Sp, _Tp>
mem_fun(_Sp (_Tp::*__f)())
{
        return mem_fun_t<_Sp, _Tp>(__f);
}
template <class _Sp, class _Tp, class _Ap>
inline mem_fun1_t<_Sp, _Tp, _Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap))
{
        return mem_fun1_t<_Sp, _Tp, _Ap>(__f);
}
template <class _Sp, class _Tp>
class mem_fun_ref_t
    : public __unary_function<_Tp, _Sp>
{
        _Sp (_Tp::*__p_)();

    public:
        : __p_(__p) {}
        const
        {
            return (__p.*__p_)();
        }
};
template <class _Sp, class _Tp, class _Ap>
class mem_fun1_ref_t
    : public __binary_function<_Tp, _Ap, _Sp>
{
        _Sp (_Tp::*__p_)(_Ap);

    public:
        : __p_(__p) {}
        const
        {
            return (__p.*__p_)(__x);
        }
};
template <class _Sp, class _Tp>
inline mem_fun_ref_t<_Sp, _Tp>
mem_fun_ref(_Sp (_Tp::*__f)())
{
        return mem_fun_ref_t<_Sp, _Tp>(__f);
}
template <class _Sp, class _Tp, class _Ap>
inline mem_fun1_ref_t<_Sp, _Tp, _Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap))
{
        return mem_fun1_ref_t<_Sp, _Tp, _Ap>(__f);
}
template <class _Sp, class _Tp>
class const_mem_fun_t
    : public __unary_function<const _Tp *, _Sp>
{
        _Sp (_Tp::*__p_)() const;

    public:
        : __p_(__p) {}
        const
        {
            return (__p->*__p_)();
        }
};
template <class _Sp, class _Tp, class _Ap>
class const_mem_fun1_t
    : public __binary_function<const _Tp *, _Ap, _Sp>
{
        _Sp (_Tp::*__p_)(_Ap) const;

    public:
        : __p_(__p) {}
        const
        {
            return (__p->*__p_)(__x);
        }
};
template <class _Sp, class _Tp>
inline const_mem_fun_t<_Sp, _Tp>
mem_fun(_Sp (_Tp::*__f)() const)
{
        return const_mem_fun_t<_Sp, _Tp>(__f);
}
template <class _Sp, class _Tp, class _Ap>
inline const_mem_fun1_t<_Sp, _Tp, _Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap) const)
{
        return const_mem_fun1_t<_Sp, _Tp, _Ap>(__f);
}
template <class _Sp, class _Tp>
class const_mem_fun_ref_t
    : public __unary_function<_Tp, _Sp>
{
        _Sp (_Tp::*__p_)() const;

    public:
        : __p_(__p) {}
        const
        {
            return (__p.*__p_)();
        }
};
template <class _Sp, class _Tp, class _Ap>
class const_mem_fun1_ref_t
    : public __binary_function<_Tp, _Ap, _Sp>
{
        _Sp (_Tp::*__p_)(_Ap) const;

    public:
        : __p_(__p) {}
        const
        {
            return (__p.*__p_)(__x);
        }
};
template <class _Sp, class _Tp>
inline const_mem_fun_ref_t<_Sp, _Tp>
mem_fun_ref(_Sp (_Tp::*__f)() const)
{
        return const_mem_fun_ref_t<_Sp, _Tp>(__f);
}
template <class _Sp, class _Tp, class _Ap>
inline const_mem_fun1_ref_t<_Sp, _Tp, _Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap) const)
{
        return const_mem_fun1_ref_t<_Sp, _Tp, _Ap>(__f);
}
    }
}
namespace std
{
    inline namespace __1
    {
    }
}

namespace std
{
    inline namespace __1
    {
template <class _Arg1, class _Arg2, class _Result>
class pointer_to_binary_function
    : public __binary_function<_Arg1, _Arg2, _Result>
{
        _Result (*__f_)(_Arg1, _Arg2);

    public:
        : __f_(__f) {}
        const
        {
            return __f_(__x, __y);
        }
};
template <class _Arg1, class _Arg2, class _Result>
inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
ptr_fun(_Result (*__f)(_Arg1, _Arg2))
{
        return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__f);
}
    }
}
namespace std
{
    inline namespace __1
    {
template <class _Arg, class _Result>
class pointer_to_unary_function
    : public __unary_function<_Arg, _Result>
{
        _Result (*__f_)(_Arg);

    public:
        : __f_(__f) {}
        const
        {
            return __f_(__x);
        }
};
template <class _Arg, class _Result>
inline pointer_to_unary_function<_Arg, _Result>
ptr_fun(_Result (*__f)(_Arg))
{
        return pointer_to_unary_function<_Arg, _Result>(__f);
}
    }
}
namespace std
{
    inline namespace __1
    {
template <class _Predicate>
class unary_negate
    : public __unary_function<typename _Predicate::argument_type, bool>
{
        _Predicate __pred_;

    public:
        explicit unary_negate(const _Predicate &__pred)
            : __pred_(__pred) {}

        bool operator()(const typename _Predicate::argument_type &__x) const
        {
            return !__pred_(__x);
        }
};
template <class _Predicate>
inline unary_negate<_Predicate>
not1(const _Predicate &__pred) { return unary_negate<_Predicate>(__pred); }
    }
}
extern "C"
{
    void __assert_rtn(const char *, const char *, int, const char *);
}
namespace std
{
    inline namespace __1
    {
template <class _Traits>

inline size_t __char_traits_length_checked(const typename _Traits::char_type *__s) throw()
{
        return ((void)0), _Traits::length(__s);
}
template <class _CharT, class _Traits>
class

    basic_string_view
{
    public:
        typedef _Traits traits_type;
        typedef _CharT value_type;
        typedef _CharT *pointer;
        typedef const _CharT *const_pointer;
        typedef _CharT &reference;
        typedef const _CharT &const_reference;
        typedef const_pointer const_iterator;
        typedef const_iterator iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
        typedef const_reverse_iterator reverse_iterator;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        static const size_type npos = -1;
        _Static_assert((!is_array<value_type>::value), "Character type of basic_string_view must not be an array");
        _Static_assert((is_standard_layout<value_type>::value), "Character type of basic_string_view must be standard-layout");
        _Static_assert((is_trivial<value_type>::value), "Character type of basic_string_view must be trivial");
        _Static_assert((is_same<_CharT, typename traits_type::char_type>::value), "traits_type::char_type must be the same type as CharT");

        basic_string_view() throw() : __data(__nullptr), __size(0) {}

        basic_string_view(const basic_string_view &) throw() = default;

        basic_string_view &operator=(const basic_string_view &) throw() = default;

        basic_string_view(const _CharT *__s, size_type __len) throw()
            : __data(__s), __size(__len)
        {
        }

        basic_string_view(const _CharT *__s)
            : __data(__s), __size(std::__char_traits_length_checked<_Traits>(__s)) {}

        const_iterator begin() const throw() { return cbegin(); }

        const_iterator end() const throw() { return cend(); }

        const_iterator cbegin() const throw() { return __data; }

        const_iterator cend() const throw() { return __data + __size; }

        const_reverse_iterator rbegin() const throw() { return const_reverse_iterator(cend()); }

        const_reverse_iterator rend() const throw() { return const_reverse_iterator(cbegin()); }

        const_reverse_iterator crbegin() const throw() { return const_reverse_iterator(cend()); }

        const_reverse_iterator crend() const throw() { return const_reverse_iterator(cbegin()); }

        size_type size() const throw() { return __size; }

        size_type length() const throw() { return __size; }

        size_type max_size() const throw() { return numeric_limits<size_type>::max() / sizeof(value_type); }

        bool empty() const throw() { return __size == 0; }

        const_reference operator[](size_type __pos) const throw()
        {
            return ((void)0), __data[__pos];
        }

        const_reference at(size_type __pos) const
        {
            return __pos >= size()
                       ? (__throw_out_of_range("string_view::at"), __data[0])
                       : __data[__pos];
        }

        const_reference front() const throw()
        {
            return ((void)0), __data[0];
        }

        const_reference back() const throw()
        {
            return ((void)0), __data[__size - 1];
        }

        const_pointer data() const throw() { return __data; }

        void remove_prefix(size_type __n) throw()
        {
            ((void)0);
            __data += __n;
            __size -= __n;
        }

        void remove_suffix(size_type __n) throw()
        {
            ((void)0);
            __size -= __n;
        }

        void swap(basic_string_view &__other) throw()
        {
            const value_type *__p = __data;
            __data = __other.__data;
            __other.__data = __p;
            size_type __sz = __size;
            __size = __other.__size;
            __other.__size = __sz;
        }

        size_type copy(_CharT *__s, size_type __n, size_type __pos = 0) const
        {
            if (__pos > size())
                __throw_out_of_range("string_view::copy");
            size_type __rlen = std::min(__n, size() - __pos);
            _Traits::copy(__s, data() + __pos, __rlen);
            return __rlen;
        }

        basic_string_view substr(size_type __pos = 0, size_type __n = npos) const
        {
            return __pos > size()
                       ? (__throw_out_of_range("string_view::substr"), basic_string_view())
                       : basic_string_view(data() + __pos, std::min(__n, size() - __pos));
        }
        int compare(basic_string_view __sv) const throw()
        {
            size_type __rlen = std::min(size(), __sv.size());
            int __retval = _Traits::compare(data(), __sv.data(), __rlen);
            if (__retval == 0)
                __retval = size() == __sv.size() ? 0 : (size() < __sv.size() ? -1 : 1);
            return __retval;
        }

        int compare(size_type __pos1, size_type __n1, basic_string_view __sv) const
        {
            return substr(__pos1, __n1).compare(__sv);
        }

        int compare(size_type __pos1, size_type __n1,
                    basic_string_view __sv, size_type __pos2, size_type __n2) const
        {
            return substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
        }

        int compare(const _CharT *__s) const throw()
        {
            return compare(basic_string_view(__s));
        }

        int compare(size_type __pos1, size_type __n1, const _CharT *__s) const
        {
            return substr(__pos1, __n1).compare(basic_string_view(__s));
        }

        int compare(size_type __pos1, size_type __n1, const _CharT *__s, size_type __n2) const
        {
            return substr(__pos1, __n1).compare(basic_string_view(__s, __n2));
        }

        size_type find(basic_string_view __s, size_type __pos = 0) const throw()
        {
            ((void)0);
            return __str_find<value_type, size_type, traits_type, npos>(data(), size(), __s.data(), __pos, __s.size());
        }

        size_type find(_CharT __c, size_type __pos = 0) const throw()
        {
            return __str_find<value_type, size_type, traits_type, npos>(data(), size(), __c, __pos);
        }

        size_type find(const _CharT *__s, size_type __pos, size_type __n) const throw()
        {
            ((void)0);
            return __str_find<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
        }

        size_type find(const _CharT *__s, size_type __pos = 0) const throw()
        {
            ((void)0);
            return __str_find<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, traits_type::length(__s));
        }

        size_type rfind(basic_string_view __s, size_type __pos = npos) const throw()
        {
            ((void)0);
            return __str_rfind<value_type, size_type, traits_type, npos>(data(), size(), __s.data(), __pos, __s.size());
        }

        size_type rfind(_CharT __c, size_type __pos = npos) const throw()
        {
            return __str_rfind<value_type, size_type, traits_type, npos>(data(), size(), __c, __pos);
        }

        size_type rfind(const _CharT *__s, size_type __pos, size_type __n) const throw()
        {
            ((void)0);
            return __str_rfind<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
        }

        size_type rfind(const _CharT *__s, size_type __pos = npos) const throw()
        {
            ((void)0);
            return __str_rfind<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, traits_type::length(__s));
        }

        size_type find_first_of(basic_string_view __s, size_type __pos = 0) const throw()
        {
            ((void)0);
            return __str_find_first_of<value_type, size_type, traits_type, npos>(data(), size(), __s.data(), __pos, __s.size());
        }

        size_type find_first_of(_CharT __c, size_type __pos = 0) const throw()
        {
            return find(__c, __pos);
        }

        size_type find_first_of(const _CharT *__s, size_type __pos, size_type __n) const throw()
        {
            ((void)0);
            return __str_find_first_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
        }

        size_type find_first_of(const _CharT *__s, size_type __pos = 0) const throw()
        {
            ((void)0);
            return __str_find_first_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, traits_type::length(__s));
        }

        size_type find_last_of(basic_string_view __s, size_type __pos = npos) const throw()
        {
            ((void)0);
            return __str_find_last_of<value_type, size_type, traits_type, npos>(data(), size(), __s.data(), __pos, __s.size());
        }

        size_type find_last_of(_CharT __c, size_type __pos = npos) const throw()
        {
            return rfind(__c, __pos);
        }

        size_type find_last_of(const _CharT *__s, size_type __pos, size_type __n) const throw()
        {
            ((void)0);
            return __str_find_last_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
        }

        size_type find_last_of(const _CharT *__s, size_type __pos = npos) const throw()
        {
            ((void)0);
            return __str_find_last_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, traits_type::length(__s));
        }

        size_type find_first_not_of(basic_string_view __s, size_type __pos = 0) const throw()
        {
            ((void)0);
            return __str_find_first_not_of<value_type, size_type, traits_type, npos>(data(), size(), __s.data(), __pos, __s.size());
        }

        size_type find_first_not_of(_CharT __c, size_type __pos = 0) const throw()
        {
            return __str_find_first_not_of<value_type, size_type, traits_type, npos>(data(), size(), __c, __pos);
        }

        size_type find_first_not_of(const _CharT *__s, size_type __pos, size_type __n) const throw()
        {
            ((void)0);
            return __str_find_first_not_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
        }

        size_type find_first_not_of(const _CharT *__s, size_type __pos = 0) const throw()
        {
            ((void)0);
            return __str_find_first_not_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, traits_type::length(__s));
        }

        size_type find_last_not_of(basic_string_view __s, size_type __pos = npos) const throw()
        {
            ((void)0);
            return __str_find_last_not_of<value_type, size_type, traits_type, npos>(data(), size(), __s.data(), __pos, __s.size());
        }

        size_type find_last_not_of(_CharT __c, size_type __pos = npos) const throw()
        {
            return __str_find_last_not_of<value_type, size_type, traits_type, npos>(data(), size(), __c, __pos);
        }

        size_type find_last_not_of(const _CharT *__s, size_type __pos, size_type __n) const throw()
        {
            ((void)0);
            return __str_find_last_not_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
        }

        size_type find_last_not_of(const _CharT *__s, size_type __pos = npos) const throw()
        {
            ((void)0);
            return __str_find_last_not_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, traits_type::length(__s));
        }

    private:
        const value_type *__data;
        size_type __size;
};
template <class _CharT, class _Traits>

bool operator==(basic_string_view<_CharT, _Traits> __lhs,
                basic_string_view<_CharT, _Traits> __rhs) throw()
{
        if (__lhs.size() != __rhs.size())
            return false;
        return __lhs.compare(__rhs) == 0;
}
template <class _CharT, class _Traits, int = 1>

bool operator==(basic_string_view<_CharT, _Traits> __lhs,
                typename common_type<basic_string_view<_CharT, _Traits>>::type __rhs) throw()
{
        if (__lhs.size() != __rhs.size())
            return false;
        return __lhs.compare(__rhs) == 0;
}
template <class _CharT, class _Traits, int = 2>

bool operator==(typename common_type<basic_string_view<_CharT, _Traits>>::type __lhs,
                basic_string_view<_CharT, _Traits> __rhs) throw()
{
        if (__lhs.size() != __rhs.size())
            return false;
        return __lhs.compare(__rhs) == 0;
}
template <class _CharT, class _Traits>

bool operator!=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) throw()
{
        if (__lhs.size() != __rhs.size())
            return true;
        return __lhs.compare(__rhs) != 0;
}
template <class _CharT, class _Traits, int = 1>

bool operator!=(basic_string_view<_CharT, _Traits> __lhs,
                typename common_type<basic_string_view<_CharT, _Traits>>::type __rhs) throw()
{
        if (__lhs.size() != __rhs.size())
            return true;
        return __lhs.compare(__rhs) != 0;
}
template <class _CharT, class _Traits, int = 2>

bool operator!=(typename common_type<basic_string_view<_CharT, _Traits>>::type __lhs,
                basic_string_view<_CharT, _Traits> __rhs) throw()
{
        if (__lhs.size() != __rhs.size())
            return true;
        return __lhs.compare(__rhs) != 0;
}
template <class _CharT, class _Traits>

bool operator<(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) throw()
{
        return __lhs.compare(__rhs) < 0;
}
template <class _CharT, class _Traits, int = 1>

bool operator<(basic_string_view<_CharT, _Traits> __lhs,
               typename common_type<basic_string_view<_CharT, _Traits>>::type __rhs) throw()
{
        return __lhs.compare(__rhs) < 0;
}
template <class _CharT, class _Traits, int = 2>

bool operator<(typename common_type<basic_string_view<_CharT, _Traits>>::type __lhs,
               basic_string_view<_CharT, _Traits> __rhs) throw()
{
        return __lhs.compare(__rhs) < 0;
}
template <class _CharT, class _Traits>

bool operator>(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) throw()
{
        return __lhs.compare(__rhs) > 0;
}
template <class _CharT, class _Traits, int = 1>

bool operator>(basic_string_view<_CharT, _Traits> __lhs,
               typename common_type<basic_string_view<_CharT, _Traits>>::type __rhs) throw()
{
        return __lhs.compare(__rhs) > 0;
}
template <class _CharT, class _Traits, int = 2>

bool operator>(typename common_type<basic_string_view<_CharT, _Traits>>::type __lhs,
               basic_string_view<_CharT, _Traits> __rhs) throw()
{
        return __lhs.compare(__rhs) > 0;
}
template <class _CharT, class _Traits>

bool operator<=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) throw()
{
        return __lhs.compare(__rhs) <= 0;
}
template <class _CharT, class _Traits, int = 1>

bool operator<=(basic_string_view<_CharT, _Traits> __lhs,
                typename common_type<basic_string_view<_CharT, _Traits>>::type __rhs) throw()
{
        return __lhs.compare(__rhs) <= 0;
}
template <class _CharT, class _Traits, int = 2>

bool operator<=(typename common_type<basic_string_view<_CharT, _Traits>>::type __lhs,
                basic_string_view<_CharT, _Traits> __rhs) throw()
{
        return __lhs.compare(__rhs) <= 0;
}
template <class _CharT, class _Traits>

bool operator>=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) throw()
{
        return __lhs.compare(__rhs) >= 0;
}
template <class _CharT, class _Traits, int = 1>

bool operator>=(basic_string_view<_CharT, _Traits> __lhs,
                typename common_type<basic_string_view<_CharT, _Traits>>::type __rhs) throw()
{
        return __lhs.compare(__rhs) >= 0;
}
template <class _CharT, class _Traits, int = 2>

bool operator>=(typename common_type<basic_string_view<_CharT, _Traits>>::type __lhs,
                basic_string_view<_CharT, _Traits> __rhs) throw()
{
        return __lhs.compare(__rhs) >= 0;
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os,
           basic_string_view<_CharT, _Traits> __str);
template <class _CharT>
struct hash<basic_string_view<_CharT, char_traits<_CharT>>>
    : public __unary_function<basic_string_view<_CharT, char_traits<_CharT>>, size_t>
{

        size_t operator()(const basic_string_view<_CharT, char_traits<_CharT>> __val) const throw()
        {
            return __do_string_hash(__val.data(), __val.data() + __val.size());
        }
};
    }
}
namespace std
{
    inline namespace __1
    {
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator> &__x,
          const basic_string<_CharT, _Traits, _Allocator> &__y);
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT *__x, const basic_string<_CharT, _Traits, _Allocator> &__y);
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __x, const basic_string<_CharT, _Traits, _Allocator> &__y);
template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator> &__x, const _CharT *__y);
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator> &__x, _CharT __y);
extern template;
template <class _Iter>
struct __string_is_trivial_iterator : public false_type
{
};
template <class _Tp>
struct __string_is_trivial_iterator<_Tp *>
    : public is_arithmetic<_Tp>
{
};
template <class _Iter>
struct __string_is_trivial_iterator<__wrap_iter<_Iter>>
    : public __string_is_trivial_iterator<_Iter>
{
};
template <class _CharT, class _Traits, class _Tp>
struct __can_be_converted_to_string_view : public _BoolConstant<
                                               is_convertible<const _Tp &, basic_string_view<_CharT, _Traits>>::value &&
                                               !is_convertible<const _Tp &, const _CharT *>::value>
{
};
typedef basic_string<char16_t> u16string;
typedef basic_string<char32_t> u32string;
struct __uninitialized_size_tag
{
};
template <class _CharT, class _Traits, class _Allocator>
class

    basic_string
{
    public:
        typedef basic_string __self;
        typedef basic_string_view<_CharT, _Traits> __self_view;
        typedef _Traits traits_type;
        typedef _CharT value_type;
        typedef _Allocator allocator_type;
        typedef allocator_traits<allocator_type> __alloc_traits;
        typedef typename __alloc_traits::size_type size_type;
        typedef typename __alloc_traits::difference_type difference_type;
        typedef value_type &reference;
        typedef const value_type &const_reference;
        typedef typename __alloc_traits::pointer pointer;
        typedef typename __alloc_traits::const_pointer const_pointer;
        _Static_assert((!is_array<value_type>::value), "Character type of basic_string must not be an array");
        _Static_assert((is_standard_layout<value_type>::value), "Character type of basic_string must be standard-layout");
        _Static_assert((is_trivial<value_type>::value), "Character type of basic_string must be trivial");
        _Static_assert((is_same<_CharT, typename traits_type::char_type>::value), "traits_type::char_type must be the same type as CharT");
        _Static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");
        typedef __wrap_iter<pointer> iterator;
        typedef __wrap_iter<const_pointer> const_iterator;
        typedef std::reverse_iterator<iterator> reverse_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    private:
        _Static_assert(8 == 8, "This implementation assumes that one byte contains 8 bits");
        struct __long
        {
            pointer __data_;
            size_type __size_;
            size_type __cap_ : sizeof(size_type) * 8 - 1;
            size_type __is_long_ : 1;
        };
        enum
        {
            __min_cap = (sizeof(__long) - 1) / sizeof(value_type) > 2 ? (sizeof(__long) - 1) / sizeof(value_type) : 2
        };
        struct __short
        {
            value_type __data_[__min_cap];
            unsigned char __padding_[sizeof(value_type) - 1];
            unsigned char __size_ : 7;
            unsigned char __is_long_ : 1;
        };
        static const size_type __endian_factor = 1;
        _Static_assert(sizeof(__short) == (sizeof(value_type) * (__min_cap + 1)), "__short has an unexpected size.");
        union __ulx
        {
            __long __lx;
            __short __lxx;
        };
        enum
        {
            __n_words = sizeof(__ulx) / sizeof(size_type)
        };
        struct __raw
        {
            size_type __words[__n_words];
        };
        struct __rep
        {
            union
            {
                __long __l;
                __short __s;
                __raw __r;
            };
        };
        __compressed_pair<__rep, allocator_type> __r_;

        explicit basic_string(__uninitialized_size_tag, size_type __size, const allocator_type &__a)
            : __r_(__default_init_tag(), __a)
        {
            if (__size > max_size())
                __throw_length_error();
            if (__fits_in_sso(__size))
            {
                __zero();
                __set_short_size(__size);
            }
            else
            {
                auto __capacity = __recommend(__size) + 1;
                auto __allocation = __alloc_traits::allocate(__alloc(), __capacity);
                __begin_lifetime(__allocation, __capacity);
                __set_long_cap(__capacity);
                __set_long_pointer(__allocation);
                __set_long_size(__size);
            }
            std::__debug_db_insert_c(this);
        }

    public:
        static const size_type npos = -1;

        ;

        ;
        basic_string(const basic_string &__str);
        basic_string(const basic_string &__str, const allocator_type &__a);
        template <class = __enable_if_t<__is_allocator<_Allocator>::value, nullptr_t>>

        basic_string(const _CharT *__s) : __r_(__default_init_tag(), __default_init_tag())
        {
            ((void)0);
            __init(__s, traits_type::length(__s));
            std::__debug_db_insert_c(this);
        }
        template <class = __enable_if_t<__is_allocator<_Allocator>::value, nullptr_t>>

        basic_string(const _CharT *__s, const _Allocator &__a);

        basic_string(const _CharT *__s, size_type __n);

        basic_string(const _CharT *__s, size_type __n, const _Allocator &__a);

        basic_string(size_type __n, _CharT __c);
        template <class = __enable_if_t<__is_allocator<_Allocator>::value, nullptr_t>>

        basic_string(size_type __n, _CharT __c, const _Allocator &__a);
        basic_string(const basic_string &__str, size_type __pos, size_type __n,
                     const _Allocator &__a = _Allocator());

        basic_string(const basic_string &__str, size_type __pos,
                     const _Allocator &__a = _Allocator());
        template <class _Tp, class = __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value>>
        inline basic_string(const _Tp &__t, size_type __pos, size_type __n,
                            const allocator_type &__a = allocator_type());
        template <class _Tp, class = __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                                                   !__is_same_uncvref<_Tp, basic_string>::value>>
        inline explicit basic_string(const _Tp &__t);
        template <class _Tp, class = __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value>>
        inline explicit basic_string(const _Tp &__t, const allocator_type &__a);
        template <class _InputIterator, class = __enable_if_t<__is_cpp17_input_iterator<_InputIterator>::value>>

        basic_string(_InputIterator __first, _InputIterator __last);
        template <class _InputIterator, class = __enable_if_t<__is_cpp17_input_iterator<_InputIterator>::value>>

        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type &__a);
        inline ~basic_string();

        operator __self_view() const throw() { return __self_view(data(), size()); }
        basic_string &operator=(const basic_string &__str);
        template <class _Tp, class = __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                                                   !__is_same_uncvref<_Tp, basic_string>::value>>
        basic_string &operator=(const _Tp &__t)
        {
            __self_view __sv = __t;
            return assign(__sv);
        }

        basic_string &operator=(const value_type *__s) { return assign(__s); }
        basic_string &operator=(value_type __c);

        iterator begin() throw()
        {
            return iterator(this, __get_pointer());
        }

        const_iterator begin() const throw()
        {
            return const_iterator(this, __get_pointer());
        }

        iterator end() throw()
        {
            return iterator(this, __get_pointer() + size());
        }

        const_iterator end() const throw()
        {
            return const_iterator(this, __get_pointer() + size());
        }

        reverse_iterator rbegin() throw()
        {
            return reverse_iterator(end());
        }

        const_reverse_iterator rbegin() const throw()
        {
            return const_reverse_iterator(end());
        }

        reverse_iterator rend() throw()
        {
            return reverse_iterator(begin());
        }

        const_reverse_iterator rend() const throw()
        {
            return const_reverse_iterator(begin());
        }

        const_iterator cbegin() const throw()
        {
            return begin();
        }

        const_iterator cend() const throw()
        {
            return end();
        }

        const_reverse_iterator crbegin() const throw()
        {
            return rbegin();
        }

        const_reverse_iterator crend() const throw()
        {
            return rend();
        }

        {
            return __is_long() ? __get_long_size() : __get_short_size();
        };
};
{
        return (__is_long() ? __get_long_cap() : static_cast<size_type>(__min_cap)) - 1;
}
void resize(size_type __n, value_type __c);
;
    }
    void reserve(size_type __requested_capacity);
    ;
    ;
};
    ;

bool empty() const throw() { return size() == 0; }

const_reference operator[](size_type __pos) const throw();
;
const_reference at(size_type __n) const;
reference at(size_type __n);
{
    return append(__str);
}
template <class _Tp>
inline __enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value,
    basic_string &>
operator+=(const _Tp &__t)
{
    __self_view __sv = __t;
    return append(__sv);
}
{
    return append(__s);
}
{
    push_back(__c);
    return *this;
}

basic_string &append(const basic_string &__str);
template <class _Tp>
inline __enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value,
    basic_string &>
append(const _Tp &__t)
{
    __self_view __sv = __t;
    return append(__sv.data(), __sv.size());
}
basic_string &append(const basic_string &__str, size_type __pos, size_type __n = npos);
template <class _Tp>
inline __enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value,
    basic_string &>
append(const _Tp &__t, size_type __pos, size_type __n = npos);
basic_string &append(const value_type *__s, size_type __n);
basic_string &append(const value_type *__s);
basic_string &append(size_type __n, value_type __c);

void __append_default_init(size_type __n);
template <class _InputIterator>
inline __enable_if_t<
    __is_exactly_cpp17_input_iterator<_InputIterator>::value,
    basic_string &>

append(_InputIterator __first, _InputIterator __last)
{
    const basic_string __temp(__first, __last, __alloc());
    append(__temp.data(), __temp.size());
    return *this;
}
template <class _ForwardIterator>
inline __enable_if_t<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    basic_string &>

append(_ForwardIterator __first, _ForwardIterator __last);
void push_back(value_type __c);
;
;
;
;
;
template <class _Tp>
inline __enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    basic_string &>
assign(const _Tp &__t)
{
    __self_view __sv = __t;
    return assign(__sv.data(), __sv.size());
}

basic_string &assign(const basic_string &__str) { return *this = __str; }
basic_string &assign(const basic_string &__str, size_type __pos, size_type __n = npos);
template <class _Tp>
inline __enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value,
    basic_string &>
assign(const _Tp &__t, size_type __pos, size_type __n = npos);
basic_string &assign(const value_type *__s, size_type __n);
basic_string &assign(const value_type *__s);
basic_string &assign(size_type __n, value_type __c);
template <class _InputIterator>
inline __enable_if_t<
    __is_exactly_cpp17_input_iterator<_InputIterator>::value,
    basic_string &>
assign(_InputIterator __first, _InputIterator __last);
template <class _ForwardIterator>
inline __enable_if_t<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    basic_string &>
assign(_ForwardIterator __first, _ForwardIterator __last);

basic_string &insert(size_type __pos1, const basic_string &__str);
template <class _Tp>
inline __enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    basic_string &>
insert(size_type __pos1, const _Tp &__t)
{
    __self_view __sv = __t;
    return insert(__pos1, __sv.data(), __sv.size());
}
template <class _Tp>
inline __enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value,
    basic_string &>
insert(size_type __pos1, const _Tp &__t, size_type __pos2, size_type __n = npos);
basic_string &insert(size_type __pos1, const basic_string &__str, size_type __pos2, size_type __n = npos);
basic_string &insert(size_type __pos, const value_type *__s, size_type __n);
basic_string &insert(size_type __pos, const value_type *__s);
basic_string &insert(size_type __pos, size_type __n, value_type __c);
iterator insert(const_iterator __pos, value_type __c);

iterator insert(const_iterator __pos, size_type __n, value_type __c);
template <class _InputIterator>
inline __enable_if_t<
    __is_exactly_cpp17_input_iterator<_InputIterator>::value,
    iterator>
insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);
template <class _ForwardIterator>
inline __enable_if_t<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    iterator>
insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);
basic_string &erase(size_type __pos = 0, size_type __n = npos);

iterator erase(const_iterator __pos);

iterator erase(const_iterator __first, const_iterator __last);

basic_string &replace(size_type __pos1, size_type __n1, const basic_string &__str);
template <class _Tp>
inline __enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    basic_string &>
replace(size_type __pos1, size_type __n1, const _Tp &__t)
{
    __self_view __sv = __t;
    return replace(__pos1, __n1, __sv.data(), __sv.size());
}
basic_string &replace(size_type __pos1, size_type __n1, const basic_string &__str, size_type __pos2, size_type __n2 = npos);
template <class _Tp>
inline __enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value,
    basic_string &>
replace(size_type __pos1, size_type __n1, const _Tp &__t, size_type __pos2, size_type __n2 = npos);
basic_string &replace(size_type __pos, size_type __n1, const value_type *__s, size_type __n2);
basic_string &replace(size_type __pos, size_type __n1, const value_type *__s);
basic_string &replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);

basic_string &replace(const_iterator __i1, const_iterator __i2, const basic_string &__str);
template <class _Tp>
inline __enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    basic_string &>
replace(const_iterator __i1, const_iterator __i2, const _Tp &__t)
{
    __self_view __sv = __t;
    return replace(__i1 - begin(), __i2 - __i1, __sv);
}

basic_string &replace(const_iterator __i1, const_iterator __i2, const value_type *__s, size_type __n);

basic_string &replace(const_iterator __i1, const_iterator __i2, const value_type *__s);

basic_string &replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);
template <class _InputIterator>
inline __enable_if_t<
    __is_cpp17_input_iterator<_InputIterator>::value,
    basic_string &>
replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);
size_type copy(value_type *__s, size_type __n, size_type __pos = 0) const;

basic_string substr(size_type __pos = 0, size_type __n = npos) const;

void swap(basic_string &__str);

const value_type *c_str() const throw() { return data(); }

const value_type *data() const throw() { return std::__to_address(__get_pointer()); }

allocator_type get_allocator() const throw() { return __alloc(); }

size_type find(const basic_string &__str, size_type __pos = 0) const throw();
template <class _Tp>
inline __enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    size_type>
find(const _Tp &__t, size_type __pos = 0) const throw();
size_type find(const value_type *__s, size_type __pos, size_type __n) const throw();

size_type find(const value_type *__s, size_type __pos = 0) const throw();
size_type find(value_type __c, size_type __pos = 0) const throw();

size_type rfind(const basic_string &__str, size_type __pos = npos) const throw();
template <class _Tp>
inline __enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    size_type>
rfind(const _Tp &__t, size_type __pos = npos) const throw();
size_type rfind(const value_type *__s, size_type __pos, size_type __n) const throw();

size_type rfind(const value_type *__s, size_type __pos = npos) const throw();
size_type rfind(value_type __c, size_type __pos = npos) const throw();

size_type find_first_of(const basic_string &__str, size_type __pos = 0) const throw();
template <class _Tp>
inline __enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    size_type>
find_first_of(const _Tp &__t, size_type __pos = 0) const throw();
size_type find_first_of(const value_type *__s, size_type __pos, size_type __n) const throw();

size_type find_first_of(const value_type *__s, size_type __pos = 0) const throw();

size_type find_first_of(value_type __c, size_type __pos = 0) const throw();

size_type find_last_of(const basic_string &__str, size_type __pos = npos) const throw();
template <class _Tp>
inline __enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    size_type>
find_last_of(const _Tp &__t, size_type __pos = npos) const throw();
size_type find_last_of(const value_type *__s, size_type __pos, size_type __n) const throw();

size_type find_last_of(const value_type *__s, size_type __pos = npos) const throw();

size_type find_last_of(value_type __c, size_type __pos = npos) const throw();

size_type find_first_not_of(const basic_string &__str, size_type __pos = 0) const throw();
template <class _Tp>
inline __enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    size_type>
find_first_not_of(const _Tp &__t, size_type __pos = 0) const throw();
size_type find_first_not_of(const value_type *__s, size_type __pos, size_type __n) const throw();

size_type find_first_not_of(const value_type *__s, size_type __pos = 0) const throw();

size_type find_first_not_of(value_type __c, size_type __pos = 0) const throw();

size_type find_last_not_of(const basic_string &__str, size_type __pos = npos) const throw();
template <class _Tp>
inline __enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    size_type>
find_last_not_of(const _Tp &__t, size_type __pos = npos) const throw();
size_type find_last_not_of(const value_type *__s, size_type __pos, size_type __n) const throw();

size_type find_last_not_of(const value_type *__s, size_type __pos = npos) const throw();

size_type find_last_not_of(value_type __c, size_type __pos = npos) const throw();

int compare(const basic_string &__str) const throw();
template <class _Tp>
inline __enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    int>
compare(const _Tp &__t) const throw();
template <class _Tp>
inline __enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    int>
compare(size_type __pos1, size_type __n1, const _Tp &__t) const;

int compare(size_type __pos1, size_type __n1, const basic_string &__str) const;
int compare(size_type __pos1, size_type __n1, const basic_string &__str, size_type __pos2,
            size_type __n2 = npos) const;
template <class _Tp>
inline __enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value,
    int>
compare(size_type __pos1, size_type __n1, const _Tp &__t, size_type __pos2, size_type __n2 = npos) const;
int compare(const value_type *__s) const throw();
int compare(size_type __pos1, size_type __n1, const value_type *__s) const;
int compare(size_type __pos1, size_type __n1, const value_type *__s, size_type __n2) const;
const;
;

private:
template <class _Alloc>
inline bool friend operator==(const basic_string<char, char_traits<char>, _Alloc> &__lhs,
                              const basic_string<char, char_traits<char>, _Alloc> &__rhs) throw();
;

bool __is_long() const throw()
{
    if (__libcpp_is_constant_evaluated())
return true;
    return __r_.first().__s.__is_long_;
}
static
{
    (void)__begin;
    (void)__n;
}
{
    __zero();
    if (__libcpp_is_constant_evaluated())
    {
size_type __sz = __recommend(0) + 1;
pointer __ptr = __alloc_traits::allocate(__alloc(), __sz);
__begin_lifetime(__ptr, __sz);
__set_long_pointer(__ptr);
__set_long_cap(__sz);
__set_long_size(0);
    }
}
{
    if (__libcpp_is_constant_evaluated() && __get_pointer() != __nullptr)
__alloc_traits::deallocate(__alloc(), __get_pointer(), __get_long_cap());
}
{
    return !__libcpp_is_constant_evaluated() && (__sz < __min_cap);
}
template <class _ForwardIterator>

iterator __insert_from_safe_copy(size_type __n, size_type __ip, _ForwardIterator __first, _ForwardIterator __last)
{
    size_type __sz = size();
    size_type __cap = capacity();
    value_type *__p;
    if (__cap - __sz >= __n)
    {
__p = std::__to_address(__get_pointer());
size_type __n_move = __sz - __ip;
if (__n_move != 0)
        traits_type::move(__p + __ip + __n, __p + __ip, __n_move);
    }
    else
    {
__grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);
__p = std::__to_address(__get_long_pointer());
    }
    __sz += __n;
    __set_size(__sz);
    traits_type::assign(__p[__sz], value_type());
    for (__p += __ip; __first != __last; ++__p, ++__first)
traits_type::assign(*__p, *__first);
    return begin() + __ip;
};
}
;
}

void __set_short_size(size_type __s) throw()
{
    ((void)0);
    __r_.first().__s.__size_ = __s;
    __r_.first().__s.__is_long_ = false;
}

size_type __get_short_size() const throw()
{
    ((void)0);
    return __r_.first().__s.__size_;
}

void __set_long_size(size_type __s) throw()
{
    __r_.first().__l.__size_ = __s;
}

size_type __get_long_size() const throw()
{
    return __r_.first().__l.__size_;
}

void __set_size(size_type __s) throw()
{
    if (__is_long())
__set_long_size(__s);
    else
__set_short_size(__s);
}

void __set_long_cap(size_type __s) throw()
{
    __r_.first().__l.__cap_ = __s / __endian_factor;
    __r_.first().__l.__is_long_ = true;
}

size_type __get_long_cap() const throw()
{
    return __r_.first().__l.__cap_ * __endian_factor;
}

void __set_long_pointer(pointer __p) throw()
{
    __r_.first().__l.__data_ = __p;
}

pointer __get_long_pointer() throw()
{
    return __r_.first().__l.__data_;
}

const_pointer __get_long_pointer() const throw()
{
    return __r_.first().__l.__data_;
}

pointer __get_short_pointer() throw()
{
    return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);
}

const_pointer __get_short_pointer() const throw()
{
    return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);
}

pointer __get_pointer() throw()
{
    return __is_long() ? __get_long_pointer() : __get_short_pointer();
}

const_pointer __get_pointer() const throw()
{
    return __is_long() ? __get_long_pointer() : __get_short_pointer();
}

void __zero() throw()
{
    __r_.first() = __rep();
}
template <size_type __a>
static

    size_type
    __align_it(size_type __s) throw()
{
    return (__s + (__a - 1)) & ~(__a - 1);
}
enum
{
    __alignment = 16
};
static size_type __recommend(size_type __s) throw()
{
    if (__s < __min_cap)
    {
if (__libcpp_is_constant_evaluated())
        return static_cast<size_type>(__min_cap);
else
        return static_cast<size_type>(__min_cap) - 1;
    }
    size_type __guess = __align_it < sizeof(value_type) < __alignment ? __alignment / sizeof(value_type) : 1 > (__s + 1) - 1;
    if (__guess == __min_cap)
++__guess;
    return __guess;
}
inline void __init(const value_type *__s, size_type __sz, size_type __reserve);
inline void __init(const value_type *__s, size_type __sz);
inline void __init(size_type __n, value_type __c);
void __init_copy_ctor_external(const value_type *__s, size_type __sz);
template <class _InputIterator>
inline __enable_if_t<
    __is_exactly_cpp17_input_iterator<_InputIterator>::value>
__init(_InputIterator __first, _InputIterator __last);
template <class _ForwardIterator>
inline __enable_if_t<
    __is_cpp17_forward_iterator<_ForwardIterator>::value>
__init(_ForwardIterator __first, _ForwardIterator __last);
void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
               size_type __n_copy, size_type __n_del, size_type __n_add = 0);
void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                           size_type __n_copy, size_type __n_del,
                           size_type __n_add, const value_type *__p_new_stuff);
template <bool __is_short>
basic_string &__assign_no_alias(const value_type *__s, size_type __n);

void __erase_to_end(size_type __pos);
void __erase_external_with_move(size_type __pos, size_type __n);

void __copy_assign_alloc(const basic_string &__str)
{
    __copy_assign_alloc(__str, integral_constant<bool,
                                                 __alloc_traits::propagate_on_container_copy_assignment::value>());
}

void __copy_assign_alloc(const basic_string &__str, true_type)
{
    if (__alloc() == __str.__alloc())
__alloc() = __str.__alloc();
    else
    {
if (!__str.__is_long())
{
        __clear_and_shrink();
        __alloc() = __str.__alloc();
}
else
{
        allocator_type __a = __str.__alloc();
        auto __allocation = std::__allocate_at_least(__a, __str.__get_long_cap());
        __begin_lifetime(__allocation.ptr, __allocation.count);
        __clear_and_shrink();
        __alloc() = std::move(__a);
        __set_long_pointer(__allocation.ptr);
        __set_long_cap(__allocation.count);
        __set_long_size(__str.size());
}
    }
}

void __copy_assign_alloc(const basic_string &, false_type) throw()
{
}

void __move_assign_alloc(basic_string &__str)
{
    __move_assign_alloc(__str, integral_constant<bool,
                                                 __alloc_traits::propagate_on_container_move_assignment::value>());
}

void __move_assign_alloc(basic_string &__c, true_type)
{
    __alloc() = std::move(__c.__alloc());
}

void __move_assign_alloc(basic_string &, false_type) throw()
{
}
basic_string &__assign_external(const value_type *__s);
basic_string &__assign_external(const value_type *__s, size_type __n);
inline basic_string &__assign_short(const value_type *__s, size_type __n)
{
    pointer __p = __is_long()
                      ? (__set_long_size(__n), __get_long_pointer())
                      : (__set_short_size(__n), __get_short_pointer());
    traits_type::move(std::__to_address(__p), __s, __n);
    traits_type::assign(__p[__n], value_type());
    return *this;
}

basic_string &__null_terminate_at(value_type *__p, size_type __newsz)
{
    __set_size(__newsz);
    __invalidate_iterators_past(__newsz);
    traits_type::assign(__p[__newsz], value_type());
    return *this;
};
template <class _Tp>

bool __addr_in_range(_Tp &&__t) const
{
    if (__libcpp_is_constant_evaluated())
return true;
    const volatile void *__p = std::addressof(__t);
    return data() <= __p && __p <= data() + size();
}

void __throw_length_error() const
{
    std::__throw_length_error("basic_string");
}

void __throw_out_of_range() const
{
    std::__throw_out_of_range("basic_string");
}
friend basic_string operator+<>(const basic_string &, const basic_string &);
friend basic_string operator+<>(const value_type *, const basic_string &);
friend basic_string operator+<>(value_type, const basic_string &);
friend basic_string operator+<>(const basic_string &, const value_type *);
friend basic_string operator+<>(const basic_string &, value_type);
}
;
extern template;
extern template;
template <class _CharT, class _Traits, class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type __pos)
{
    (void)__pos;
}
template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>::basic_string()
    : __r_(__default_init_tag(), __default_init_tag())
{
    std::__debug_db_insert_c(this);
    __default_init();
}
template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type &__a)
    : __r_(__default_init_tag(), __a)
{
    std::__debug_db_insert_c(this);
    __default_init();
}
template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::__init(const value_type *__s,
                                                       size_type __sz,
                                                       size_type __reserve)
{
    if (__libcpp_is_constant_evaluated())
__zero();
    if (__reserve > max_size())
__throw_length_error();
    pointer __p;
    if (__fits_in_sso(__reserve))
    {
__set_short_size(__sz);
__p = __get_short_pointer();
    }
    else
    {
auto __allocation = std::__allocate_at_least(__alloc(), __recommend(__reserve) + 1);
__p = __allocation.ptr;
__begin_lifetime(__p, __allocation.count);
__set_long_pointer(__p);
__set_long_cap(__allocation.count);
__set_long_size(__sz);
    }
    traits_type::copy(std::__to_address(__p), __s, __sz);
    traits_type::assign(__p[__sz], value_type());
}
template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::__init(const value_type *__s, size_type __sz)
{
    if (__libcpp_is_constant_evaluated())
__zero();
    if (__sz > max_size())
__throw_length_error();
    pointer __p;
    if (__fits_in_sso(__sz))
    {
__set_short_size(__sz);
__p = __get_short_pointer();
    }
    else
    {
auto __allocation = std::__allocate_at_least(__alloc(), __recommend(__sz) + 1);
__p = __allocation.ptr;
__begin_lifetime(__p, __allocation.count);
__set_long_pointer(__p);
__set_long_cap(__allocation.count);
__set_long_size(__sz);
    }
    traits_type::copy(std::__to_address(__p), __s, __sz);
    traits_type::assign(__p[__sz], value_type());
}
template <class _CharT, class _Traits, class _Allocator>
template <class>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT *__s, const _Allocator &__a)
    : __r_(__default_init_tag(), __a)
{
    ((void)0);
    __init(__s, traits_type::length(__s));
    std::__debug_db_insert_c(this);
}
template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT *__s, size_type __n)
    : __r_(__default_init_tag(), __default_init_tag())
{
    ((void)0);
    __init(__s, __n);
    std::__debug_db_insert_c(this);
}
template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT *__s, size_type __n, const _Allocator &__a)
    : __r_(__default_init_tag(), __a)
{
    ((void)0);
    __init(__s, __n);
    std::__debug_db_insert_c(this);
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string &__str)
    : __r_(__default_init_tag(), __alloc_traits::select_on_container_copy_construction(__str.__alloc()))
{
    if (!__str.__is_long())
__r_.first().__r = __str.__r_.first().__r;
    else
__init_copy_ctor_external(std::__to_address(__str.__get_long_pointer()),
                          __str.__get_long_size());
    std::__debug_db_insert_c(this);
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    const basic_string &__str, const allocator_type &__a)
    : __r_(__default_init_tag(), __a)
{
    if (!__str.__is_long())
__r_.first().__r = __str.__r_.first().__r;
    else
__init_copy_ctor_external(std::__to_address(__str.__get_long_pointer()),
                          __str.__get_long_size());
    std::__debug_db_insert_c(this);
}
template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::__init_copy_ctor_external(
    const value_type *__s, size_type __sz)
{
    if (__libcpp_is_constant_evaluated())
__zero();
    pointer __p;
    if (__fits_in_sso(__sz))
    {
__p = __get_short_pointer();
__set_short_size(__sz);
    }
    else
    {
if (__sz > max_size())
        __throw_length_error();
auto __allocation = std::__allocate_at_least(__alloc(), __recommend(__sz) + 1);
__p = __allocation.ptr;
__begin_lifetime(__p, __allocation.count);
__set_long_pointer(__p);
__set_long_cap(__allocation.count);
__set_long_size(__sz);
    }
    traits_type::copy(std::__to_address(__p), __s, __sz + 1);
}
template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)
{
    if (__libcpp_is_constant_evaluated())
__zero();
    if (__n > max_size())
__throw_length_error();
    pointer __p;
    if (__fits_in_sso(__n))
    {
__set_short_size(__n);
__p = __get_short_pointer();
    }
    else
    {
auto __allocation = std::__allocate_at_least(__alloc(), __recommend(__n) + 1);
__p = __allocation.ptr;
__begin_lifetime(__p, __allocation.count);
__set_long_pointer(__p);
__set_long_cap(__allocation.count);
__set_long_size(__n);
    }
    traits_type::assign(std::__to_address(__p), __n, __c);
    traits_type::assign(__p[__n], value_type());
}
template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, _CharT __c)
    : __r_(__default_init_tag(), __default_init_tag())
{
    __init(__n, __c);
    std::__debug_db_insert_c(this);
}
template <class _CharT, class _Traits, class _Allocator>
template <class>
basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, _CharT __c, const _Allocator &__a)
    : __r_(__default_init_tag(), __a)
{
    __init(__n, __c);
    std::__debug_db_insert_c(this);
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string &__str,
                                                        size_type __pos, size_type __n,
                                                        const _Allocator &__a)
    : __r_(__default_init_tag(), __a)
{
    size_type __str_sz = __str.size();
    if (__pos > __str_sz)
__throw_out_of_range();
    __init(__str.data() + __pos, std::min(__n, __str_sz - __pos));
    std::__debug_db_insert_c(this);
}
template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string &__str, size_type __pos,
                                                               const _Allocator &__a)
    : __r_(__default_init_tag(), __a)
{
    size_type __str_sz = __str.size();
    if (__pos > __str_sz)
__throw_out_of_range();
    __init(__str.data() + __pos, __str_sz - __pos);
    std::__debug_db_insert_c(this);
}
template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, class>
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    const _Tp &__t, size_type __pos, size_type __n, const allocator_type &__a)
    : __r_(__default_init_tag(), __a)
{
    __self_view __sv0 = __t;
    __self_view __sv = __sv0.substr(__pos, __n);
    __init(__sv.data(), __sv.size());
    std::__debug_db_insert_c(this);
}
template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, class>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _Tp &__t)
    : __r_(__default_init_tag(), __default_init_tag())
{
    __self_view __sv = __t;
    __init(__sv.data(), __sv.size());
    std::__debug_db_insert_c(this);
}
template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, class>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _Tp &__t, const _Allocator &__a)
    : __r_(__default_init_tag(), __a)
{
    __self_view __sv = __t;
    __init(__sv.data(), __sv.size());
    std::__debug_db_insert_c(this);
}
template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
__enable_if_t<
    __is_exactly_cpp17_input_iterator<_InputIterator>::value>
basic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)
{
    __default_init();
    try
    {
for (; __first != __last; ++__first)
        push_back(*__first);
    }
    catch (...)
    {
if (__is_long())
        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
throw;
    }
}
template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator>
__enable_if_t<
    __is_cpp17_forward_iterator<_ForwardIterator>::value>
basic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)
{
    if (__libcpp_is_constant_evaluated())
__zero();
    size_type __sz = static_cast<size_type>(std::distance(__first, __last));
    if (__sz > max_size())
__throw_length_error();
    pointer __p;
    if (__fits_in_sso(__sz))
    {
__set_short_size(__sz);
__p = __get_short_pointer();
    }
    else
    {
auto __allocation = std::__allocate_at_least(__alloc(), __recommend(__sz) + 1);
__p = __allocation.ptr;
__begin_lifetime(__p, __allocation.count);
__set_long_pointer(__p);
__set_long_cap(__allocation.count);
__set_long_size(__sz);
    }
    try
    {
for (; __first != __last; ++__first, (void)++__p)
        traits_type::assign(*__p, *__first);
traits_type::assign(*__p, value_type());
    }
    catch (...)
    {
if (__is_long())
        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
throw;
    }
}
template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator, class>
inline basic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)
    : __r_(__default_init_tag(), __default_init_tag())
{
    __init(__first, __last);
    std::__debug_db_insert_c(this);
}
template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator, class>
inline basic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,
                                                               const allocator_type &__a)
    : __r_(__default_init_tag(), __a)
{
    __init(__first, __last);
    std::__debug_db_insert_c(this);
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::~basic_string()
{
    std::__debug_db_erase_c(this);
    if (__is_long())
__alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
}
template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                                                                      size_type __n_copy, size_type __n_del, size_type __n_add, const value_type *__p_new_stuff)
{
    size_type __ms = max_size();
    if (__delta_cap > __ms - __old_cap - 1)
__throw_length_error();
    pointer __old_p = __get_pointer();
    size_type __cap = __old_cap < __ms / 2 - __alignment ? __recommend(std::max(__old_cap + __delta_cap, 2 * __old_cap)) : __ms - 1;
    auto __allocation = std::__allocate_at_least(__alloc(), __cap + 1);
    pointer __p = __allocation.ptr;
    __begin_lifetime(__p, __allocation.count);
    std::__debug_db_invalidate_all(this);
    if (__n_copy != 0)
traits_type::copy(std::__to_address(__p),
                  std::__to_address(__old_p), __n_copy);
    if (__n_add != 0)
traits_type::copy(std::__to_address(__p) + __n_copy, __p_new_stuff, __n_add);
    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
    if (__sec_cp_sz != 0)
traits_type::copy(std::__to_address(__p) + __n_copy + __n_add,
                  std::__to_address(__old_p) + __n_copy + __n_del, __sec_cp_sz);
    if (__old_cap + 1 != __min_cap || __libcpp_is_constant_evaluated())
__alloc_traits::deallocate(__alloc(), __old_p, __old_cap + 1);
    __set_long_pointer(__p);
    __set_long_cap(__allocation.count);
    __old_sz = __n_copy + __n_add + __sec_cp_sz;
    __set_long_size(__old_sz);
    traits_type::assign(__p[__old_sz], value_type());
}
template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                                                          size_type __n_copy, size_type __n_del, size_type __n_add)
{
    size_type __ms = max_size();
    if (__delta_cap > __ms - __old_cap)
__throw_length_error();
    pointer __old_p = __get_pointer();
    size_type __cap = __old_cap < __ms / 2 - __alignment ? __recommend(std::max(__old_cap + __delta_cap, 2 * __old_cap)) : __ms - 1;
    auto __allocation = std::__allocate_at_least(__alloc(), __cap + 1);
    pointer __p = __allocation.ptr;
    __begin_lifetime(__p, __allocation.count);
    std::__debug_db_invalidate_all(this);
    if (__n_copy != 0)
traits_type::copy(std::__to_address(__p),
                  std::__to_address(__old_p), __n_copy);
    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
    if (__sec_cp_sz != 0)
traits_type::copy(std::__to_address(__p) + __n_copy + __n_add,
                  std::__to_address(__old_p) + __n_copy + __n_del,
                  __sec_cp_sz);
    if (__libcpp_is_constant_evaluated() || __old_cap + 1 != __min_cap)
__alloc_traits::deallocate(__alloc(), __old_p, __old_cap + 1);
    __set_long_pointer(__p);
    __set_long_cap(__allocation.count);
}
template <class _CharT, class _Traits, class _Allocator>
template <bool __is_short>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::__assign_no_alias(
    const value_type *__s, size_type __n)
{
    size_type __cap = __is_short ? static_cast<size_type>(__min_cap) : __get_long_cap();
    if (__n < __cap)
    {
pointer __p = __is_short ? __get_short_pointer() : __get_long_pointer();
__is_short ? __set_short_size(__n) : __set_long_size(__n);
traits_type::copy(std::__to_address(__p), __s, __n);
traits_type::assign(__p[__n], value_type());
__invalidate_iterators_past(__n);
    }
    else
    {
size_type __sz = __is_short ? __get_short_size() : __get_long_size();
__grow_by_and_replace(__cap - 1, __n - __cap + 1, __sz, 0, __sz, __n, __s);
    }
    return *this;
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::__assign_external(
    const value_type *__s, size_type __n)
{
    size_type __cap = capacity();
    if (__cap >= __n)
    {
value_type *__p = std::__to_address(__get_pointer());
traits_type::move(__p, __s, __n);
return __null_terminate_at(__p, __n);
    }
    else
    {
size_type __sz = size();
__grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);
return *this;
    }
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type *__s, size_type __n)
{
    ((void)0);
    return (__builtin_constant_p(__n) && __fits_in_sso(__n))
               ? __assign_short(__s, __n)
               : __assign_external(__s, __n);
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)
{
    size_type __cap = capacity();
    if (__cap < __n)
    {
size_type __sz = size();
__grow_by(__cap, __n - __cap, __sz, 0, __sz);
    }
    value_type *__p = std::__to_address(__get_pointer());
    traits_type::assign(__p, __n, __c);
    return __null_terminate_at(__p, __n);
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)
{
    pointer __p;
    if (__is_long())
    {
__p = __get_long_pointer();
__set_long_size(1);
    }
    else
    {
__p = __get_short_pointer();
__set_short_size(1);
    }
    traits_type::assign(*__p, __c);
    traits_type::assign(*++__p, value_type());
    __invalidate_iterators_past(1);
    return *this;
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string &__str)
{
    if (this != &__str)
    {
__copy_assign_alloc(__str);
if (!__is_long())
{
        if (!__str.__is_long())
        {
            __r_.first().__r = __str.__r_.first().__r;
        }
        else
        {
            return __assign_no_alias<true>(__str.data(), __str.size());
        }
}
else
{
        return __assign_no_alias<false>(__str.data(), __str.size());
}
    }
    return *this;
}
template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
__enable_if_t<
    __is_exactly_cpp17_input_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator> &>
basic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
    const basic_string __temp(__first, __last, __alloc());
    assign(__temp.data(), __temp.size());
    return *this;
}
template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator>
__enable_if_t<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    basic_string<_CharT, _Traits, _Allocator> &>
basic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __cap = capacity();
    size_type __n = __string_is_trivial_iterator<_ForwardIterator>::value ? static_cast<size_type>(std::distance(__first, __last)) : 0;
    if (__string_is_trivial_iterator<_ForwardIterator>::value &&
        (__cap >= __n || !__addr_in_range(*__first)))
    {
if (__cap < __n)
{
        size_type __sz = size();
        __grow_by(__cap, __n - __cap, __sz, 0, __sz);
}
pointer __p = __get_pointer();
for (; __first != __last; ++__p, (void)++__first)
        traits_type::assign(*__p, *__first);
traits_type::assign(*__p, value_type());
__set_size(__n);
__invalidate_iterators_past(__n);
    }
    else
    {
const basic_string __temp(__first, __last, __alloc());
assign(__temp.data(), __temp.size());
    }
    return *this;
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::assign(const basic_string &__str, size_type __pos, size_type __n)
{
    size_type __sz = __str.size();
    if (__pos > __sz)
__throw_out_of_range();
    return assign(__str.data() + __pos, std::min(__n, __sz - __pos));
}
template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
__enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator>>::value,
    basic_string<_CharT, _Traits, _Allocator> &>
basic_string<_CharT, _Traits, _Allocator>::assign(const _Tp &__t, size_type __pos, size_type __n)
{
    __self_view __sv = __t;
    size_type __sz = __sv.size();
    if (__pos > __sz)
__throw_out_of_range();
    return assign(__sv.data() + __pos, std::min(__n, __sz - __pos));
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::__assign_external(const value_type *__s)
{
    return __assign_external(__s, traits_type::length(__s));
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type *__s)
{
    ((void)0);
    return __builtin_constant_p(*__s)
               ? (__fits_in_sso(traits_type::length(__s))
                      ? __assign_short(__s, traits_type::length(__s))
                      : __assign_external(__s, traits_type::length(__s)))
               : __assign_external(__s);
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::append(const value_type *__s, size_type __n)
{
    ((void)0);
    size_type __cap = capacity();
    size_type __sz = size();
    if (__cap - __sz >= __n)
    {
if (__n)
{
        value_type *__p = std::__to_address(__get_pointer());
        traits_type::copy(__p + __sz, __s, __n);
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
}
    }
    else
__grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);
    return *this;
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)
{
    if (__n)
    {
size_type __cap = capacity();
size_type __sz = size();
if (__cap - __sz < __n)
        __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
pointer __p = __get_pointer();
traits_type::assign(std::__to_address(__p) + __sz, __n, __c);
__sz += __n;
__set_size(__sz);
traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}
template <class _CharT, class _Traits, class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::__append_default_init(size_type __n)
{
    if (__n)
    {
size_type __cap = capacity();
size_type __sz = size();
if (__cap - __sz < __n)
        __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
pointer __p = __get_pointer();
__sz += __n;
__set_size(__sz);
traits_type::assign(__p[__sz], value_type());
    }
}
template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)
{
    bool __is_short = !__is_long();
    size_type __cap;
    size_type __sz;
    if (__is_short)
    {
__cap = __min_cap - 1;
__sz = __get_short_size();
    }
    else
    {
__cap = __get_long_cap() - 1;
__sz = __get_long_size();
    }
    if (__sz == __cap)
    {
__grow_by(__cap, 1, __sz, __sz, 0);
__is_short = false;
    }
    pointer __p = __get_pointer();
    if (__is_short)
    {
__p = __get_short_pointer() + __sz;
__set_short_size(__sz + 1);
    }
    else
    {
__p = __get_long_pointer() + __sz;
__set_long_size(__sz + 1);
    }
    traits_type::assign(*__p, __c);
    traits_type::assign(*++__p, value_type());
}
template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator>
__enable_if_t<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    basic_string<_CharT, _Traits, _Allocator> &>
basic_string<_CharT, _Traits, _Allocator>::append(
    _ForwardIterator __first, _ForwardIterator __last)
{
    size_type __sz = size();
    size_type __cap = capacity();
    size_type __n = static_cast<size_type>(std::distance(__first, __last));
    if (__n)
    {
if (__string_is_trivial_iterator<_ForwardIterator>::value &&
    !__addr_in_range(*__first))
{
        if (__cap - __sz < __n)
            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
        pointer __p = __get_pointer() + __sz;
        for (; __first != __last; ++__p, (void)++__first)
            traits_type::assign(*__p, *__first);
        traits_type::assign(*__p, value_type());
        __set_size(__sz + __n);
}
else
{
        const basic_string __temp(__first, __last, __alloc());
        append(__temp.data(), __temp.size());
}
    }
    return *this;
}
template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string &__str)
{
    return append(__str.data(), __str.size());
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string &__str, size_type __pos, size_type __n)
{
    size_type __sz = __str.size();
    if (__pos > __sz)
__throw_out_of_range();
    return append(__str.data() + __pos, std::min(__n, __sz - __pos));
}
template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
__enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator>>::value,
    basic_string<_CharT, _Traits, _Allocator> &>
basic_string<_CharT, _Traits, _Allocator>::append(const _Tp &__t, size_type __pos, size_type __n)
{
    __self_view __sv = __t;
    size_type __sz = __sv.size();
    if (__pos > __sz)
__throw_out_of_range();
    return append(__sv.data() + __pos, std::min(__n, __sz - __pos));
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::append(const value_type *__s)
{
    ((void)0);
    return append(__s, traits_type::length(__s));
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type *__s, size_type __n)
{
    ((void)0);
    size_type __sz = size();
    if (__pos > __sz)
__throw_out_of_range();
    size_type __cap = capacity();
    if (__libcpp_is_constant_evaluated())
    {
if (__cap - __sz >= __n)
        __grow_by_and_replace(__cap, 0, __sz, __pos, 0, __n, __s);
else
        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);
return *this;
    }
    if (__cap - __sz >= __n)
    {
if (__n)
{
        value_type *__p = std::__to_address(__get_pointer());
        size_type __n_move = __sz - __pos;
        if (__n_move != 0)
        {
            if (__p + __pos <= __s && __s < __p + __sz)
                __s += __n;
            traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
        }
        traits_type::move(__p + __pos, __s, __n);
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
}
    }
    else
__grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);
    return *this;
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)
{
    size_type __sz = size();
    if (__pos > __sz)
__throw_out_of_range();
    if (__n)
    {
size_type __cap = capacity();
value_type *__p;
if (__cap - __sz >= __n)
{
        __p = std::__to_address(__get_pointer());
        size_type __n_move = __sz - __pos;
        if (__n_move != 0)
            traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
}
else
{
        __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);
        __p = std::__to_address(__get_long_pointer());
}
traits_type::assign(__p + __pos, __n, __c);
__sz += __n;
__set_size(__sz);
traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}
template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
__enable_if_t<
    __is_exactly_cpp17_input_iterator<_InputIterator>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::iterator>
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)
{
    ((void)0);
    const basic_string __temp(__first, __last, __alloc());
    return insert(__pos, __temp.data(), __temp.data() + __temp.size());
}
template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator>
__enable_if_t<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::iterator>
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)
{
    ((void)0);
    size_type __ip = static_cast<size_type>(__pos - begin());
    size_type __n = static_cast<size_type>(std::distance(__first, __last));
    if (__n == 0)
return begin() + __ip;
    if (__string_is_trivial_iterator<_ForwardIterator>::value && !__addr_in_range(*__first))
    {
return __insert_from_safe_copy(__n, __ip, __first, __last);
    }
    else
    {
const basic_string __temp(__first, __last, __alloc());
return __insert_from_safe_copy(__n, __ip, __temp.begin(), __temp.end());
    }
}
template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string &__str)
{
    return insert(__pos1, __str.data(), __str.size());
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string &__str,
                                                  size_type __pos2, size_type __n)
{
    size_type __str_sz = __str.size();
    if (__pos2 > __str_sz)
__throw_out_of_range();
    return insert(__pos1, __str.data() + __pos2, std::min(__n, __str_sz - __pos2));
}
template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
__enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator>>::value,
    basic_string<_CharT, _Traits, _Allocator> &>
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const _Tp &__t,
                                                  size_type __pos2, size_type __n)
{
    __self_view __sv = __t;
    size_type __str_sz = __sv.size();
    if (__pos2 > __str_sz)
__throw_out_of_range();
    return insert(__pos1, __sv.data() + __pos2, std::min(__n, __str_sz - __pos2));
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type *__s)
{
    ((void)0);
    return insert(__pos, __s, traits_type::length(__s));
}
template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)
{
    ((void)0);
    size_type __ip = static_cast<size_type>(__pos - begin());
    size_type __sz = size();
    size_type __cap = capacity();
    value_type *__p;
    if (__cap == __sz)
    {
__grow_by(__cap, 1, __sz, __ip, 0, 1);
__p = std::__to_address(__get_long_pointer());
    }
    else
    {
__p = std::__to_address(__get_pointer());
size_type __n_move = __sz - __ip;
if (__n_move != 0)
        traits_type::move(__p + __ip + 1, __p + __ip, __n_move);
    }
    traits_type::assign(__p[__ip], __c);
    traits_type::assign(__p[++__sz], value_type());
    __set_size(__sz);
    return begin() + static_cast<difference_type>(__ip);
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::iterator
    basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)
{
    ((void)0);
    difference_type __p = __pos - begin();
    insert(static_cast<size_type>(__p), __n, __c);
    return begin() + __p;
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type *__s, size_type __n2)

{
    ((void)0);
    size_type __sz = size();
    if (__pos > __sz)
__throw_out_of_range();
    __n1 = std::min(__n1, __sz - __pos);
    size_type __cap = capacity();
    if (__cap - __sz + __n1 >= __n2)
    {
if (__libcpp_is_constant_evaluated())
{
        __grow_by_and_replace(__cap, 0, __sz, __pos, __n1, __n2, __s);
        return *this;
}
value_type *__p = std::__to_address(__get_pointer());
if (__n1 != __n2)
{
        size_type __n_move = __sz - __pos - __n1;
        if (__n_move != 0)
        {
            if (__n1 > __n2)
            {
                traits_type::move(__p + __pos, __s, __n2);
                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
                return __null_terminate_at(__p, __sz + (__n2 - __n1));
            }
            if (__p + __pos < __s && __s < __p + __sz)
            {
                if (__p + __pos + __n1 <= __s)
                    __s += __n2 - __n1;
                else
                {
                    traits_type::move(__p + __pos, __s, __n1);
                    __pos += __n1;
                    __s += __n2;
                    __n2 -= __n1;
                    __n1 = 0;
                }
            }
            traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
        }
}
traits_type::move(__p + __pos, __s, __n2);
return __null_terminate_at(__p, __sz + (__n2 - __n1));
    }
    else
__grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);
    return *this;
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)
{
    size_type __sz = size();
    if (__pos > __sz)
__throw_out_of_range();
    __n1 = std::min(__n1, __sz - __pos);
    size_type __cap = capacity();
    value_type *__p;
    if (__cap - __sz + __n1 >= __n2)
    {
__p = std::__to_address(__get_pointer());
if (__n1 != __n2)
{
        size_type __n_move = __sz - __pos - __n1;
        if (__n_move != 0)
            traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
}
    }
    else
    {
__grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);
__p = std::__to_address(__get_long_pointer());
    }
    traits_type::assign(__p + __pos, __n2, __c);
    return __null_terminate_at(__p, __sz - (__n1 - __n2));
}
template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
__enable_if_t<
    __is_cpp17_input_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator> &>
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,
                                                   _InputIterator __j1, _InputIterator __j2)
{
    const basic_string __temp(__j1, __j2, __alloc());
    return replace(__i1, __i2, __temp);
}
template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string &__str)
{
    return replace(__pos1, __n1, __str.data(), __str.size());
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string &__str,
                                                   size_type __pos2, size_type __n2)
{
    size_type __str_sz = __str.size();
    if (__pos2 > __str_sz)
__throw_out_of_range();
    return replace(__pos1, __n1, __str.data() + __pos2, std::min(__n2, __str_sz - __pos2));
}
template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
__enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator>>::value,
    basic_string<_CharT, _Traits, _Allocator> &>
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const _Tp &__t,
                                                   size_type __pos2, size_type __n2)
{
    __self_view __sv = __t;
    size_type __str_sz = __sv.size();
    if (__pos2 > __str_sz)
__throw_out_of_range();
    return replace(__pos1, __n1, __sv.data() + __pos2, std::min(__n2, __str_sz - __pos2));
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type *__s)
{
    ((void)0);
    return replace(__pos, __n1, __s, traits_type::length(__s));
}
template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string &__str)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),
                   __str.data(), __str.size());
}
template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type *__s, size_type __n)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);
}
template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type *__s)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);
}
template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);
}
template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::__erase_external_with_move(
    size_type __pos, size_type __n)
{
    if (__n)
    {
size_type __sz = size();
value_type *__p = std::__to_address(__get_pointer());
__n = std::min(__n, __sz - __pos);
size_type __n_move = __sz - __pos - __n;
if (__n_move != 0)
        traits_type::move(__p + __pos, __p + __pos + __n, __n_move);
__null_terminate_at(__p, __sz - __n);
    }
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos,
                                                 size_type __n)
{
    if (__pos > size())
__throw_out_of_range();
    if (__n == npos)
    {
__erase_to_end(__pos);
    }
    else
    {
__erase_external_with_move(__pos, __n);
    }
    return *this;
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::iterator
    basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)
{
    ((void)0);
    ((void)0);
    iterator __b = begin();
    size_type __r = static_cast<size_type>(__pos - __b);
    erase(__r, 1);
    return __b + static_cast<difference_type>(__r);
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::iterator
    basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)
{
    ((void)0);
    ((void)0);
    iterator __b = begin();
    size_type __r = static_cast<size_type>(__first - __b);
    erase(__r, static_cast<size_type>(__last - __first));
    return __b + static_cast<difference_type>(__r);
}
template <class _CharT, class _Traits, class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::pop_back()
{
    ((void)0);
    __erase_to_end(size() - 1);
}
template <class _CharT, class _Traits, class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::clear() throw()
{
    std::__debug_db_invalidate_all(this);
    if (__is_long())
    {
traits_type::assign(*__get_long_pointer(), value_type());
__set_long_size(0);
    }
    else
    {
traits_type::assign(*__get_short_pointer(), value_type());
__set_short_size(0);
    }
}
template <class _CharT, class _Traits, class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)
{
    __null_terminate_at(std::__to_address(__get_pointer()), __pos);
}
template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)
{
    size_type __sz = size();
    if (__n > __sz)
append(__n - __sz, __c);
    else
__erase_to_end(__n);
}
template <class _CharT, class _Traits, class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::__resize_default_init(size_type __n)
{
    size_type __sz = size();
    if (__n > __sz)
    {
__append_default_init(__n - __sz);
    }
    else
__erase_to_end(__n);
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::max_size() const throw()
{
    size_type __m = __alloc_traits::max_size(__alloc());
    if (__m <= std::numeric_limits<size_type>::max() / 2)
    {
return __m - __alignment;
    }
    else
    {
bool __uses_lsb = __endian_factor == 2;
return __uses_lsb ? __m - __alignment : (__m / 2) - __alignment;
    }
}
template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::reserve(size_type __requested_capacity)
{
    if (__requested_capacity > max_size())
__throw_length_error();
    if (__requested_capacity <= capacity())
return;
    size_type __target_capacity = std::max(__requested_capacity, size());
    __target_capacity = __recommend(__target_capacity);
    if (__target_capacity == capacity())
return;
    __shrink_or_extend(__target_capacity);
}
template <class _CharT, class _Traits, class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::shrink_to_fit() throw()
{
    size_type __target_capacity = __recommend(size());
    if (__target_capacity == capacity())
return;
    __shrink_or_extend(__target_capacity);
}
template <class _CharT, class _Traits, class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::__shrink_or_extend(size_type __target_capacity)
{
    size_type __cap = capacity();
    size_type __sz = size();
    pointer __new_data, __p;
    bool __was_long, __now_long;
    if (__fits_in_sso(__target_capacity))
    {
__was_long = true;
__now_long = false;
__new_data = __get_short_pointer();
__p = __get_long_pointer();
    }
    else
    {
if (__target_capacity > __cap)
{
        auto __allocation = std::__allocate_at_least(__alloc(), __target_capacity + 1);
        __new_data = __allocation.ptr;
        __target_capacity = __allocation.count - 1;
}
else
{
        try
        {
            auto __allocation = std::__allocate_at_least(__alloc(), __target_capacity + 1);
            __new_data = __allocation.ptr;
            __target_capacity = __allocation.count - 1;
        }
        catch (...)
        {
            return;
        }
}
__begin_lifetime(__new_data, __target_capacity + 1);
__now_long = true;
__was_long = __is_long();
__p = __get_pointer();
    }
    traits_type::copy(std::__to_address(__new_data),
                      std::__to_address(__p), size() + 1);
    if (__was_long)
__alloc_traits::deallocate(__alloc(), __p, __cap + 1);
    if (__now_long)
    {
__set_long_cap(__target_capacity + 1);
__set_long_size(__sz);
__set_long_pointer(__new_data);
    }
    else
__set_short_size(__sz);
    std::__debug_db_invalidate_all(this);
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::const_reference
    basic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const throw()
{
    ((void)0);
    return *(data() + __pos);
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::reference
    basic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) throw()
{
    ((void)0);
    return *(__get_pointer() + __pos);
}
template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
__throw_out_of_range();
    return (*this)[__n];
}
template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n)
{
    if (__n >= size())
__throw_out_of_range();
    return (*this)[__n];
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::reference
    basic_string<_CharT, _Traits, _Allocator>::front() throw()
{
    ((void)0);
    return *__get_pointer();
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::const_reference
    basic_string<_CharT, _Traits, _Allocator>::front() const throw()
{
    ((void)0);
    return *data();
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::reference
    basic_string<_CharT, _Traits, _Allocator>::back() throw()
{
    ((void)0);
    return *(__get_pointer() + size() - 1);
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::const_reference
    basic_string<_CharT, _Traits, _Allocator>::back() const throw()
{
    ((void)0);
    return *(data() + size() - 1);
}
template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::copy(value_type *__s, size_type __n, size_type __pos) const
{
    size_type __sz = size();
    if (__pos > __sz)
__throw_out_of_range();
    size_type __rlen = std::min(__n, __sz - __pos);
    traits_type::copy(__s, data() + __pos, __rlen);
    return __rlen;
}
template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>
basic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const
{
    return basic_string(*this, __pos, __n, __alloc());
}
template <class _CharT, class _Traits, class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::swap(basic_string &__str)
{
    if (!__is_long())
std::__debug_db_invalidate_all(this);
    if (!__str.__is_long())
std::__debug_db_invalidate_all(&__str);
    std::__debug_db_swap(this, &__str);
    ((void)0);
    std::swap(__r_.first(), __str.__r_.first());
    std::__swap_allocator(__alloc(), __str.__alloc());
}
template <class _Traits>
struct __traits_eq
{
    typedef typename _Traits::char_type char_type;

    bool operator()(const char_type &__x, const char_type &__y) throw()
    {
return _Traits::eq(__x, __y);
    }
};
template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type *__s,
                                                size_type __pos,
                                                size_type __n) const throw()
{
    ((void)0);
    return __str_find<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find(const basic_string &__str,
                                                    size_type __pos) const throw()
{
    return __str_find<value_type, size_type, traits_type, npos>(data(), size(), __str.data(), __pos, __str.size());
}
template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
__enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type>
basic_string<_CharT, _Traits, _Allocator>::find(const _Tp &__t,
                                                size_type __pos) const throw()
{
    __self_view __sv = __t;
    return __str_find<value_type, size_type, traits_type, npos>(data(), size(), __sv.data(), __pos, __sv.size());
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find(const value_type *__s,
                                                    size_type __pos) const throw()
{
    ((void)0);
    return __str_find<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, traits_type::length(__s));
}
template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(value_type __c,
                                                size_type __pos) const throw()
{
    return __str_find<value_type, size_type, traits_type, npos>(data(), size(), __c, __pos);
}
template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type *__s,
                                                 size_type __pos,
                                                 size_type __n) const throw()
{
    ((void)0);
    return __str_rfind<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string &__str,
                                                     size_type __pos) const throw()
{
    return __str_rfind<value_type, size_type, traits_type, npos>(data(), size(), __str.data(), __pos, __str.size());
}
template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
__enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type>
basic_string<_CharT, _Traits, _Allocator>::rfind(const _Tp &__t,
                                                 size_type __pos) const throw()
{
    __self_view __sv = __t;
    return __str_rfind<value_type, size_type, traits_type, npos>(data(), size(), __sv.data(), __pos, __sv.size());
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type *__s,
                                                     size_type __pos) const throw()
{
    ((void)0);
    return __str_rfind<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, traits_type::length(__s));
}
template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,
                                                 size_type __pos) const throw()
{
    return __str_rfind<value_type, size_type, traits_type, npos>(data(), size(), __c, __pos);
}
template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type *__s,
                                                         size_type __pos,
                                                         size_type __n) const throw()
{
    ((void)0);
    return __str_find_first_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string &__str,
                                                             size_type __pos) const throw()
{
    return __str_find_first_of<value_type, size_type, traits_type, npos>(data(), size(), __str.data(), __pos, __str.size());
}
template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
__enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type>
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const _Tp &__t,
                                                         size_type __pos) const throw()
{
    __self_view __sv = __t;
    return __str_find_first_of<value_type, size_type, traits_type, npos>(data(), size(), __sv.data(), __pos, __sv.size());
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type *__s,
                                                             size_type __pos) const throw()
{
    ((void)0);
    return __str_find_first_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, traits_type::length(__s));
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,
                                                             size_type __pos) const throw()
{
    return find(__c, __pos);
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type *__s,
                                                            size_type __pos,
                                                            size_type __n) const throw()
{
    ((void)0);
    return __str_find_last_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string &__str,
                                                            size_type __pos) const throw()
{
    return __str_find_last_of<value_type, size_type, traits_type, npos>(data(), size(), __str.data(), __pos, __str.size());
}
template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
__enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type>
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const _Tp &__t,
                                                        size_type __pos) const throw()
{
    __self_view __sv = __t;
    return __str_find_last_of<value_type, size_type, traits_type, npos>(data(), size(), __sv.data(), __pos, __sv.size());
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type *__s,
                                                            size_type __pos) const throw()
{
    ((void)0);
    return __str_find_last_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, traits_type::length(__s));
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,
                                                            size_type __pos) const throw()
{
    return rfind(__c, __pos);
}
template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type *__s,
                                                             size_type __pos,
                                                             size_type __n) const throw()
{
    ((void)0);
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string &__str,
                                                                 size_type __pos) const throw()
{
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>(data(), size(), __str.data(), __pos, __str.size());
}
template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
__enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type>
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const _Tp &__t,
                                                             size_type __pos) const throw()
{
    __self_view __sv = __t;
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>(data(), size(), __sv.data(), __pos, __sv.size());
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type *__s,
                                                                 size_type __pos) const throw()
{
    ((void)0);
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, traits_type::length(__s));
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,
                                                                 size_type __pos) const throw()
{
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>(data(), size(), __c, __pos);
}
template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type *__s,
                                                            size_type __pos,
                                                            size_type __n) const throw()
{
    ((void)0);
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string &__str,
                                                                size_type __pos) const throw()
{
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>(data(), size(), __str.data(), __pos, __str.size());
}
template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
__enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type>
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const _Tp &__t,
                                                            size_type __pos) const throw()
{
    __self_view __sv = __t;
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>(data(), size(), __sv.data(), __pos, __sv.size());
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type *__s,
                                                                size_type __pos) const throw()
{
    ((void)0);
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, traits_type::length(__s));
}
template <class _CharT, class _Traits, class _Allocator>
inline
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,
                                                                size_type __pos) const throw()
{
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>(data(), size(), __c, __pos);
}
template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
__enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    int>
basic_string<_CharT, _Traits, _Allocator>::compare(const _Tp &__t) const throw()
{
    __self_view __sv = __t;
    size_t __lhs_sz = size();
    size_t __rhs_sz = __sv.size();
    int __result = traits_type::compare(data(), __sv.data(),
                                        std::min(__lhs_sz, __rhs_sz));
    if (__result != 0)
return __result;
    if (__lhs_sz < __rhs_sz)
return -1;
    if (__lhs_sz > __rhs_sz)
return 1;
    return 0;
}
template <class _CharT, class _Traits, class _Allocator>
inline int
basic_string<_CharT, _Traits, _Allocator>::compare(const basic_string &__str) const throw()
{
    return compare(__self_view(__str));
}
template <class _CharT, class _Traits, class _Allocator>
inline int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const value_type *__s,
                                                   size_type __n2) const
{
    ((void)0);
    size_type __sz = size();
    if (__pos1 > __sz || __n2 == npos)
__throw_out_of_range();
    size_type __rlen = std::min(__n1, __sz - __pos1);
    int __r = traits_type::compare(data() + __pos1, __s, std::min(__rlen, __n2));
    if (__r == 0)
    {
if (__rlen < __n2)
        __r = -1;
else if (__rlen > __n2)
        __r = 1;
    }
    return __r;
}
template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
__enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    int>
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const _Tp &__t) const
{
    __self_view __sv = __t;
    return compare(__pos1, __n1, __sv.data(), __sv.size());
}
template <class _CharT, class _Traits, class _Allocator>
inline int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string &__str) const
{
    return compare(__pos1, __n1, __str.data(), __str.size());
}
template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
__enable_if_t<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator>>::value,
    int>
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const _Tp &__t,
                                                   size_type __pos2,
                                                   size_type __n2) const
{
    __self_view __sv = __t;
    return __self_view(*this).substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
}
template <class _CharT, class _Traits, class _Allocator>
int basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                       size_type __n1,
                                                       const basic_string &__str,
                                                       size_type __pos2,
                                                       size_type __n2) const
{
    return compare(__pos1, __n1, __self_view(__str), __pos2, __n2);
}
template <class _CharT, class _Traits, class _Allocator>
int basic_string<_CharT, _Traits, _Allocator>::compare(const value_type *__s) const throw()
{
    ((void)0);
    return compare(0, npos, __s, traits_type::length(__s));
}
template <class _CharT, class _Traits, class _Allocator>
int basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                       size_type __n1,
                                                       const value_type *__s) const
{
    ((void)0);
    return compare(__pos1, __n1, __s, traits_type::length(__s));
}
template <class _CharT, class _Traits, class _Allocator>
inline bool
basic_string<_CharT, _Traits, _Allocator>::__invariants() const
{
    if (size() > capacity())
return false;
    if (capacity() < __min_cap - 1)
return false;
    if (data() == __nullptr)
return false;
    if (data()[size()] != value_type())
return false;
    return true;
}
template <class _CharT, class _Traits, class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::__clear_and_shrink() throw()
{
    clear();
    if (__is_long())
    {
__alloc_traits::deallocate(__alloc(), __get_long_pointer(), capacity() + 1);
__set_long_cap(0);
__set_short_size(0);
traits_type::assign(*__get_short_pointer(), value_type());
    }
}
template <class _CharT, class _Traits, class _Allocator>
inline bool
operator==(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
           const basic_string<_CharT, _Traits, _Allocator> &__rhs) throw()
{
    size_t __lhs_sz = __lhs.size();
    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),
                                                        __rhs.data(),
                                                        __lhs_sz) == 0;
}
template <class _Allocator>
inline bool
operator==(const basic_string<char, char_traits<char>, _Allocator> &__lhs,
           const basic_string<char, char_traits<char>, _Allocator> &__rhs) throw()
{
    size_t __lhs_sz = __lhs.size();
    if (__lhs_sz != __rhs.size())
return false;
    const char *__lp = __lhs.data();
    const char *__rp = __rhs.data();
    if (__lhs.__is_long())
return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;
    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)
if (*__lp != *__rp)
        return false;
    return true;
}
template <class _CharT, class _Traits, class _Allocator>
inline bool
operator==(const _CharT *__lhs,
           const basic_string<_CharT, _Traits, _Allocator> &__rhs) throw()
{
    typedef basic_string<_CharT, _Traits, _Allocator> _String;
    ((void)0);
    size_t __lhs_len = _Traits::length(__lhs);
    if (__lhs_len != __rhs.size())
return false;
    return __rhs.compare(0, _String::npos, __lhs, __lhs_len) == 0;
}
template <class _CharT, class _Traits, class _Allocator>
inline bool
operator==(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
           const _CharT *__rhs) throw()
{
    typedef basic_string<_CharT, _Traits, _Allocator> _String;
    ((void)0);
    size_t __rhs_len = _Traits::length(__rhs);
    if (__rhs_len != __lhs.size())
return false;
    return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;
}
template <class _CharT, class _Traits, class _Allocator>
inline bool
operator!=(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
           const basic_string<_CharT, _Traits, _Allocator> &__rhs) throw()
{
    return !(__lhs == __rhs);
}
template <class _CharT, class _Traits, class _Allocator>
inline bool
operator!=(const _CharT *__lhs,
           const basic_string<_CharT, _Traits, _Allocator> &__rhs) throw()
{
    return !(__lhs == __rhs);
}
template <class _CharT, class _Traits, class _Allocator>
inline bool
operator!=(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
           const _CharT *__rhs) throw()
{
    return !(__lhs == __rhs);
}
template <class _CharT, class _Traits, class _Allocator>
inline bool
operator<(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
          const basic_string<_CharT, _Traits, _Allocator> &__rhs) throw()
{
    return __lhs.compare(__rhs) < 0;
}
template <class _CharT, class _Traits, class _Allocator>
inline bool
operator<(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
          const _CharT *__rhs) throw()
{
    return __lhs.compare(__rhs) < 0;
}
template <class _CharT, class _Traits, class _Allocator>
inline bool
operator<(const _CharT *__lhs,
          const basic_string<_CharT, _Traits, _Allocator> &__rhs) throw()
{
    return __rhs.compare(__lhs) > 0;
}
template <class _CharT, class _Traits, class _Allocator>
inline bool
operator>(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
          const basic_string<_CharT, _Traits, _Allocator> &__rhs) throw()
{
    return __rhs < __lhs;
}
template <class _CharT, class _Traits, class _Allocator>
inline bool
operator>(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
          const _CharT *__rhs) throw()
{
    return __rhs < __lhs;
}
template <class _CharT, class _Traits, class _Allocator>
inline bool
operator>(const _CharT *__lhs,
          const basic_string<_CharT, _Traits, _Allocator> &__rhs) throw()
{
    return __rhs < __lhs;
}
template <class _CharT, class _Traits, class _Allocator>
inline bool
operator<=(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
           const basic_string<_CharT, _Traits, _Allocator> &__rhs) throw()
{
    return !(__rhs < __lhs);
}
template <class _CharT, class _Traits, class _Allocator>
inline bool
operator<=(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
           const _CharT *__rhs) throw()
{
    return !(__rhs < __lhs);
}
template <class _CharT, class _Traits, class _Allocator>
inline bool
operator<=(const _CharT *__lhs,
           const basic_string<_CharT, _Traits, _Allocator> &__rhs) throw()
{
    return !(__rhs < __lhs);
}
template <class _CharT, class _Traits, class _Allocator>
inline bool
operator>=(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
           const basic_string<_CharT, _Traits, _Allocator> &__rhs) throw()
{
    return !(__lhs < __rhs);
}
template <class _CharT, class _Traits, class _Allocator>
inline bool
operator>=(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
           const _CharT *__rhs) throw()
{
    return !(__lhs < __rhs);
}
template <class _CharT, class _Traits, class _Allocator>
inline bool
operator>=(const _CharT *__lhs,
           const basic_string<_CharT, _Traits, _Allocator> &__rhs) throw()
{
    return !(__lhs < __rhs);
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
          const basic_string<_CharT, _Traits, _Allocator> &__rhs)
{
    using _String = basic_string<_CharT, _Traits, _Allocator>;
    auto __lhs_sz = __lhs.size();
    auto __rhs_sz = __rhs.size();
    _String __r(__uninitialized_size_tag(),
                __lhs_sz + __rhs_sz,
                _String::__alloc_traits::select_on_container_copy_construction(__lhs.get_allocator()));
    auto __ptr = std::__to_address(__r.__get_pointer());
    _Traits::copy(__ptr, __lhs.data(), __lhs_sz);
    _Traits::copy(__ptr + __lhs_sz, __rhs.data(), __rhs_sz);
    _Traits::assign(__ptr + __lhs_sz + __rhs_sz, 1, _CharT());
    return __r;
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs)
{
    using _String = basic_string<_CharT, _Traits, _Allocator>;
    auto __lhs_sz = _Traits::length(__lhs);
    auto __rhs_sz = __rhs.size();
    _String __r(__uninitialized_size_tag(),
                __lhs_sz + __rhs_sz,
                _String::__alloc_traits::select_on_container_copy_construction(__rhs.get_allocator()));
    auto __ptr = std::__to_address(__r.__get_pointer());
    _Traits::copy(__ptr, __lhs, __lhs_sz);
    _Traits::copy(__ptr + __lhs_sz, __rhs.data(), __rhs_sz);
    _Traits::assign(__ptr + __lhs_sz + __rhs_sz, 1, _CharT());
    return __r;
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs)
{
    using _String = basic_string<_CharT, _Traits, _Allocator>;
    typename _String::size_type __rhs_sz = __rhs.size();
    _String __r(__uninitialized_size_tag(),
                __rhs_sz + 1,
                _String::__alloc_traits::select_on_container_copy_construction(__rhs.get_allocator()));
    auto __ptr = std::__to_address(__r.__get_pointer());
    _Traits::assign(__ptr, 1, __lhs);
    _Traits::copy(__ptr + 1, __rhs.data(), __rhs_sz);
    _Traits::assign(__ptr + 1 + __rhs_sz, 1, _CharT());
    return __r;
}
template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const _CharT *__rhs)
{
    using _String = basic_string<_CharT, _Traits, _Allocator>;
    typename _String::size_type __lhs_sz = __lhs.size();
    typename _String::size_type __rhs_sz = _Traits::length(__rhs);
    _String __r(__uninitialized_size_tag(),
                __lhs_sz + __rhs_sz,
                _String::__alloc_traits::select_on_container_copy_construction(__lhs.get_allocator()));
    auto __ptr = std::__to_address(__r.__get_pointer());
    _Traits::copy(__ptr, __lhs.data(), __lhs_sz);
    _Traits::copy(__ptr + __lhs_sz, __rhs, __rhs_sz);
    _Traits::assign(__ptr + __lhs_sz + __rhs_sz, 1, _CharT());
    return __r;
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator> &__lhs, _CharT __rhs)
{
    using _String = basic_string<_CharT, _Traits, _Allocator>;
    typename _String::size_type __lhs_sz = __lhs.size();
    _String __r(__uninitialized_size_tag(),
                __lhs_sz + 1,
                _String::__alloc_traits::select_on_container_copy_construction(__lhs.get_allocator()));
    auto __ptr = std::__to_address(__r.__get_pointer());
    _Traits::copy(__ptr, __lhs.data(), __lhs_sz);
    _Traits::assign(__ptr + __lhs_sz, 1, __rhs);
    _Traits::assign(__ptr + 1 + __lhs_sz, 1, _CharT());
    return __r;
}
template <class _CharT, class _Traits, class _Allocator>
inline void
swap(basic_string<_CharT, _Traits, _Allocator> &__lhs,
     basic_string<_CharT, _Traits, _Allocator> &__rhs)
{
    __lhs.swap(__rhs);
};
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
template <class _CharT, class _Traits, class _Allocator>

const typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::npos;
template <class _CharT, class _Allocator>
struct
    hash<basic_string<_CharT, char_traits<_CharT>, _Allocator>>
    : public __unary_function<basic_string<_CharT, char_traits<_CharT>, _Allocator>, size_t>
{
    size_t
    operator()(const basic_string<_CharT, char_traits<_CharT>, _Allocator> &__val) const throw()
    {
return __do_string_hash(__val.data(), __val.data() + __val.size());
    }
};
template <class _CharT, class _Traits, class _Allocator>
basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os,
           const basic_string<_CharT, _Traits, _Allocator> &__str);
template <class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits> &
operator>>(basic_istream<_CharT, _Traits> &__is,
           basic_string<_CharT, _Traits, _Allocator> &__str);
template <class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits> &
getline(basic_istream<_CharT, _Traits> &__is,
        basic_string<_CharT, _Traits, _Allocator> &__str, _CharT __dlm);
template <class _CharT, class _Traits, class _Allocator>
inline basic_istream<_CharT, _Traits> &
getline(basic_istream<_CharT, _Traits> &__is,
        basic_string<_CharT, _Traits, _Allocator> &__str);
template <class _CharT, class _Traits, class _Allocator>
inline basic_istream<_CharT, _Traits> &
getline(basic_istream<_CharT, _Traits> &&__is,
        basic_string<_CharT, _Traits, _Allocator> &__str, _CharT __dlm);
template <class _CharT, class _Traits, class _Allocator>
inline basic_istream<_CharT, _Traits> &
getline(basic_istream<_CharT, _Traits> &&__is,
        basic_string<_CharT, _Traits, _Allocator> &__str);
}
}
namespace boost
{
    struct source_location
    {
private:
char const *file_;
char const *function_;
boost::uint_least32_t line_;
boost::uint_least32_t column_;

public:
source_location() : file_(""), function_(""), line_(0), column_(0)
{
}
source_location(char const *file, boost::uint_least32_t ln, char const *function, boost::uint_least32_t col = 0) : file_(file), function_(function), line_(ln), column_(col)
{
}
char const *file_name() const
{
        return file_;
}
char const *function_name() const
{
        return function_;
}
boost::uint_least32_t line() const
{
        return line_;
}
boost::uint_least32_t column() const
{
        return column_;
}
std::string to_string() const
{
        unsigned long ln = line();
        if (ln == 0)
        {
            return "(unknown source location)";
        }
        std::string r = file_name();
        char buffer[16];
        std::snprintf(buffer, sizeof(buffer) / sizeof(buffer[0]), ":%lu", ln);
        r += buffer;
        unsigned long co = column();
        if (co)
        {
            std::snprintf(buffer, sizeof(buffer) / sizeof(buffer[0]), ":%lu", co);
            r += buffer;
        }
        char const *fn = function_name();
        if (*fn != 0)
        {
            r += " in function '";
            r += fn;
            r += '\'';
        }
        return r;
}
inline friend bool operator==(source_location const &s1, source_location const &s2)
{
        return std::strcmp(s1.file_, s2.file_) == 0 && std::strcmp(s1.function_, s2.function_) == 0 && s1.line_ == s2.line_ && s1.column_ == s2.column_;
}
inline friend bool operator!=(source_location const &s1, source_location const &s2)
{
        return !(s1 == s2);
}
    };
    template <class E, class T>
    std::basic_ostream<E, T> &operator<<(std::basic_ostream<E, T> &os, source_location const &loc)
    {
os << loc.to_string();
return os;
    }
}
namespace boost
{
    template <class T>
    class shared_ptr;
}
namespace boost
{
    namespace exception_detail
    {
using boost::shared_ptr;
    }
}
namespace boost
{
    namespace exception_detail
    {
template <class T>
class
    refcount_ptr
{
    public:
        refcount_ptr() : px_(0)
        {
        }
        ~refcount_ptr()
        {
            release();
        }
        refcount_ptr(refcount_ptr const &x) : px_(x.px_)
        {
            add_ref();
        }
        refcount_ptr &
        operator=(refcount_ptr const &x)
        {
            adopt(x.px_);
            return *this;
        }
        void
        adopt(T *px)
        {
            release();
            px_ = px;
            add_ref();
        }
        T *
        get() const
        {
            return px_;
        }

    private:
        T *px_;
        void
        add_ref()
        {
            if (px_)
                px_->add_ref();
        }
        void
        release()
        {
            if (px_ && px_->release())
                px_ = 0;
        }
};
    }
    template <class Tag, class T>
    class error_info;
    typedef error_info<struct throw_function_, char const *> throw_function;
    typedef error_info<struct throw_file_, char const *> throw_file;
    typedef error_info<struct throw_line_, int> throw_line;
    typedef error_info<struct throw_column_, int> throw_column;
    template <>
    class
        error_info<throw_function_, char const *>
    {
public:
typedef char const *value_type;
value_type v_;
explicit error_info(value_type v) : v_(v)
{
}
    };
    template <>
    class
        error_info<throw_file_, char const *>
    {
public:
typedef char const *value_type;
value_type v_;
explicit error_info(value_type v) : v_(v)
{
}
    };
    template <>
    class
        error_info<throw_line_, int>
    {
public:
typedef int value_type;
value_type v_;
explicit error_info(value_type v) : v_(v)
{
}
    };
    template <>
    class
        error_info<throw_column_, int>
    {
public:
typedef int value_type;
value_type v_;
explicit error_info(value_type v) : v_(v)
{
}
    };
    class

        exception;
    namespace exception_detail
    {
class error_info_base;
struct type_info_;
struct
    error_info_container
{
        virtual char const *diagnostic_information(char const *) const = 0;
        virtual shared_ptr<error_info_base> get(type_info_ const &) const = 0;
        virtual void set(shared_ptr<error_info_base> const &, type_info_ const &) = 0;
        virtual void add_ref() const = 0;
        virtual bool release() const = 0;
        virtual refcount_ptr<exception_detail::error_info_container> clone() const = 0;

    protected:
        ~error_info_container() throw()
        {
        }
};
template <class>
struct get_info;
template <>
struct get_info<throw_function>;
template <>
struct get_info<throw_file>;
template <>
struct get_info<throw_line>;
template <>
struct get_info<throw_column>;
template <class>
struct set_info_rv;
template <>
struct set_info_rv<throw_function>;
template <>
struct set_info_rv<throw_file>;
template <>
struct set_info_rv<throw_line>;
template <>
struct set_info_rv<throw_column>;
char const *get_diagnostic_information(exception const &, char const *);
void copy_boost_exception(exception *, exception const *);
template <class E, class Tag, class T>
E const &set_info(E const &, error_info<Tag, T> const &);
template <class E>
E const &set_info(E const &, throw_function const &);
template <class E>
E const &set_info(E const &, throw_file const &);
template <class E>
E const &set_info(E const &, throw_line const &);
template <class E>
E const &set_info(E const &, throw_column const &);
boost::source_location get_exception_throw_location(exception const &);
    }
    class

        exception
    {
public:
template <class Tag>
void set(typename Tag::type const &);
template <class Tag>
typename Tag::type const *get() const;

protected:
exception() : throw_function_(0),
              throw_file_(0),
              throw_line_(-1),
              throw_column_(-1)
{
}
virtual ~exception() throw() = 0;

private:
template <class E>
friend E const &exception_detail::set_info(E const &, throw_function const &);
template <class E>
friend E const &exception_detail::set_info(E const &, throw_file const &);
template <class E>
friend E const &exception_detail::set_info(E const &, throw_line const &);
template <class E>
friend E const &exception_detail::set_info(E const &, throw_column const &);
template <class E, class Tag, class T>
friend E const &exception_detail::set_info(E const &, error_info<Tag, T> const &);
friend char const *exception_detail::get_diagnostic_information(exception const &, char const *);
friend boost::source_location exception_detail::get_exception_throw_location(exception const &);
template <class>
friend struct exception_detail::get_info;
friend struct exception_detail::get_info<throw_function>;
friend struct exception_detail::get_info<throw_file>;
friend struct exception_detail::get_info<throw_line>;
friend struct exception_detail::get_info<throw_column>;
template <class>
friend struct exception_detail::set_info_rv;
friend struct exception_detail::set_info_rv<throw_function>;
friend struct exception_detail::set_info_rv<throw_file>;
friend struct exception_detail::set_info_rv<throw_line>;
friend struct exception_detail::set_info_rv<throw_column>;
friend void exception_detail::copy_boost_exception(exception *, exception const *);
mutable exception_detail::refcount_ptr<exception_detail::error_info_container> data_;
mutable char const *throw_function_;
mutable char const *throw_file_;
mutable int throw_line_;
mutable int throw_column_;
    };
    inline exception::
        ~exception() throw()
    {
    }
    namespace exception_detail
    {
template <class E>
E const &
set_info(E const &x, throw_function const &y)
{
        x.throw_function_ = y.v_;
        return x;
}
template <class E>
E const &
set_info(E const &x, throw_file const &y)
{
        x.throw_file_ = y.v_;
        return x;
}
template <class E>
E const &
set_info(E const &x, throw_line const &y)
{
        x.throw_line_ = y.v_;
        return x;
}
template <class E>
E const &
set_info(E const &x, throw_column const &y)
{
        x.throw_column_ = y.v_;
        return x;
}
inline boost::source_location get_exception_throw_location(exception const &x)
{
        return boost::source_location(
            x.throw_file_ ? x.throw_file_ : "",
            x.throw_line_ >= 0 ? x.throw_line_ : 0,
            x.throw_function_ ? x.throw_function_ : "",
            x.throw_column_ >= 0 ? x.throw_column_ : 0);
}
    }
    namespace exception_detail
    {
template <class T>
struct

    error_info_injector : public T,
                          public exception
{
        explicit error_info_injector(T const &x) : T(x)
        {
        }
        ~error_info_injector() throw()
        {
        }
};
struct large_size
{
        char c[256];
};
large_size dispatch_boost_exception(exception const *);
struct small_size
{
};
small_size dispatch_boost_exception(void const *);
template <class, int>
struct enable_error_info_helper;
template <class T>
struct
    enable_error_info_helper<T, sizeof(large_size)>
{
        typedef T type;
};
template <class T>
struct
    enable_error_info_helper<T, sizeof(small_size)>
{
        typedef error_info_injector<T> type;
};
template <class T>
struct
    enable_error_info_return_type
{
        typedef typename enable_error_info_helper<T, sizeof(exception_detail::dispatch_boost_exception(static_cast<T *>(0)))>::type type;
};
    }
    template <class T>
    inline
        typename exception_detail::enable_error_info_return_type<T>::type
        enable_error_info(T const &x)
    {
typedef typename exception_detail::enable_error_info_return_type<T>::type rt;
return rt(x);
    }
    namespace exception_detail
    {
class

    clone_base
{
    public:
        virtual clone_base const *clone() const = 0;
        virtual void rethrow() const = 0;
        virtual ~clone_base() throw()
        {
        }
};
inline void
copy_boost_exception(exception *a, exception const *b)
{
        refcount_ptr<error_info_container> data;
        if (error_info_container *d = b->data_.get())
            data = d->clone();
        a->throw_file_ = b->throw_file_;
        a->throw_line_ = b->throw_line_;
        a->throw_function_ = b->throw_function_;
        a->throw_column_ = b->throw_column_;
        a->data_ = data;
}
inline void
copy_boost_exception(void *, void const *)
{
}
template <class T>
class

    clone_impl : public T,
                 public virtual clone_base
{
        struct clone_tag
        {
        };
        clone_impl(clone_impl const &x, clone_tag) : T(x)
        {
            copy_boost_exception(this, &x);
        }

    public:
        explicit clone_impl(T const &x) : T(x)
        {
            copy_boost_exception(this, &x);
        }
        ~clone_impl() throw()
        {
        }

    private:
        clone_base const *
        clone() const
        {
            return new clone_impl(*this, clone_tag());
        }
        void
        rethrow() const
        {
            throw *this;
        }
};
    }
    template <class T>
    inline exception_detail::clone_impl<T>
    enable_current_exception(T const &x)
    {
return exception_detail::clone_impl<T>(x);
    }
}
namespace boost
{
    namespace detail
    {
typedef char (&wrapexcept_s1)[1];
typedef char (&wrapexcept_s2)[2];
template <class T>
wrapexcept_s1 wrapexcept_is_convertible(T *);
template <class T>
wrapexcept_s2 wrapexcept_is_convertible(void *);
template <class E, class B, std::size_t I = sizeof(wrapexcept_is_convertible<B>(static_cast<E *>(0)))>
struct wrapexcept_add_base;
template <class E, class B>
struct wrapexcept_add_base<E, B, 1>
{
        struct type
        {
        };
};
template <class E, class B>
struct wrapexcept_add_base<E, B, 2>
{
        typedef B type;
};
    }
    template <class E>
    struct wrapexcept : public detail::wrapexcept_add_base<E, boost::exception_detail::clone_base>::type,
                        public E,
                        public detail::wrapexcept_add_base<E, boost::exception>::type
    {
private:
struct deleter
{
        wrapexcept *p_;
        ~deleter() { delete p_; }
};

private:
void copy_from(void const *)
{
}
void copy_from(boost::exception const *p)
{
        static_cast<boost::exception &>(*this) = *p;
}

public:
explicit wrapexcept(E const &e) : E(e)
{
        copy_from(&e);
}
explicit wrapexcept(E const &e, boost::source_location const &loc) : E(e)
{
        copy_from(&e);
        set_info(*this, throw_file(loc.file_name()));
        set_info(*this, throw_line(loc.line()));
        set_info(*this, throw_function(loc.function_name()));
        set_info(*this, throw_column(loc.column()));
}
virtual boost::exception_detail::clone_base const *clone() const
{
        wrapexcept *p = new wrapexcept(*this);
        deleter del = {p};
        boost::exception_detail::copy_boost_exception(p, this);
        del.p_ = 0;
        return p;
}
virtual void rethrow() const
{
        throw *this;
}
    };
    inline void throw_exception_assert_compatibility(std::exception const &) {}
    template <class E>
    __attribute__((__noreturn__)) void throw_exception(E const &e)
    {
throw_exception_assert_compatibility(e);
throw wrapexcept<E>(e);
    }
    template <class E>
    __attribute__((__noreturn__)) void throw_exception(E const &e, boost::source_location const &loc)
    {
throw_exception_assert_compatibility(e);
throw wrapexcept<E>(e, loc);
    }
}
namespace boost
{
    namespace detail
    {
struct throw_location
{
        boost::source_location location_;
        explicit throw_location(boost::source_location const &loc) : location_(loc)
        {
        }
};
template <class E>
class with_throw_location : public E, public throw_location
{
    public:
        with_throw_location(E const &e, boost::source_location const &loc) : E(e), throw_location(loc)
        {
        }
};
    }
    template <class E>
    __attribute__((__noreturn__)) void throw_with_location(E const &e, boost::source_location const &loc = ::boost::source_location(__builtin_FILE(), __builtin_LINE(), __builtin_FUNCTION(), __builtin_COLUMN()))
    {
throw_exception_assert_compatibility(e);
throw detail::with_throw_location<E>(e, loc);
    }
    template <class E>
    boost::source_location get_throw_location(E const &e)
    {
if (detail::throw_location const *pl = dynamic_cast<detail::throw_location const *>(&e))
{
        return pl->location_;
}
else if (boost::exception const *px = dynamic_cast<boost::exception const *>(&e))
{
        return exception_detail::get_exception_throw_location(*px);
}
else
{
        return boost::source_location();
}
    }
}
namespace boost
{
    template <bool b, class T, class U>
    struct conditional
    {
typedef T type;
    };
    template <class T, class U>
    struct conditional<false, T, U>
    {
typedef U type;
    };
}
namespace mpl_
{
    template <bool B>
    struct bool_;
    template <class I, I val>
    struct integral_c;
    struct integral_c_tag;
}
namespace boost
{
    namespace mpl
    {
using ::mpl_::bool_;
using ::mpl_::integral_c;
using ::mpl_::integral_c_tag;
    }
}
namespace boost
{
    template <class T, T val>
    struct integral_constant
    {
typedef mpl::integral_c_tag tag;
typedef T value_type;
typedef integral_constant<T, val> type;
static const T value = val;
operator const mpl::integral_c<T, val> &() const
{
        static const char data[sizeof(long)] = {0};
        static const void *pdata = data;
        return *(reinterpret_cast<const mpl::integral_c<T, val> *>(pdata));
}
operator T() const { return val; }
    };
    template <class T, T val>
    T const integral_constant<T, val>::value;
    template <bool val>
    struct integral_constant<bool, val>
    {
typedef mpl::integral_c_tag tag;
typedef bool value_type;
typedef integral_constant<bool, val> type;
static const bool value = val;
operator const mpl::bool_<val> &() const
{
        static const char data[sizeof(long)] = {0};
        static const void *pdata = data;
        return *(reinterpret_cast<const mpl::bool_<val> *>(pdata));
}
operator bool() const { return val; }
    };
    template <bool val>
    bool const integral_constant<bool, val>::value;
    typedef integral_constant<bool, true> true_type;
    typedef integral_constant<bool, false> false_type;
}
namespace boost
{
    template <class T>
    struct remove_cv
    {
typedef T type;
    };
    template <class T>
    struct remove_cv<T const>
    {
typedef T type;
    };
    template <class T>
    struct remove_cv<T volatile>
    {
typedef T type;
    };
    template <class T>
    struct remove_cv<T const volatile>
    {
typedef T type;
    };
    template <class T, std::size_t N>
    struct remove_cv<T const [N]>
    { typedef T type[N]; };
    template <class T, std::size_t N>
    struct remove_cv<T const volatile [N]>
    { typedef T type[N]; };
    template <class T, std::size_t N>
    struct remove_cv<T volatile [N]>
    { typedef T type[N]; };
    template <class T>
    struct remove_cv<T const[]> { typedef T type[]; };
    template <class T>
    struct remove_cv<T const volatile[]> { typedef T type[]; };
    template <class T>
    struct remove_cv<T volatile[]> { typedef T type[]; };
}
namespace boost
{
    template <class T, class U>
    struct is_same : public false_type
    {
    };
    template <class T>
    struct is_same<T, T> : public true_type
    {
    };
}

namespace boost
{
    namespace detail
    {
template <typename B, typename D>
struct is_base_and_derived_impl
{
        typedef typename remove_cv<B>::type ncvB;
        typedef typename remove_cv<D>::type ncvD;
        static const bool value = ((__is_base_of(B, D) && !is_same<B, D>::value) && !::boost::is_same<ncvB, ncvD>::value);
};
    }
    template <class Base, class Derived>
    struct is_base_and_derived
        : public integral_constant<bool, (::boost::detail::is_base_and_derived_impl<Base, Derived>::value)>
    {
    };
    template <class Base, class Derived>
    struct is_base_and_derived<Base &, Derived> : public false_type
    {
    };
    template <class Base, class Derived>
    struct is_base_and_derived<Base, Derived &> : public false_type
    {
    };
    template <class Base, class Derived>
    struct is_base_and_derived<Base &, Derived &> : public false_type
    {
    };
}

namespace boost
{
    namespace detail
    {
template <typename T>
struct is_class_impl
{
        static const bool value = __is_class(T);
};
    }
    template <class T>
    struct is_class : public integral_constant<bool, ::boost::detail::is_class_impl<T>::value>
    {
    };
}

namespace boost
{
    namespace detail
    {
template <class B, class D>
struct is_base_of_imp
{
        typedef typename remove_cv<B>::type ncvB;
        typedef typename remove_cv<D>::type ncvD;
        static const bool value = ((::boost::detail::is_base_and_derived_impl<ncvB, ncvD>::value) || (::boost::is_same<ncvB, ncvD>::value && ::boost::is_class<ncvB>::value));
};
    }
    template <class Base, class Derived>
    struct is_base_of
        : public integral_constant<bool, (::boost::detail::is_base_of_imp<Base, Derived>::value)>
    {
    };
    template <class Base, class Derived>
    struct is_base_of<Base, Derived &> : false_type
    {
    };
    template <class Base, class Derived>
    struct is_base_of<Base &, Derived &> : false_type
    {
    };
    template <class Base, class Derived>
    struct is_base_of<Base &, Derived> : false_type
    {
    };
}

namespace boost
{
    namespace CV
    {
enum violation_enum
{
    min_violation,
    max_violation
};
template <class value_policies>
class constrained_value
{
    public:
        typedef typename value_policies::value_type value_type;
        constrained_value(value_type value) : value_((min)())
        {
            assign(value);
        }
        constrained_value &operator=(value_type v)
        {
            assign(v);
            return *this;
        }
        static value_type
        max() { return (value_policies::max)(); }
        static value_type
        min() { return (value_policies::min)(); }
        operator value_type() const { return value_; }

    protected:
        value_type value_;

    private:
        void assign(value_type value)
        {
            if (value + 1 < (min)() + 1)
            {
                value_policies::on_error(value_, value, min_violation);
                return;
            }
            if (value > (max)())
            {
                value_policies::on_error(value_, value, max_violation);
                return;
            }
            value_ = value;
        }
};
template <typename rep_type, rep_type min_value,
          rep_type max_value, class exception_type>
class simple_exception_policy
{
        struct exception_wrapper : public exception_type
        {
            operator std::out_of_range() const
            {
                return std::out_of_range("constrained value boundary has been violated");
            }
        };
        typedef typename conditional<
            is_base_of<std::exception, exception_type>::value,
            exception_type,
            exception_wrapper>::type actual_exception_type;

    public:
        typedef rep_type value_type;
        static rep_type
        min() { return min_value; }
        static rep_type
        max() { return max_value; }
        static void on_error(rep_type, rep_type, violation_enum)
        {
            boost::throw_exception(actual_exception_type());
        }
};
    }
}
namespace boost
{
    namespace date_time
    {
enum weekdays
{
    Sunday,
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday
};
enum months_of_year
{
    Jan = 1,
    Feb,
    Mar,
    Apr,
    May,
    Jun,
    Jul,
    Aug,
    Sep,
    Oct,
    Nov,
    Dec,
    NotAMonth,
    NumMonths
};
    }
}
namespace boost
{
    namespace gregorian
    {
using date_time::Friday;
using date_time::Monday;
using date_time::Saturday;
using date_time::Sunday;
using date_time::Thursday;
using date_time::Tuesday;
using date_time::Wednesday;
struct bad_weekday : public std::out_of_range
{
        bad_weekday() : std::out_of_range(std::string("Weekday is out of range 0..6")) {}
};
typedef CV::simple_exception_policy<unsigned short, 0, 6, bad_weekday> greg_weekday_policies;
typedef CV::constrained_value<greg_weekday_policies> greg_weekday_rep;
class greg_weekday : public greg_weekday_rep
{
    public:
        typedef boost::date_time::weekdays weekday_enum;
        greg_weekday(value_type day_of_week_num) : greg_weekday_rep(day_of_week_num)
        {
        }
        value_type as_number() const { return value_; }
        weekday_enum as_enum() const { return static_cast<weekday_enum>(value_); }
        const char *as_short_string() const
        {
            static const char *const short_weekday_names[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
            return short_weekday_names[value_];
        }
        const char *as_long_string() const
        {
            static const char *const long_weekday_names[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
            return long_weekday_names[value_];
        }
        const wchar_t *as_short_wstring() const
        {
            static const wchar_t *const w_short_weekday_names[] = {L"Sun", L"Mon", L"Tue",
                                                                   L"Wed", L"Thu", L"Fri", L"Sat"};
            return w_short_weekday_names[value_];
        }
        const wchar_t *as_long_wstring() const
        {
            static const wchar_t *const w_long_weekday_names[] = {L"Sunday", L"Monday", L"Tuesday",
                                                                  L"Wednesday", L"Thursday",
                                                                  L"Friday", L"Saturday"};
            return w_long_weekday_names[value_];
        }
};
    }
}
namespace boost
{
    namespace gregorian
    {
struct bad_day_of_year : public std::out_of_range
{
        bad_day_of_year() : std::out_of_range(std::string("Day of year value is out of range 1..366"))
        {
        }
};
typedef CV::simple_exception_policy<unsigned short, 1, 366, bad_day_of_year> greg_day_of_year_policies;
typedef CV::constrained_value<greg_day_of_year_policies> greg_day_of_year_rep;
    }
}
namespace boost
{
    namespace date_time
    {
template <typename ymd_type_, typename date_int_type_>  //FIXME:base
class gregorian_calendar_base
{
    public:
        typedef ymd_type_ ymd_type;
        typedef typename ymd_type::month_type month_type;
        typedef typename ymd_type::day_type day_type;
        typedef typename ymd_type::year_type year_type;
        typedef date_int_type_ date_int_type;
        static unsigned short day_of_week(const ymd_type &ymd);
        static int week_number(const ymd_type &ymd);
        static date_int_type day_number(const ymd_type &ymd);
        static date_int_type julian_day_number(const ymd_type &ymd);
        static date_int_type modjulian_day_number(const ymd_type &ymd);
        static ymd_type from_day_number(date_int_type);
        static ymd_type from_julian_day_number(date_int_type);
        static ymd_type from_modjulian_day_number(date_int_type);
        static bool is_leap_year(year_type);
        static unsigned short end_of_month_day(year_type y, month_type m);
        static ymd_type epoch();
        static unsigned short days_in_week();
};
    }
}
namespace boost
{
    namespace date_time
    {
template <typename ymd_type_, typename date_int_type_>
inline unsigned short
gregorian_calendar_base<ymd_type_, date_int_type_>::day_of_week(const ymd_type &ymd)
{
        unsigned short a = static_cast<unsigned short>((14 - ymd.month) / 12);
        unsigned short y = static_cast<unsigned short>(ymd.year - a);
        unsigned short m = static_cast<unsigned short>(ymd.month + 12 * a - 2);
        unsigned short d = static_cast<unsigned short>((ymd.day + y + (y / 4) - (y / 100) + (y / 400) + (31 * m) / 12) % 7);
        return d;
}
template <typename ymd_type_, typename date_int_type_>
inline int
gregorian_calendar_base<ymd_type_, date_int_type_>::week_number(const ymd_type &ymd)
{
        unsigned long julianbegin = julian_day_number(ymd_type(ymd.year, 1, 1));
        unsigned long juliantoday = julian_day_number(ymd);
        unsigned long day = (julianbegin + 3) % 7;
        unsigned long week = (juliantoday + day - julianbegin + 4) / 7;
        if ((week >= 1) && (week <= 52))
        {
            return static_cast<int>(week);
        }
        if (week == 53)
        {
            if ((day == 6) || (day == 5 && is_leap_year(ymd.year)))
            {
                return static_cast<int>(week);
            }
            else
            {
                return 1;
            }
        }
        else if (week == 0)
        {
            julianbegin = julian_day_number(ymd_type(static_cast<unsigned short>(ymd.year - 1), 1, 1));
            juliantoday = julian_day_number(ymd);
            day = (julianbegin + 3) % 7;
            week = (juliantoday + day - julianbegin + 4) / 7;
            return static_cast<int>(week);
        }
        return static_cast<int>(week);
}
template <typename ymd_type_, typename date_int_type_>
inline date_int_type_
gregorian_calendar_base<ymd_type_, date_int_type_>::day_number(const ymd_type &ymd)
{
        unsigned short a = static_cast<unsigned short>((14 - ymd.month) / 12);
        unsigned short y = static_cast<unsigned short>(ymd.year + 4800 - a);
        unsigned short m = static_cast<unsigned short>(ymd.month + 12 * a - 3);
        unsigned long d = static_cast<unsigned long>(ymd.day) + ((153 * m + 2) / 5) + 365 * y + (y / 4) - (y / 100) + (y / 400) - 32045;
        return static_cast<date_int_type>(d);
}
template <typename ymd_type_, typename date_int_type_>
inline date_int_type_
gregorian_calendar_base<ymd_type_, date_int_type_>::julian_day_number(const ymd_type &ymd)
{
        return day_number(ymd);
}
template <typename ymd_type_, typename date_int_type_>
inline date_int_type_
gregorian_calendar_base<ymd_type_, date_int_type_>::modjulian_day_number(const ymd_type &ymd)
{
        return julian_day_number(ymd) - 2400001;
}
template <typename ymd_type_, typename date_int_type_>
inline ymd_type_
gregorian_calendar_base<ymd_type_, date_int_type_>::from_day_number(date_int_type dayNumber)
{
        date_int_type a = dayNumber + 32044;
        date_int_type b = (4 * a + 3) / 146097;
        date_int_type c = a - ((146097 * b) / 4);
        date_int_type d = (4 * c + 3) / 1461;
        date_int_type e = c - (1461 * d) / 4;
        date_int_type m = (5 * e + 2) / 153;
        unsigned short day = static_cast<unsigned short>(e - ((153 * m + 2) / 5) + 1);
        unsigned short month = static_cast<unsigned short>(m + 3 - 12 * (m / 10));
        year_type year = static_cast<unsigned short>(100 * b + d - 4800 + (m / 10));
        return ymd_type(static_cast<unsigned short>(year), month, day);
}
template <typename ymd_type_, typename date_int_type_>
inline ymd_type_
gregorian_calendar_base<ymd_type_, date_int_type_>::from_julian_day_number(date_int_type dayNumber)
{
        date_int_type a = dayNumber + 32044;
        date_int_type b = (4 * a + 3) / 146097;
        date_int_type c = a - ((146097 * b) / 4);
        date_int_type d = (4 * c + 3) / 1461;
        date_int_type e = c - ((1461 * d) / 4);
        date_int_type m = (5 * e + 2) / 153;
        unsigned short day = static_cast<unsigned short>(e - ((153 * m + 2) / 5) + 1);
        unsigned short month = static_cast<unsigned short>(m + 3 - 12 * (m / 10));
        year_type year = static_cast<year_type>(100 * b + d - 4800 + (m / 10));
        return ymd_type(year, month, day);
}
template <typename ymd_type_, typename date_int_type_>
inline ymd_type_
gregorian_calendar_base<ymd_type_, date_int_type_>::from_modjulian_day_number(date_int_type dayNumber)
{
        date_int_type jd = dayNumber + 2400001;
        return from_julian_day_number(jd);
}
template <typename ymd_type_, typename date_int_type_>
inline bool
gregorian_calendar_base<ymd_type_, date_int_type_>::is_leap_year(year_type year)
{
        return (!(year % 4)) && ((year % 100) || (!(year % 400)));
}
template <typename ymd_type_, typename date_int_type_>
inline unsigned short
gregorian_calendar_base<ymd_type_, date_int_type_>::end_of_month_day(year_type year,
                                                                     month_type month)
{
        switch (month)
        {
        case 2:
            if (is_leap_year(year))
            {
                return 29;
            }
            else
            {
                return 28;
            }
        case 4:
        case 6:
        case 9:
        case 11:
            return 30;
        default:
            return 31;
        }
}
template <typename ymd_type_, typename date_int_type_>
inline ymd_type_
gregorian_calendar_base<ymd_type_, date_int_type_>::epoch()
{
        return ymd_type(1400, 1, 1);
}
template <typename ymd_type_, typename date_int_type_>
inline unsigned short
gregorian_calendar_base<ymd_type_, date_int_type_>::days_in_week()
{
        return 7;
}
    }
}
namespace boost
{
    namespace gregorian
    {
struct bad_day_of_month : public std::out_of_range
{
        bad_day_of_month() : std::out_of_range(std::string("Day of month value is out of range 1..31"))
        {
        }
        bad_day_of_month(const std::string &s) : std::out_of_range(s)
        {
        }
};
typedef CV::simple_exception_policy<unsigned short, 1, 31, bad_day_of_month> greg_day_policies;
typedef CV::constrained_value<greg_day_policies> greg_day_rep;
class greg_day : public greg_day_rep
{
    public:
        greg_day(value_type day_of_month) : greg_day_rep(day_of_month) {}
        value_type as_number() const { return value_; }
        operator value_type() const { return value_; }

    private:
};
    }
}
namespace boost
{
    namespace gregorian
    {
struct bad_year : public std::out_of_range
{
        bad_year() : std::out_of_range(std::string("Year is out of valid range: 1400..9999"))
        {
        }
};
typedef CV::simple_exception_policy<unsigned short, 1400, 9999, bad_year> greg_year_policies;
typedef CV::constrained_value<greg_year_policies> greg_year_rep;
class greg_year : public greg_year_rep
{
    public:
        greg_year(value_type year) : greg_year_rep(year) {}
        operator value_type() const { return value_; }
};
    }
}
namespace boost
{
    namespace gregorian
    {
typedef date_time::months_of_year months_of_year;
using date_time::Apr;
using date_time::Aug;
using date_time::Dec;
using date_time::Feb;
using date_time::Jan;
using date_time::Jul;
using date_time::Jun;
using date_time::Mar;
using date_time::May;
using date_time::NotAMonth;
using date_time::Nov;
using date_time::NumMonths;
using date_time::Oct;
using date_time::Sep;
struct bad_month : public std::out_of_range
{
        bad_month() : std::out_of_range(std::string("Month number is out of range 1..12")) {}
};
typedef CV::simple_exception_policy<unsigned short, 1, 12, bad_month> greg_month_policies;
typedef CV::constrained_value<greg_month_policies> greg_month_rep;
class greg_month : public greg_month_rep
{
    public:
        typedef date_time::months_of_year month_enum;
        greg_month(month_enum theMonth) : greg_month_rep(static_cast<greg_month_rep::value_type>(theMonth)) {}
        greg_month(value_type theMonth) : greg_month_rep(theMonth) {}
        operator value_type() const { return value_; }
        value_type as_number() const { return value_; }
        month_enum as_enum() const { return static_cast<month_enum>(value_); }
        const char *
        as_short_string() const
        {
            static const char *const short_month_names[NumMonths] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "NAM"};
            return short_month_names[value_ - 1];
        }
        const char *
        as_long_string() const
        {
            static const char *const long_month_names[NumMonths] = {"January", "February", "March", "April", "May", "June", "July", "August",
                                                                    "September", "October", "November", "December", "NotAMonth"};
            return long_month_names[value_ - 1];
        }
        const wchar_t *
        as_short_wstring() const
        {
            static const wchar_t *const w_short_month_names[NumMonths] = {L"Jan", L"Feb", L"Mar", L"Apr", L"May", L"Jun", L"Jul", L"Aug", L"Sep", L"Oct",
                                                                          L"Nov", L"Dec", L"NAM"};
            return w_short_month_names[value_ - 1];
        }
        const wchar_t *
        as_long_wstring() const
        {
            static const wchar_t *const w_long_month_names[NumMonths] = {L"January", L"February", L"March", L"April", L"May", L"June", L"July", L"August",
                                                                         L"September", L"October", L"November", L"December", L"NotAMonth"};
            return w_long_month_names[value_ - 1];
        }
        const char *as_short_string(char) const
        {
            return as_short_string();
        }
        const char *as_long_string(char) const
        {
            return as_long_string();
        }
        const wchar_t *as_short_string(wchar_t) const
        {
            return as_short_wstring();
        }
        const wchar_t *as_long_string(wchar_t) const
        {
            return as_long_wstring();
        }
};
    }
}

namespace boost
{
    namespace gregorian
    {
typedef date_time::year_month_day_base<greg_year,
                                       greg_month,
                                       greg_day>
    greg_year_month_day;
    }
}
namespace std
{
    inline namespace __1
    {
template <size_t _N_words, size_t _Size>
class __bitset;
template <size_t _N_words, size_t _Size>
struct __has_storage_type<__bitset<_N_words, _Size>>
{
        static const bool value = true;
};
template <size_t _N_words, size_t _Size>
class __bitset
{
    public:
        typedef ptrdiff_t difference_type;
        typedef size_t size_type;
        typedef size_type __storage_type;

    protected:
        typedef __bitset __self;
        typedef __storage_type *__storage_pointer;
        typedef const __storage_type *__const_storage_pointer;
        static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);
        friend class __bit_reference<__bitset>;
        friend class __bit_const_reference<__bitset>;
        friend class __bit_iterator<__bitset, false>;
        friend class __bit_iterator<__bitset, true>;
        friend struct __bit_array<__bitset>;
        __storage_type __first_[_N_words];
        typedef __bit_reference<__bitset> reference;
        typedef __bit_const_reference<__bitset> const_reference;
        typedef __bit_iterator<__bitset, false> iterator;
        typedef __bit_iterator<__bitset, true> const_iterator;

        __bitset() throw();

        explicit __bitset(unsigned long long __v) throw();

        {
            return reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);
        }

        {
            return const_reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);
        }

        {
            return iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);
        }

        {
            return const_iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);
        }

        void operator&=(const __bitset &__v) throw();

        void operator|=(const __bitset &__v) throw();

        void operator^=(const __bitset &__v) throw();
        void flip() throw();
        const
        {
            return to_ulong(integral_constant < bool, _Size<sizeof(unsigned long) * 8>());
        }
        const
        {
            return to_ullong(integral_constant < bool, _Size<sizeof(unsigned long long) * 8>());
        }
        bool all() const throw();
        bool any() const throw();

        size_t __hash_code() const throw();

    private:
        void __init(unsigned long long __v, false_type) throw();

        void __init(unsigned long long __v, true_type) throw();
        unsigned long to_ulong(false_type) const;

        unsigned long to_ulong(true_type) const;
        unsigned long long to_ullong(false_type) const;

        unsigned long long to_ullong(true_type) const;

        unsigned long long to_ullong(true_type, false_type) const;
        unsigned long long to_ullong(true_type, true_type) const;
};
template <size_t _N_words, size_t _Size>
inline __bitset<_N_words, _Size>::__bitset() throw()
{
        std::fill_n(__first_, _N_words, __storage_type(0));
}
template <size_t _N_words, size_t _Size>
void __bitset<_N_words, _Size>::__init(unsigned long long __v, false_type) throw()
{
        __storage_type __t[sizeof(unsigned long long) / sizeof(__storage_type)];
        size_t __sz = _Size;
        for (size_t __i = 0; __i < sizeof(__t) / sizeof(__t[0]); ++__i, __v >>= __bits_per_word, __sz -= __bits_per_word)
            if (__sz < __bits_per_word)
                __t[__i] = static_cast<__storage_type>(__v) & (1ULL << __sz) - 1;
            else
                __t[__i] = static_cast<__storage_type>(__v);
        std::copy(__t, __t + sizeof(__t) / sizeof(__t[0]), __first_);
        std::fill(__first_ + sizeof(__t) / sizeof(__t[0]), __first_ + sizeof(__first_) / sizeof(__first_[0]),
                  __storage_type(0));
}
template <size_t _N_words, size_t _Size>
inline void
__bitset<_N_words, _Size>::__init(unsigned long long __v, true_type) throw()
{
        __first_[0] = __v;
        if (_Size < __bits_per_word)
            __first_[0] &= (1ULL << _Size) - 1;
        std::fill(__first_ + 1, __first_ + sizeof(__first_) / sizeof(__first_[0]), __storage_type(0));
}
template <size_t _N_words, size_t _Size>
inline __bitset<_N_words, _Size>::__bitset(unsigned long long __v) throw()
{
        __init(__v, integral_constant<bool, sizeof(unsigned long long) == sizeof(__storage_type)>());
}
template <size_t _N_words, size_t _Size>
inline void
__bitset<_N_words, _Size>::operator&=(const __bitset &__v) throw()
{
        for (size_type __i = 0; __i < _N_words; ++__i)
            __first_[__i] &= __v.__first_[__i];
}
template <size_t _N_words, size_t _Size>
inline void
__bitset<_N_words, _Size>::operator|=(const __bitset &__v) throw()
{
        for (size_type __i = 0; __i < _N_words; ++__i)
            __first_[__i] |= __v.__first_[__i];
}
template <size_t _N_words, size_t _Size>
inline void
__bitset<_N_words, _Size>::operator^=(const __bitset &__v) throw()
{
        for (size_type __i = 0; __i < _N_words; ++__i)
            __first_[__i] ^= __v.__first_[__i];
}
template <size_t _N_words, size_t _Size>
void __bitset<_N_words, _Size>::flip() throw()
{
        size_type __n = _Size;
        __storage_pointer __p = __first_;
        for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
            *__p = ~*__p;
        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__p & __m;
            *__p &= ~__m;
            *__p |= ~__b & __m;
        }
}
template <size_t _N_words, size_t _Size>
unsigned long
__bitset<_N_words, _Size>::to_ulong(false_type) const
{
        const_iterator __e = __make_iter(_Size);
        const_iterator __i = std::find(__make_iter(sizeof(unsigned long) * 8), __e, true);
        if (__i != __e)
            __throw_overflow_error("bitset to_ulong overflow error");
        return __first_[0];
}
template <size_t _N_words, size_t _Size>
inline unsigned long
__bitset<_N_words, _Size>::to_ulong(true_type) const
{
        return __first_[0];
}
template <size_t _N_words, size_t _Size>
unsigned long long
__bitset<_N_words, _Size>::to_ullong(false_type) const
{
        const_iterator __e = __make_iter(_Size);
        const_iterator __i = std::find(__make_iter(sizeof(unsigned long long) * 8), __e, true);
        if (__i != __e)
            __throw_overflow_error("bitset to_ullong overflow error");
        return to_ullong(true_type());
}
template <size_t _N_words, size_t _Size>
inline unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type) const
{
        return to_ullong(true_type(), integral_constant<bool, sizeof(__storage_type) < sizeof(unsigned long long)>());
}
template <size_t _N_words, size_t _Size>
inline unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, false_type) const
{
        return __first_[0];
}
template <size_t _N_words, size_t _Size>
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, true_type) const
{
        unsigned long long __r = __first_[0];
        for (size_t __i = 1; __i < sizeof(unsigned long long) / sizeof(__storage_type); ++__i)
            __r |= static_cast<unsigned long long>(__first_[__i]) << (sizeof(__storage_type) * 8);
        return __r;
}
template <size_t _N_words, size_t _Size>
bool __bitset<_N_words, _Size>::all() const throw()
{
        size_type __n = _Size;
        __const_storage_pointer __p = __first_;
        for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
            if (~*__p)
                return false;
        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            if (~*__p & __m)
                return false;
        }
        return true;
}
template <size_t _N_words, size_t _Size>
bool __bitset<_N_words, _Size>::any() const throw()
{
        size_type __n = _Size;
        __const_storage_pointer __p = __first_;
        for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
            if (*__p)
                return true;
        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            if (*__p & __m)
                return true;
        }
        return false;
}
template <size_t _N_words, size_t _Size>
inline size_t
__bitset<_N_words, _Size>::__hash_code() const throw()
{
        size_t __h = 0;
        for (size_type __i = 0; __i < _N_words; ++__i)
            __h ^= __first_[__i];
        return __h;
}
template <size_t _Size>
class __bitset<1, _Size>
{
    public:
        typedef ptrdiff_t difference_type;
        typedef size_t size_type;
        typedef size_type __storage_type;

    protected:
        typedef __bitset __self;
        typedef __storage_type *__storage_pointer;
        typedef const __storage_type *__const_storage_pointer;
        static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);
        friend class __bit_reference<__bitset>;
        friend class __bit_const_reference<__bitset>;
        friend class __bit_iterator<__bitset, false>;
        friend class __bit_iterator<__bitset, true>;
        friend struct __bit_array<__bitset>;
        __storage_type __first_;
        typedef __bit_reference<__bitset> reference;
        typedef __bit_const_reference<__bitset> const_reference;
        typedef __bit_iterator<__bitset, false> iterator;
        typedef __bit_iterator<__bitset, true> const_iterator;

        __bitset() throw();

        explicit __bitset(unsigned long long __v) throw();

        {
            return reference(&__first_, __storage_type(1) << __pos);
        }

        {
            return const_reference(&__first_, __storage_type(1) << __pos);
        }

        {
            return iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);
        }

        {
            return const_iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);
        }

        void operator&=(const __bitset &__v) throw();

        void operator|=(const __bitset &__v) throw();

        void operator^=(const __bitset &__v) throw();

        void flip() throw();

        unsigned long to_ulong() const;

        unsigned long long to_ullong() const;

        bool all() const throw();

        bool any() const throw();

        size_t __hash_code() const throw();
};
template <size_t _Size>
inline __bitset<1, _Size>::__bitset() throw()
    : __first_(0)
{
}
template <size_t _Size>
inline __bitset<1, _Size>::__bitset(unsigned long long __v) throw()
    : __first_(
          _Size == __bits_per_word ? static_cast<__storage_type>(__v)
                                   : static_cast<__storage_type>(__v) & ((__storage_type(1) << _Size) - 1))
{
}
template <size_t _Size>
inline void
__bitset<1, _Size>::operator&=(const __bitset &__v) throw()
{
        __first_ &= __v.__first_;
}
template <size_t _Size>
inline void
__bitset<1, _Size>::operator|=(const __bitset &__v) throw()
{
        __first_ |= __v.__first_;
}
template <size_t _Size>
inline void
__bitset<1, _Size>::operator^=(const __bitset &__v) throw()
{
        __first_ ^= __v.__first_;
}
template <size_t _Size>
inline void
__bitset<1, _Size>::flip() throw()
{
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
        __first_ = ~__first_;
        __first_ &= __m;
}
template <size_t _Size>
inline unsigned long
__bitset<1, _Size>::to_ulong() const
{
        return __first_;
}
template <size_t _Size>
inline unsigned long long
__bitset<1, _Size>::to_ullong() const
{
        return __first_;
}
template <size_t _Size>
inline bool
__bitset<1, _Size>::all() const throw()
{
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
        return !(~__first_ & __m);
}
template <size_t _Size>
inline bool
__bitset<1, _Size>::any() const throw()
{
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
        return __first_ & __m;
}
template <size_t _Size>
inline size_t
__bitset<1, _Size>::__hash_code() const throw()
{
        return __first_;
}
template <>
class __bitset<0, 0>
{
    public:
        typedef ptrdiff_t difference_type;
        typedef size_t size_type;
        typedef size_type __storage_type;

    protected:
        typedef __bitset __self;
        typedef __storage_type *__storage_pointer;
        typedef const __storage_type *__const_storage_pointer;
        static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);
        friend class __bit_reference<__bitset>;
        friend class __bit_const_reference<__bitset>;
        friend class __bit_iterator<__bitset, false>;
        friend class __bit_iterator<__bitset, true>;
        friend struct __bit_array<__bitset>;
        typedef __bit_reference<__bitset> reference;
        typedef __bit_const_reference<__bitset> const_reference;
        typedef __bit_iterator<__bitset, false> iterator;
        typedef __bit_iterator<__bitset, true> const_iterator;

        __bitset() throw();

        explicit __bitset(unsigned long long) throw();

        {
            return reference(__nullptr, 1);
        }

        {
            return const_reference(__nullptr, 1);
        }

        {
            return iterator(__nullptr, 0);
        }

        {
            return const_iterator(__nullptr, 0);
        }
        {} {} {} {
        }
        const { return 0; }
        const { return 0; }
        {
            return true;
        }
        {
            return false;
        }
        {
            return 0;
        }
};
inline __bitset<0, 0>::__bitset() throw()
{
}
inline __bitset<0, 0>::__bitset(unsigned long long) throw()
{
}
template <size_t _Size>
class bitset;
template <size_t _Size>
struct hash<bitset<_Size>>;
template <size_t _Size>
class bitset
    : private __bitset<_Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1, _Size>
{
    public:
        static const unsigned __n_words = _Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1;
        typedef __bitset<__n_words, _Size> base;

    public:
        typedef typename base::reference reference;
        typedef typename base::const_reference const_reference;
        {
        }

        bitset(unsigned long long __v) throw() : base(__v) {}
        template <class _CharT, class = __enable_if_t<_IsCharLikeType<_CharT>::value>>
        explicit bitset(const _CharT *__str,
                        typename basic_string<_CharT>::size_type __n = basic_string<_CharT>::npos,
                        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));
        template <class _CharT, class _Traits, class _Allocator>
        explicit bitset(const basic_string<_CharT, _Traits, _Allocator> &__str,
                        typename basic_string<_CharT, _Traits, _Allocator>::size_type __pos = 0,
                        typename basic_string<_CharT, _Traits, _Allocator>::size_type __n =
                            (basic_string<_CharT, _Traits, _Allocator>::npos),
                        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));

        bitset &operator&=(const bitset &__rhs) throw();

        bitset &operator|=(const bitset &__rhs) throw();

        bitset &operator^=(const bitset &__rhs) throw();
        bitset &operator<<=(size_t __pos) throw();
        bitset &operator>>=(size_t __pos) throw();

        bitset &set() throw();
        bitset &set(size_t __pos, bool __val = true);

        bitset &reset() throw();
        bitset &reset(size_t __pos);

        bitset operator~() const throw();

        bitset &flip() throw();
        bitset &flip(size_t __pos);
        ;
};
    }

    unsigned long to_ulong() const;

    unsigned long long to_ullong() const;
    template <class _CharT, class _Traits, class _Allocator>
    basic_string<_CharT, _Traits, _Allocator> to_string(_CharT __zero = _CharT('0'),
                                                        _CharT __one = _CharT('1')) const;
    template <class _CharT, class _Traits>

    basic_string<_CharT, _Traits, allocator<_CharT>> to_string(_CharT __zero = _CharT('0'),
                                                               _CharT __one = _CharT('1')) const;
    template <class _CharT>

    basic_string<_CharT, char_traits<_CharT>, allocator<_CharT>> to_string(_CharT __zero = _CharT('0'),
                                                                           _CharT __one = _CharT('1')) const;

    basic_string<char, char_traits<char>, allocator<char>> to_string(char __zero = '0',
                                                                     char __one = '1') const;

    size_t count() const throw();
    {
return _Size;
    }

    bool operator==(const bitset &__rhs) const throw();

    bool operator!=(const bitset &__rhs) const throw();
    bool test(size_t __pos) const;

    bool all() const throw();

    bool any() const throw();
    ;
}

bitset operator<<(size_t __pos) const throw();

bitset operator>>(size_t __pos) const throw();

private:
size_t __hash_code() const throw() { return base::__hash_code(); }
friend struct hash<bitset>;
}
;
template <size_t _Size>
template <class _CharT, class>
bitset<_Size>::bitset(const _CharT *__str,
                      typename basic_string<_CharT>::size_type __n,
                      _CharT __zero, _CharT __one)
{
    size_t __rlen = std::min(__n, char_traits<_CharT>::length(__str));
    for (size_t __i = 0; __i < __rlen; ++__i)
if (__str[__i] != __zero && __str[__i] != __one)
        __throw_invalid_argument("bitset string ctor has invalid argument");
    size_t _Mp = std::min(__rlen, _Size);
    size_t __i = 0;
    for (; __i < _Mp; ++__i)
    {
_CharT __c = __str[_Mp - 1 - __i];
(*this)[__i] = (__c == __one);
    }
    std::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}
template <size_t _Size>
template <class _CharT, class _Traits, class _Allocator>
bitset<_Size>::bitset(const basic_string<_CharT, _Traits, _Allocator> &__str,
                      typename basic_string<_CharT, _Traits, _Allocator>::size_type __pos,
                      typename basic_string<_CharT, _Traits, _Allocator>::size_type __n,
                      _CharT __zero, _CharT __one)
{
    if (__pos > __str.size())
__throw_out_of_range("bitset string pos out of range");
    size_t __rlen = std::min(__n, __str.size() - __pos);
    for (size_t __i = __pos; __i < __pos + __rlen; ++__i)
if (!_Traits::eq(__str[__i], __zero) && !_Traits::eq(__str[__i], __one))
        __throw_invalid_argument("bitset string ctor has invalid argument");
    size_t _Mp = std::min(__rlen, _Size);
    size_t __i = 0;
    for (; __i < _Mp; ++__i)
    {
_CharT __c = __str[__pos + _Mp - 1 - __i];
(*this)[__i] = _Traits::eq(__c, __one);
    }
    std::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}
template <size_t _Size>
inline bitset<_Size> &
bitset<_Size>::operator&=(const bitset &__rhs) throw()
{
    base::operator&=(__rhs);
    return *this;
}
template <size_t _Size>
inline bitset<_Size> &
bitset<_Size>::operator|=(const bitset &__rhs) throw()
{
    base::operator|=(__rhs);
    return *this;
}
template <size_t _Size>
inline bitset<_Size> &
bitset<_Size>::operator^=(const bitset &__rhs) throw()
{
    base::operator^=(__rhs);
    return *this;
}
template <size_t _Size>
bitset<_Size> &
bitset<_Size>::operator<<=(size_t __pos) throw()
{
    __pos = std::min(__pos, _Size);
    std::copy_backward(base::__make_iter(0), base::__make_iter(_Size - __pos), base::__make_iter(_Size));
    std::fill_n(base::__make_iter(0), __pos, false);
    return *this;
}
template <size_t _Size>
bitset<_Size> &
bitset<_Size>::operator>>=(size_t __pos) throw()
{
    __pos = std::min(__pos, _Size);
    std::copy(base::__make_iter(__pos), base::__make_iter(_Size), base::__make_iter(0));
    std::fill_n(base::__make_iter(_Size - __pos), __pos, false);
    return *this;
}
template <size_t _Size>
inline bitset<_Size> &
bitset<_Size>::set() throw()
{
    std::fill_n(base::__make_iter(0), _Size, true);
    return *this;
}
template <size_t _Size>
bitset<_Size> &
bitset<_Size>::set(size_t __pos, bool __val)
{
    if (__pos >= _Size)
__throw_out_of_range("bitset set argument out of range");
    (*this)[__pos] = __val;
    return *this;
}
template <size_t _Size>
inline bitset<_Size> &
bitset<_Size>::reset() throw()
{
    std::fill_n(base::__make_iter(0), _Size, false);
    return *this;
}
template <size_t _Size>
bitset<_Size> &
bitset<_Size>::reset(size_t __pos)
{
    if (__pos >= _Size)
__throw_out_of_range("bitset reset argument out of range");
    (*this)[__pos] = false;
    return *this;
}
template <size_t _Size>
inline bitset<_Size>
bitset<_Size>::operator~() const throw()
{
    bitset __x(*this);
    __x.flip();
    return __x;
}
template <size_t _Size>
inline bitset<_Size> &
bitset<_Size>::flip() throw()
{
    base::flip();
    return *this;
}
template <size_t _Size>
bitset<_Size> &
bitset<_Size>::flip(size_t __pos)
{
    if (__pos >= _Size)
__throw_out_of_range("bitset flip argument out of range");
    reference r = base::__make_ref(__pos);
    r = ~r;
    return *this;
}
template <size_t _Size>
inline unsigned long
bitset<_Size>::to_ulong() const
{
    return base::to_ulong();
}
template <size_t _Size>
inline unsigned long long
bitset<_Size>::to_ullong() const
{
    return base::to_ullong();
}
template <size_t _Size>
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    basic_string<_CharT, _Traits, _Allocator> __r(_Size, __zero);
    for (size_t __i = 0; __i != _Size; ++__i)
    {
if ((*this)[__i])
        __r[_Size - 1 - __i] = __one;
    }
    return __r;
}
template <size_t _Size>
template <class _CharT, class _Traits>
inline basic_string<_CharT, _Traits, allocator<_CharT>>
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    return to_string<_CharT, _Traits, allocator<_CharT>>(__zero, __one);
}
template <size_t _Size>
template <class _CharT>
inline basic_string<_CharT, char_traits<_CharT>, allocator<_CharT>>
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    return to_string<_CharT, char_traits<_CharT>, allocator<_CharT>>(__zero, __one);
}
template <size_t _Size>
inline basic_string<char, char_traits<char>, allocator<char>>
bitset<_Size>::to_string(char __zero, char __one) const
{
    return to_string<char, char_traits<char>, allocator<char>>(__zero, __one);
}
template <size_t _Size>
inline size_t
bitset<_Size>::count() const throw()
{
    return static_cast<size_t>(std::__count_bool_true(base::__make_iter(0), _Size));
}
template <size_t _Size>
inline bool
bitset<_Size>::operator==(const bitset &__rhs) const throw()
{
    return std::equal(base::__make_iter(0), base::__make_iter(_Size), __rhs.__make_iter(0));
}
template <size_t _Size>
inline bool
bitset<_Size>::operator!=(const bitset &__rhs) const throw()
{
    return !(*this == __rhs);
}
template <size_t _Size>
bool bitset<_Size>::test(size_t __pos) const
{
    if (__pos >= _Size)
__throw_out_of_range("bitset test argument out of range");
    return (*this)[__pos];
}
template <size_t _Size>
inline bool
bitset<_Size>::all() const throw()
{
    return base::all();
}
template <size_t _Size>
inline bool
bitset<_Size>::any() const throw()
{
    return base::any();
}
template <size_t _Size>
inline bitset<_Size>
bitset<_Size>::operator<<(size_t __pos) const throw()
{
    bitset __r = *this;
    __r <<= __pos;
    return __r;
}
template <size_t _Size>
inline bitset<_Size>
bitset<_Size>::operator>>(size_t __pos) const throw()
{
    bitset __r = *this;
    __r >>= __pos;
    return __r;
}
template <size_t _Size>
inline bitset<_Size>
operator&(const bitset<_Size> &__x, const bitset<_Size> &__y) throw()
{
    bitset<_Size> __r = __x;
    __r &= __y;
    return __r;
}
template <size_t _Size>
inline bitset<_Size>
operator|(const bitset<_Size> &__x, const bitset<_Size> &__y) throw()
{
    bitset<_Size> __r = __x;
    __r |= __y;
    return __r;
}
template <size_t _Size>
inline bitset<_Size>
operator^(const bitset<_Size> &__x, const bitset<_Size> &__y) throw()
{
    bitset<_Size> __r = __x;
    __r ^= __y;
    return __r;
}
template <size_t _Size>
struct hash<bitset<_Size>>
    : public __unary_function<bitset<_Size>, size_t>
{

    size_t operator()(const bitset<_Size> &__bs) const throw()
    {
return __bs.__hash_code();
    }
};
template <class _CharT, class _Traits, size_t _Size>
basic_istream<_CharT, _Traits> &
operator>>(basic_istream<_CharT, _Traits> &__is, bitset<_Size> &__x);
template <class _CharT, class _Traits, size_t _Size>
basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os, const bitset<_Size> &__x);
}
}
struct lconv
{
    char *decimal_point;
    char *thousands_sep;
    char *grouping;
    char *int_curr_symbol;
    char *currency_symbol;
    char *mon_decimal_point;
    char *mon_thousands_sep;
    char *mon_grouping;
    char *positive_sign;
    char *negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
    char int_p_cs_precedes;
    char int_n_cs_precedes;
    char int_p_sep_by_space;
    char int_n_sep_by_space;
    char int_p_sign_posn;
    char int_n_sign_posn;
};
extern "C"
{
    struct lconv *localeconv(void);
}
extern "C"
{
    char *setlocale(int, const char *);
}
extern "C"
{
    void __assert_rtn(const char *, const char *, int, const char *);
}
namespace std
{
    inline namespace __1
    {
struct errc
{
        enum __lx
        {
            address_family_not_supported = 47,
            address_in_use = 48,
            address_not_available = 49,
            already_connected = 56,
            argument_list_too_long = 7,
            argument_out_of_domain = 33,
            bad_address = 14,
            bad_file_descriptor = 9,
            bad_message = 94,
            broken_pipe = 32,
            connection_aborted = 53,
            connection_already_in_progress = 37,
            connection_refused = 61,
            connection_reset = 54,
            cross_device_link = 18,
            destination_address_required = 39,
            device_or_resource_busy = 16,
            directory_not_empty = 66,
            executable_format_error = 8,
            file_exists = 17,
            file_too_large = 27,
            filename_too_long = 63,
            function_not_supported = 78,
            host_unreachable = 65,
            identifier_removed = 90,
            illegal_byte_sequence = 92,
            inappropriate_io_control_operation = 25,
            interrupted = 4,
            invalid_argument = 22,
            invalid_seek = 29,
            io_error = 5,
            is_a_directory = 21,
            message_size = 40,
            network_down = 50,
            network_reset = 52,
            network_unreachable = 51,
            no_buffer_space = 55,
            no_child_process = 10,
            no_link = 97,
            no_lock_available = 77,
            no_message_available = 96,
            no_message = 91,
            no_protocol_option = 42,
            no_space_on_device = 28,
            no_stream_resources = 98,
            no_such_device_or_address = 6,
            no_such_device = 19,
            no_such_file_or_directory = 2,
            no_such_process = 3,
            not_a_directory = 20,
            not_a_socket = 38,
            not_a_stream = 99,
            not_connected = 57,
            not_enough_memory = 12,
            not_supported = 45,
            operation_canceled = 89,
            operation_in_progress = 36,
            operation_not_permitted = 1,
            operation_not_supported = 102,
            operation_would_block = 35,
            owner_dead = 105,
            permission_denied = 13,
            protocol_error = 100,
            protocol_not_supported = 43,
            read_only_file_system = 30,
            resource_deadlock_would_occur = 11,
            resource_unavailable_try_again = 35,
            result_out_of_range = 34,
            state_not_recoverable = 104,
            stream_timeout = 101,
            text_file_busy = 26,
            timed_out = 60,
            too_many_files_open_in_system = 23,
            too_many_files_open = 24,
            too_many_links = 31,
            too_many_symbolic_link_levels = 62,
            value_too_large = 84,
            wrong_protocol_type = 41
        };
        __lx __v_;
        const { return __v_; }
};
    }
}
namespace std
{
    inline namespace __1
    {
template <class _Tp>
struct is_error_code_enum
    : public false_type
{
};
template <class _Tp>
struct is_error_condition_enum
    : public false_type
{
};
template <>
struct is_error_condition_enum<errc>
    : true_type
{
};
template <>
struct is_error_condition_enum<errc::__lx>
    : true_type
{
};
class error_condition;
class error_code;
class __do_message;
class error_category
{
    public:
        virtual ~error_category() throw();

        error_category() throw() = default;
        error_category(const error_category &) = delete;
        error_category &operator=(const error_category &) = delete;
        virtual const char *name() const throw() = 0;
        virtual error_condition default_error_condition(int __ev) const throw();
        virtual bool equivalent(int __code, const error_condition &__condition) const throw();
        virtual bool equivalent(const error_code &__code, int __condition) const throw();
        virtual string message(int __ev) const = 0;

        bool operator==(const error_category &__rhs) const throw() { return this == &__rhs; }

        bool operator!=(const error_category &__rhs) const throw() { return !(*this == __rhs); }

        bool operator<(const error_category &__rhs) const throw() { return this < &__rhs; }
        friend class __do_message;
};
class __do_message
    : public error_category
{
    public:
        virtual string message(int __ev) const;
};
;
;
class error_condition
{
        int __val_;
        const error_category *__cat_;

    public:
        error_condition() throw() : __val_(0), __cat_(&generic_category()) {}

        error_condition(int __val, const error_category &__cat) throw()
            : __val_(__val), __cat_(&__cat) {}
        template <class _Ep>

        error_condition(_Ep __e,
                        typename enable_if<is_error_condition_enum<_Ep>::value>::type * = __nullptr) throw()
        {
            *this = make_error_condition(__e);
        }

        void assign(int __val, const error_category &__cat) throw()
        {
            __val_ = __val;
            __cat_ = &__cat;
        }
        template <class _Ep>

        typename enable_if<
            is_error_condition_enum<_Ep>::value,
            error_condition &>::type
        operator=(_Ep __e) throw()
        {
            *this = make_error_condition(__e);
            return *this;
        }

        void clear() throw()
        {
            __val_ = 0;
            __cat_ = &generic_category();
        }

        int value() const throw() { return __val_; }

        const error_category &category() const throw() { return *__cat_; }
        string message() const;

        explicit operator bool() const throw() { return __val_ != 0; }
};
inline error_condition
make_error_condition(errc __e) throw()
{
        return error_condition(static_cast<int>(__e), generic_category());
}
inline bool
operator<(const error_condition &__x, const error_condition &__y) throw()
{
        return __x.category() < __y.category() || (__x.category() == __y.category() && __x.value() < __y.value());
}
class error_code
{
        int __val_;
        const error_category *__cat_;

    public:
        error_code() throw() : __val_(0), __cat_(&system_category()) {}

        error_code(int __val, const error_category &__cat) throw()
            : __val_(__val), __cat_(&__cat) {}
        template <class _Ep>

        error_code(_Ep __e,
                   typename enable_if<is_error_code_enum<_Ep>::value>::type * = __nullptr) throw()
        {
            *this = make_error_code(__e);
        }

        void assign(int __val, const error_category &__cat) throw()
        {
            __val_ = __val;
            __cat_ = &__cat;
        }
        template <class _Ep>

        typename enable_if<
            is_error_code_enum<_Ep>::value,
            error_code &>::type
        operator=(_Ep __e) throw()
        {
            *this = make_error_code(__e);
            return *this;
        }

        void clear() throw()
        {
            __val_ = 0;
            __cat_ = &system_category();
        }

        int value() const throw() { return __val_; }

        const error_category &category() const throw() { return *__cat_; }

        error_condition default_error_condition() const throw()
        {
            return __cat_->default_error_condition(__val_);
        }
        string message() const;

        explicit operator bool() const throw() { return __val_ != 0; }
};
inline error_code
make_error_code(errc __e) throw()
{
        return error_code(static_cast<int>(__e), generic_category());
}
inline bool
operator<(const error_code &__x, const error_code &__y) throw()
{
        return __x.category() < __y.category() || (__x.category() == __y.category() && __x.value() < __y.value());
}
inline bool
operator==(const error_code &__x, const error_code &__y) throw()
{
        return __x.category() == __y.category() && __x.value() == __y.value();
}
inline bool
operator==(const error_code &__x, const error_condition &__y) throw()
{
        return __x.category().equivalent(__x.value(), __y) || __y.category().equivalent(__x, __y.value());
}
inline bool
operator==(const error_condition &__x, const error_code &__y) throw()
{
        return __y == __x;
}
inline bool
operator==(const error_condition &__x, const error_condition &__y) throw()
{
        return __x.category() == __y.category() && __x.value() == __y.value();
}
inline bool
operator!=(const error_code &__x, const error_code &__y) throw()
{
        return !(__x == __y);
}
inline bool
operator!=(const error_code &__x, const error_condition &__y) throw()
{
        return !(__x == __y);
}
inline bool
operator!=(const error_condition &__x, const error_code &__y) throw()
{
        return !(__x == __y);
}
inline bool
operator!=(const error_condition &__x, const error_condition &__y) throw()
{
        return !(__x == __y);
}
template <>
struct hash<error_code>
    : public __unary_function<error_code, size_t>
{

        size_t operator()(const error_code &__ec) const throw()
        {
            return static_cast<size_t>(__ec.value());
        }
};
template <>
struct hash<error_condition>
    : public __unary_function<error_condition, size_t>
{

        size_t operator()(const error_condition &__ec) const throw()
        {
            return static_cast<size_t>(__ec.value());
        }
};
class system_error
    : public runtime_error
{
        error_code __ec_;

    public:
        system_error(error_code __ec, const string &__what_arg);
        system_error(error_code __ec, const char *__what_arg);
        system_error(error_code __ec);
        system_error(int __ev, const error_category &__ecat, const string &__what_arg);
        system_error(int __ev, const error_category &__ecat, const char *__what_arg);
        system_error(int __ev, const error_category &__ecat);
        system_error(const system_error &) throw() = default;
        ~system_error() throw();

        const error_code &code() const throw() { return __ec_; }

    private:
        static string __init(const error_code &, string);
};

void __throw_system_error(int __ev, const char *__what_arg);
    }
}
namespace std
{
    inline namespace __1
    {
class mutex
{
        __libcpp_mutex_t __m_ = {0x32AAABA7, {0}};

    public:
        mutex() = default;
        mutex(const mutex &) = delete;
        mutex &operator=(const mutex &) = delete;
        ~mutex() throw();
        void lock();
        bool try_lock() throw();
        void unlock() throw();
        typedef __libcpp_mutex_t *native_handle_type;
        {
            return &__m_;
        }
};
_Static_assert(is_nothrow_default_constructible<mutex>::value, "the default constructor for std::mutex must be nothrow");
struct = default;
    };
    struct = default;
};
struct = default;
}
;
extern const defer_lock_t defer_lock;
extern const try_to_lock_t try_to_lock;
extern const adopt_lock_t adopt_lock;
template <class _Mutex>
class
    lock_guard
{
public:
    typedef _Mutex mutex_type;

private:
    mutex_type &__m_;

public:
    explicit lock_guard(mutex_type &__m)
        : __m_(__m) { __m_.lock(); }

    lock_guard(mutex_type &__m, adopt_lock_t)
        : __m_(__m) {}

    ~lock_guard() { __m_.unlock(); }

private:
    lock_guard(lock_guard const &) = delete;
    lock_guard &operator=(lock_guard const &) = delete;
};
template <class _Mutex>
class unique_lock
{
public:
    typedef _Mutex mutex_type;

private:
    mutex_type *__m_;
    bool __owns_;

public:
    unique_lock() throw() : __m_(__nullptr), __owns_(false) {}

    explicit unique_lock(mutex_type &__m)
        : __m_(std::addressof(__m)), __owns_(true) { __m_->lock(); }

    unique_lock(mutex_type &__m, defer_lock_t) throw()
        : __m_(std::addressof(__m)), __owns_(false) {}

    unique_lock(mutex_type &__m, try_to_lock_t)
        : __m_(std::addressof(__m)), __owns_(__m.try_lock()) {}

    unique_lock(mutex_type &__m, adopt_lock_t)
        : __m_(std::addressof(__m)), __owns_(true) {}
    template <class _Clock, class _Duration>

    unique_lock(mutex_type &__m, const chrono::time_point<_Clock, _Duration> &__t)
        : __m_(std::addressof(__m)), __owns_(__m.try_lock_until(__t))
    {
    }
    template <class _Rep, class _Period>

    unique_lock(mutex_type &__m, const chrono::duration<_Rep, _Period> &__d)
        : __m_(std::addressof(__m)), __owns_(__m.try_lock_for(__d))
    {
    }

    ~unique_lock()
    {
if (__owns_)
        __m_->unlock();
    }
    unique_lock(unique_lock const &) = delete;
    unique_lock &operator=(unique_lock const &) = delete;

    unique_lock(unique_lock &&__u) throw()
        : __m_(__u.__m_), __owns_(__u.__owns_)
    {
__u.__m_ = __nullptr;
__u.__owns_ = false;
    }

    unique_lock &operator=(unique_lock &&__u) throw()
    {
if (__owns_)
        __m_->unlock();
__m_ = __u.__m_;
__owns_ = __u.__owns_;
__u.__m_ = __nullptr;
__u.__owns_ = false;
return *this;
    }
    void lock();
    bool try_lock();
    template <class _Rep, class _Period>
    bool try_lock_for(const chrono::duration<_Rep, _Period> &__d);
    template <class _Clock, class _Duration>
    bool try_lock_until(const chrono::time_point<_Clock, _Duration> &__t);
    void unlock();

    void swap(unique_lock &__u) throw()
    {
std::swap(__m_, __u.__m_);
std::swap(__owns_, __u.__owns_);
    }

    mutex_type *release() throw()
    {
mutex_type *__m = __m_;
__m_ = __nullptr;
__owns_ = false;
return __m;
    }

    bool owns_lock() const throw() { return __owns_; }

    explicit operator bool() const throw() { return __owns_; }

    mutex_type *mutex() const throw() { return __m_; }
};
template <class _Mutex>
void unique_lock<_Mutex>::lock()
{
    if (__m_ == __nullptr)
__throw_system_error(1, "unique_lock::lock: references null mutex");
    if (__owns_)
__throw_system_error(11, "unique_lock::lock: already locked");
    __m_->lock();
    __owns_ = true;
}
template <class _Mutex>
bool unique_lock<_Mutex>::try_lock()
{
    if (__m_ == __nullptr)
__throw_system_error(1, "unique_lock::try_lock: references null mutex");
    if (__owns_)
__throw_system_error(11, "unique_lock::try_lock: already locked");
    __owns_ = __m_->try_lock();
    return __owns_;
}
template <class _Mutex>
template <class _Rep, class _Period>
bool unique_lock<_Mutex>::try_lock_for(const chrono::duration<_Rep, _Period> &__d)
{
    if (__m_ == __nullptr)
__throw_system_error(1, "unique_lock::try_lock_for: references null mutex");
    if (__owns_)
__throw_system_error(11, "unique_lock::try_lock_for: already locked");
    __owns_ = __m_->try_lock_for(__d);
    return __owns_;
}
template <class _Mutex>
template <class _Clock, class _Duration>
bool unique_lock<_Mutex>::try_lock_until(const chrono::time_point<_Clock, _Duration> &__t)
{
    if (__m_ == __nullptr)
__throw_system_error(1, "unique_lock::try_lock_until: references null mutex");
    if (__owns_)
__throw_system_error(11, "unique_lock::try_lock_until: already locked");
    __owns_ = __m_->try_lock_until(__t);
    return __owns_;
}
template <class _Mutex>
void unique_lock<_Mutex>::unlock()
{
    if (!__owns_)
__throw_system_error(1, "unique_lock::unlock: not locked");
    __m_->unlock();
    __owns_ = false;
}
template <class _Mutex>
inline void
swap(unique_lock<_Mutex> &__x, unique_lock<_Mutex> &__y) throw()
{
    __x.swap(__y);
}
struct cv_status
{
    enum __lx
    {
        no_timeout,
        timeout
    };
    __lx __v_;
    const { return __v_; }
};
class condition_variable
{
    __libcpp_condvar_t __cv_ = {0x3CB0B1BB, {0}};

public:
    condition_variable() throw() = default;
    ~condition_variable();
    condition_variable(const condition_variable &) = delete;
    condition_variable &operator=(const condition_variable &) = delete;
    void notify_one() throw();
    void notify_all() throw();
    void wait(unique_lock<mutex> &__lk) throw();
    template <class _Predicate>
    inline void wait(unique_lock<mutex> &__lk, _Predicate __pred);
    template <class _Clock, class _Duration>
    inline cv_status
    wait_until(unique_lock<mutex> &__lk,
               const chrono::time_point<_Clock, _Duration> &__t);
    template <class _Clock, class _Duration, class _Predicate>
    inline bool
    wait_until(unique_lock<mutex> &__lk,
               const chrono::time_point<_Clock, _Duration> &__t,
               _Predicate __pred);
    template <class _Rep, class _Period>
    inline cv_status
    wait_for(unique_lock<mutex> &__lk,
             const chrono::duration<_Rep, _Period> &__d);
    template <class _Rep, class _Period, class _Predicate>
    bool

    wait_for(unique_lock<mutex> &__lk,
             const chrono::duration<_Rep, _Period> &__d,
             _Predicate __pred);
    typedef __libcpp_condvar_t *native_handle_type;
    {
return &__cv_;
    }

private:
    void __do_timed_wait(unique_lock<mutex> &__lk,
                         chrono::time_point<chrono::system_clock, chrono::nanoseconds>) throw();
    template <class _Clock>
    void __do_timed_wait(unique_lock<mutex> &__lk,
                         chrono::time_point<_Clock, chrono::nanoseconds>) throw();
};
template <class _Rep, class _Period>
inline __enable_if_t<is_floating_point<_Rep>::value, chrono::nanoseconds>
__safe_nanosecond_cast(chrono::duration<_Rep, _Period> __d)
{
    using namespace chrono;
    using __ratio = ratio_divide<_Period, nano>;
    using __ns_rep = nanoseconds::rep;
    _Rep __result_float = __d.count() * __ratio::num / __ratio::den;
    _Rep __result_max = numeric_limits<__ns_rep>::max();
    if (__result_float >= __result_max)
    {
return nanoseconds::max();
    }
    _Rep __result_min = numeric_limits<__ns_rep>::min();
    if (__result_float <= __result_min)
    {
return nanoseconds::min();
    }
    return nanoseconds(static_cast<__ns_rep>(__result_float));
}
template <class _Rep, class _Period>
inline __enable_if_t<!is_floating_point<_Rep>::value, chrono::nanoseconds>
__safe_nanosecond_cast(chrono::duration<_Rep, _Period> __d)
{
    using namespace chrono;
    if (__d.count() == 0)
    {
return nanoseconds(0);
    }
    using __ratio = ratio_divide<_Period, nano>;
    using __ns_rep = nanoseconds::rep;
    __ns_rep __result_max = numeric_limits<__ns_rep>::max();
    if (__d.count() > 0 && __d.count() > __result_max / __ratio::num)
    {
return nanoseconds::max();
    }
    __ns_rep __result_min = numeric_limits<__ns_rep>::min();
    if (__d.count() < 0 && __d.count() < __result_min / __ratio::num)
    {
return nanoseconds::min();
    }
    __ns_rep __result = __d.count() * __ratio::num / __ratio::den;
    if (__result == 0)
    {
return nanoseconds(1);
    }
    return nanoseconds(__result);
}
template <class _Predicate>
void condition_variable::wait(unique_lock<mutex> &__lk, _Predicate __pred)
{
    while (!__pred())
wait(__lk);
}
template <class _Clock, class _Duration>
cv_status
condition_variable::wait_until(unique_lock<mutex> &__lk,
                               const chrono::time_point<_Clock, _Duration> &__t)
{
    using namespace chrono;
    using __clock_tp_ns = time_point<_Clock, nanoseconds>;
    typename _Clock::time_point __now = _Clock::now();
    if (__t <= __now)
return cv_status::timeout;
    __clock_tp_ns __t_ns = __clock_tp_ns(std::__safe_nanosecond_cast(__t.time_since_epoch()));
    __do_timed_wait(__lk, __t_ns);
    return _Clock::now() < __t ? cv_status::no_timeout : cv_status::timeout;
}
template <class _Clock, class _Duration, class _Predicate>
bool condition_variable::wait_until(unique_lock<mutex> &__lk,
                                    const chrono::time_point<_Clock, _Duration> &__t,
                                    _Predicate __pred)
{
    while (!__pred())
    {
if (wait_until(__lk, __t) == cv_status::timeout)
        return __pred();
    }
    return true;
}
template <class _Rep, class _Period>
cv_status
condition_variable::wait_for(unique_lock<mutex> &__lk,
                             const chrono::duration<_Rep, _Period> &__d)
{
    using namespace chrono;
    if (__d <= __d.zero())
return cv_status::timeout;
    using __ns_rep = nanoseconds::rep;
    steady_clock::time_point __c_now = steady_clock::now();
    using __clock_tp_ns = time_point<system_clock, nanoseconds>;
    __ns_rep __now_count_ns = std::__safe_nanosecond_cast(system_clock::now().time_since_epoch()).count();
    __ns_rep __d_ns_count = std::__safe_nanosecond_cast(__d).count();
    if (__now_count_ns > numeric_limits<__ns_rep>::max() - __d_ns_count)
    {
__do_timed_wait(__lk, __clock_tp_ns::max());
    }
    else
    {
__do_timed_wait(__lk, __clock_tp_ns(nanoseconds(__now_count_ns + __d_ns_count)));
    }
    return steady_clock::now() - __c_now < __d ? cv_status::no_timeout : cv_status::timeout;
}
template <class _Rep, class _Period, class _Predicate>
inline bool
condition_variable::wait_for(unique_lock<mutex> &__lk,
                             const chrono::duration<_Rep, _Period> &__d,
                             _Predicate __pred)
{
    return wait_until(__lk, chrono::steady_clock::now() + __d,
                      std::move(__pred));
}
template <class _Clock>
inline void
condition_variable::__do_timed_wait(unique_lock<mutex> &__lk,
                                    chrono::time_point<_Clock, chrono::nanoseconds> __tp) throw()
{
    wait_for(__lk, __tp - _Clock::now());
}
}
}
extern "C"
{
    void __assert_rtn(const char *, const char *, int, const char *);
}
namespace std
{
    inline namespace __1
    {
class recursive_mutex
{
        __libcpp_recursive_mutex_t __m_;

    public:
        recursive_mutex();
        ~recursive_mutex();
        recursive_mutex(const recursive_mutex &) = delete;
        recursive_mutex &operator=(const recursive_mutex &) = delete;
        void lock();
        bool try_lock() throw();
        void unlock() throw();
        typedef __libcpp_recursive_mutex_t *native_handle_type;

        native_handle_type native_handle() { return &__m_; }
};
class timed_mutex
{
        mutex __m_;
        condition_variable __cv_;
        bool __locked_;

    public:
        timed_mutex();
        ~timed_mutex();
        timed_mutex(const timed_mutex &) = delete;
        timed_mutex &operator=(const timed_mutex &) = delete;

    public:
        void lock();
        bool try_lock() throw();
        template <class _Rep, class _Period>

        bool try_lock_for(const chrono::duration<_Rep, _Period> &__d)
        {
            return try_lock_until(chrono::steady_clock::now() + __d);
        }
        template <class _Clock, class _Duration>
        inline bool try_lock_until(const chrono::time_point<_Clock, _Duration> &__t);
        void unlock() throw();
};
template <class _Clock, class _Duration>
bool timed_mutex::try_lock_until(const chrono::time_point<_Clock, _Duration> &__t)
{
        using namespace chrono;
        unique_lock<mutex> __lk(__m_);
        bool no_timeout = _Clock::now() < __t;
        while (no_timeout && __locked_)
            no_timeout = __cv_.wait_until(__lk, __t) == cv_status::no_timeout;
        if (!__locked_)
        {
            __locked_ = true;
            return true;
        }
        return false;
}
class recursive_timed_mutex
{
        mutex __m_;
        condition_variable __cv_;
        size_t __count_;
        __thread_id __id_;

    public:
        recursive_timed_mutex();
        ~recursive_timed_mutex();
        recursive_timed_mutex(const recursive_timed_mutex &) = delete;
        recursive_timed_mutex &operator=(const recursive_timed_mutex &) = delete;
        void lock();
        bool try_lock() throw();
        template <class _Rep, class _Period>

        bool try_lock_for(const chrono::duration<_Rep, _Period> &__d)
        {
            return try_lock_until(chrono::steady_clock::now() + __d);
        }
        template <class _Clock, class _Duration>
        inline bool try_lock_until(const chrono::time_point<_Clock, _Duration> &__t);
        void unlock() throw();
};
template <class _Clock, class _Duration>
bool recursive_timed_mutex::try_lock_until(const chrono::time_point<_Clock, _Duration> &__t)
{
        using namespace chrono;
        __thread_id __id = this_thread::get_id();
        unique_lock<mutex> lk(__m_);
        if (__id == __id_)
        {
            if (__count_ == numeric_limits<size_t>::max())
                return false;
            ++__count_;
            return true;
        }
        bool no_timeout = _Clock::now() < __t;
        while (no_timeout && __count_ != 0)
            no_timeout = __cv_.wait_until(lk, __t) == cv_status::no_timeout;
        if (__count_ == 0)
        {
            __count_ = 1;
            __id_ = __id;
            return true;
        }
        return false;
}
template <class _L0, class _L1>
int try_lock(_L0 &__l0, _L1 &__l1)
{
        unique_lock<_L0> __u0(__l0, try_to_lock);
        if (__u0.owns_lock())
        {
            if (__l1.try_lock())
            {
                __u0.release();
                return -1;
            }
            else
                return 1;
        }
        return 0;
}
template <class _L0, class _L1>
void lock(_L0 &__l0, _L1 &__l1)
{
        while (true)
        {
            {
                unique_lock<_L0> __u0(__l0);
                if (__l1.try_lock())
                {
                    __u0.release();
                    break;
                }
            }
            __libcpp_thread_yield();
            {
                unique_lock<_L1> __u1(__l1);
                if (__l0.try_lock())
                {
                    __u1.release();
                    break;
                }
            }
            __libcpp_thread_yield();
        }
}
struct once_flag;
template <class _Callable>

void call_once(once_flag &, _Callable &);
template <class _Callable>

void call_once(once_flag &, const _Callable &);
struct once_flag
{

        once_flag() throw() : __state_(0) {}
        once_flag(const once_flag &) = delete;
        once_flag &operator=(const once_flag &) = delete;
        typedef unsigned long _State_type;

    private:
        _State_type __state_;
        template <class _Callable>
        friend void call_once(once_flag &, _Callable &);
        template <class _Callable>
        friend void call_once(once_flag &, const _Callable &);
};
template <class _Fp>
class __call_once_param
{
        _Fp &__f_;

    public:
        explicit __call_once_param(_Fp &__f) : __f_(__f) {}

        void operator()()
        {
            __f_();
        }
};
template <class _Fp>
void __call_once_proxy(void *__vp)
{
        __call_once_param<_Fp> *__p = static_cast<__call_once_param<_Fp> *>(__vp);
        (*__p)();
}
void __call_once(volatile once_flag::_State_type &, void *,
                 void (*)(void *));
template <class _Callable>
inline void
call_once(once_flag &__flag, _Callable &__func)
{
        if (__libcpp_acquire_load(&__flag.__state_) != ~once_flag::_State_type(0))
        {
            __call_once_param<_Callable> __p(__func);
            __call_once(__flag.__state_, &__p, &__call_once_proxy<_Callable>);
        }
}
template <class _Callable>
inline void
call_once(once_flag &__flag, const _Callable &__func)
{
        if (__libcpp_acquire_load(&__flag.__state_) != ~once_flag::_State_type(0))
        {
            __call_once_param<const _Callable> __p(__func);
            __call_once(__flag.__state_, &__p, &__call_once_proxy<const _Callable>);
        }
}
    }
}
struct _xlocale;
typedef struct _xlocale *locale_t;
extern "C"
{
    int ___mb_cur_max(void);
    int ___mb_cur_max_l(locale_t);
}
extern "C"
{
    extern const locale_t _c_locale;
    locale_t duplocale(locale_t);
    int freelocale(locale_t);
    struct lconv *localeconv_l(locale_t);
    locale_t newlocale(int, const char *, locale_t);
    const char *querylocale(int, locale_t);
    locale_t uselocale(locale_t);
}
extern "C"
{
    unsigned long ___runetype_l(__darwin_ct_rune_t, locale_t);
    __darwin_ct_rune_t ___tolower_l(__darwin_ct_rune_t, locale_t);
    __darwin_ct_rune_t ___toupper_l(__darwin_ct_rune_t, locale_t);
}
extern "C"
{
    int __maskrune_l(__darwin_ct_rune_t, unsigned long, locale_t);
}
inline int
__istype_l(__darwin_ct_rune_t _c, unsigned long _f, locale_t _l)
{
    return !!(isascii(_c) ? (_DefaultRuneLocale.__runetype[_c] & _f)
                          : __maskrune_l(_c, _f, _l));
}
inline __darwin_ct_rune_t
__toupper_l(__darwin_ct_rune_t _c, locale_t _l)
{
    return isascii(_c) ? _DefaultRuneLocale.__mapupper[_c]
                       : ___toupper_l(_c, _l);
}
inline __darwin_ct_rune_t
__tolower_l(__darwin_ct_rune_t _c, locale_t _l)
{
    return isascii(_c) ? _DefaultRuneLocale.__maplower[_c]
                       : ___tolower_l(_c, _l);
}
inline int
__wcwidth_l(__darwin_ct_rune_t _c, locale_t _l)
{
    unsigned int _x;
    if (_c == 0)
return (0);
    _x = (unsigned int)__maskrune_l(_c, 0xe0000000L | 0x00040000L, _l);
    if ((_x & 0xe0000000L) != 0)
return ((_x & 0xe0000000L) >> 30);
    return ((_x & 0x00040000L) != 0 ? 1 : -1);
}
inline int
digittoint_l(int c, locale_t l)
{
    return (__maskrune_l(c, 0x0F, l));
}
inline int
isalnum_l(int c, locale_t l)
{
    return (__istype_l(c, 0x00000100L | 0x00000400L, l));
}
inline int
isalpha_l(int c, locale_t l)
{
    return (__istype_l(c, 0x00000100L, l));
}
inline int
isblank_l(int c, locale_t l)
{
    return (__istype_l(c, 0x00020000L, l));
}
inline int
iscntrl_l(int c, locale_t l)
{
    return (__istype_l(c, 0x00000200L, l));
}
inline int
isdigit_l(int c, locale_t l)
{
    return (__istype_l(c, 0x00000400L, l));
}
inline int
isgraph_l(int c, locale_t l)
{
    return (__istype_l(c, 0x00000800L, l));
}
inline int
ishexnumber_l(int c, locale_t l)
{
    return (__istype_l(c, 0x00010000L, l));
}
inline int
isideogram_l(int c, locale_t l)
{
    return (__istype_l(c, 0x00080000L, l));
}
inline int
islower_l(int c, locale_t l)
{
    return (__istype_l(c, 0x00001000L, l));
}
inline int
isnumber_l(int c, locale_t l)
{
    return (__istype_l(c, 0x00000400L, l));
}
inline int
isphonogram_l(int c, locale_t l)
{
    return (__istype_l(c, 0x00200000L, l));
}
inline int
isprint_l(int c, locale_t l)
{
    return (__istype_l(c, 0x00040000L, l));
}
inline int
ispunct_l(int c, locale_t l)
{
    return (__istype_l(c, 0x00002000L, l));
}
inline int
isrune_l(int c, locale_t l)
{
    return (__istype_l(c, 0xFFFFFFF0L, l));
}
inline int
isspace_l(int c, locale_t l)
{
    return (__istype_l(c, 0x00004000L, l));
}
inline int
isspecial_l(int c, locale_t l)
{
    return (__istype_l(c, 0x00100000L, l));
}
inline int
isupper_l(int c, locale_t l)
{
    return (__istype_l(c, 0x00008000L, l));
}
inline int
isxdigit_l(int c, locale_t l)
{
    return (__istype_l(c, 0x00010000L, l));
}
inline int
tolower_l(int c, locale_t l)
{
    return (__tolower_l(c, l));
}
inline int
toupper_l(int c, locale_t l)
{
    return (__toupper_l(c, l));
}
inline int
iswalnum_l(wint_t _wc, locale_t _l)
{
    return (__istype_l(_wc, 0x00000100L | 0x00000400L, _l));
}
inline int
iswalpha_l(wint_t _wc, locale_t _l)
{
    return (__istype_l(_wc, 0x00000100L, _l));
}
inline int
iswcntrl_l(wint_t _wc, locale_t _l)
{
    return (__istype_l(_wc, 0x00000200L, _l));
}
inline int
iswctype_l(wint_t _wc, wctype_t _charclass, locale_t _l)
{
    return (__istype_l(_wc, _charclass, _l));
}
inline int
iswdigit_l(wint_t _wc, locale_t _l)
{
    return (__istype_l(_wc, 0x00000400L, _l));
}
inline int
iswgraph_l(wint_t _wc, locale_t _l)
{
    return (__istype_l(_wc, 0x00000800L, _l));
}
inline int
iswlower_l(wint_t _wc, locale_t _l)
{
    return (__istype_l(_wc, 0x00001000L, _l));
}
inline int
iswprint_l(wint_t _wc, locale_t _l)
{
    return (__istype_l(_wc, 0x00040000L, _l));
}
inline int
iswpunct_l(wint_t _wc, locale_t _l)
{
    return (__istype_l(_wc, 0x00002000L, _l));
}
inline int
iswspace_l(wint_t _wc, locale_t _l)
{
    return (__istype_l(_wc, 0x00004000L, _l));
}
inline int
iswupper_l(wint_t _wc, locale_t _l)
{
    return (__istype_l(_wc, 0x00008000L, _l));
}
inline int
iswxdigit_l(wint_t _wc, locale_t _l)
{
    return (__istype_l(_wc, 0x00010000L, _l));
}
inline wint_t
towlower_l(wint_t _wc, locale_t _l)
{
    return (__tolower_l(_wc, _l));
}
inline wint_t
towupper_l(wint_t _wc, locale_t _l)
{
    return (__toupper_l(_wc, _l));
}
extern "C"
{
    wctype_t
    wctype_l(const char *, locale_t);
}
extern "C"
{
    int fprintf_l(FILE *, locale_t, const char *, ...);
    int fscanf_l(FILE *, locale_t, const char *, ...);
    int printf_l(locale_t, const char *, ...);
    int scanf_l(locale_t, const char *, ...);
    int sprintf_l(char *, locale_t, const char *, ...);
    int sscanf_l(const char *, locale_t, const char *, ...);
    int vfprintf_l(FILE *, locale_t, const char *, va_list);
    int vprintf_l(locale_t, const char *, va_list);
    int vsprintf_l(char *, locale_t, const char *, va_list);
    int snprintf_l(char *, size_t, locale_t, const char *, ...);
    int vfscanf_l(FILE *, locale_t, const char *, va_list);
    int vscanf_l(locale_t, const char *, va_list);
    int vsnprintf_l(char *, size_t, locale_t, const char *, va_list);
    int vsscanf_l(const char *, locale_t, const char *, va_list);
    int dprintf_l(int, locale_t, const char *, ...);
    int vdprintf_l(int, locale_t, const char *, va_list);
    int asprintf_l(char **, locale_t, const char *, ...);
    int vasprintf_l(char **, locale_t, const char *, va_list);
}
extern "C"
{
    double atof_l(const char *, locale_t);
    int atoi_l(const char *, locale_t);
    long atol_l(const char *, locale_t);
    long long
    atoll_l(const char *, locale_t);
    int mblen_l(const char *, size_t, locale_t);
    size_t mbstowcs_l(wchar_t *, const char *, size_t,
                      locale_t);
    int mbtowc_l(wchar_t *, const char *, size_t,
                 locale_t);
    double strtod_l(const char *, char **, locale_t) __asm("_"
                                                           "strtod_l");
    float strtof_l(const char *, char **, locale_t) __asm("_"
                                                          "strtof_l");
    long strtol_l(const char *, char **, int, locale_t);
    long double
    strtold_l(const char *, char **, locale_t);
    long long
    strtoll_l(const char *, char **, int, locale_t);
    long long
    strtoq_l(const char *, char **, int, locale_t);
    unsigned long
    strtoul_l(const char *, char **, int, locale_t);
    unsigned long long
    strtoull_l(const char *, char **, int, locale_t);
    unsigned long long
    strtouq_l(const char *, char **, int, locale_t);
    size_t wcstombs_l(char *, const wchar_t *, size_t,
                      locale_t);
    int wctomb_l(char *, wchar_t, locale_t);
}
extern "C"
{
    int strcoll_l(const char *, const char *, locale_t);
    size_t strxfrm_l(char *, const char *, size_t, locale_t);
    int strcasecmp_l(const char *, const char *, locale_t);
    char *strcasestr_l(const char *, const char *, locale_t);
    int strncasecmp_l(const char *, const char *, size_t, locale_t);
}
extern "C"
{
    size_t strftime_l(char *, size_t, const char *,
                      const struct tm *, locale_t) __asm("_"
                                                         "strftime_l");
    char *strptime_l(const char *, const char *,
                     struct tm *, locale_t) __asm("_"
                                                  "strptime_l");
}
extern "C"
{
    wint_t btowc_l(int, locale_t);
    wint_t fgetwc_l(FILE *, locale_t);
    wchar_t *fgetws_l(wchar_t *, int, FILE *, locale_t);
    wint_t fputwc_l(wchar_t, FILE *, locale_t);
    int fputws_l(const wchar_t *, FILE *, locale_t);
    int fwprintf_l(FILE *, locale_t, const wchar_t *, ...);
    int fwscanf_l(FILE *, locale_t, const wchar_t *, ...);
    wint_t getwc_l(FILE *, locale_t);
    wint_t getwchar_l(locale_t);
    size_t mbrlen_l(const char *, size_t, mbstate_t *,
                    locale_t);
    size_t mbrtowc_l(wchar_t *, const char *, size_t,
                     mbstate_t *, locale_t);
    int mbsinit_l(const mbstate_t *, locale_t);
    size_t mbsrtowcs_l(wchar_t *, const char **, size_t,
                       mbstate_t *, locale_t);
    wint_t putwc_l(wchar_t, FILE *, locale_t);
    wint_t putwchar_l(wchar_t, locale_t);
    int swprintf_l(wchar_t *, size_t n, locale_t,
                   const wchar_t *, ...);
    int swscanf_l(const wchar_t *, locale_t,
                  const wchar_t *, ...);
    wint_t ungetwc_l(wint_t, FILE *, locale_t);
    int vfwprintf_l(FILE *, locale_t, const wchar_t *,
                    __darwin_va_list);
    int vswprintf_l(wchar_t *, size_t n, locale_t,
                    const wchar_t *, __darwin_va_list);
    int vwprintf_l(locale_t, const wchar_t *, __darwin_va_list);
    size_t wcrtomb_l(char *, wchar_t, mbstate_t *,
                     locale_t);
    int wcscoll_l(const wchar_t *, const wchar_t *, locale_t);
    size_t wcsftime_l(wchar_t *, size_t, const wchar_t *,
                      const struct tm *, locale_t) __asm("_"
                                                         "wcsftime_l");
    size_t wcsrtombs_l(char *, const wchar_t **, size_t,
                       mbstate_t *, locale_t);
    double wcstod_l(const wchar_t *, wchar_t **, locale_t);
    long wcstol_l(const wchar_t *, wchar_t **, int,
                  locale_t);
    unsigned long
    wcstoul_l(const wchar_t *, wchar_t **, int,
              locale_t);
    int wcswidth_l(const wchar_t *, size_t, locale_t);
    size_t wcsxfrm_l(wchar_t *, const wchar_t *, size_t,
                     locale_t);
    int wctob_l(wint_t, locale_t);
    int wcwidth_l(wchar_t, locale_t);
    int wprintf_l(locale_t, const wchar_t *, ...);
    int wscanf_l(locale_t, const wchar_t *, ...);
}
extern "C"
{
    int vfwscanf_l(FILE *, locale_t, const wchar_t *,
                   __darwin_va_list);
    int vswscanf_l(const wchar_t *, locale_t,
                   const wchar_t *, __darwin_va_list);
    int vwscanf_l(locale_t, const wchar_t *, __darwin_va_list);
    float wcstof_l(const wchar_t *, wchar_t **, locale_t);
    long double
    wcstold_l(const wchar_t *, wchar_t **, locale_t);
    long long
    wcstoll_l(const wchar_t *, wchar_t **, int,
              locale_t);
    unsigned long long
    wcstoull_l(const wchar_t *, wchar_t **, int,
               locale_t);
}
extern "C"
{
    size_t mbsnrtowcs_l(wchar_t *, const char **, size_t,
                        size_t, mbstate_t *, locale_t);
    int wcscasecmp_l(const wchar_t *, const wchar_t *, locale_t);
    int wcsncasecmp_l(const wchar_t *, const wchar_t *, size_t n, locale_t);
    size_t wcsnrtombs_l(char *, const wchar_t **, size_t,
                        size_t, mbstate_t *, locale_t);
}
extern "C"
{
    wchar_t *fgetwln_l(FILE *, size_t *, locale_t);
}
inline int
iswblank_l(wint_t _wc, locale_t _l)
{
    return (__istype_l(_wc, 0x00020000L, _l));
}
inline int
iswhexnumber_l(wint_t _wc, locale_t _l)
{
    return (__istype_l(_wc, 0x00010000L, _l));
}
inline int
iswideogram_l(wint_t _wc, locale_t _l)
{
    return (__istype_l(_wc, 0x00080000L, _l));
}
inline int
iswnumber_l(wint_t _wc, locale_t _l)
{
    return (__istype_l(_wc, 0x00000400L, _l));
}
inline int
iswphonogram_l(wint_t _wc, locale_t _l)
{
    return (__istype_l(_wc, 0x00200000L, _l));
}
inline int
iswrune_l(wint_t _wc, locale_t _l)
{
    return (__istype_l(_wc, 0xFFFFFFF0L, _l));
}
inline int
iswspecial_l(wint_t _wc, locale_t _l)
{
    return (__istype_l(_wc, 0x00100000L, _l));
}
extern "C"
{
    wint_t nextwctype_l(wint_t, wctype_t, locale_t);
    wint_t towctrans_l(wint_t, wctrans_t, locale_t);
    wctrans_t
    wctrans_l(const char *, locale_t);
}
namespace std
{
    inline namespace __1
    {
class locale;
template <class _Facet>

bool has_facet(const locale &) throw();
template <class _Facet>

const _Facet &
use_facet(const locale &);
class locale
{
    public:
        class facet;
        class id;
        typedef int category;

        static const category
            none = 0,
            collate = (1 << 0),
            ctype = (1 << 1),
            monetary = (1 << 3),
            numeric = (1 << 4),
            time = (1 << 5),
            messages = (1 << 2),
            all = collate | ctype | monetary | numeric | time | messages;
        locale() throw();
        locale(const locale &) throw();
        explicit locale(const char *);
        explicit locale(const string &);
        locale(const locale &, const char *, category);
        locale(const locale &, const string &, category);
        template <class _Facet>
        ;
        locale(const locale &, const locale &, category);
        ~locale();
        const locale &operator=(const locale &) throw();
        template <class _Facet>
        inline locale combine(const locale &) const;
        string name() const;
        bool operator==(const locale &) const;
        bool operator!=(const locale &__y) const { return !(*this == __y); }
        template <class _CharT, class _Traits, class _Allocator>
        inline bool operator()(const basic_string<_CharT, _Traits, _Allocator> &,
                               const basic_string<_CharT, _Traits, _Allocator> &) const;
        static locale global(const locale &);
        static const locale &classic();

    private:
        class __imp;
        __imp *__locale_;
        void __install_ctor(const locale &, facet *, long);
        static locale &__global();
        bool has_facet(id &) const;
        const facet *use_facet(id &) const;
        template <class _Facet>
        friend bool has_facet(const locale &) throw();
        template <class _Facet>
        friend const _Facet &use_facet(const locale &);
};
class locale::facet
    : public __shared_count
{
    protected:
        explicit facet(size_t __refs = 0)
            : __shared_count(static_cast<long>(__refs) - 1) {}
        virtual ~facet();

    private:
        virtual void __on_zero_shared() throw();
};
class locale::id
{
        once_flag __flag_;
        int32_t __id_;
        static int32_t __next_id;

    public:
        {
        }
        void operator=(const id &) = delete;
        id(const id &) = delete;

    private:
        void __init();

    public:
        long __get();
        friend class locale;
        friend class locale::__imp;
};
template <class _Facet>
inline locale::locale(const locale &__other, _Facet *__f)
{
        __install_ctor(__other, __f, __f ? __f->id.__get() : 0);
}
template <class _Facet>
locale
locale::combine(const locale &__other) const
{
        if (!std::has_facet<_Facet>(__other))
            __throw_runtime_error("locale::combine: locale missing facet");
        return locale(*this, &const_cast<_Facet &>(std::use_facet<_Facet>(__other)));
}
template <class _Facet>
inline bool
has_facet(const locale &__l) throw()
{
        return __l.has_facet(_Facet::id);
}
template <class _Facet>
inline const _Facet &
use_facet(const locale &__l)
{
        return static_cast<const _Facet &>(*__l.use_facet(_Facet::id));
}
template <class _CharT>
class collate
    : public locale::facet
{
    public:
        typedef _CharT char_type;
        typedef basic_string<char_type> string_type;

        explicit collate(size_t __refs = 0)
            : locale::facet(__refs) {}

        int compare(const char_type *__lo1, const char_type *__hi1,
                    const char_type *__lo2, const char_type *__hi2) const
        {
            return do_compare(__lo1, __hi1, __lo2, __hi2);
        }

        string_type transform(const char_type *__lo, const char_type *__hi) const
        {
            return do_transform(__lo, __hi);
        }

        long hash(const char_type *__lo, const char_type *__hi) const
        {
            return do_hash(__lo, __hi);
        }
        static locale::id id;

    protected:
        ~collate();
        virtual int do_compare(const char_type *__lo1, const char_type *__hi1,
                               const char_type *__lo2, const char_type *__hi2) const;
        virtual string_type do_transform(const char_type *__lo, const char_type *__hi) const
        {
            return string_type(__lo, __hi);
        }
        virtual long do_hash(const char_type *__lo, const char_type *__hi) const;
};
template <class _CharT>
locale::id collate<_CharT>::id;
template <class _CharT>
collate<_CharT>::~collate()
{
}
template <class _CharT>
int collate<_CharT>::do_compare(const char_type *__lo1, const char_type *__hi1,
                                const char_type *__lo2, const char_type *__hi2) const
{
        for (; __lo2 != __hi2; ++__lo1, ++__lo2)
        {
            if (__lo1 == __hi1 || *__lo1 < *__lo2)
                return -1;
            if (*__lo2 < *__lo1)
                return 1;
        }
        return __lo1 != __hi1;
}
template <class _CharT>
long collate<_CharT>::do_hash(const char_type *__lo, const char_type *__hi) const
{
        size_t __h = 0;
        const size_t __sr = 8 * sizeof(size_t) - 8;
        const size_t __mask = size_t(0xF) << (__sr + 4);
        for (const char_type *__p = __lo; __p != __hi; ++__p)
        {
            __h = (__h << 4) + static_cast<size_t>(*__p);
            size_t __g = __h & __mask;
            __h ^= __g | (__g >> __sr);
        }
        return static_cast<long>(__h);
}
extern template class collate<char>;
extern template class collate<wchar_t>;
template <class _CharT>
class collate_byname;
template <>
class collate_byname<char>
    : public collate<char>
{
        locale_t __l;

    public:
        typedef char char_type;
        typedef basic_string<char_type> string_type;
        explicit collate_byname(const char *__n, size_t __refs = 0);
        explicit collate_byname(const string &__n, size_t __refs = 0);

    protected:
        ~collate_byname();
        virtual int do_compare(const char_type *__lo1, const char_type *__hi1,
                               const char_type *__lo2, const char_type *__hi2) const;
        virtual string_type do_transform(const char_type *__lo, const char_type *__hi) const;
};
template <>
class collate_byname<wchar_t>
    : public collate<wchar_t>
{
        locale_t __l;

    public:
        typedef wchar_t char_type;
        typedef basic_string<char_type> string_type;
        explicit collate_byname(const char *__n, size_t __refs = 0);
        explicit collate_byname(const string &__n, size_t __refs = 0);

    protected:
        ~collate_byname();
        virtual int do_compare(const char_type *__lo1, const char_type *__hi1,
                               const char_type *__lo2, const char_type *__hi2) const;
        virtual string_type do_transform(const char_type *__lo, const char_type *__hi) const;
};
template <class _CharT, class _Traits, class _Allocator>
bool locale::operator()(const basic_string<_CharT, _Traits, _Allocator> &__x,
                        const basic_string<_CharT, _Traits, _Allocator> &__y) const
{
        return std::use_facet<std::collate<_CharT>>(*this).compare(
                   __x.data(), __x.data() + __x.size(),
                   __y.data(), __y.data() + __y.size()) < 0;
}
class ctype_base
{
    public:
        typedef __uint32_t mask;
        static const mask space = 0x00004000L;
        static const mask print = 0x00040000L;
        static const mask cntrl = 0x00000200L;
        static const mask upper = 0x00008000L;
        static const mask lower = 0x00001000L;
        static const mask alpha = 0x00000100L;
        static const mask digit = 0x00000400L;
        static const mask punct = 0x00002000L;
        static const mask xdigit = 0x00010000L;
        static const mask blank = 0x00020000L;
        static const mask __regex_word = 0x80;
        static const mask alnum = alpha | digit;
        static const mask graph = alnum | punct;
        {
        }
        _Static_assert((__regex_word & ~(space | print | cntrl | upper | lower | alpha | digit | punct | xdigit | blank)) == __regex_word, "__regex_word can't overlap other bits");
};
template <class _CharT>
class ctype;
template <>
class ctype<wchar_t>
    : public locale::facet,
      public ctype_base
{
    public:
        typedef wchar_t char_type;

        explicit ctype(size_t __refs = 0)
            : locale::facet(__refs) {}

        bool is(mask __m, char_type __c) const
        {
            return do_is(__m, __c);
        }

        const char_type *is(const char_type *__low, const char_type *__high, mask *__vec) const
        {
            return do_is(__low, __high, __vec);
        }

        const char_type *scan_is(mask __m, const char_type *__low, const char_type *__high) const
        {
            return do_scan_is(__m, __low, __high);
        }

        const char_type *scan_not(mask __m, const char_type *__low, const char_type *__high) const
        {
            return do_scan_not(__m, __low, __high);
        }

        char_type toupper(char_type __c) const
        {
            return do_toupper(__c);
        }

        const char_type *toupper(char_type *__low, const char_type *__high) const
        {
            return do_toupper(__low, __high);
        }

        char_type tolower(char_type __c) const
        {
            return do_tolower(__c);
        }

        const char_type *tolower(char_type *__low, const char_type *__high) const
        {
            return do_tolower(__low, __high);
        }

        char_type widen(char __c) const
        {
            return do_widen(__c);
        }

        const char *widen(const char *__low, const char *__high, char_type *__to) const
        {
            return do_widen(__low, __high, __to);
        }

        char narrow(char_type __c, char __dfault) const
        {
            return do_narrow(__c, __dfault);
        }

        const char_type *narrow(const char_type *__low, const char_type *__high, char __dfault, char *__to) const
        {
            return do_narrow(__low, __high, __dfault, __to);
        }
        static locale::id id;

    protected:
        ~ctype();
        virtual bool do_is(mask __m, char_type __c) const;
        virtual const char_type *do_is(const char_type *__low, const char_type *__high, mask *__vec) const;
        virtual const char_type *do_scan_is(mask __m, const char_type *__low, const char_type *__high) const;
        virtual const char_type *do_scan_not(mask __m, const char_type *__low, const char_type *__high) const;
        virtual char_type do_toupper(char_type) const;
        virtual const char_type *do_toupper(char_type *__low, const char_type *__high) const;
        virtual char_type do_tolower(char_type) const;
        virtual const char_type *do_tolower(char_type *__low, const char_type *__high) const;
        virtual char_type do_widen(char) const;
        virtual const char *do_widen(const char *__low, const char *__high, char_type *__dest) const;
        virtual char do_narrow(char_type, char __dfault) const;
        virtual const char_type *do_narrow(const char_type *__low, const char_type *__high, char __dfault, char *__dest) const;
};
template <>
class ctype<char>
    : public locale::facet, public ctype_base
{
        const mask *__tab_;
        bool __del_;

    public:
        typedef char char_type;
        explicit ctype(const mask *__tab = __nullptr, bool __del = false, size_t __refs = 0);

        bool is(mask __m, char_type __c) const
        {
            return isascii(__c) ? (__tab_[static_cast<int>(__c)] & __m) != 0 : false;
        }

        const char_type *is(const char_type *__low, const char_type *__high, mask *__vec) const
        {
            for (; __low != __high; ++__low, ++__vec)
                *__vec = isascii(*__low) ? __tab_[static_cast<int>(*__low)] : 0;
            return __low;
        }

        const char_type *scan_is(mask __m, const char_type *__low, const char_type *__high) const
        {
            for (; __low != __high; ++__low)
                if (isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m))
                    break;
            return __low;
        }

        const char_type *scan_not(mask __m, const char_type *__low, const char_type *__high) const
        {
            for (; __low != __high; ++__low)
                if (!(isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m)))
                    break;
            return __low;
        }

        char_type toupper(char_type __c) const
        {
            return do_toupper(__c);
        }

        const char_type *toupper(char_type *__low, const char_type *__high) const
        {
            return do_toupper(__low, __high);
        }

        char_type tolower(char_type __c) const
        {
            return do_tolower(__c);
        }

        const char_type *tolower(char_type *__low, const char_type *__high) const
        {
            return do_tolower(__low, __high);
        }

        char_type widen(char __c) const
        {
            return do_widen(__c);
        }

        const char *widen(const char *__low, const char *__high, char_type *__to) const
        {
            return do_widen(__low, __high, __to);
        }

        char narrow(char_type __c, char __dfault) const
        {
            return do_narrow(__c, __dfault);
        }

        const char *narrow(const char_type *__low, const char_type *__high, char __dfault, char *__to) const
        {
            return do_narrow(__low, __high, __dfault, __to);
        }
        static locale::id id;
        static const size_t table_size = (1 << 8);
        {
            return __tab_;
        }
        static const mask *classic_table() throw();

    protected:
        ~ctype();
        virtual char_type do_toupper(char_type __c) const;
        virtual const char_type *do_toupper(char_type *__low, const char_type *__high) const;
        virtual char_type do_tolower(char_type __c) const;
        virtual const char_type *do_tolower(char_type *__low, const char_type *__high) const;
        virtual char_type do_widen(char __c) const;
        virtual const char *do_widen(const char *__low, const char *__high, char_type *__to) const;
        virtual char do_narrow(char_type __c, char __dfault) const;
        virtual const char *do_narrow(const char_type *__low, const char_type *__high, char __dfault, char *__to) const;
};
template <class _CharT>
class ctype_byname;
template <>
class ctype_byname<char>
    : public ctype<char>
{
        locale_t __l;

    public:
        explicit ctype_byname(const char *, size_t = 0);
        explicit ctype_byname(const string &, size_t = 0);

    protected:
        ~ctype_byname();
        virtual char_type do_toupper(char_type) const;
        virtual const char_type *do_toupper(char_type *__low, const char_type *__high) const;
        virtual char_type do_tolower(char_type) const;
        virtual const char_type *do_tolower(char_type *__low, const char_type *__high) const;
};
template <>
class ctype_byname<wchar_t>
    : public ctype<wchar_t>
{
        locale_t __l;

    public:
        explicit ctype_byname(const char *, size_t = 0);
        explicit ctype_byname(const string &, size_t = 0);

    protected:
        ~ctype_byname();
        virtual bool do_is(mask __m, char_type __c) const;
        virtual const char_type *do_is(const char_type *__low, const char_type *__high, mask *__vec) const;
        virtual const char_type *do_scan_is(mask __m, const char_type *__low, const char_type *__high) const;
        virtual const char_type *do_scan_not(mask __m, const char_type *__low, const char_type *__high) const;
        virtual char_type do_toupper(char_type) const;
        virtual const char_type *do_toupper(char_type *__low, const char_type *__high) const;
        virtual char_type do_tolower(char_type) const;
        virtual const char_type *do_tolower(char_type *__low, const char_type *__high) const;
        virtual char_type do_widen(char) const;
        virtual const char *do_widen(const char *__low, const char *__high, char_type *__dest) const;
        virtual char do_narrow(char_type, char __dfault) const;
        virtual const char_type *do_narrow(const char_type *__low, const char_type *__high, char __dfault, char *__dest) const;
};
template <class _CharT>
inline bool
isspace(_CharT __c, const locale &__loc)
{
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::space, __c);
}
template <class _CharT>
inline bool
isprint(_CharT __c, const locale &__loc)
{
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::print, __c);
}
template <class _CharT>
inline bool
iscntrl(_CharT __c, const locale &__loc)
{
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::cntrl, __c);
}
template <class _CharT>
inline bool
isupper(_CharT __c, const locale &__loc)
{
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::upper, __c);
}
template <class _CharT>
inline bool
islower(_CharT __c, const locale &__loc)
{
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::lower, __c);
}
template <class _CharT>
inline bool
isalpha(_CharT __c, const locale &__loc)
{
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::alpha, __c);
}
template <class _CharT>
inline bool
isdigit(_CharT __c, const locale &__loc)
{
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::digit, __c);
}
template <class _CharT>
inline bool
ispunct(_CharT __c, const locale &__loc)
{
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::punct, __c);
}
template <class _CharT>
inline bool
isxdigit(_CharT __c, const locale &__loc)
{
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::xdigit, __c);
}
template <class _CharT>
inline bool
isalnum(_CharT __c, const locale &__loc)
{
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::alnum, __c);
}
template <class _CharT>
inline bool
isgraph(_CharT __c, const locale &__loc)
{
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::graph, __c);
}
template <class _CharT>
inline _CharT
toupper(_CharT __c, const locale &__loc)
{
        return use_facet<ctype<_CharT>>(__loc).toupper(__c);
}
template <class _CharT>
inline _CharT
tolower(_CharT __c, const locale &__loc)
{
        return use_facet<ctype<_CharT>>(__loc).tolower(__c);
}
class codecvt_base
{
    public:
        {
        }
        enum result
        {
            ok,
            partial,
            error,
            noconv
        };
};
template <class _InternT, class _ExternT, class _StateT>
class codecvt;
template <>
class codecvt<char, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
    public:
        typedef char intern_type;
        typedef char extern_type;
        typedef mbstate_t state_type;

        explicit codecvt(size_t __refs = 0)
            : locale::facet(__refs) {}

        result out(state_type &__st,
                   const intern_type *__frm, const intern_type *__frm_end, const intern_type *&__frm_nxt,
                   extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const
        {
            return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
        }

        result unshift(state_type &__st,
                       extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const
        {
            return do_unshift(__st, __to, __to_end, __to_nxt);
        }

        result in(state_type &__st,
                  const extern_type *__frm, const extern_type *__frm_end, const extern_type *&__frm_nxt,
                  intern_type *__to, intern_type *__to_end, intern_type *&__to_nxt) const
        {
            return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
        }

        int encoding() const throw()
        {
            return do_encoding();
        }

        bool always_noconv() const throw()
        {
            return do_always_noconv();
        }

        int length(state_type &__st, const extern_type *__frm, const extern_type *__end, size_t __mx) const
        {
            return do_length(__st, __frm, __end, __mx);
        }

        int max_length() const throw()
        {
            return do_max_length();
        }
        static locale::id id;

    protected:
        explicit codecvt(const char *, size_t __refs = 0)
            : locale::facet(__refs) {}
        ~codecvt();
        virtual result do_out(state_type &__st,
                              const intern_type *__frm, const intern_type *__frm_end, const intern_type *&__frm_nxt,
                              extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const;
        virtual result do_in(state_type &__st,
                             const extern_type *__frm, const extern_type *__frm_end, const extern_type *&__frm_nxt,
                             intern_type *__to, intern_type *__to_end, intern_type *&__to_nxt) const;
        virtual result do_unshift(state_type &__st,
                                  extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const;
        virtual int do_encoding() const throw();
        virtual bool do_always_noconv() const throw();
        virtual int do_length(state_type &__st, const extern_type *__frm, const extern_type *__end, size_t __mx) const;
        virtual int do_max_length() const throw();
};
template <>
class codecvt<wchar_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
        locale_t __l;

    public:
        typedef wchar_t intern_type;
        typedef char extern_type;
        typedef mbstate_t state_type;
        explicit codecvt(size_t __refs = 0);

        result out(state_type &__st,
                   const intern_type *__frm, const intern_type *__frm_end, const intern_type *&__frm_nxt,
                   extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const
        {
            return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
        }

        result unshift(state_type &__st,
                       extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const
        {
            return do_unshift(__st, __to, __to_end, __to_nxt);
        }

        result in(state_type &__st,
                  const extern_type *__frm, const extern_type *__frm_end, const extern_type *&__frm_nxt,
                  intern_type *__to, intern_type *__to_end, intern_type *&__to_nxt) const
        {
            return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
        }

        int encoding() const throw()
        {
            return do_encoding();
        }

        bool always_noconv() const throw()
        {
            return do_always_noconv();
        }

        int length(state_type &__st, const extern_type *__frm, const extern_type *__end, size_t __mx) const
        {
            return do_length(__st, __frm, __end, __mx);
        }

        int max_length() const throw()
        {
            return do_max_length();
        }
        static locale::id id;

    protected:
        explicit codecvt(const char *, size_t __refs = 0);
        ~codecvt();
        virtual result do_out(state_type &__st,
                              const intern_type *__frm, const intern_type *__frm_end, const intern_type *&__frm_nxt,
                              extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const;
        virtual result do_in(state_type &__st,
                             const extern_type *__frm, const extern_type *__frm_end, const extern_type *&__frm_nxt,
                             intern_type *__to, intern_type *__to_end, intern_type *&__to_nxt) const;
        virtual result do_unshift(state_type &__st,
                                  extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const;
        virtual int do_encoding() const throw();
        virtual bool do_always_noconv() const throw();
        virtual int do_length(state_type &, const extern_type *__frm, const extern_type *__end, size_t __mx) const;
        virtual int do_max_length() const throw();
};
template <>
class codecvt<char16_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
    public:
        typedef char16_t intern_type;
        typedef char extern_type;
        typedef mbstate_t state_type;

        explicit codecvt(size_t __refs = 0)
            : locale::facet(__refs) {}

        result out(state_type &__st,
                   const intern_type *__frm, const intern_type *__frm_end, const intern_type *&__frm_nxt,
                   extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const
        {
            return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
        }

        result unshift(state_type &__st,
                       extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const
        {
            return do_unshift(__st, __to, __to_end, __to_nxt);
        }

        result in(state_type &__st,
                  const extern_type *__frm, const extern_type *__frm_end, const extern_type *&__frm_nxt,
                  intern_type *__to, intern_type *__to_end, intern_type *&__to_nxt) const
        {
            return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
        }

        int encoding() const throw()
        {
            return do_encoding();
        }

        bool always_noconv() const throw()
        {
            return do_always_noconv();
        }

        int length(state_type &__st, const extern_type *__frm, const extern_type *__end, size_t __mx) const
        {
            return do_length(__st, __frm, __end, __mx);
        }

        int max_length() const throw()
        {
            return do_max_length();
        }
        static locale::id id;

    protected:
        explicit codecvt(const char *, size_t __refs = 0)
            : locale::facet(__refs) {}
        ~codecvt();
        virtual result do_out(state_type &__st,
                              const intern_type *__frm, const intern_type *__frm_end, const intern_type *&__frm_nxt,
                              extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const;
        virtual result do_in(state_type &__st,
                             const extern_type *__frm, const extern_type *__frm_end, const extern_type *&__frm_nxt,
                             intern_type *__to, intern_type *__to_end, intern_type *&__to_nxt) const;
        virtual result do_unshift(state_type &__st,
                                  extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const;
        virtual int do_encoding() const throw();
        virtual bool do_always_noconv() const throw();
        virtual int do_length(state_type &, const extern_type *__frm, const extern_type *__end, size_t __mx) const;
        virtual int do_max_length() const throw();
};
template <>
class codecvt<char32_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
    public:
        typedef char32_t intern_type;
        typedef char extern_type;
        typedef mbstate_t state_type;

        explicit codecvt(size_t __refs = 0)
            : locale::facet(__refs) {}

        result out(state_type &__st,
                   const intern_type *__frm, const intern_type *__frm_end, const intern_type *&__frm_nxt,
                   extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const
        {
            return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
        }

        result unshift(state_type &__st,
                       extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const
        {
            return do_unshift(__st, __to, __to_end, __to_nxt);
        }

        result in(state_type &__st,
                  const extern_type *__frm, const extern_type *__frm_end, const extern_type *&__frm_nxt,
                  intern_type *__to, intern_type *__to_end, intern_type *&__to_nxt) const
        {
            return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
        }

        int encoding() const throw()
        {
            return do_encoding();
        }

        bool always_noconv() const throw()
        {
            return do_always_noconv();
        }

        int length(state_type &__st, const extern_type *__frm, const extern_type *__end, size_t __mx) const
        {
            return do_length(__st, __frm, __end, __mx);
        }

        int max_length() const throw()
        {
            return do_max_length();
        }
        static locale::id id;

    protected:
        explicit codecvt(const char *, size_t __refs = 0)
            : locale::facet(__refs) {}
        ~codecvt();
        virtual result do_out(state_type &__st,
                              const intern_type *__frm, const intern_type *__frm_end, const intern_type *&__frm_nxt,
                              extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const;
        virtual result do_in(state_type &__st,
                             const extern_type *__frm, const extern_type *__frm_end, const extern_type *&__frm_nxt,
                             intern_type *__to, intern_type *__to_end, intern_type *&__to_nxt) const;
        virtual result do_unshift(state_type &__st,
                                  extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const;
        virtual int do_encoding() const throw();
        virtual bool do_always_noconv() const throw();
        virtual int do_length(state_type &, const extern_type *__frm, const extern_type *__end, size_t __mx) const;
        virtual int do_max_length() const throw();
};
template <class _InternT, class _ExternT, class _StateT>
class codecvt_byname
    : public codecvt<_InternT, _ExternT, _StateT>
{
    public:
        explicit codecvt_byname(const char *__nm, size_t __refs = 0)
            : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {}

        explicit codecvt_byname(const string &__nm, size_t __refs = 0)
            : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {}

    protected:
        ~codecvt_byname();
};
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _InternT, class _ExternT, class _StateT>
codecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname()
{
}
#pragma GCC diagnostic pop
extern template class codecvt_byname<char, char, mbstate_t>;
extern template class codecvt_byname<wchar_t, char, mbstate_t>;
extern template class codecvt_byname<char16_t, char, mbstate_t>;
extern template class codecvt_byname<char32_t, char, mbstate_t>;
template <size_t _Np>
struct __narrow_to_utf8
{
        template <class _OutputIterator, class _CharT>
        _OutputIterator
        operator()(_OutputIterator __s, const _CharT *__wb, const _CharT *__we) const;
};
template <>
struct __narrow_to_utf8<8>
{
        template <class _OutputIterator, class _CharT>

        _OutputIterator
        operator()(_OutputIterator __s, const _CharT *__wb, const _CharT *__we) const
        {
            for (; __wb < __we; ++__wb, ++__s)
                *__s = *__wb;
            return __s;
        }
};
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __narrow_to_utf8<16>
    : public codecvt<char16_t, char, mbstate_t>
{

        __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}
#pragma GCC diagnostic pop
        ~__narrow_to_utf8();
        template <class _OutputIterator, class _CharT>

        _OutputIterator
        operator()(_OutputIterator __s, const _CharT *__wb, const _CharT *__we) const
        {
            result __r = ok;
            mbstate_t __mb;
            while (__wb < __we && __r != error)
            {
                const int __sz = 32;
                char __buf[__sz];
                char *__bn;
                const char16_t *__wn = (const char16_t *)__wb;
                __r = do_out(__mb, (const char16_t *)__wb, (const char16_t *)__we, __wn,
                             __buf, __buf + __sz, __bn);
                if (__r == codecvt_base::error || __wn == (const char16_t *)__wb)
                    __throw_runtime_error("locale not supported");
                for (const char *__p = __buf; __p < __bn; ++__p, ++__s)
                    *__s = *__p;
                __wb = (const _CharT *)__wn;
            }
            return __s;
        }
};
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __narrow_to_utf8<32>
    : public codecvt<char32_t, char, mbstate_t>
{

        __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}
#pragma GCC diagnostic pop
        ~__narrow_to_utf8();
        template <class _OutputIterator, class _CharT>

        _OutputIterator
        operator()(_OutputIterator __s, const _CharT *__wb, const _CharT *__we) const
        {
            result __r = ok;
            mbstate_t __mb;
            while (__wb < __we && __r != error)
            {
                const int __sz = 32;
                char __buf[__sz];
                char *__bn;
                const char32_t *__wn = (const char32_t *)__wb;
                __r = do_out(__mb, (const char32_t *)__wb, (const char32_t *)__we, __wn,
                             __buf, __buf + __sz, __bn);
                if (__r == codecvt_base::error || __wn == (const char32_t *)__wb)
                    __throw_runtime_error("locale not supported");
                for (const char *__p = __buf; __p < __bn; ++__p, ++__s)
                    *__s = *__p;
                __wb = (const _CharT *)__wn;
            }
            return __s;
        }
};
template <size_t _Np>
struct __widen_from_utf8
{
        template <class _OutputIterator>
        _OutputIterator
        operator()(_OutputIterator __s, const char *__nb, const char *__ne) const;
};
template <>
struct __widen_from_utf8<8>
{
        template <class _OutputIterator>

        _OutputIterator
        operator()(_OutputIterator __s, const char *__nb, const char *__ne) const
        {
            for (; __nb < __ne; ++__nb, ++__s)
                *__s = *__nb;
            return __s;
        }
};
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __widen_from_utf8<16>
    : public codecvt<char16_t, char, mbstate_t>
{

        __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}
#pragma GCC diagnostic pop
        ~__widen_from_utf8();
        template <class _OutputIterator>

        _OutputIterator
        operator()(_OutputIterator __s, const char *__nb, const char *__ne) const
        {
            result __r = ok;
            mbstate_t __mb;
            while (__nb < __ne && __r != error)
            {
                const int __sz = 32;
                char16_t __buf[__sz];
                char16_t *__bn;
                const char *__nn = __nb;
                __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb + __sz : __ne, __nn,
                            __buf, __buf + __sz, __bn);
                if (__r == codecvt_base::error || __nn == __nb)
                    __throw_runtime_error("locale not supported");
                for (const char16_t *__p = __buf; __p < __bn; ++__p, ++__s)
                    *__s = *__p;
                __nb = __nn;
            }
            return __s;
        }
};
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __widen_from_utf8<32>
    : public codecvt<char32_t, char, mbstate_t>
{

        __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}
#pragma GCC diagnostic pop
        ~__widen_from_utf8();
        template <class _OutputIterator>

        _OutputIterator
        operator()(_OutputIterator __s, const char *__nb, const char *__ne) const
        {
            result __r = ok;
            mbstate_t __mb;
            while (__nb < __ne && __r != error)
            {
                const int __sz = 32;
                char32_t __buf[__sz];
                char32_t *__bn;
                const char *__nn = __nb;
                __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb + __sz : __ne, __nn,
                            __buf, __buf + __sz, __bn);
                if (__r == codecvt_base::error || __nn == __nb)
                    __throw_runtime_error("locale not supported");
                for (const char32_t *__p = __buf; __p < __bn; ++__p, ++__s)
                    *__s = *__p;
                __nb = __nn;
            }
            return __s;
        }
};
template <class _CharT>
class numpunct;
template <>
class numpunct<char>
    : public locale::facet
{
    public:
        typedef char char_type;
        typedef basic_string<char_type> string_type;
        explicit numpunct(size_t __refs = 0);
        ;
};
    };
};
}
;
}
static locale::id id;

protected:
~numpunct();
virtual char_type do_decimal_point() const;
virtual char_type do_thousands_sep() const;
virtual string do_grouping() const;
virtual string_type do_truename() const;
virtual string_type do_falsename() const;
char_type __decimal_point_;
char_type __thousands_sep_;
string __grouping_;
}
;
template <>
class numpunct<wchar_t>
    : public locale::facet
{
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;
    explicit numpunct(size_t __refs = 0);
    ;
};
}
;
}
;
}
;
}
static locale::id id;

protected:
~numpunct();
virtual char_type do_decimal_point() const;
virtual char_type do_thousands_sep() const;
virtual string do_grouping() const;
virtual string_type do_truename() const;
virtual string_type do_falsename() const;
char_type __decimal_point_;
char_type __thousands_sep_;
string __grouping_;
}
;
template <class _CharT>
class numpunct_byname;
template <>
class numpunct_byname<char>
    : public numpunct<char>
{
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;
    explicit numpunct_byname(const char *__nm, size_t __refs = 0);
    explicit numpunct_byname(const string &__nm, size_t __refs = 0);

protected:
    ~numpunct_byname();

private:
    void __init(const char *);
};
template <>
class numpunct_byname<wchar_t>
    : public numpunct<wchar_t>
{
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;
    explicit numpunct_byname(const char *__nm, size_t __refs = 0);
    explicit numpunct_byname(const string &__nm, size_t __refs = 0);

protected:
    ~numpunct_byname();

private:
    void __init(const char *);
};
}
}
namespace std
{
    inline namespace __1
    {
typedef ptrdiff_t streamsize;
class ios_base
{
    public:
        class failure;
        typedef unsigned int fmtflags;
        static const fmtflags boolalpha = 0x0001;
        static const fmtflags dec = 0x0002;
        static const fmtflags fixed = 0x0004;
        static const fmtflags hex = 0x0008;
        static const fmtflags internal = 0x0010;
        static const fmtflags left = 0x0020;
        static const fmtflags oct = 0x0040;
        static const fmtflags right = 0x0080;
        static const fmtflags scientific = 0x0100;
        static const fmtflags showbase = 0x0200;
        static const fmtflags showpoint = 0x0400;
        static const fmtflags showpos = 0x0800;
        static const fmtflags skipws = 0x1000;
        static const fmtflags unitbuf = 0x2000;
        static const fmtflags uppercase = 0x4000;
        static const fmtflags adjustfield = left | right | internal;
        static const fmtflags basefield = dec | oct | hex;
        static const fmtflags floatfield = scientific | fixed;
        typedef unsigned int iostate;
        static const iostate badbit = 0x1;
        static const iostate eofbit = 0x2;
        static const iostate failbit = 0x4;
        static const iostate goodbit = 0x0;
        typedef unsigned int openmode;
        static const openmode app = 0x01;
        static const openmode ate = 0x02;
        static const openmode binary = 0x04;
        static const openmode in = 0x08;
        static const openmode out = 0x10;
        static const openmode trunc = 0x20;
        enum seekdir
        {
            beg,
            cur,
            end
        };
        typedef iostate io_state;
        typedef openmode open_mode;
        typedef seekdir seek_dir;
        typedef std::streamoff streamoff;
        typedef std::streampos streampos;
        class Init;
        const;
        ;
        ;
        ;
        ;
        const;
        ;
        const;
        ;
        locale imbue(const locale &__loc);
        locale getloc() const;
        static int xalloc();
        long &iword(int __index);
        void *&pword(int __index);
        virtual ~ios_base();
        enum event
        {
            erase_event,
            imbue_event,
            copyfmt_event
        };
        typedef void (*event_callback)(event, ios_base &, int __index);
        void register_callback(event_callback __fn, int __index);
        ios_base(const ios_base &) = delete;
        ios_base &operator=(const ios_base &) = delete;
        static bool sync_with_stdio(bool __sync = true);
        const;
        void clear(iostate __state = goodbit);
        ;
        const;
        const;
        const;
        const;
        const;
        ;
        void __set_badbit_and_consider_rethrow();
        void __set_failbit_and_consider_rethrow();

        void __setstate_nothrow(iostate __state)
        {
            if (__rdbuf_)
                __rdstate_ |= __state;
            else
                __rdstate_ |= __state | ios_base::badbit;
        }

    protected:
        ios_base()
        {
        }
        void init(void *__sb);
        const { return __rdbuf_; }

        void rdbuf(void *__sb)
        {
            __rdbuf_ = __sb;
            clear();
        }
        void __call_callbacks(event);
        void copyfmt(const ios_base &);
        void move(ios_base &);
        void swap(ios_base &) throw();

        void set_rdbuf(void *__sb)
        {
            __rdbuf_ = __sb;
        }

    private:
        fmtflags __fmtflags_;
        streamsize __precision_;
        streamsize __width_;
        iostate __rdstate_;
        iostate __exceptions_;
        void *__rdbuf_;
        void *__loc_;
        event_callback *__fn_;
        int *__index_;
        size_t __event_size_;
        size_t __event_cap_;
        static atomic<int> __xindex_;
        long *__iarray_;
        size_t __iarray_size_;
        size_t __iarray_cap_;
        void **__parray_;
        size_t __parray_size_;
        size_t __parray_cap_;
};
struct io_errc
{
        enum __lx
        {
            stream = 1
        };
        __lx __v_;
        const { return __v_; }
};
template <>
struct is_error_code_enum<io_errc> : public true_type
{
};
template <>
struct is_error_code_enum<io_errc::__lx> : public true_type
{
};

const error_category &iostream_category() throw();
inline error_code
make_error_code(io_errc __e) throw()
{
        return error_code(static_cast<int>(__e), iostream_category());
}
inline error_condition
make_error_condition(io_errc __e) throw()
{
        return error_condition(static_cast<int>(__e), iostream_category());
}
class ios_base::failure
    : public system_error
{
    public:
        explicit failure(const string &__msg, const error_code &__ec = io_errc::stream);
        explicit failure(const char *__msg, const error_code &__ec = io_errc::stream);
        failure(const failure &) throw() = default;
        virtual ~failure() throw();
};

void __throw_failure(char const *__msg)
{
        throw ios_base::failure(__msg);
}
class ios_base::Init
{
    public:
        Init();
        ~Init();
};
inline ios_base::fmtflags
ios_base::flags() const
{
        return __fmtflags_;
}
inline ios_base::fmtflags
ios_base::flags(fmtflags __fmtfl)
{
        fmtflags __r = __fmtflags_;
        __fmtflags_ = __fmtfl;
        return __r;
}
inline ios_base::fmtflags
ios_base::setf(fmtflags __fmtfl)
{
        fmtflags __r = __fmtflags_;
        __fmtflags_ |= __fmtfl;
        return __r;
}
inline void
ios_base::unsetf(fmtflags __mask)
{
        __fmtflags_ &= ~__mask;
}
inline ios_base::fmtflags
ios_base::setf(fmtflags __fmtfl, fmtflags __mask)
{
        fmtflags __r = __fmtflags_;
        unsetf(__mask);
        __fmtflags_ |= __fmtfl & __mask;
        return __r;
}
inline streamsize
ios_base::precision() const
{
        return __precision_;
}
inline streamsize
ios_base::precision(streamsize __prec)
{
        streamsize __r = __precision_;
        __precision_ = __prec;
        return __r;
}
inline streamsize
ios_base::width() const
{
        return __width_;
}
inline streamsize
ios_base::width(streamsize __wide)
{
        streamsize __r = __width_;
        __width_ = __wide;
        return __r;
}
inline ios_base::iostate
ios_base::rdstate() const
{
        return __rdstate_;
}
inline void
ios_base::setstate(iostate __state)
{
        clear(__rdstate_ | __state);
}
inline bool
ios_base::good() const
{
        return __rdstate_ == 0;
}
inline bool
ios_base::eof() const
{
        return (__rdstate_ & eofbit) != 0;
}
inline bool
ios_base::fail() const
{
        return (__rdstate_ & (failbit | badbit)) != 0;
}
inline bool
ios_base::bad() const
{
        return (__rdstate_ & badbit) != 0;
}
inline ios_base::iostate
ios_base::exceptions() const
{
        return __exceptions_;
}
inline void
ios_base::exceptions(iostate __iostate)
{
        __exceptions_ = __iostate;
        clear(__rdstate_);
}
template <class _CharT, class _Traits>
class basic_ios
    : public ios_base
{
    public:
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        _Static_assert((is_same<_CharT, typename traits_type::char_type>::value), "traits_type::char_type must be the same type as CharT");

        operator void *() const { return fail() ? __nullptr : (void *)this; };
};
    };
};
}
;
}
;
}
;
}
;
}
;
}
;
}

explicit basic_ios(basic_streambuf<char_type, traits_type> *__sb);
virtual ~basic_ios();

basic_ostream<char_type, traits_type> *tie() const;

basic_ostream<char_type, traits_type> *tie(basic_ostream<char_type, traits_type> *__tiestr);

basic_streambuf<char_type, traits_type> *rdbuf() const;

basic_streambuf<char_type, traits_type> *rdbuf(basic_streambuf<char_type, traits_type> *__sb);
basic_ios &copyfmt(const basic_ios &__rhs);

char_type fill() const;

char_type fill(char_type __ch);

locale imbue(const locale &__loc);

char narrow(char_type __c, char __dfault) const;

char_type widen(char __c) const;

protected:
basic_ios()
{
}

void init(basic_streambuf<char_type, traits_type> *__sb);

void move(basic_ios &__rhs);

void move(basic_ios &&__rhs) { move(__rhs); }

void swap(basic_ios &__rhs) throw();

void set_rdbuf(basic_streambuf<char_type, traits_type> *__sb);

private:
basic_ostream<char_type, traits_type> *__tie_;
mutable int_type __fill_;
}
;
template <class _CharT, class _Traits>
inline basic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type, traits_type> *__sb)
{
    init(__sb);
}
template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>::~basic_ios()
{
}
template <class _CharT, class _Traits>
inline void
basic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type> *__sb)
{
    ios_base::init(__sb);
    __tie_ = __nullptr;
    __fill_ = traits_type::eof();
}
template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits> *
basic_ios<_CharT, _Traits>::tie() const
{
    return __tie_;
}
template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits> *
basic_ios<_CharT, _Traits>::tie(basic_ostream<char_type, traits_type> *__tiestr)
{
    basic_ostream<char_type, traits_type> *__r = __tie_;
    __tie_ = __tiestr;
    return __r;
}
template <class _CharT, class _Traits>
inline basic_streambuf<_CharT, _Traits> *
basic_ios<_CharT, _Traits>::rdbuf() const
{
    return static_cast<basic_streambuf<char_type, traits_type> *>(ios_base::rdbuf());
}
template <class _CharT, class _Traits>
inline basic_streambuf<_CharT, _Traits> *
basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type> *__sb)
{
    basic_streambuf<char_type, traits_type> *__r = rdbuf();
    ios_base::rdbuf(__sb);
    return __r;
}
template <class _CharT, class _Traits>
inline locale
basic_ios<_CharT, _Traits>::imbue(const locale &__loc)
{
    locale __r = getloc();
    ios_base::imbue(__loc);
    if (rdbuf())
rdbuf()->pubimbue(__loc);
    return __r;
}
template <class _CharT, class _Traits>
inline char
basic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const
{
    return use_facet<ctype<char_type>>(getloc()).narrow(__c, __dfault);
}
template <class _CharT, class _Traits>
inline _CharT
basic_ios<_CharT, _Traits>::widen(char __c) const
{
    return use_facet<ctype<char_type>>(getloc()).widen(__c);
}
template <class _CharT, class _Traits>
inline _CharT
basic_ios<_CharT, _Traits>::fill() const
{
    if (traits_type::eq_int_type(traits_type::eof(), __fill_))
__fill_ = widen(' ');
    return __fill_;
}
template <class _CharT, class _Traits>
inline _CharT
basic_ios<_CharT, _Traits>::fill(char_type __ch)
{
    if (traits_type::eq_int_type(traits_type::eof(), __fill_))
__fill_ = widen(' ');
    char_type __r = __fill_;
    __fill_ = __ch;
    return __r;
}
template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits> &
basic_ios<_CharT, _Traits>::copyfmt(const basic_ios &__rhs)
{
    if (this != &__rhs)
    {
__call_callbacks(erase_event);
ios_base::copyfmt(__rhs);
__tie_ = __rhs.__tie_;
__fill_ = __rhs.__fill_;
__call_callbacks(copyfmt_event);
exceptions(__rhs.exceptions());
    }
    return *this;
}
template <class _CharT, class _Traits>
inline void
basic_ios<_CharT, _Traits>::move(basic_ios &__rhs)
{
    ios_base::move(__rhs);
    __tie_ = __rhs.__tie_;
    __rhs.__tie_ = __nullptr;
    __fill_ = __rhs.__fill_;
}
template <class _CharT, class _Traits>
inline void
basic_ios<_CharT, _Traits>::swap(basic_ios &__rhs) throw()
{
    ios_base::swap(__rhs);
    std::swap(__tie_, __rhs.__tie_);
    std::swap(__fill_, __rhs.__fill_);
}
template <class _CharT, class _Traits>
inline void
basic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type> *__sb)
{
    ios_base::set_rdbuf(__sb);
}
inline ios_base &
boolalpha(ios_base &__str)
{
    __str.setf(ios_base::boolalpha);
    return __str;
}
inline ios_base &
noboolalpha(ios_base &__str)
{
    __str.unsetf(ios_base::boolalpha);
    return __str;
}
inline ios_base &
showbase(ios_base &__str)
{
    __str.setf(ios_base::showbase);
    return __str;
}
inline ios_base &
noshowbase(ios_base &__str)
{
    __str.unsetf(ios_base::showbase);
    return __str;
}
inline ios_base &
showpoint(ios_base &__str)
{
    __str.setf(ios_base::showpoint);
    return __str;
}
inline ios_base &
noshowpoint(ios_base &__str)
{
    __str.unsetf(ios_base::showpoint);
    return __str;
}
inline ios_base &
showpos(ios_base &__str)
{
    __str.setf(ios_base::showpos);
    return __str;
}
inline ios_base &
noshowpos(ios_base &__str)
{
    __str.unsetf(ios_base::showpos);
    return __str;
}
inline ios_base &
skipws(ios_base &__str)
{
    __str.setf(ios_base::skipws);
    return __str;
}
inline ios_base &
noskipws(ios_base &__str)
{
    __str.unsetf(ios_base::skipws);
    return __str;
}
inline ios_base &
uppercase(ios_base &__str)
{
    __str.setf(ios_base::uppercase);
    return __str;
}
inline ios_base &
nouppercase(ios_base &__str)
{
    __str.unsetf(ios_base::uppercase);
    return __str;
}
inline ios_base &
unitbuf(ios_base &__str)
{
    __str.setf(ios_base::unitbuf);
    return __str;
}
inline ios_base &
nounitbuf(ios_base &__str)
{
    __str.unsetf(ios_base::unitbuf);
    return __str;
}
inline ios_base &
internal(ios_base &__str)
{
    __str.setf(ios_base::internal, ios_base::adjustfield);
    return __str;
}
inline ios_base &
left(ios_base &__str)
{
    __str.setf(ios_base::left, ios_base::adjustfield);
    return __str;
}
inline ios_base &
right(ios_base &__str)
{
    __str.setf(ios_base::right, ios_base::adjustfield);
    return __str;
}
inline ios_base &
dec(ios_base &__str)
{
    __str.setf(ios_base::dec, ios_base::basefield);
    return __str;
}
inline ios_base &
hex(ios_base &__str)
{
    __str.setf(ios_base::hex, ios_base::basefield);
    return __str;
}
inline ios_base &
oct(ios_base &__str)
{
    __str.setf(ios_base::oct, ios_base::basefield);
    return __str;
}
inline ios_base &
fixed(ios_base &__str)
{
    __str.setf(ios_base::fixed, ios_base::floatfield);
    return __str;
}
inline ios_base &
scientific(ios_base &__str)
{
    __str.setf(ios_base::scientific, ios_base::floatfield);
    return __str;
}
inline ios_base &
hexfloat(ios_base &__str)
{
    __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __str;
}
inline ios_base &
defaultfloat(ios_base &__str)
{
    __str.unsetf(ios_base::floatfield);
    return __str;
}
}
}
namespace std
{
    inline namespace __1
    {
using ::va_list;
    }
}
extern "C"
{
    void __assert_rtn(const char *, const char *, int, const char *);
}

namespace std
{
    inline namespace __1
    {
template <class _CharT, class _Traits>
class basic_streambuf
{
    public:
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        _Static_assert((is_same<_CharT, typename traits_type::char_type>::value), "traits_type::char_type must be the same type as CharT");
        virtual ~basic_streambuf();
        inline locale pubimbue(const locale &__loc)
        {
            imbue(__loc);
            locale __r = __loc_;
            __loc_ = __loc;
            return __r;
        }
        inline locale getloc() const { return __loc_; }
        inline basic_streambuf *pubsetbuf(char_type *__s, streamsize __n)
        {
            return setbuf(__s, __n);
        }
        inline pos_type pubseekoff(off_type __off, ios_base::seekdir __way,
                                   ios_base::openmode __which = ios_base::in | ios_base::out)
        {
            return seekoff(__off, __way, __which);
        }
        inline pos_type pubseekpos(pos_type __sp,
                                   ios_base::openmode __which = ios_base::in | ios_base::out)
        {
            return seekpos(__sp, __which);
        }
        inline int pubsync() { return sync(); }
        inline streamsize in_avail()
        {
            if (__ninp_ < __einp_)
                return static_cast<streamsize>(__einp_ - __ninp_);
            return showmanyc();
        }
        inline int_type snextc()
        {
            if (sbumpc() == traits_type::eof())
                return traits_type::eof();
            return sgetc();
        }
        inline int_type sbumpc()
        {
            if (__ninp_ == __einp_)
                return uflow();
            return traits_type::to_int_type(*__ninp_++);
        }
        inline int_type sgetc()
        {
            if (__ninp_ == __einp_)
                return underflow();
            return traits_type::to_int_type(*__ninp_);
        }
        inline streamsize sgetn(char_type *__s, streamsize __n)
        {
            return xsgetn(__s, __n);
        }
        inline int_type sputbackc(char_type __c)
        {
            if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))
                return pbackfail(traits_type::to_int_type(__c));
            return traits_type::to_int_type(*--__ninp_);
        }
        inline int_type sungetc()
        {
            if (__binp_ == __ninp_)
                return pbackfail();
            return traits_type::to_int_type(*--__ninp_);
        }
        inline int_type sputc(char_type __c)
        {
            if (__nout_ == __eout_)
                return overflow(traits_type::to_int_type(__c));
            *__nout_++ = __c;
            return traits_type::to_int_type(__c);
        }
        inline streamsize sputn(const char_type *__s, streamsize __n)
        {
            return xsputn(__s, __n);
        }

    protected:
        basic_streambuf();
        basic_streambuf(const basic_streambuf &__rhs);
        basic_streambuf &operator=(const basic_streambuf &__rhs);
        void swap(basic_streambuf &__rhs);
        const { return __binp_; }
        const { return __ninp_; }
        const { return __einp_; }
        inline void gbump(int __n) { __ninp_ += __n; }
        inline void setg(char_type *__gbeg, char_type *__gnext, char_type *__gend)
        {
            __binp_ = __gbeg;
            __ninp_ = __gnext;
            __einp_ = __gend;
        }
        const { return __bout_; }
        const { return __nout_; }
        const { return __eout_; }
        inline void pbump(int __n) { __nout_ += __n; }

        void __pbump(streamsize __n) { __nout_ += __n; }
        inline void setp(char_type *__pbeg, char_type *__pend)
        {
            __bout_ = __nout_ = __pbeg;
            __eout_ = __pend;
        }
        virtual void imbue(const locale &__loc);
        virtual basic_streambuf *setbuf(char_type *__s, streamsize __n);
        virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                                 ios_base::openmode __which = ios_base::in | ios_base::out);
        virtual pos_type seekpos(pos_type __sp,
                                 ios_base::openmode __which = ios_base::in | ios_base::out);
        virtual int sync();
        virtual streamsize showmanyc();
        virtual streamsize xsgetn(char_type *__s, streamsize __n);
        virtual int_type underflow();
        virtual int_type uflow();
        virtual int_type pbackfail(int_type __c = traits_type::eof());
        virtual streamsize xsputn(const char_type *__s, streamsize __n);
        virtual int_type overflow(int_type __c = traits_type::eof());

    private:
        locale __loc_;
        char_type *__binp_;
        char_type *__ninp_;
        char_type *__einp_;
        char_type *__bout_;
        char_type *__nout_;
        char_type *__eout_;
};
template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::~basic_streambuf()
{
}
template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf()
    : __binp_(__nullptr),
      __ninp_(__nullptr),
      __einp_(__nullptr),
      __bout_(__nullptr),
      __nout_(__nullptr),
      __eout_(__nullptr)
{
}
template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf &__sb)
    : __loc_(__sb.__loc_),
      __binp_(__sb.__binp_),
      __ninp_(__sb.__ninp_),
      __einp_(__sb.__einp_),
      __bout_(__sb.__bout_),
      __nout_(__sb.__nout_),
      __eout_(__sb.__eout_)
{
}
template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits> &
basic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf &__sb)
{
        __loc_ = __sb.__loc_;
        __binp_ = __sb.__binp_;
        __ninp_ = __sb.__ninp_;
        __einp_ = __sb.__einp_;
        __bout_ = __sb.__bout_;
        __nout_ = __sb.__nout_;
        __eout_ = __sb.__eout_;
        return *this;
}
template <class _CharT, class _Traits>
void basic_streambuf<_CharT, _Traits>::swap(basic_streambuf &__sb)
{
        std::swap(__loc_, __sb.__loc_);
        std::swap(__binp_, __sb.__binp_);
        std::swap(__ninp_, __sb.__ninp_);
        std::swap(__einp_, __sb.__einp_);
        std::swap(__bout_, __sb.__bout_);
        std::swap(__nout_, __sb.__nout_);
        std::swap(__eout_, __sb.__eout_);
}
template <class _CharT, class _Traits>
void basic_streambuf<_CharT, _Traits>::imbue(const locale &)
{
}
template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits> *
basic_streambuf<_CharT, _Traits>::setbuf(char_type *, streamsize)
{
        return this;
}
template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,
                                          ios_base::openmode)
{
        return pos_type(off_type(-1));
}
template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)
{
        return pos_type(off_type(-1));
}
template <class _CharT, class _Traits>
int basic_streambuf<_CharT, _Traits>::sync()
{
        return 0;
}
template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::showmanyc()
{
        return 0;
}
template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsgetn(char_type *__s, streamsize __n)
{
        const int_type __eof = traits_type::eof();
        int_type __c;
        streamsize __i = 0;
        while (__i < __n)
        {
            if (__ninp_ < __einp_)
            {
                const streamsize __len = std::min(static_cast<streamsize>(2147483647),
                                                  std::min(__einp_ - __ninp_, __n - __i));
                traits_type::copy(__s, __ninp_, __len);
                __s += __len;
                __i += __len;
                this->gbump(__len);
            }
            else if ((__c = uflow()) != __eof)
            {
                *__s = traits_type::to_char_type(__c);
                ++__s;
                ++__i;
            }
            else
                break;
        }
        return __i;
}
template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::underflow()
{
        return traits_type::eof();
}
template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::uflow()
{
        if (underflow() == traits_type::eof())
            return traits_type::eof();
        return traits_type::to_int_type(*__ninp_++);
}
template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::pbackfail(int_type)
{
        return traits_type::eof();
}
template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsputn(const char_type *__s, streamsize __n)
{
        streamsize __i = 0;
        int_type __eof = traits_type::eof();
        while (__i < __n)
        {
            if (__nout_ >= __eout_)
            {
                if (overflow(traits_type::to_int_type(*__s)) == __eof)
                    break;
                ++__s;
                ++__i;
            }
            else
            {
                streamsize __chunk_size = std::min(__eout_ - __nout_, __n - __i);
                traits_type::copy(__nout_, __s, __chunk_size);
                __nout_ += __chunk_size;
                __s += __chunk_size;
                __i += __chunk_size;
            }
        }
        return __i;
}
template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::overflow(int_type)
{
        return traits_type::eof();
}
extern template class basic_streambuf<char>;
extern template class basic_streambuf<wchar_t>;
extern template class basic_ios<char>;
extern template class basic_ios<wchar_t>;
    }
}
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;

typedef unsigned long u_long;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef u_int64_t u_quad_t;
typedef int64_t quad_t;
typedef quad_t *qaddr_t;
typedef char *caddr_t;

typedef int32_t daddr_t;
typedef u_int32_t fixpt_t;
typedef __darwin_blkcnt_t blkcnt_t;
typedef __darwin_blksize_t blksize_t;

typedef __uint32_t in_addr_t;
typedef __uint16_t in_port_t;
typedef __darwin_ino_t ino_t;
typedef __darwin_ino64_t ino64_t;
typedef __int32_t key_t;

typedef __uint16_t nlink_t;
typedef int32_t segsz_t;
typedef int32_t swblk_t;
static inline __int32_t
major(__uint32_t _x)
{
    return (__int32_t)(((__uint32_t)_x >> 24) & 0xff);
}
static inline __int32_t
minor(__uint32_t _x)
{
    return (__int32_t)((_x)&0xffffff);
}
static inline dev_t
makedev(__uint32_t _major, __uint32_t _minor)
{
    return (dev_t)(((_major) << 24) | (_minor));
}
typedef __int32_t fd_mask;
typedef __darwin_fsblkcnt_t fsblkcnt_t;
typedef __darwin_fsfilcnt_t fsfilcnt_t;
typedef struct __nl_cat_d
{
    void *__data;
    int __size;
} *nl_catd;
typedef __darwin_nl_item nl_item;

extern "C"
{
    nl_catd catopen(const char *, int);
    char *catgets(nl_catd, int, int, const char *);
    int catclose(nl_catd);
}
namespace std
{
    inline namespace __1
    {
template <class _InputIterator, class _ForwardIterator, class _Ctype>

_ForwardIterator
__scan_keyword(_InputIterator &__b, _InputIterator __e,
               _ForwardIterator __kb, _ForwardIterator __ke,
               const _Ctype &__ct, ios_base::iostate &__err,
               bool __case_sensitive = true)
{
        typedef typename iterator_traits<_InputIterator>::value_type _CharT;
        size_t __nkw = static_cast<size_t>(std::distance(__kb, __ke));
        const unsigned char __doesnt_match = '\0';
        const unsigned char __might_match = '\1';
        const unsigned char __does_match = '\2';
        unsigned char __statbuf[100];
        unsigned char *__status = __statbuf;
        unique_ptr<unsigned char, void (*)(void *)> __stat_hold(__nullptr, free);
        if (__nkw > sizeof(__statbuf))
        {
            __status = (unsigned char *)malloc(__nkw);
            if (__status == __nullptr)
                __throw_bad_alloc();
            __stat_hold.reset(__status);
        }
        size_t __n_might_match = __nkw;
        size_t __n_does_match = 0;
        unsigned char *__st = __status;
        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void)++__st)
        {
            if (!__ky->empty())
                *__st = __might_match;
            else
            {
                *__st = __does_match;
                --__n_might_match;
                ++__n_does_match;
            }
        }
        for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx)
        {
            _CharT __c = *__b;
            if (!__case_sensitive)
                __c = __ct.toupper(__c);
            bool __consume = false;
            __st = __status;
            for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void)++__st)
            {
                if (*__st == __might_match)
                {
                    _CharT __kc = (*__ky)[__indx];
                    if (!__case_sensitive)
                        __kc = __ct.toupper(__kc);
                    if (__c == __kc)
                    {
                        __consume = true;
                        if (__ky->size() == __indx + 1)
                        {
                            *__st = __does_match;
                            --__n_might_match;
                            ++__n_does_match;
                        }
                    }
                    else
                    {
                        *__st = __doesnt_match;
                        --__n_might_match;
                    }
                }
            }
            if (__consume)
            {
                ++__b;
                if (__n_might_match + __n_does_match > 1)
                {
                    __st = __status;
                    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void)++__st)
                    {
                        if (*__st == __does_match && __ky->size() != __indx + 1)
                        {
                            *__st = __doesnt_match;
                            --__n_does_match;
                        }
                    }
                }
            }
        }
        if (__b == __e)
            __err |= ios_base::eofbit;
        for (__st = __status; __kb != __ke; ++__kb, (void)++__st)
            if (*__st == __does_match)
                break;
        if (__kb == __ke)
            __err |= ios_base::failbit;
        return __kb;
}
struct __num_get_base
{
        static const int __num_get_buf_sz = 40;
        static int __get_base(ios_base &);
        static const char __src[33];
};

void __check_grouping(const string &__grouping, unsigned *__g, unsigned *__g_end,
                      ios_base::iostate &__err);
template <class _CharT>
struct __num_get
    : protected __num_get_base
{
        static string __stage2_float_prep(ios_base &__iob, _CharT *__atoms, _CharT &__decimal_point,
                                          _CharT &__thousands_sep);
        static int __stage2_float_loop(_CharT __ct, bool &__in_units, char &__exp,
                                       char *__a, char *&__a_end,
                                       _CharT __decimal_point, _CharT __thousands_sep,
                                       const string &__grouping, unsigned *__g,
                                       unsigned *&__g_end, unsigned &__dc, _CharT *__atoms);
        static string __stage2_int_prep(ios_base &__iob, _CharT *__atoms, _CharT &__thousands_sep);
        static int __stage2_int_loop(_CharT __ct, int __base, char *__a, char *&__a_end,
                                     unsigned &__dc, _CharT __thousands_sep, const string &__grouping,
                                     unsigned *__g, unsigned *&__g_end, _CharT *__atoms);
};
template <class _CharT>
string
__num_get<_CharT>::__stage2_int_prep(ios_base &__iob, _CharT *__atoms, _CharT &__thousands_sep)
{
        locale __loc = __iob.getloc();
        use_facet<ctype<_CharT>>(__loc).widen(__src, __src + 26, __atoms);
        const numpunct<_CharT> &__np = use_facet<numpunct<_CharT>>(__loc);
        __thousands_sep = __np.thousands_sep();
        return __np.grouping();
}
template <class _CharT>
string
__num_get<_CharT>::__stage2_float_prep(ios_base &__iob, _CharT *__atoms, _CharT &__decimal_point,
                                       _CharT &__thousands_sep)
{
        locale __loc = __iob.getloc();
        use_facet<ctype<_CharT>>(__loc).widen(__src, __src + 32, __atoms);
        const numpunct<_CharT> &__np = use_facet<numpunct<_CharT>>(__loc);
        __decimal_point = __np.decimal_point();
        __thousands_sep = __np.thousands_sep();
        return __np.grouping();
}
template <class _CharT>
int __num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char *__a, char *&__a_end,
                                         unsigned &__dc, _CharT __thousands_sep, const string &__grouping,
                                         unsigned *__g, unsigned *&__g_end, _CharT *__atoms)
{
        if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25]))
        {
            *__a_end++ = __ct == __atoms[24] ? '+' : '-';
            __dc = 0;
            return 0;
        }
        if (__grouping.size() != 0 && __ct == __thousands_sep)
        {
            if (__g_end - __g < __num_get_buf_sz)
            {
                *__g_end++ = __dc;
                __dc = 0;
            }
            return 0;
        }
        ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;
        if (__f >= 24)
            return -1;
        switch (__base)
        {
        case 8:
        case 10:
            if (__f >= __base)
                return -1;
            break;
        case 16:
            if (__f < 22)
                break;
            if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0')
            {
                __dc = 0;
                *__a_end++ = __src[__f];
                return 0;
            }
            return -1;
        }
        *__a_end++ = __src[__f];
        ++__dc;
        return 0;
}
template <class _CharT>
int __num_get<_CharT>::__stage2_float_loop(_CharT __ct, bool &__in_units, char &__exp, char *__a, char *&__a_end,
                                           _CharT __decimal_point, _CharT __thousands_sep, const string &__grouping,
                                           unsigned *__g, unsigned *&__g_end, unsigned &__dc, _CharT *__atoms)
{
        if (__ct == __decimal_point)
        {
            if (!__in_units)
                return -1;
            __in_units = false;
            *__a_end++ = '.';
            if (__grouping.size() != 0 && __g_end - __g < __num_get_buf_sz)
                *__g_end++ = __dc;
            return 0;
        }
        if (__ct == __thousands_sep && __grouping.size() != 0)
        {
            if (!__in_units)
                return -1;
            if (__g_end - __g < __num_get_buf_sz)
            {
                *__g_end++ = __dc;
                __dc = 0;
            }
            return 0;
        }
        ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;
        if (__f >= 32)
            return -1;
        char __x = __src[__f];
        if (__x == '-' || __x == '+')
        {
            if (__a_end == __a || (__a_end[-1] & 0x5F) == (__exp & 0x7F))
            {
                *__a_end++ = __x;
                return 0;
            }
            return -1;
        }
        if (__x == 'x' || __x == 'X')
            __exp = 'P';
        else if ((__x & 0x5F) == __exp)
        {
            __exp |= (char)0x80;
            if (__in_units)
            {
                __in_units = false;
                if (__grouping.size() != 0 && __g_end - __g < __num_get_buf_sz)
                    *__g_end++ = __dc;
            }
        }
        *__a_end++ = __x;
        if (__f >= 22)
            return 0;
        ++__dc;
        return 0;
}
extern template struct __num_get<char>;
extern template struct __num_get<wchar_t>;
template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT>>
class num_get
    : public locale::facet,
      private __num_get<_CharT>
{
    public:
        typedef _CharT char_type;
        typedef _InputIterator iter_type;

        explicit num_get(size_t __refs = 0)
            : locale::facet(__refs) {}

        iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                      ios_base::iostate &__err, bool &__v) const
        {
            return do_get(__b, __e, __iob, __err, __v);
        }

        iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                      ios_base::iostate &__err, long &__v) const
        {
            return do_get(__b, __e, __iob, __err, __v);
        }

        iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                      ios_base::iostate &__err, long long &__v) const
        {
            return do_get(__b, __e, __iob, __err, __v);
        }

        iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                      ios_base::iostate &__err, unsigned short &__v) const
        {
            return do_get(__b, __e, __iob, __err, __v);
        }

        iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                      ios_base::iostate &__err, unsigned int &__v) const
        {
            return do_get(__b, __e, __iob, __err, __v);
        }

        iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                      ios_base::iostate &__err, unsigned long &__v) const
        {
            return do_get(__b, __e, __iob, __err, __v);
        }

        iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                      ios_base::iostate &__err, unsigned long long &__v) const
        {
            return do_get(__b, __e, __iob, __err, __v);
        }

        iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                      ios_base::iostate &__err, float &__v) const
        {
            return do_get(__b, __e, __iob, __err, __v);
        }

        iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                      ios_base::iostate &__err, double &__v) const
        {
            return do_get(__b, __e, __iob, __err, __v);
        }

        iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                      ios_base::iostate &__err, long double &__v) const
        {
            return do_get(__b, __e, __iob, __err, __v);
        }

        iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                      ios_base::iostate &__err, void *&__v) const
        {
            return do_get(__b, __e, __iob, __err, __v);
        }
        static locale::id id;

    protected:
        ~num_get() {}
        template <class _Fp>
        inline iter_type __do_get_floating_point(iter_type __b, iter_type __e, ios_base &__iob,
                                                 ios_base::iostate &__err, _Fp &__v) const;
        template <class _Signed>
        inline iter_type __do_get_signed(iter_type __b, iter_type __e, ios_base &__iob,
                                         ios_base::iostate &__err, _Signed &__v) const;
        template <class _Unsigned>
        inline iter_type __do_get_unsigned(iter_type __b, iter_type __e, ios_base &__iob,
                                           ios_base::iostate &__err, _Unsigned &__v) const;
        virtual iter_type do_get(iter_type __b, iter_type __e, ios_base &__iob,
                                 ios_base::iostate &__err, bool &__v) const;
        virtual iter_type do_get(iter_type __b, iter_type __e, ios_base &__iob,
                                 ios_base::iostate &__err, long &__v) const
        {
            return this->__do_get_signed(__b, __e, __iob, __err, __v);
        }
        virtual iter_type do_get(iter_type __b, iter_type __e, ios_base &__iob,
                                 ios_base::iostate &__err, long long &__v) const
        {
            return this->__do_get_signed(__b, __e, __iob, __err, __v);
        }
        virtual iter_type do_get(iter_type __b, iter_type __e, ios_base &__iob,
                                 ios_base::iostate &__err, unsigned short &__v) const
        {
            return this->__do_get_unsigned(__b, __e, __iob, __err, __v);
        }
        virtual iter_type do_get(iter_type __b, iter_type __e, ios_base &__iob,
                                 ios_base::iostate &__err, unsigned int &__v) const
        {
            return this->__do_get_unsigned(__b, __e, __iob, __err, __v);
        }
        virtual iter_type do_get(iter_type __b, iter_type __e, ios_base &__iob,
                                 ios_base::iostate &__err, unsigned long &__v) const
        {
            return this->__do_get_unsigned(__b, __e, __iob, __err, __v);
        }
        virtual iter_type do_get(iter_type __b, iter_type __e, ios_base &__iob,
                                 ios_base::iostate &__err, unsigned long long &__v) const
        {
            return this->__do_get_unsigned(__b, __e, __iob, __err, __v);
        }
        virtual iter_type do_get(iter_type __b, iter_type __e, ios_base &__iob,
                                 ios_base::iostate &__err, float &__v) const
        {
            return this->__do_get_floating_point(__b, __e, __iob, __err, __v);
        }
        virtual iter_type do_get(iter_type __b, iter_type __e, ios_base &__iob,
                                 ios_base::iostate &__err, double &__v) const
        {
            return this->__do_get_floating_point(__b, __e, __iob, __err, __v);
        }
        virtual iter_type do_get(iter_type __b, iter_type __e, ios_base &__iob,
                                 ios_base::iostate &__err, long double &__v) const
        {
            return this->__do_get_floating_point(__b, __e, __iob, __err, __v);
        }
        virtual iter_type do_get(iter_type __b, iter_type __e, ios_base &__iob,
                                 ios_base::iostate &__err, void *&__v) const;
};
template <class _CharT, class _InputIterator>
locale::id
    num_get<_CharT, _InputIterator>::id;
template <class _Tp>
_Tp __num_get_signed_integral(const char *__a, const char *__a_end,
                              ios_base::iostate &__err, int __base)
{
        if (__a != __a_end)
        {
            typename remove_reference<__decltype((*__error()))>::type __save_errno = (*__error());
            (*__error()) = 0;
            char *__p2;
            long long __ll = strtoll_l(__a, &__p2, __base, 0);
            typename remove_reference<__decltype((*__error()))>::type __current_errno = (*__error());
            if (__current_errno == 0)
                (*__error()) = __save_errno;
            if (__p2 != __a_end)
            {
                __err = ios_base::failbit;
                return 0;
            }
            else if (__current_errno == 34 ||
                     __ll < numeric_limits<_Tp>::min() ||
                     numeric_limits<_Tp>::max() < __ll)
            {
                __err = ios_base::failbit;
                if (__ll > 0)
                    return numeric_limits<_Tp>::max();
                else
                    return numeric_limits<_Tp>::min();
            }
            return static_cast<_Tp>(__ll);
        }
        __err = ios_base::failbit;
        return 0;
}
template <class _Tp>
_Tp __num_get_unsigned_integral(const char *__a, const char *__a_end,
                                ios_base::iostate &__err, int __base)
{
        if (__a != __a_end)
        {
            const bool __negate = *__a == '-';
            if (__negate && ++__a == __a_end)
            {
                __err = ios_base::failbit;
                return 0;
            }
            typename remove_reference<__decltype((*__error()))>::type __save_errno = (*__error());
            (*__error()) = 0;
            char *__p2;
            unsigned long long __ll = strtoull_l(__a, &__p2, __base, 0);
            typename remove_reference<__decltype((*__error()))>::type __current_errno = (*__error());
            if (__current_errno == 0)
                (*__error()) = __save_errno;
            if (__p2 != __a_end)
            {
                __err = ios_base::failbit;
                return 0;
            }
            else if (__current_errno == 34 || numeric_limits<_Tp>::max() < __ll)
            {
                __err = ios_base::failbit;
                return numeric_limits<_Tp>::max();
            }
            _Tp __res = static_cast<_Tp>(__ll);
            if (__negate)
                __res = -__res;
            return __res;
        }
        __err = ios_base::failbit;
        return 0;
}
template <class _Tp>

_Tp __do_strtod(const char *__a, char **__p2);
template <>
inline float __do_strtod<float>(const char *__a, char **__p2)
{
        return strtof_l(__a, __p2, 0);
}
template <>
inline double __do_strtod<double>(const char *__a, char **__p2)
{
        return strtod_l(__a, __p2, 0);
}
template <>
inline long double __do_strtod<long double>(const char *__a, char **__p2)
{
        return strtold_l(__a, __p2, 0);
}
template <class _Tp>

_Tp __num_get_float(const char *__a, const char *__a_end, ios_base::iostate &__err)
{
        if (__a != __a_end)
        {
            typename remove_reference<__decltype((*__error()))>::type __save_errno = (*__error());
            (*__error()) = 0;
            char *__p2;
            _Tp __ld = __do_strtod<_Tp>(__a, &__p2);
            typename remove_reference<__decltype((*__error()))>::type __current_errno = (*__error());
            if (__current_errno == 0)
                (*__error()) = __save_errno;
            if (__p2 != __a_end)
            {
                __err = ios_base::failbit;
                return 0;
            }
            else if (__current_errno == 34)
                __err = ios_base::failbit;
            return __ld;
        }
        __err = ios_base::failbit;
        return 0;
}
template <class _CharT, class _InputIterator>
_InputIterator
num_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                        ios_base &__iob,
                                        ios_base::iostate &__err,
                                        bool &__v) const
{
        if ((__iob.flags() & ios_base::boolalpha) == 0)
        {
            long __lv = -1;
            __b = do_get(__b, __e, __iob, __err, __lv);
            switch (__lv)
            {
            case 0:
                __v = false;
                break;
            case 1:
                __v = true;
                break;
            default:
                __v = true;
                __err = ios_base::failbit;
                break;
            }
            return __b;
        }
        const ctype<_CharT> &__ct = use_facet<ctype<_CharT>>(__iob.getloc());
        const numpunct<_CharT> &__np = use_facet<numpunct<_CharT>>(__iob.getloc());
        typedef typename numpunct<_CharT>::string_type string_type;
        const string_type __names[2] = {__np.truename(), __np.falsename()};
        const string_type *__i = std::__scan_keyword(__b, __e, __names, __names + 2,
                                                     __ct, __err);
        __v = __i == __names;
        return __b;
}
template <class _CharT, class _InputIterator>
template <class _Signed>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_signed(iter_type __b, iter_type __e,
                                                 ios_base &__iob,
                                                 ios_base::iostate &__err,
                                                 _Signed &__v) const
{
        int __base = this->__get_base(__iob);
        char_type __thousands_sep;
        const int __atoms_size = 26;
        char_type __atoms[__atoms_size];
        string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);
        string __buf;
        __buf.resize(__buf.capacity());
        char *__a = &__buf[0];
        char *__a_end = __a;
        unsigned __g[__num_get_base::__num_get_buf_sz];
        unsigned *__g_end = __g;
        unsigned __dc = 0;
        for (; __b != __e; ++__b)
        {
            if (__a_end == __a + __buf.size())
            {
                size_t __tmp = __buf.size();
                __buf.resize(2 * __buf.size());
                __buf.resize(__buf.capacity());
                __a = &__buf[0];
                __a_end = __a + __tmp;
            }
            if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                        __thousands_sep, __grouping, __g, __g_end,
                                        __atoms))
                break;
        }
        if (__grouping.size() != 0 && __g_end - __g < __num_get_base::__num_get_buf_sz)
            *__g_end++ = __dc;
        __v = __num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);
        __check_grouping(__grouping, __g, __g_end, __err);
        if (__b == __e)
            __err |= ios_base::eofbit;
        return __b;
}
template <class _CharT, class _InputIterator>
template <class _Unsigned>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_unsigned(iter_type __b, iter_type __e,
                                                   ios_base &__iob,
                                                   ios_base::iostate &__err,
                                                   _Unsigned &__v) const
{
        int __base = this->__get_base(__iob);
        char_type __thousands_sep;
        const int __atoms_size = 26;
        char_type __atoms[__atoms_size];
        string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);
        string __buf;
        __buf.resize(__buf.capacity());
        char *__a = &__buf[0];
        char *__a_end = __a;
        unsigned __g[__num_get_base::__num_get_buf_sz];
        unsigned *__g_end = __g;
        unsigned __dc = 0;
        for (; __b != __e; ++__b)
        {
            if (__a_end == __a + __buf.size())
            {
                size_t __tmp = __buf.size();
                __buf.resize(2 * __buf.size());
                __buf.resize(__buf.capacity());
                __a = &__buf[0];
                __a_end = __a + __tmp;
            }
            if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                        __thousands_sep, __grouping, __g, __g_end,
                                        __atoms))
                break;
        }
        if (__grouping.size() != 0 && __g_end - __g < __num_get_base::__num_get_buf_sz)
            *__g_end++ = __dc;
        __v = __num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);
        __check_grouping(__grouping, __g, __g_end, __err);
        if (__b == __e)
            __err |= ios_base::eofbit;
        return __b;
}
template <class _CharT, class _InputIterator>
template <class _Fp>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_floating_point(iter_type __b, iter_type __e,
                                                         ios_base &__iob,
                                                         ios_base::iostate &__err,
                                                         _Fp &__v) const
{
        char_type __atoms[32];
        char_type __decimal_point;
        char_type __thousands_sep;
        string __grouping = this->__stage2_float_prep(__iob, __atoms,
                                                      __decimal_point,
                                                      __thousands_sep);
        string __buf;
        __buf.resize(__buf.capacity());
        char *__a = &__buf[0];
        char *__a_end = __a;
        unsigned __g[__num_get_base::__num_get_buf_sz];
        unsigned *__g_end = __g;
        unsigned __dc = 0;
        bool __in_units = true;
        char __exp = 'E';
        for (; __b != __e; ++__b)
        {
            if (__a_end == __a + __buf.size())
            {
                size_t __tmp = __buf.size();
                __buf.resize(2 * __buf.size());
                __buf.resize(__buf.capacity());
                __a = &__buf[0];
                __a_end = __a + __tmp;
            }
            if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,
                                          __decimal_point, __thousands_sep,
                                          __grouping, __g, __g_end,
                                          __dc, __atoms))
                break;
        }
        if (__grouping.size() != 0 && __in_units && __g_end - __g < __num_get_base::__num_get_buf_sz)
            *__g_end++ = __dc;
        __v = __num_get_float<_Fp>(__a, __a_end, __err);
        __check_grouping(__grouping, __g, __g_end, __err);
        if (__b == __e)
            __err |= ios_base::eofbit;
        return __b;
}
template <class _CharT, class _InputIterator>
_InputIterator
num_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                        ios_base &__iob,
                                        ios_base::iostate &__err,
                                        void *&__v) const
{
        int __base = 16;
        char_type __atoms[26];
        char_type __thousands_sep = 0;
        string __grouping;
        use_facet<ctype<_CharT>>(__iob.getloc()).widen(__num_get_base::__src, __num_get_base::__src + 26, __atoms);
        string __buf;
        __buf.resize(__buf.capacity());
        char *__a = &__buf[0];
        char *__a_end = __a;
        unsigned __g[__num_get_base::__num_get_buf_sz];
        unsigned *__g_end = __g;
        unsigned __dc = 0;
        for (; __b != __e; ++__b)
        {
            if (__a_end == __a + __buf.size())
            {
                size_t __tmp = __buf.size();
                __buf.resize(2 * __buf.size());
                __buf.resize(__buf.capacity());
                __a = &__buf[0];
                __a_end = __a + __tmp;
            }
            if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                        __thousands_sep, __grouping,
                                        __g, __g_end, __atoms))
                break;
        }
        __buf.resize(__a_end - __a);
        if (sscanf_l(__buf.c_str(), 0, "%p", &__v) != 1)
            __err = ios_base::failbit;
        if (__b == __e)
            __err |= ios_base::eofbit;
        return __b;
}
extern template class num_get<char>;
extern template class num_get<wchar_t>;
struct __num_put_base
{
    protected:
        static void __format_int(char *__fmt, const char *__len, bool __signd,
                                 ios_base::fmtflags __flags);
        static bool __format_float(char *__fmt, const char *__len,
                                   ios_base::fmtflags __flags);
        static char *__identify_padding(char *__nb, char *__ne,
                                        const ios_base &__iob);
};
template <class _CharT>
struct __num_put
    : protected __num_put_base
{
        static void __widen_and_group_int(char *__nb, char *__np, char *__ne,
                                          _CharT *__ob, _CharT *&__op, _CharT *&__oe,
                                          const locale &__loc);
        static void __widen_and_group_float(char *__nb, char *__np, char *__ne,
                                            _CharT *__ob, _CharT *&__op, _CharT *&__oe,
                                            const locale &__loc);
};
template <class _CharT>
void __num_put<_CharT>::__widen_and_group_int(char *__nb, char *__np, char *__ne,
                                              _CharT *__ob, _CharT *&__op, _CharT *&__oe,
                                              const locale &__loc)
{
        const ctype<_CharT> &__ct = use_facet<ctype<_CharT>>(__loc);
        const numpunct<_CharT> &__npt = use_facet<numpunct<_CharT>>(__loc);
        string __grouping = __npt.grouping();
        if (__grouping.empty())
        {
            __ct.widen(__nb, __ne, __ob);
            __oe = __ob + (__ne - __nb);
        }
        else
        {
            __oe = __ob;
            char *__nf = __nb;
            if (*__nf == '-' || *__nf == '+')
                *__oe++ = __ct.widen(*__nf++);
            if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' || __nf[1] == 'X'))
            {
                *__oe++ = __ct.widen(*__nf++);
                *__oe++ = __ct.widen(*__nf++);
            }
            reverse(__nf, __ne);
            _CharT __thousands_sep = __npt.thousands_sep();
            unsigned __dc = 0;
            unsigned __dg = 0;
            for (char *__p = __nf; __p < __ne; ++__p)
            {
                if (static_cast<unsigned>(__grouping[__dg]) > 0 &&
                    __dc == static_cast<unsigned>(__grouping[__dg]))
                {
                    *__oe++ = __thousands_sep;
                    __dc = 0;
                    if (__dg < __grouping.size() - 1)
                        ++__dg;
                }
                *__oe++ = __ct.widen(*__p);
                ++__dc;
            }
            reverse(__ob + (__nf - __nb), __oe);
        }
        if (__np == __ne)
            __op = __oe;
        else
            __op = __ob + (__np - __nb);
}
template <class _CharT>
void __num_put<_CharT>::__widen_and_group_float(char *__nb, char *__np, char *__ne,
                                                _CharT *__ob, _CharT *&__op, _CharT *&__oe,
                                                const locale &__loc)
{
        const ctype<_CharT> &__ct = use_facet<ctype<_CharT>>(__loc);
        const numpunct<_CharT> &__npt = use_facet<numpunct<_CharT>>(__loc);
        string __grouping = __npt.grouping();
        __oe = __ob;
        char *__nf = __nb;
        if (*__nf == '-' || *__nf == '+')
            *__oe++ = __ct.widen(*__nf++);
        char *__ns;
        if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' || __nf[1] == 'X'))
        {
            *__oe++ = __ct.widen(*__nf++);
            *__oe++ = __ct.widen(*__nf++);
            for (__ns = __nf; __ns < __ne; ++__ns)
                if (!isxdigit_l(*__ns, 0))
                    break;
        }
        else
        {
            for (__ns = __nf; __ns < __ne; ++__ns)
                if (!isdigit_l(*__ns, 0))
                    break;
        }
        if (__grouping.empty())
        {
            __ct.widen(__nf, __ns, __oe);
            __oe += __ns - __nf;
        }
        else
        {
            reverse(__nf, __ns);
            _CharT __thousands_sep = __npt.thousands_sep();
            unsigned __dc = 0;
            unsigned __dg = 0;
            for (char *__p = __nf; __p < __ns; ++__p)
            {
                if (__grouping[__dg] > 0 && __dc == static_cast<unsigned>(__grouping[__dg]))
                {
                    *__oe++ = __thousands_sep;
                    __dc = 0;
                    if (__dg < __grouping.size() - 1)
                        ++__dg;
                }
                *__oe++ = __ct.widen(*__p);
                ++__dc;
            }
            reverse(__ob + (__nf - __nb), __oe);
        }
        for (__nf = __ns; __nf < __ne; ++__nf)
        {
            if (*__nf == '.')
            {
                *__oe++ = __npt.decimal_point();
                ++__nf;
                break;
            }
            else
                *__oe++ = __ct.widen(*__nf);
        }
        __ct.widen(__nf, __ne, __oe);
        __oe += __ne - __nf;
        if (__np == __ne)
            __op = __oe;
        else
            __op = __ob + (__np - __nb);
}
extern template struct __num_put<char>;
extern template struct __num_put<wchar_t>;
template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT>>
class num_put
    : public locale::facet,
      private __num_put<_CharT>
{
    public:
        typedef _CharT char_type;
        typedef _OutputIterator iter_type;

        explicit num_put(size_t __refs = 0)
            : locale::facet(__refs) {}

        iter_type put(iter_type __s, ios_base &__iob, char_type __fl,
                      bool __v) const
        {
            return do_put(__s, __iob, __fl, __v);
        }

        iter_type put(iter_type __s, ios_base &__iob, char_type __fl,
                      long __v) const
        {
            return do_put(__s, __iob, __fl, __v);
        }

        iter_type put(iter_type __s, ios_base &__iob, char_type __fl,
                      long long __v) const
        {
            return do_put(__s, __iob, __fl, __v);
        }

        iter_type put(iter_type __s, ios_base &__iob, char_type __fl,
                      unsigned long __v) const
        {
            return do_put(__s, __iob, __fl, __v);
        }

        iter_type put(iter_type __s, ios_base &__iob, char_type __fl,
                      unsigned long long __v) const
        {
            return do_put(__s, __iob, __fl, __v);
        }

        iter_type put(iter_type __s, ios_base &__iob, char_type __fl,
                      double __v) const
        {
            return do_put(__s, __iob, __fl, __v);
        }

        iter_type put(iter_type __s, ios_base &__iob, char_type __fl,
                      long double __v) const
        {
            return do_put(__s, __iob, __fl, __v);
        }

        iter_type put(iter_type __s, ios_base &__iob, char_type __fl,
                      const void *__v) const
        {
            return do_put(__s, __iob, __fl, __v);
        }
        static locale::id id;

    protected:
        ~num_put() {}
        virtual iter_type do_put(iter_type __s, ios_base &__iob, char_type __fl,
                                 bool __v) const;
        virtual iter_type do_put(iter_type __s, ios_base &__iob, char_type __fl,
                                 long __v) const;
        virtual iter_type do_put(iter_type __s, ios_base &__iob, char_type __fl,
                                 long long __v) const;
        virtual iter_type do_put(iter_type __s, ios_base &__iob, char_type __fl,
                                 unsigned long) const;
        virtual iter_type do_put(iter_type __s, ios_base &__iob, char_type __fl,
                                 unsigned long long) const;
        virtual iter_type do_put(iter_type __s, ios_base &__iob, char_type __fl,
                                 double __v) const;
        virtual iter_type do_put(iter_type __s, ios_base &__iob, char_type __fl,
                                 long double __v) const;
        virtual iter_type do_put(iter_type __s, ios_base &__iob, char_type __fl,
                                 const void *__v) const;
        template <class _Integral>
        inline _OutputIterator __do_put_integral(iter_type __s, ios_base &__iob,
                                                 char_type __fl, _Integral __v,
                                                 char const *__len) const;
        template <class _Float>
        inline _OutputIterator __do_put_floating_point(iter_type __s, ios_base &__iob,
                                                       char_type __fl, _Float __v,
                                                       char const *__len) const;
};
template <class _CharT, class _OutputIterator>
locale::id
    num_put<_CharT, _OutputIterator>::id;
template <class _CharT, class _OutputIterator>

_OutputIterator
__pad_and_output(_OutputIterator __s,
                 const _CharT *__ob, const _CharT *__op, const _CharT *__oe,
                 ios_base &__iob, _CharT __fl)
{
        streamsize __sz = __oe - __ob;
        streamsize __ns = __iob.width();
        if (__ns > __sz)
            __ns -= __sz;
        else
            __ns = 0;
        for (; __ob < __op; ++__ob, ++__s)
            *__s = *__ob;
        for (; __ns; --__ns, ++__s)
            *__s = __fl;
        for (; __ob < __oe; ++__ob, ++__s)
            *__s = *__ob;
        __iob.width(0);
        return __s;
}
template <class _CharT, class _Traits>

ostreambuf_iterator<_CharT, _Traits>
__pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s,
                 const _CharT *__ob, const _CharT *__op, const _CharT *__oe,
                 ios_base &__iob, _CharT __fl)
{
        if (__s.__sbuf_ == __nullptr)
            return __s;
        streamsize __sz = __oe - __ob;
        streamsize __ns = __iob.width();
        if (__ns > __sz)
            __ns -= __sz;
        else
            __ns = 0;
        streamsize __np = __op - __ob;
        if (__np > 0)
        {
            if (__s.__sbuf_->sputn(__ob, __np) != __np)
            {
                __s.__sbuf_ = __nullptr;
                return __s;
            }
        }
        if (__ns > 0)
        {
            basic_string<_CharT, _Traits> __sp(__ns, __fl);
            if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns)
            {
                __s.__sbuf_ = __nullptr;
                return __s;
            }
        }
        __np = __oe - __op;
        if (__np > 0)
        {
            if (__s.__sbuf_->sputn(__op, __np) != __np)
            {
                __s.__sbuf_ = __nullptr;
                return __s;
            }
        }
        __iob.width(0);
        return __s;
}
template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base &__iob,
                                         char_type __fl, bool __v) const
{
        if ((__iob.flags() & ios_base::boolalpha) == 0)
            return do_put(__s, __iob, __fl, (unsigned long)__v);
        const numpunct<char_type> &__np = use_facet<numpunct<char_type>>(__iob.getloc());
        typedef typename numpunct<char_type>::string_type string_type;
        string_type __nm = __v ? __np.truename() : __np.falsename();
        for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i, ++__s)
            *__s = *__i;
        return __s;
}
template <class _CharT, class _OutputIterator>
template <class _Integral>
inline _OutputIterator
num_put<_CharT, _OutputIterator>::__do_put_integral(iter_type __s, ios_base &__iob,
                                                    char_type __fl, _Integral __v,
                                                    char const *__len) const
{
        char __fmt[8] = {'%', 0};
        this->__format_int(__fmt + 1, __len, is_signed<_Integral>::value, __iob.flags());
        using _Unsigned = typename make_unsigned<_Integral>::type;
        const unsigned __nbuf = (numeric_limits<_Unsigned>::digits / 3) + ((numeric_limits<_Unsigned>::digits % 3) != 0) + 2;
        char __nar[__nbuf];
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wformat-nonliteral"
        int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);
#pragma clang diagnostic pop
        char *__ne = __nar + __nc;
        char *__np = this->__identify_padding(__nar, __ne, __iob);
        char_type __o[2 * (__nbuf - 1) - 1];
        char_type *__op;
        char_type *__oe;
        this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
        return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}
template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base &__iob,
                                         char_type __fl, long __v) const
{
        return this->__do_put_integral(__s, __iob, __fl, __v, "l");
}
template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base &__iob,
                                         char_type __fl, long long __v) const
{
        return this->__do_put_integral(__s, __iob, __fl, __v, "ll");
}
template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base &__iob,
                                         char_type __fl, unsigned long __v) const
{
        return this->__do_put_integral(__s, __iob, __fl, __v, "l");
}
template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base &__iob,
                                         char_type __fl, unsigned long long __v) const
{
        return this->__do_put_integral(__s, __iob, __fl, __v, "ll");
}
template <class _CharT, class _OutputIterator>
template <class _Float>
inline _OutputIterator
num_put<_CharT, _OutputIterator>::__do_put_floating_point(iter_type __s, ios_base &__iob,
                                                          char_type __fl, _Float __v,
                                                          char const *__len) const
{
        char __fmt[8] = {'%', 0};
        bool __specify_precision = this->__format_float(__fmt + 1, __len, __iob.flags());
        const unsigned __nbuf = 30;
        char __nar[__nbuf];
        char *__nb = __nar;
        int __nc;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wformat-nonliteral"
        if (__specify_precision)
            __nc = snprintf_l(__nb, __nbuf, 0, __fmt, (int)__iob.precision(), __v);
        else
            __nc = snprintf_l(__nb, __nbuf, 0, __fmt, __v);
        unique_ptr<char, void (*)(void *)> __nbh(__nullptr, free);
        if (__nc > static_cast<int>(__nbuf - 1))
        {
            if (__specify_precision)
                __nc = asprintf_l(&__nb, 0, __fmt, (int)__iob.precision(), __v);
            else
                __nc = asprintf_l(&__nb, 0, __fmt, __v);
            if (__nc == -1)
                __throw_bad_alloc();
            __nbh.reset(__nb);
        }
#pragma clang diagnostic pop
        char *__ne = __nb + __nc;
        char *__np = this->__identify_padding(__nb, __ne, __iob);
        char_type __o[2 * (__nbuf - 1) - 1];
        char_type *__ob = __o;
        unique_ptr<char_type, void (*)(void *)> __obh(0, free);
        if (__nb != __nar)
        {
            __ob = (char_type *)malloc(2 * static_cast<size_t>(__nc) * sizeof(char_type));
            if (__ob == 0)
                __throw_bad_alloc();
            __obh.reset(__ob);
        }
        char_type *__op;
        char_type *__oe;
        this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());
        __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
        return __s;
}
template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base &__iob,
                                         char_type __fl, double __v) const
{
        return this->__do_put_floating_point(__s, __iob, __fl, __v, "");
}
template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base &__iob,
                                         char_type __fl, long double __v) const
{
        return this->__do_put_floating_point(__s, __iob, __fl, __v, "L");
}
template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base &__iob,
                                         char_type __fl, const void *__v) const
{
        const unsigned __nbuf = 20;
        char __nar[__nbuf];
        int __nc = snprintf_l(__nar, sizeof(__nar), 0, "%p", __v);
        char *__ne = __nar + __nc;
        char *__np = this->__identify_padding(__nar, __ne, __iob);
        char_type __o[2 * (__nbuf - 1) - 1];
        char_type *__op;
        char_type *__oe;
        const ctype<char_type> &__ct = use_facet<ctype<char_type>>(__iob.getloc());
        __ct.widen(__nar, __ne, __o);
        __oe = __o + (__ne - __nar);
        if (__np == __ne)
            __op = __oe;
        else
            __op = __o + (__np - __nar);
        return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}
extern template class num_put<char>;
extern template class num_put<wchar_t>;
template <class _CharT, class _InputIterator>

int __get_up_to_n_digits(_InputIterator &__b, _InputIterator __e,
                         ios_base::iostate &__err, const ctype<_CharT> &__ct, int __n)
{
        if (__b == __e)
        {
            __err |= ios_base::eofbit | ios_base::failbit;
            return 0;
        }
        _CharT __c = *__b;
        if (!__ct.is(ctype_base::digit, __c))
        {
            __err |= ios_base::failbit;
            return 0;
        }
        int __r = __ct.narrow(__c, 0) - '0';
        for (++__b, (void)--__n; __b != __e && __n > 0; ++__b, (void)--__n)
        {
            __c = *__b;
            if (!__ct.is(ctype_base::digit, __c))
                return __r;
            __r = __r * 10 + __ct.narrow(__c, 0) - '0';
        }
        if (__b == __e)
            __err |= ios_base::eofbit;
        return __r;
}
class time_base
{
    public:
        enum dateorder
        {
            no_order,
            dmy,
            mdy,
            ymd,
            ydm
        };
};
template <class _CharT>
class __time_get_c_storage
{
    protected:
        typedef basic_string<_CharT> string_type;
        virtual const string_type *__weeks() const;
        virtual const string_type *__months() const;
        virtual const string_type *__am_pm() const;
        virtual const string_type &__c() const;
        virtual const string_type &__r() const;
        virtual const string_type &__x() const;
        virtual const string_type &__X() const;

        ~__time_get_c_storage() {}
};
template <>
const;
template <>
const;
template <>
const;
template <>
const;
template <>
const;
template <>
const;
template <>
const;
template <>
const;
template <>
const;
template <>
const;
template <>
const;
template <>
const;
template <>
const;
template <>
const;
template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT>>
class time_get
    : public locale::facet,
      public time_base,
      private __time_get_c_storage<_CharT>
{
    public:
        typedef _CharT char_type;
        typedef _InputIterator iter_type;
        typedef time_base::dateorder dateorder;
        typedef basic_string<char_type> string_type;

        explicit time_get(size_t __refs = 0)
            : locale::facet(__refs) {}

        dateorder date_order() const
        {
            return this->do_date_order();
        }

        iter_type get_time(iter_type __b, iter_type __e, ios_base &__iob,
                           ios_base::iostate &__err, tm *__tm) const
        {
            return do_get_time(__b, __e, __iob, __err, __tm);
        }

        iter_type get_date(iter_type __b, iter_type __e, ios_base &__iob,
                           ios_base::iostate &__err, tm *__tm) const
        {
            return do_get_date(__b, __e, __iob, __err, __tm);
        }

        iter_type get_weekday(iter_type __b, iter_type __e, ios_base &__iob,
                              ios_base::iostate &__err, tm *__tm) const
        {
            return do_get_weekday(__b, __e, __iob, __err, __tm);
        }

        iter_type get_monthname(iter_type __b, iter_type __e, ios_base &__iob,
                                ios_base::iostate &__err, tm *__tm) const
        {
            return do_get_monthname(__b, __e, __iob, __err, __tm);
        }

        iter_type get_year(iter_type __b, iter_type __e, ios_base &__iob,
                           ios_base::iostate &__err, tm *__tm) const
        {
            return do_get_year(__b, __e, __iob, __err, __tm);
        }

        iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                      ios_base::iostate &__err, tm *__tm,
                      char __fmt, char __mod = 0) const
        {
            return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);
        }
        iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                      ios_base::iostate &__err, tm *__tm,
                      const char_type *__fmtb, const char_type *__fmte) const;
        static locale::id id;

    protected:
        ~time_get() {}
        virtual dateorder do_date_order() const;
        virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base &__iob,
                                      ios_base::iostate &__err, tm *__tm) const;
        virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base &__iob,
                                      ios_base::iostate &__err, tm *__tm) const;
        virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base &__iob,
                                         ios_base::iostate &__err, tm *__tm) const;
        virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base &__iob,
                                           ios_base::iostate &__err, tm *__tm) const;
        virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base &__iob,
                                      ios_base::iostate &__err, tm *__tm) const;
        virtual iter_type do_get(iter_type __b, iter_type __e, ios_base &__iob,
                                 ios_base::iostate &__err, tm *__tm,
                                 char __fmt, char __mod) const;

    private:
        void __get_white_space(iter_type &__b, iter_type __e,
                               ios_base::iostate &__err, const ctype<char_type> &__ct) const;
        void __get_percent(iter_type &__b, iter_type __e, ios_base::iostate &__err,
                           const ctype<char_type> &__ct) const;
        void __get_weekdayname(int &__m,
                               iter_type &__b, iter_type __e,
                               ios_base::iostate &__err,
                               const ctype<char_type> &__ct) const;
        void __get_monthname(int &__m,
                             iter_type &__b, iter_type __e,
                             ios_base::iostate &__err,
                             const ctype<char_type> &__ct) const;
        void __get_day(int &__d,
                       iter_type &__b, iter_type __e,
                       ios_base::iostate &__err,
                       const ctype<char_type> &__ct) const;
        void __get_month(int &__m,
                         iter_type &__b, iter_type __e,
                         ios_base::iostate &__err,
                         const ctype<char_type> &__ct) const;
        void __get_year(int &__y,
                        iter_type &__b, iter_type __e,
                        ios_base::iostate &__err,
                        const ctype<char_type> &__ct) const;
        void __get_year4(int &__y,
                         iter_type &__b, iter_type __e,
                         ios_base::iostate &__err,
                         const ctype<char_type> &__ct) const;
        void __get_hour(int &__d,
                        iter_type &__b, iter_type __e,
                        ios_base::iostate &__err,
                        const ctype<char_type> &__ct) const;
        void __get_12_hour(int &__h,
                           iter_type &__b, iter_type __e,
                           ios_base::iostate &__err,
                           const ctype<char_type> &__ct) const;
        void __get_am_pm(int &__h,
                         iter_type &__b, iter_type __e,
                         ios_base::iostate &__err,
                         const ctype<char_type> &__ct) const;
        void __get_minute(int &__m,
                          iter_type &__b, iter_type __e,
                          ios_base::iostate &__err,
                          const ctype<char_type> &__ct) const;
        void __get_second(int &__s,
                          iter_type &__b, iter_type __e,
                          ios_base::iostate &__err,
                          const ctype<char_type> &__ct) const;
        void __get_weekday(int &__w,
                           iter_type &__b, iter_type __e,
                           ios_base::iostate &__err,
                           const ctype<char_type> &__ct) const;
        void __get_day_year_num(int &__w,
                                iter_type &__b, iter_type __e,
                                ios_base::iostate &__err,
                                const ctype<char_type> &__ct) const;
};
template <class _CharT, class _InputIterator>
locale::id
    time_get<_CharT, _InputIterator>::id;
template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_weekdayname(int &__w,
                                                         iter_type &__b, iter_type __e,
                                                         ios_base::iostate &__err,
                                                         const ctype<char_type> &__ct) const
{
        const string_type *__wk = this->__weeks();
        ptrdiff_t __i = std::__scan_keyword(__b, __e, __wk, __wk + 14, __ct, __err, false) - __wk;
        if (__i < 14)
            __w = __i % 7;
}
template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_monthname(int &__m,
                                                       iter_type &__b, iter_type __e,
                                                       ios_base::iostate &__err,
                                                       const ctype<char_type> &__ct) const
{
        const string_type *__month = this->__months();
        ptrdiff_t __i = std::__scan_keyword(__b, __e, __month, __month + 24, __ct, __err, false) - __month;
        if (__i < 24)
            __m = __i % 12;
}
template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_day(int &__d,
                                                 iter_type &__b, iter_type __e,
                                                 ios_base::iostate &__err,
                                                 const ctype<char_type> &__ct) const
{
        int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 2);
        if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)
            __d = __t;
        else
            __err |= ios_base::failbit;
}
template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_month(int &__m,
                                                   iter_type &__b, iter_type __e,
                                                   ios_base::iostate &__err,
                                                   const ctype<char_type> &__ct) const
{
        int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;
        if (!(__err & ios_base::failbit) && 0 <= __t && __t <= 11)
            __m = __t;
        else
            __err |= ios_base::failbit;
}
template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_year(int &__y,
                                                  iter_type &__b, iter_type __e,
                                                  ios_base::iostate &__err,
                                                  const ctype<char_type> &__ct) const
{
        int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
        if (!(__err & ios_base::failbit))
        {
            if (__t < 69)
                __t += 2000;
            else if (69 <= __t && __t <= 99)
                __t += 1900;
            __y = __t - 1900;
        }
}
template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_year4(int &__y,
                                                   iter_type &__b, iter_type __e,
                                                   ios_base::iostate &__err,
                                                   const ctype<char_type> &__ct) const
{
        int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
        if (!(__err & ios_base::failbit))
            __y = __t - 1900;
}
template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_hour(int &__h,
                                                  iter_type &__b, iter_type __e,
                                                  ios_base::iostate &__err,
                                                  const ctype<char_type> &__ct) const
{
        int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
        if (!(__err & ios_base::failbit) && __t <= 23)
            __h = __t;
        else
            __err |= ios_base::failbit;
}
template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_12_hour(int &__h,
                                                     iter_type &__b, iter_type __e,
                                                     ios_base::iostate &__err,
                                                     const ctype<char_type> &__ct) const
{
        int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
        if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)
            __h = __t;
        else
            __err |= ios_base::failbit;
}
template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_minute(int &__m,
                                                    iter_type &__b, iter_type __e,
                                                    ios_base::iostate &__err,
                                                    const ctype<char_type> &__ct) const
{
        int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
        if (!(__err & ios_base::failbit) && __t <= 59)
            __m = __t;
        else
            __err |= ios_base::failbit;
}
template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_second(int &__s,
                                                    iter_type &__b, iter_type __e,
                                                    ios_base::iostate &__err,
                                                    const ctype<char_type> &__ct) const
{
        int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
        if (!(__err & ios_base::failbit) && __t <= 60)
            __s = __t;
        else
            __err |= ios_base::failbit;
}
template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_weekday(int &__w,
                                                     iter_type &__b, iter_type __e,
                                                     ios_base::iostate &__err,
                                                     const ctype<char_type> &__ct) const
{
        int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 1);
        if (!(__err & ios_base::failbit) && __t <= 6)
            __w = __t;
        else
            __err |= ios_base::failbit;
}
template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_day_year_num(int &__d,
                                                          iter_type &__b, iter_type __e,
                                                          ios_base::iostate &__err,
                                                          const ctype<char_type> &__ct) const
{
        int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 3);
        if (!(__err & ios_base::failbit) && __t <= 365)
            __d = __t;
        else
            __err |= ios_base::failbit;
}
template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_white_space(iter_type &__b, iter_type __e,
                                                         ios_base::iostate &__err,
                                                         const ctype<char_type> &__ct) const
{
        for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
            ;
        if (__b == __e)
            __err |= ios_base::eofbit;
}
template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_am_pm(int &__h,
                                                   iter_type &__b, iter_type __e,
                                                   ios_base::iostate &__err,
                                                   const ctype<char_type> &__ct) const
{
        const string_type *__ap = this->__am_pm();
        if (__ap[0].size() + __ap[1].size() == 0)
        {
            __err |= ios_base::failbit;
            return;
        }
        ptrdiff_t __i = std::__scan_keyword(__b, __e, __ap, __ap + 2, __ct, __err, false) - __ap;
        if (__i == 0 && __h == 12)
            __h = 0;
        else if (__i == 1 && __h < 12)
            __h += 12;
}
template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_percent(iter_type &__b, iter_type __e,
                                                     ios_base::iostate &__err,
                                                     const ctype<char_type> &__ct) const
{
        if (__b == __e)
        {
            __err |= ios_base::eofbit | ios_base::failbit;
            return;
        }
        if (__ct.narrow(*__b, 0) != '%')
            __err |= ios_base::failbit;
        else if (++__b == __e)
            __err |= ios_base::eofbit;
}
template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::get(iter_type __b, iter_type __e,
                                      ios_base &__iob,
                                      ios_base::iostate &__err, tm *__tm,
                                      const char_type *__fmtb, const char_type *__fmte) const
{
        const ctype<char_type> &__ct = use_facet<ctype<char_type>>(__iob.getloc());
        __err = ios_base::goodbit;
        while (__fmtb != __fmte && __err == ios_base::goodbit)
        {
            if (__b == __e)
            {
                __err = ios_base::failbit;
                break;
            }
            if (__ct.narrow(*__fmtb, 0) == '%')
            {
                if (++__fmtb == __fmte)
                {
                    __err = ios_base::failbit;
                    break;
                }
                char __cmd = __ct.narrow(*__fmtb, 0);
                char __opt = '\0';
                if (__cmd == 'E' || __cmd == '0')
                {
                    if (++__fmtb == __fmte)
                    {
                        __err = ios_base::failbit;
                        break;
                    }
                    __opt = __cmd;
                    __cmd = __ct.narrow(*__fmtb, 0);
                }
                __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);
                ++__fmtb;
            }
            else if (__ct.is(ctype_base::space, *__fmtb))
            {
                for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)
                    ;
                for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
                    ;
            }
            else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb))
            {
                ++__b;
                ++__fmtb;
            }
            else
                __err = ios_base::failbit;
        }
        if (__b == __e)
            __err |= ios_base::eofbit;
        return __b;
}
template <class _CharT, class _InputIterator>
typename time_get<_CharT, _InputIterator>::dateorder
time_get<_CharT, _InputIterator>::do_date_order() const
{
        return mdy;
}
template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_time(iter_type __b, iter_type __e,
                                              ios_base &__iob,
                                              ios_base::iostate &__err,
                                              tm *__tm) const
{
        const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
        return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof(__fmt) / sizeof(__fmt[0]));
}
template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_date(iter_type __b, iter_type __e,
                                              ios_base &__iob,
                                              ios_base::iostate &__err,
                                              tm *__tm) const
{
        const string_type &__fmt = this->__x();
        return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());
}
template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_weekday(iter_type __b, iter_type __e,
                                                 ios_base &__iob,
                                                 ios_base::iostate &__err,
                                                 tm *__tm) const
{
        const ctype<char_type> &__ct = use_facet<ctype<char_type>>(__iob.getloc());
        __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
        return __b;
}
template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_monthname(iter_type __b, iter_type __e,
                                                   ios_base &__iob,
                                                   ios_base::iostate &__err,
                                                   tm *__tm) const
{
        const ctype<char_type> &__ct = use_facet<ctype<char_type>>(__iob.getloc());
        __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
        return __b;
}
template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_year(iter_type __b, iter_type __e,
                                              ios_base &__iob,
                                              ios_base::iostate &__err,
                                              tm *__tm) const
{
        const ctype<char_type> &__ct = use_facet<ctype<char_type>>(__iob.getloc());
        __get_year(__tm->tm_year, __b, __e, __err, __ct);
        return __b;
}
template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                         ios_base &__iob,
                                         ios_base::iostate &__err, tm *__tm,
                                         char __fmt, char) const
{
        __err = ios_base::goodbit;
        const ctype<char_type> &__ct = use_facet<ctype<char_type>>(__iob.getloc());
        switch (__fmt)
        {
        case 'a':
        case 'A':
            __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
            break;
        case 'b':
        case 'B':
        case 'h':
            __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
            break;
        case 'c':
        {
            const string_type &__fm = this->__c();
            __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
        }
        break;
        case 'd':
        case 'e':
            __get_day(__tm->tm_mday, __b, __e, __err, __ct);
            break;
        case 'D':
        {
            const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};
            __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm) / sizeof(__fm[0]));
        }
        break;
        case 'F':
        {
            const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};
            __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm) / sizeof(__fm[0]));
        }
        break;
        case 'H':
            __get_hour(__tm->tm_hour, __b, __e, __err, __ct);
            break;
        case 'I':
            __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);
            break;
        case 'j':
            __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);
            break;
        case 'm':
            __get_month(__tm->tm_mon, __b, __e, __err, __ct);
            break;
        case 'M':
            __get_minute(__tm->tm_min, __b, __e, __err, __ct);
            break;
        case 'n':
        case 't':
            __get_white_space(__b, __e, __err, __ct);
            break;
        case 'p':
            __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);
            break;
        case 'r':
        {
            const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};
            __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm) / sizeof(__fm[0]));
        }
        break;
        case 'R':
        {
            const char_type __fm[] = {'%', 'H', ':', '%', 'M'};
            __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm) / sizeof(__fm[0]));
        }
        break;
        case 'S':
            __get_second(__tm->tm_sec, __b, __e, __err, __ct);
            break;
        case 'T':
        {
            const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
            __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm) / sizeof(__fm[0]));
        }
        break;
        case 'w':
            __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);
            break;
        case 'x':
            return do_get_date(__b, __e, __iob, __err, __tm);
        case 'X':
        {
            const string_type &__fm = this->__X();
            __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
        }
        break;
        case 'y':
            __get_year(__tm->tm_year, __b, __e, __err, __ct);
            break;
        case 'Y':
            __get_year4(__tm->tm_year, __b, __e, __err, __ct);
            break;
        case '%':
            __get_percent(__b, __e, __err, __ct);
            break;
        default:
            __err |= ios_base::failbit;
        }
        return __b;
}
extern template class time_get<char>;
extern template class time_get<wchar_t>;
class __time_get
{
    protected:
        locale_t __loc_;
        __time_get(const char *__nm);
        __time_get(const string &__nm);
        ~__time_get();
};
template <class _CharT>
class __time_get_storage
    : public __time_get
{
    protected:
        typedef basic_string<_CharT> string_type;
        string_type __weeks_[14];
        string_type __months_[24];
        string_type __am_pm_[2];
        string_type __c_;
        string_type __r_;
        string_type __x_;
        string_type __X_;
        explicit __time_get_storage(const char *__nm);
        explicit __time_get_storage(const string &__nm);
        {
        }
        time_base::dateorder __do_date_order() const;

    private:
        void init(const ctype<_CharT> &);
        string_type __analyze(char __fmt, const ctype<_CharT> &);
};
template <>
;
template <>
;
template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT>>
class time_get_byname
    : public time_get<_CharT, _InputIterator>,
      private __time_get_storage<_CharT>
{
    public:
        typedef time_base::dateorder dateorder;
        typedef _InputIterator iter_type;
        typedef _CharT char_type;
        typedef basic_string<char_type> string_type;

        explicit time_get_byname(const char *__nm, size_t __refs = 0)
            : time_get<_CharT, _InputIterator>(__refs),
              __time_get_storage<_CharT>(__nm) {}

        explicit time_get_byname(const string &__nm, size_t __refs = 0)
            : time_get<_CharT, _InputIterator>(__refs),
              __time_get_storage<_CharT>(__nm) {}

    protected:
        ~time_get_byname() {}

        virtual dateorder do_date_order() const { return this->__do_date_order(); }

    private:
        virtual const string_type *__weeks() const { return this->__weeks_; }

        virtual const string_type *__months() const { return this->__months_; }

        virtual const string_type *__am_pm() const { return this->__am_pm_; }

        virtual const string_type &__c() const { return this->__c_; }

        virtual const string_type &__r() const { return this->__r_; }

        virtual const string_type &__x() const { return this->__x_; }

        virtual const string_type &__X() const { return this->__X_; }
};
extern template class time_get_byname<char>;
extern template class time_get_byname<wchar_t>;
class __time_put
{
        locale_t __loc_;

    protected:
        {
        }
        __time_put(const char *__nm);
        __time_put(const string &__nm);
        ~__time_put();
        void __do_put(char *__nb, char *&__ne, const tm *__tm,
                      char __fmt, char __mod) const;
        void __do_put(wchar_t *__wb, wchar_t *&__we, const tm *__tm,
                      char __fmt, char __mod) const;
};
template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT>>
class time_put
    : public locale::facet,
      private __time_put
{
    public:
        typedef _CharT char_type;
        typedef _OutputIterator iter_type;

        explicit time_put(size_t __refs = 0)
            : locale::facet(__refs) {}
        iter_type put(iter_type __s, ios_base &__iob, char_type __fl, const tm *__tm,
                      const char_type *__pb, const char_type *__pe) const;

        iter_type put(iter_type __s, ios_base &__iob, char_type __fl,
                      const tm *__tm, char __fmt, char __mod = 0) const
        {
            return do_put(__s, __iob, __fl, __tm, __fmt, __mod);
        }
        static locale::id id;

    protected:
        ~time_put() {}
        virtual iter_type do_put(iter_type __s, ios_base &, char_type, const tm *__tm,
                                 char __fmt, char __mod) const;

        explicit time_put(const char *__nm, size_t __refs)
            : locale::facet(__refs),
              __time_put(__nm) {}

        explicit time_put(const string &__nm, size_t __refs)
            : locale::facet(__refs),
              __time_put(__nm) {}
};
template <class _CharT, class _OutputIterator>
locale::id
    time_put<_CharT, _OutputIterator>::id;
template <class _CharT, class _OutputIterator>
_OutputIterator
time_put<_CharT, _OutputIterator>::put(iter_type __s, ios_base &__iob,
                                       char_type __fl, const tm *__tm,
                                       const char_type *__pb,
                                       const char_type *__pe) const
{
        const ctype<char_type> &__ct = use_facet<ctype<char_type>>(__iob.getloc());
        for (; __pb != __pe; ++__pb)
        {
            if (__ct.narrow(*__pb, 0) == '%')
            {
                if (++__pb == __pe)
                {
                    *__s++ = __pb[-1];
                    break;
                }
                char __mod = 0;
                char __fmt = __ct.narrow(*__pb, 0);
                if (__fmt == 'E' || __fmt == 'O')
                {
                    if (++__pb == __pe)
                    {
                        *__s++ = __pb[-2];
                        *__s++ = __pb[-1];
                        break;
                    }
                    __mod = __fmt;
                    __fmt = __ct.narrow(*__pb, 0);
                }
                __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);
            }
            else
                *__s++ = *__pb;
        }
        return __s;
}
template <class _CharT, class _OutputIterator>
_OutputIterator
time_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base &,
                                          char_type, const tm *__tm,
                                          char __fmt, char __mod) const
{
        char_type __nar[100];
        char_type *__nb = __nar;
        char_type *__ne = __nb + 100;
        __do_put(__nb, __ne, __tm, __fmt, __mod);
        return std::copy(__nb, __ne, __s);
}
extern template class time_put<char>;
extern template class time_put<wchar_t>;
template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT>>
class time_put_byname
    : public time_put<_CharT, _OutputIterator>
{
    public:
        explicit time_put_byname(const char *__nm, size_t __refs = 0)
            : time_put<_CharT, _OutputIterator>(__nm, __refs) {}

        explicit time_put_byname(const string &__nm, size_t __refs = 0)
            : time_put<_CharT, _OutputIterator>(__nm, __refs) {}

    protected:
        ~time_put_byname() {}
};
extern template class time_put_byname<char>;
extern template class time_put_byname<wchar_t>;
class money_base
{
    public:
        enum part
        {
            none,
            space,
            symbol,
            sign,
            value
        };
        struct pattern
        {
            char field[4];
        };
        {
        }
};
template <class _CharT, bool _International = false>
class moneypunct
    : public locale::facet,
      public money_base
{
    public:
        typedef _CharT char_type;
        typedef basic_string<char_type> string_type;

        explicit moneypunct(size_t __refs = 0)
            : locale::facet(__refs){};
};
    };
};
}
;
}
;
}
;
}
;
}
;
}
static locale::id id;
static const bool intl = _International;

protected:
~moneypunct() {}
virtual char_type do_decimal_point() const { return numeric_limits<char_type>::max(); }
virtual char_type do_thousands_sep() const { return numeric_limits<char_type>::max(); }
virtual string do_grouping() const { return string(); }
virtual string_type do_curr_symbol() const { return string_type(); }
virtual string_type do_positive_sign() const { return string_type(); }
virtual string_type do_negative_sign() const { return string_type(1, '-'); }
virtual int do_frac_digits() const { return 0; }
virtual pattern do_pos_format() const
{
    pattern __p = {{symbol, sign, none, value}};
    return __p;
}
virtual pattern do_neg_format() const
{
    pattern __p = {{symbol, sign, none, value}};
    return __p;
}
}
;
template <class _CharT, bool _International>
locale::id
    moneypunct<_CharT, _International>::id;
template <class _CharT, bool _International>
const bool
    moneypunct<_CharT, _International>::intl;
extern template class moneypunct<char, false>;
extern template class moneypunct<char, true>;
extern template class moneypunct<wchar_t, false>;
extern template class moneypunct<wchar_t, true>;
template <class _CharT, bool _International = false>
class moneypunct_byname
    : public moneypunct<_CharT, _International>
{
public:
    typedef money_base::pattern pattern;
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    explicit moneypunct_byname(const char *__nm, size_t __refs = 0)
        : moneypunct<_CharT, _International>(__refs) { init(__nm); }

    explicit moneypunct_byname(const string &__nm, size_t __refs = 0)
        : moneypunct<_CharT, _International>(__refs) { init(__nm.c_str()); }

protected:
    ~moneypunct_byname() {}
    virtual char_type do_decimal_point() const { return __decimal_point_; }
    virtual char_type do_thousands_sep() const { return __thousands_sep_; }
    virtual string do_grouping() const { return __grouping_; }
    virtual string_type do_curr_symbol() const { return __curr_symbol_; }
    virtual string_type do_positive_sign() const { return __positive_sign_; }
    virtual string_type do_negative_sign() const { return __negative_sign_; }
    virtual int do_frac_digits() const { return __frac_digits_; }
    virtual pattern do_pos_format() const { return __pos_format_; }
    virtual pattern do_neg_format() const { return __neg_format_; }

private:
    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
    string_type __curr_symbol_;
    string_type __positive_sign_;
    string_type __negative_sign_;
    int __frac_digits_;
    pattern __pos_format_;
    pattern __neg_format_;
    void init(const char *);
};
template <>
;
template <>
;
extern template class moneypunct_byname<char, false>;
extern template class moneypunct_byname<char, true>;
template <>
;
template <>
;
extern template class moneypunct_byname<wchar_t, false>;
extern template class moneypunct_byname<wchar_t, true>;
template <class _CharT>
class __money_get
{
protected:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;
    {
    }
    static void __gather_info(bool __intl, const locale &__loc,
                              money_base::pattern &__pat, char_type &__dp,
                              char_type &__ts, string &__grp,
                              string_type &__sym, string_type &__psn,
                              string_type &__nsn, int &__fd);
};
template <class _CharT>
void __money_get<_CharT>::__gather_info(bool __intl, const locale &__loc,
                                        money_base::pattern &__pat, char_type &__dp,
                                        char_type &__ts, string &__grp,
                                        string_type &__sym, string_type &__psn,
                                        string_type &__nsn, int &__fd)
{
    if (__intl)
    {
const moneypunct<char_type, true> &__mp =
    use_facet<moneypunct<char_type, true>>(__loc);
__pat = __mp.neg_format();
__nsn = __mp.negative_sign();
__psn = __mp.positive_sign();
__dp = __mp.decimal_point();
__ts = __mp.thousands_sep();
__grp = __mp.grouping();
__sym = __mp.curr_symbol();
__fd = __mp.frac_digits();
    }
    else
    {
const moneypunct<char_type, false> &__mp =
    use_facet<moneypunct<char_type, false>>(__loc);
__pat = __mp.neg_format();
__nsn = __mp.negative_sign();
__psn = __mp.positive_sign();
__dp = __mp.decimal_point();
__ts = __mp.thousands_sep();
__grp = __mp.grouping();
__sym = __mp.curr_symbol();
__fd = __mp.frac_digits();
    }
}
extern template class __money_get<char>;
extern template class __money_get<wchar_t>;
template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT>>
class money_get
    : public locale::facet,
      private __money_get<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;
    typedef basic_string<char_type> string_type;

    explicit money_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base &__iob,
                  ios_base::iostate &__err, long double &__v) const
    {
return do_get(__b, __e, __intl, __iob, __err, __v);
    }

    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base &__iob,
                  ios_base::iostate &__err, string_type &__v) const
    {
return do_get(__b, __e, __intl, __iob, __err, __v);
    }
    static locale::id id;

protected:
    ~money_get() {}
    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
                             ios_base &__iob, ios_base::iostate &__err,
                             long double &__v) const;
    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
                             ios_base &__iob, ios_base::iostate &__err,
                             string_type &__v) const;

private:
    static bool __do_get(iter_type &__b, iter_type __e,
                         bool __intl, const locale &__loc,
                         ios_base::fmtflags __flags, ios_base::iostate &__err,
                         bool &__neg, const ctype<char_type> &__ct,
                         unique_ptr<char_type, void (*)(void *)> &__wb,
                         char_type *&__wn, char_type *__we);
};
template <class _CharT, class _InputIterator>
locale::id
    money_get<_CharT, _InputIterator>::id;
;
template <class _Tp>

void __double_or_nothing(unique_ptr<_Tp, void (*)(void *)> &__b, _Tp *&__n, _Tp *&__e)
{
    bool __owns = __b.get_deleter() != __do_nothing;
    size_t __cur_cap = static_cast<size_t>(__e - __b.get()) * sizeof(_Tp);
    size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ? 2 * __cur_cap : numeric_limits<size_t>::max();
    if (__new_cap == 0)
__new_cap = sizeof(_Tp);
    size_t __n_off = static_cast<size_t>(__n - __b.get());
    _Tp *__t = (_Tp *)realloc(__owns ? __b.get() : 0, __new_cap);
    if (__t == 0)
__throw_bad_alloc();
    if (__owns)
__b.release();
    __b = unique_ptr<_Tp, void (*)(void *)>(__t, free);
    __new_cap /= sizeof(_Tp);
    __n = __b.get() + __n_off;
    __e = __b.get() + __new_cap;
}
template <class _CharT, class _InputIterator>
bool money_get<_CharT, _InputIterator>::__do_get(iter_type &__b, iter_type __e,
                                                 bool __intl, const locale &__loc,
                                                 ios_base::fmtflags __flags,
                                                 ios_base::iostate &__err,
                                                 bool &__neg,
                                                 const ctype<char_type> &__ct,
                                                 unique_ptr<char_type, void (*)(void *)> &__wb,
                                                 char_type *&__wn, char_type *__we)
{
    if (__b == __e)
    {
__err |= ios_base::failbit;
return false;
    }
    const unsigned __bz = 100;
    unsigned __gbuf[__bz];
    unique_ptr<unsigned, void (*)(void *)> __gb(__gbuf, __do_nothing);
    unsigned *__gn = __gb.get();
    unsigned *__ge = __gn + __bz;
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __psn;
    string_type __nsn;
    string_type __spaces;
    int __fd;
    __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp,
                                       __sym, __psn, __nsn, __fd);
    const string_type *__trailing_sign = 0;
    __wn = __wb.get();
    for (unsigned __p = 0; __p < 4 && __b != __e; ++__p)
    {
switch (__pat.field[__p])
{
case money_base::space:
        if (__p != 3)
        {
            if (__ct.is(ctype_base::space, *__b))
                __spaces.push_back(*__b++);
            else
            {
                __err |= ios_base::failbit;
                return false;
            }
        };
case money_base::none:
        if (__p != 3)
        {
            while (__b != __e && __ct.is(ctype_base::space, *__b))
                __spaces.push_back(*__b++);
        }
        break;
case money_base::sign:
        if (__psn.size() > 0 && *__b == __psn[0])
        {
            ++__b;
            __neg = false;
            if (__psn.size() > 1)
                __trailing_sign = &__psn;
            break;
        }
        if (__nsn.size() > 0 && *__b == __nsn[0])
        {
            ++__b;
            __neg = true;
            if (__nsn.size() > 1)
                __trailing_sign = &__nsn;
            break;
        }
        if (__psn.size() > 0 && __nsn.size() > 0)
        {
            __err |= ios_base::failbit;
            return false;
        }
        if (__psn.size() == 0 && __nsn.size() == 0)
            break;
        __neg = (__nsn.size() == 0);
        break;
case money_base::symbol:
{
        bool __more_needed = __trailing_sign ||
                             (__p < 2) ||
                             (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));
        bool __sb = (__flags & ios_base::showbase) != 0;
        if (__sb || __more_needed)
        {
            typename string_type::const_iterator __sym_space_end = __sym.begin();
            if (__p > 0 && (__pat.field[__p - 1] == money_base::none ||
                            __pat.field[__p - 1] == money_base::space))
            {
                while (__sym_space_end != __sym.end() &&
                       __ct.is(ctype_base::space, *__sym_space_end))
                    ++__sym_space_end;
                const size_t __num_spaces = __sym_space_end - __sym.begin();
                if (__num_spaces > __spaces.size() ||
                    !equal(__spaces.end() - __num_spaces, __spaces.end(),
                           __sym.begin()))
                {
                    __sym_space_end = __sym.begin();
                }
            }
            typename string_type::const_iterator __sym_curr_char = __sym_space_end;
            while (__sym_curr_char != __sym.end() && __b != __e &&
                   *__b == *__sym_curr_char)
            {
                ++__b;
                ++__sym_curr_char;
            }
            if (__sb && __sym_curr_char != __sym.end())
            {
                __err |= ios_base::failbit;
                return false;
            }
        }
}
break;
case money_base::value:
{
        unsigned __ng = 0;
        for (; __b != __e; ++__b)
        {
            char_type __c = *__b;
            if (__ct.is(ctype_base::digit, __c))
            {
                if (__wn == __we)
                    __double_or_nothing(__wb, __wn, __we);
                *__wn++ = __c;
                ++__ng;
            }
            else if (__grp.size() > 0 && __ng > 0 && __c == __ts)
            {
                if (__gn == __ge)
                    __double_or_nothing(__gb, __gn, __ge);
                *__gn++ = __ng;
                __ng = 0;
            }
            else
                break;
        }
        if (__gb.get() != __gn && __ng > 0)
        {
            if (__gn == __ge)
                __double_or_nothing(__gb, __gn, __ge);
            *__gn++ = __ng;
        }
        if (__fd > 0)
        {
            if (__b == __e || *__b != __dp)
            {
                __err |= ios_base::failbit;
                return false;
            }
            for (++__b; __fd > 0; --__fd, ++__b)
            {
                if (__b == __e || !__ct.is(ctype_base::digit, *__b))
                {
                    __err |= ios_base::failbit;
                    return false;
                }
                if (__wn == __we)
                    __double_or_nothing(__wb, __wn, __we);
                *__wn++ = *__b;
            }
        }
        if (__wn == __wb.get())
        {
            __err |= ios_base::failbit;
            return false;
        }
}
break;
}
    }
    if (__trailing_sign)
    {
for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b)
{
        if (__b == __e || *__b != (*__trailing_sign)[__i])
        {
            __err |= ios_base::failbit;
            return false;
        }
}
    }
    if (__gb.get() != __gn)
    {
ios_base::iostate __et = ios_base::goodbit;
__check_grouping(__grp, __gb.get(), __gn, __et);
if (__et)
{
        __err |= ios_base::failbit;
        return false;
}
    }
    return true;
}
template <class _CharT, class _InputIterator>
_InputIterator
money_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                          bool __intl, ios_base &__iob,
                                          ios_base::iostate &__err,
                                          long double &__v) const
{
    const int __bz = 100;
    char_type __wbuf[__bz];
    unique_ptr<char_type, void (*)(void *)> __wb(__wbuf, __do_nothing);
    char_type *__wn;
    char_type *__we = __wbuf + __bz;
    locale __loc = __iob.getloc();
    const ctype<char_type> &__ct = use_facet<ctype<char_type>>(__loc);
    bool __neg = false;
    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,
                 __wb, __wn, __we))
    {
const char __src[] = "0123456789";
char_type __atoms[sizeof(__src) - 1];
__ct.widen(__src, __src + (sizeof(__src) - 1), __atoms);
char __nbuf[__bz];
char *__nc = __nbuf;
unique_ptr<char, void (*)(void *)> __h(__nullptr, free);
if (__wn - __wb.get() > __bz - 2)
{
        __h.reset((char *)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));
        if (__h.get() == __nullptr)
            __throw_bad_alloc();
        __nc = __h.get();
}
if (__neg)
        *__nc++ = '-';
for (const char_type *__w = __wb.get(); __w < __wn; ++__w, ++__nc)
        *__nc = __src[find(__atoms, std::end(__atoms), *__w) - __atoms];
*__nc = char();
if (sscanf(__nbuf, "%Lf", &__v) != 1)
        __throw_runtime_error("money_get error");
    }
    if (__b == __e)
__err |= ios_base::eofbit;
    return __b;
}
template <class _CharT, class _InputIterator>
_InputIterator
money_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                          bool __intl, ios_base &__iob,
                                          ios_base::iostate &__err,
                                          string_type &__v) const
{
    const int __bz = 100;
    char_type __wbuf[__bz];
    unique_ptr<char_type, void (*)(void *)> __wb(__wbuf, __do_nothing);
    char_type *__wn;
    char_type *__we = __wbuf + __bz;
    locale __loc = __iob.getloc();
    const ctype<char_type> &__ct = use_facet<ctype<char_type>>(__loc);
    bool __neg = false;
    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,
                 __wb, __wn, __we))
    {
__v.clear();
if (__neg)
        __v.push_back(__ct.widen('-'));
char_type __z = __ct.widen('0');
char_type *__w;
for (__w = __wb.get(); __w < __wn - 1; ++__w)
        if (*__w != __z)
            break;
__v.append(__w, __wn);
    }
    if (__b == __e)
__err |= ios_base::eofbit;
    return __b;
}
extern template class money_get<char>;
extern template class money_get<wchar_t>;
template <class _CharT>
class __money_put
{
protected:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;
    {
    }
    static void __gather_info(bool __intl, bool __neg, const locale &__loc,
                              money_base::pattern &__pat, char_type &__dp,
                              char_type &__ts, string &__grp,
                              string_type &__sym, string_type &__sn,
                              int &__fd);
    static void __format(char_type *__mb, char_type *&__mi, char_type *&__me,
                         ios_base::fmtflags __flags,
                         const char_type *__db, const char_type *__de,
                         const ctype<char_type> &__ct, bool __neg,
                         const money_base::pattern &__pat, char_type __dp,
                         char_type __ts, const string &__grp,
                         const string_type &__sym, const string_type &__sn,
                         int __fd);
};
template <class _CharT>
void __money_put<_CharT>::__gather_info(bool __intl, bool __neg, const locale &__loc,
                                        money_base::pattern &__pat, char_type &__dp,
                                        char_type &__ts, string &__grp,
                                        string_type &__sym, string_type &__sn,
                                        int &__fd)
{
    if (__intl)
    {
const moneypunct<char_type, true> &__mp =
    use_facet<moneypunct<char_type, true>>(__loc);
if (__neg)
{
        __pat = __mp.neg_format();
        __sn = __mp.negative_sign();
}
else
{
        __pat = __mp.pos_format();
        __sn = __mp.positive_sign();
}
__dp = __mp.decimal_point();
__ts = __mp.thousands_sep();
__grp = __mp.grouping();
__sym = __mp.curr_symbol();
__fd = __mp.frac_digits();
    }
    else
    {
const moneypunct<char_type, false> &__mp =
    use_facet<moneypunct<char_type, false>>(__loc);
if (__neg)
{
        __pat = __mp.neg_format();
        __sn = __mp.negative_sign();
}
else
{
        __pat = __mp.pos_format();
        __sn = __mp.positive_sign();
}
__dp = __mp.decimal_point();
__ts = __mp.thousands_sep();
__grp = __mp.grouping();
__sym = __mp.curr_symbol();
__fd = __mp.frac_digits();
    }
}
template <class _CharT>
void __money_put<_CharT>::__format(char_type *__mb, char_type *&__mi, char_type *&__me,
                                   ios_base::fmtflags __flags,
                                   const char_type *__db, const char_type *__de,
                                   const ctype<char_type> &__ct, bool __neg,
                                   const money_base::pattern &__pat, char_type __dp,
                                   char_type __ts, const string &__grp,
                                   const string_type &__sym, const string_type &__sn,
                                   int __fd)
{
    __me = __mb;
    for (char __p : __pat.field)
    {
switch (__p)
{
case money_base::none:
        __mi = __me;
        break;
case money_base::space:
        __mi = __me;
        *__me++ = __ct.widen(' ');
        break;
case money_base::sign:
        if (!__sn.empty())
            *__me++ = __sn[0];
        break;
case money_base::symbol:
        if (!__sym.empty() && (__flags & ios_base::showbase))
            __me = std::copy(__sym.begin(), __sym.end(), __me);
        break;
case money_base::value:
{
        char_type *__t = __me;
        if (__neg)
            ++__db;
        const char_type *__d;
        for (__d = __db; __d < __de; ++__d)
            if (!__ct.is(ctype_base::digit, *__d))
                break;
        if (__fd > 0)
        {
            int __f;
            for (__f = __fd; __d > __db && __f > 0; --__f)
                *__me++ = *--__d;
            char_type __z = __f > 0 ? __ct.widen('0') : char_type();
            for (; __f > 0; --__f)
                *__me++ = __z;
            *__me++ = __dp;
        }
        if (__d == __db)
        {
            *__me++ = __ct.widen('0');
        }
        else
        {
            unsigned __ng = 0;
            unsigned __ig = 0;
            unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max()
                                          : static_cast<unsigned>(__grp[__ig]);
            while (__d != __db)
            {
                if (__ng == __gl)
                {
                    *__me++ = __ts;
                    __ng = 0;
                    if (++__ig < __grp.size())
                        __gl = __grp[__ig] == numeric_limits<char>::max() ? numeric_limits<unsigned>::max() : static_cast<unsigned>(__grp[__ig]);
                }
                *__me++ = *--__d;
                ++__ng;
            }
        }
        reverse(__t, __me);
}
break;
}
    }
    if (__sn.size() > 1)
__me = std::copy(__sn.begin() + 1, __sn.end(), __me);
    if ((__flags & ios_base::adjustfield) == ios_base::left)
__mi = __me;
    else if ((__flags & ios_base::adjustfield) != ios_base::internal)
__mi = __mb;
}
extern template class __money_put<char>;
extern template class __money_put<wchar_t>;
template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT>>
class money_put
    : public locale::facet,
      private __money_put<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;
    typedef basic_string<char_type> string_type;

    explicit money_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    iter_type put(iter_type __s, bool __intl, ios_base &__iob, char_type __fl,
                  long double __units) const
    {
return do_put(__s, __intl, __iob, __fl, __units);
    }

    iter_type put(iter_type __s, bool __intl, ios_base &__iob, char_type __fl,
                  const string_type &__digits) const
    {
return do_put(__s, __intl, __iob, __fl, __digits);
    }
    static locale::id id;

protected:
    ~money_put() {}
    virtual iter_type do_put(iter_type __s, bool __intl, ios_base &__iob,
                             char_type __fl, long double __units) const;
    virtual iter_type do_put(iter_type __s, bool __intl, ios_base &__iob,
                             char_type __fl, const string_type &__digits) const;
};
template <class _CharT, class _OutputIterator>
locale::id
    money_put<_CharT, _OutputIterator>::id;
template <class _CharT, class _OutputIterator>
_OutputIterator
money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
                                           ios_base &__iob, char_type __fl,
                                           long double __units) const
{
    const size_t __bs = 100;
    char __buf[__bs];
    char *__bb = __buf;
    char_type __digits[__bs];
    char_type *__db = __digits;
    int __n = snprintf(__bb, __bs, "%.0Lf", __units);
    unique_ptr<char, void (*)(void *)> __hn(__nullptr, free);
    unique_ptr<char_type, void (*)(void *)> __hd(0, free);
    if (static_cast<size_t>(__n) > __bs - 1)
    {
__n = asprintf_l(&__bb, 0, "%.0Lf", __units);
if (__n == -1)
        __throw_bad_alloc();
__hn.reset(__bb);
__hd.reset((char_type *)malloc(static_cast<size_t>(__n) * sizeof(char_type)));
if (__hd == __nullptr)
        __throw_bad_alloc();
__db = __hd.get();
    }
    locale __loc = __iob.getloc();
    const ctype<char_type> &__ct = use_facet<ctype<char_type>>(__loc);
    __ct.widen(__bb, __bb + __n, __db);
    bool __neg = __n > 0 && __bb[0] == '-';
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __sn;
    int __fd;
    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    char_type __mbuf[__bs];
    char_type *__mb = __mbuf;
    unique_ptr<char_type, void (*)(void *)> __hw(0, free);
    size_t __exn = __n > __fd ? (static_cast<size_t>(__n) - static_cast<size_t>(__fd)) * 2 +
                                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1
                              : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
    if (__exn > __bs)
    {
__hw.reset((char_type *)malloc(__exn * sizeof(char_type)));
__mb = __hw.get();
if (__mb == 0)
        __throw_bad_alloc();
    }
    char_type *__mi;
    char_type *__me;
    this->__format(__mb, __mi, __me, __iob.flags(),
                   __db, __db + __n, __ct,
                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
}
template <class _CharT, class _OutputIterator>
_OutputIterator
money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
                                           ios_base &__iob, char_type __fl,
                                           const string_type &__digits) const
{
    locale __loc = __iob.getloc();
    const ctype<char_type> &__ct = use_facet<ctype<char_type>>(__loc);
    bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __sn;
    int __fd;
    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    char_type __mbuf[100];
    char_type *__mb = __mbuf;
    unique_ptr<char_type, void (*)(void *)> __h(0, free);
    size_t __exn = static_cast<int>(__digits.size()) > __fd ? (__digits.size() - static_cast<size_t>(__fd)) * 2 +
                                                                  __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1
                                                            : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
    if (__exn > 100)
    {
__h.reset((char_type *)malloc(__exn * sizeof(char_type)));
__mb = __h.get();
if (__mb == 0)
        __throw_bad_alloc();
    }
    char_type *__mi;
    char_type *__me;
    this->__format(__mb, __mi, __me, __iob.flags(),
                   __digits.data(), __digits.data() + __digits.size(), __ct,
                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
}
extern template class money_put<char>;
extern template class money_put<wchar_t>;
class messages_base
{
public:
    typedef ptrdiff_t catalog;
    {
    }
};
template <class _CharT>
class messages
    : public locale::facet,
      public messages_base
{
public:
    typedef _CharT char_type;
    typedef basic_string<_CharT> string_type;

    explicit messages(size_t __refs = 0)
        : locale::facet(__refs) {}

    catalog open(const basic_string<char> &__nm, const locale &__loc) const
    {
return do_open(__nm, __loc);
    }

    string_type get(catalog __c, int __set, int __msgid,
                    const string_type &__dflt) const
    {
return do_get(__c, __set, __msgid, __dflt);
    }

    void close(catalog __c) const
    {
do_close(__c);
    }
    static locale::id id;

protected:
    ~messages() {}
    virtual catalog do_open(const basic_string<char> &, const locale &) const;
    virtual string_type do_get(catalog, int __set, int __msgid,
                               const string_type &__dflt) const;
    virtual void do_close(catalog) const;
};
template <class _CharT>
locale::id
    messages<_CharT>::id;
template <class _CharT>
typename messages<_CharT>::catalog
messages<_CharT>::do_open(const basic_string<char> &__nm, const locale &) const
{
    catalog __cat = (catalog)catopen(__nm.c_str(), 1);
    if (__cat != -1)
__cat = static_cast<catalog>((static_cast<size_t>(__cat) >> 1));
    return __cat;
}
template <class _CharT>
typename messages<_CharT>::string_type
messages<_CharT>::do_get(catalog __c, int __set, int __msgid,
                         const string_type &__dflt) const
{
    string __ndflt;
    __narrow_to_utf8<sizeof(char_type) * 8>()(back_inserter(__ndflt),
                                              __dflt.c_str(),
                                              __dflt.c_str() + __dflt.size());
    if (__c != -1)
__c <<= 1;
    nl_catd __cat = (nl_catd)__c;
    char *__n = catgets(__cat, __set, __msgid, __ndflt.c_str());
    string_type __w;
    __widen_from_utf8<sizeof(char_type) * 8>()(back_inserter(__w),
                                               __n, __n + std::strlen(__n));
    return __w;
}
template <class _CharT>
void messages<_CharT>::do_close(catalog __c) const
{
    if (__c != -1)
__c <<= 1;
    nl_catd __cat = (nl_catd)__c;
    catclose(__cat);
}
extern template class messages<char>;
extern template class messages<wchar_t>;
template <class _CharT>
class messages_byname
    : public messages<_CharT>
{
public:
    typedef messages_base::catalog catalog;
    typedef basic_string<_CharT> string_type;

    explicit messages_byname(const char *, size_t __refs = 0)
        : messages<_CharT>(__refs) {}

    explicit messages_byname(const string &, size_t __refs = 0)
        : messages<_CharT>(__refs) {}

protected:
    ~messages_byname() {}
};
extern template class messages_byname<char>;
extern template class messages_byname<wchar_t>;
template <class _Codecvt, class _Elem = wchar_t,
          class _Wide_alloc = allocator<_Elem>,
          class _Byte_alloc = allocator<char>>
class wstring_convert
{
public:
    typedef basic_string<char, char_traits<char>, _Byte_alloc> byte_string;
    typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;
    typedef typename _Codecvt::state_type state_type;
    typedef typename wide_string::traits_type::int_type int_type;

private:
    byte_string __byte_err_string_;
    wide_string __wide_err_string_;
    _Codecvt *__cvtptr_;
    state_type __cvtstate_;
    size_t __cvtcount_;
    wstring_convert(const wstring_convert &__wc);
    wstring_convert &operator=(const wstring_convert &__wc);

public:
    wstring_convert(_Codecvt *__pcvt = new _Codecvt);

    wstring_convert(_Codecvt *__pcvt, state_type __state);
    wstring_convert(const byte_string &__byte_err,
                    const wide_string &__wide_err = wide_string());
    ~wstring_convert();

    wide_string from_bytes(char __byte)
    {
return from_bytes(&__byte, &__byte + 1);
    }

    wide_string from_bytes(const char *__ptr)
    {
return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));
    }

    wide_string from_bytes(const byte_string &__str)
    {
return from_bytes(__str.data(), __str.data() + __str.size());
    }
    wide_string from_bytes(const char *__first, const char *__last);

    byte_string to_bytes(_Elem __wchar)
    {
return to_bytes(&__wchar, &__wchar + 1);
    }

    byte_string to_bytes(const _Elem *__wptr)
    {
return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));
    }

    byte_string to_bytes(const wide_string &__wstr)
    {
return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());
    }
    byte_string to_bytes(const _Elem *__first, const _Elem *__last);

    size_t converted() const throw() { return __cvtcount_; }

    state_type state() const { return __cvtstate_; }
};
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(_Codecvt *__pcvt)
    : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0)
{
}
#pragma GCC diagnostic pop
template <class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(_Codecvt *__pcvt, state_type __state)
    : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0)
{
}
template <class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(const byte_string &__byte_err, const wide_string &__wide_err)
    : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err),
      __cvtstate_(), __cvtcount_(0)
{
    __cvtptr_ = new _Codecvt;
}
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::~wstring_convert()
{
    delete __cvtptr_;
}
template <class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    from_bytes(const char *__frm, const char *__frm_end)
{
#pragma GCC diagnostic pop
    __cvtcount_ = 0;
    if (__cvtptr_ != __nullptr)
    {
wide_string __ws(2 * (__frm_end - __frm), _Elem());
if (__frm != __frm_end)
        __ws.resize(__ws.capacity());
codecvt_base::result __r = codecvt_base::ok;
state_type __st = __cvtstate_;
if (__frm != __frm_end)
{
        _Elem *__to = &__ws[0];
        _Elem *__to_end = __to + __ws.size();
        const char *__frm_nxt;
        do
        {
            _Elem *__to_nxt;
            __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt,
                                __to, __to_end, __to_nxt);
            __cvtcount_ += __frm_nxt - __frm;
            if (__frm_nxt == __frm)
            {
                __r = codecvt_base::error;
            }
            else if (__r == codecvt_base::noconv)
            {
                __ws.resize(__to - &__ws[0]);
                __ws.append((const _Elem *)__frm, (const _Elem *)__frm_end);
                __frm = __frm_nxt;
                __r = codecvt_base::ok;
            }
            else if (__r == codecvt_base::ok)
            {
                __ws.resize(__to_nxt - &__ws[0]);
                __frm = __frm_nxt;
            }
            else if (__r == codecvt_base::partial)
            {
                ptrdiff_t __s = __to_nxt - &__ws[0];
                __ws.resize(2 * __s);
                __to = &__ws[0] + __s;
                __to_end = &__ws[0] + __ws.size();
                __frm = __frm_nxt;
            }
        } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
}
if (__r == codecvt_base::ok)
        return __ws;
    }
    if (__wide_err_string_.empty())
__throw_range_error("wstring_convert: from_bytes error");
    return __wide_err_string_;
}
template <class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    to_bytes(const _Elem *__frm, const _Elem *__frm_end)
{
    __cvtcount_ = 0;
    if (__cvtptr_ != __nullptr)
    {
byte_string __bs(2 * (__frm_end - __frm), char());
if (__frm != __frm_end)
        __bs.resize(__bs.capacity());
codecvt_base::result __r = codecvt_base::ok;
state_type __st = __cvtstate_;
if (__frm != __frm_end)
{
        char *__to = &__bs[0];
        char *__to_end = __to + __bs.size();
        const _Elem *__frm_nxt;
        do
        {
            char *__to_nxt;
            __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt,
                                 __to, __to_end, __to_nxt);
            __cvtcount_ += __frm_nxt - __frm;
            if (__frm_nxt == __frm)
            {
                __r = codecvt_base::error;
            }
            else if (__r == codecvt_base::noconv)
            {
                __bs.resize(__to - &__bs[0]);
                __bs.append((const char *)__frm, (const char *)__frm_end);
                __frm = __frm_nxt;
                __r = codecvt_base::ok;
            }
            else if (__r == codecvt_base::ok)
            {
                __bs.resize(__to_nxt - &__bs[0]);
                __frm = __frm_nxt;
            }
            else if (__r == codecvt_base::partial)
            {
                ptrdiff_t __s = __to_nxt - &__bs[0];
                __bs.resize(2 * __s);
                __to = &__bs[0] + __s;
                __to_end = &__bs[0] + __bs.size();
                __frm = __frm_nxt;
            }
        } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
}
if (__r == codecvt_base::ok)
{
        size_t __s = __bs.size();
        __bs.resize(__bs.capacity());
        char *__to = &__bs[0] + __s;
        char *__to_end = __to + __bs.size();
        do
        {
            char *__to_nxt;
            __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);
            if (__r == codecvt_base::noconv)
            {
                __bs.resize(__to - &__bs[0]);
                __r = codecvt_base::ok;
            }
            else if (__r == codecvt_base::ok)
            {
                __bs.resize(__to_nxt - &__bs[0]);
            }
            else if (__r == codecvt_base::partial)
            {
                ptrdiff_t __sp = __to_nxt - &__bs[0];
                __bs.resize(2 * __sp);
                __to = &__bs[0] + __sp;
                __to_end = &__bs[0] + __bs.size();
            }
        } while (__r == codecvt_base::partial);
        if (__r == codecvt_base::ok)
            return __bs;
}
    }
    if (__byte_err_string_.empty())
__throw_range_error("wstring_convert: to_bytes error");
    return __byte_err_string_;
}
template <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem>>
class wbuffer_convert
    : public basic_streambuf<_Elem, _Tr>
{
public:
    typedef _Elem char_type;
    typedef _Tr traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef typename _Codecvt::state_type state_type;

private:
    char *__extbuf_;
    const char *__extbufnext_;
    const char *__extbufend_;
    char __extbuf_min_[8];
    size_t __ebs_;
    char_type *__intbuf_;
    size_t __ibs_;
    streambuf *__bufptr_;
    _Codecvt *__cv_;
    state_type __st_;
    ios_base::openmode __cm_;
    bool __owns_eb_;
    bool __owns_ib_;
    bool __always_noconv_;
    wbuffer_convert(const wbuffer_convert &);
    wbuffer_convert &operator=(const wbuffer_convert &);

public:
    wbuffer_convert(streambuf *__bytebuf = __nullptr,
                    _Codecvt *__pcvt = new _Codecvt,
                    state_type __state = state_type());
    ~wbuffer_convert();

    streambuf *rdbuf() const { return __bufptr_; }

    streambuf *rdbuf(streambuf *__bytebuf)
    {
streambuf *__r = __bufptr_;
__bufptr_ = __bytebuf;
return __r;
    }

    state_type state() const { return __st_; }

protected:
    virtual int_type underflow();
    virtual int_type pbackfail(int_type __c = traits_type::eof());
    virtual int_type overflow(int_type __c = traits_type::eof());
    virtual basic_streambuf<char_type, traits_type> *setbuf(char_type *__s,
                                                            streamsize __n);
    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    virtual int sync();

private:
    bool __read_mode();
    void __write_mode();
    wbuffer_convert *__close();
};
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>::
    wbuffer_convert(streambuf *__bytebuf, _Codecvt *__pcvt, state_type __state)
    : __extbuf_(__nullptr),
      __extbufnext_(__nullptr),
      __extbufend_(__nullptr),
      __ebs_(0),
      __intbuf_(0),
      __ibs_(0),
      __bufptr_(__bytebuf),
      __cv_(__pcvt),
      __st_(__state),
      __cm_(0),
      __owns_eb_(false),
      __owns_ib_(false),
      __always_noconv_(__cv_ ? __cv_->always_noconv() : false)
{
    setbuf(0, 4096);
}
template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert()
{
    __close();
    delete __cv_;
    if (__owns_eb_)
delete[] __extbuf_;
    if (__owns_ib_)
delete[] __intbuf_;
}
template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::underflow()
{
#pragma GCC diagnostic pop
    if (__cv_ == 0 || __bufptr_ == 0)
return traits_type::eof();
    bool __initial = __read_mode();
    char_type __1buf;
    if (this->gptr() == 0)
this->setg(&__1buf, &__1buf + 1, &__1buf + 1);
    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);
    int_type __c = traits_type::eof();
    if (this->gptr() == this->egptr())
    {
std::memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));
if (__always_noconv_)
{
        streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);
        __nmemb = __bufptr_->sgetn((char *)this->eback() + __unget_sz, __nmemb);
        if (__nmemb != 0)
        {
            this->setg(this->eback(),
                       this->eback() + __unget_sz,
                       this->eback() + __unget_sz + __nmemb);
            __c = *this->gptr();
        }
}
else
{
        ((void)0);
        if (__extbufend_ != __extbufnext_)
            std::memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);
        __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);
        __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);
        streamsize __nmemb = std::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),
                                      static_cast<streamsize>(__extbufend_ - __extbufnext_));
        codecvt_base::result __r;
        streamsize __nr = __bufptr_->sgetn(const_cast<char *>(__extbufnext_), __nmemb);
        if (__nr != 0)
        {
            __extbufend_ = __extbufnext_ + __nr;
            char_type *__inext;
            __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,
                            this->eback() + __unget_sz,
                            this->egptr(), __inext);
            if (__r == codecvt_base::noconv)
            {
                this->setg((char_type *)__extbuf_, (char_type *)__extbuf_,
                           (char_type *)const_cast<char *>(__extbufend_));
                __c = *this->gptr();
            }
            else if (__inext != this->eback() + __unget_sz)
            {
                this->setg(this->eback(), this->eback() + __unget_sz, __inext);
                __c = *this->gptr();
            }
        }
}
    }
    else
__c = *this->gptr();
    if (this->eback() == &__1buf)
this->setg(0, 0, 0);
    return __c;
}
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c)
{
#pragma GCC diagnostic pop
    if (__cv_ != 0 && __bufptr_ != 0 && this->eback() < this->gptr())
    {
if (traits_type::eq_int_type(__c, traits_type::eof()))
{
        this->gbump(-1);
        return traits_type::not_eof(__c);
}
if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))
{
        this->gbump(-1);
        *this->gptr() = traits_type::to_char_type(__c);
        return __c;
}
    }
    return traits_type::eof();
}
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c)
{
#pragma GCC diagnostic pop
    if (__cv_ == 0 || __bufptr_ == 0)
return traits_type::eof();
    __write_mode();
    char_type __1buf;
    char_type *__pb_save = this->pbase();
    char_type *__epb_save = this->epptr();
    if (!traits_type::eq_int_type(__c, traits_type::eof()))
    {
if (this->pptr() == 0)
        this->setp(&__1buf, &__1buf + 1);
*this->pptr() = traits_type::to_char_type(__c);
this->pbump(1);
    }
    if (this->pptr() != this->pbase())
    {
if (__always_noconv_)
{
        streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());
        if (__bufptr_->sputn((const char *)this->pbase(), __nmemb) != __nmemb)
            return traits_type::eof();
}
else
{
        char *__extbe = __extbuf_;
        codecvt_base::result __r;
        do
        {
            const char_type *__e;
            __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,
                             __extbuf_, __extbuf_ + __ebs_, __extbe);
            if (__e == this->pbase())
                return traits_type::eof();
            if (__r == codecvt_base::noconv)
            {
                streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
                if (__bufptr_->sputn((const char *)this->pbase(), __nmemb) != __nmemb)
                    return traits_type::eof();
            }
            else if (__r == codecvt_base::ok || __r == codecvt_base::partial)
            {
                streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);
                if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
                    return traits_type::eof();
                if (__r == codecvt_base::partial)
                {
                    this->setp(const_cast<char_type *>(__e), this->pptr());
                    this->__pbump(this->epptr() - this->pbase());
                }
            }
            else
                return traits_type::eof();
        } while (__r == codecvt_base::partial);
}
this->setp(__pb_save, __epb_save);
    }
    return traits_type::not_eof(__c);
}
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Codecvt, class _Elem, class _Tr>
basic_streambuf<_Elem, _Tr> *
wbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type *__s, streamsize __n)
{
#pragma GCC diagnostic pop
    this->setg(0, 0, 0);
    this->setp(0, 0);
    if (__owns_eb_)
delete[] __extbuf_;
    if (__owns_ib_)
delete[] __intbuf_;
    __ebs_ = __n;
    if (__ebs_ > sizeof(__extbuf_min_))
    {
if (__always_noconv_ && __s)
{
        __extbuf_ = (char *)__s;
        __owns_eb_ = false;
}
else
{
        __extbuf_ = new char[__ebs_];
        __owns_eb_ = true;
}
    }
    else
    {
__extbuf_ = __extbuf_min_;
__ebs_ = sizeof(__extbuf_min_);
__owns_eb_ = false;
    }
    if (!__always_noconv_)
    {
__ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));
if (__s && __ibs_ >= sizeof(__extbuf_min_))
{
        __intbuf_ = __s;
        __owns_ib_ = false;
}
else
{
        __intbuf_ = new char_type[__ibs_];
        __owns_ib_ = true;
}
    }
    else
    {
__ibs_ = 0;
__intbuf_ = 0;
__owns_ib_ = false;
    }
    return this;
}
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way,
                                               ios_base::openmode __om)
{
    int __width = __cv_->encoding();
    if (__cv_ == 0 || __bufptr_ == 0 || (__width <= 0 && __off != 0) || sync())
return pos_type(off_type(-1));
    if (__way != ios_base::beg && __way != ios_base::cur && __way != ios_base::end)
return pos_type(off_type(-1));
    pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);
    __r.state(__st_);
    return __r;
}
template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch)
{
    if (__cv_ == 0 || __bufptr_ == 0 || sync())
return pos_type(off_type(-1));
    if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))
return pos_type(off_type(-1));
    return __sp;
}
template <class _Codecvt, class _Elem, class _Tr>
int wbuffer_convert<_Codecvt, _Elem, _Tr>::sync()
{
#pragma GCC diagnostic pop
    if (__cv_ == 0 || __bufptr_ == 0)
return 0;
    if (__cm_ & ios_base::out)
    {
if (this->pptr() != this->pbase())
        if (overflow() == traits_type::eof())
            return -1;
codecvt_base::result __r;
do
{
        char *__extbe;
        __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);
        streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);
        if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
            return -1;
} while (__r == codecvt_base::partial);
if (__r == codecvt_base::error)
        return -1;
if (__bufptr_->pubsync())
        return -1;
    }
    else if (__cm_ & ios_base::in)
    {
off_type __c;
if (__always_noconv_)
        __c = this->egptr() - this->gptr();
else
{
        int __width = __cv_->encoding();
        __c = __extbufend_ - __extbufnext_;
        if (__width > 0)
            __c += __width * (this->egptr() - this->gptr());
        else
        {
            if (this->gptr() != this->egptr())
            {
                reverse(this->gptr(), this->egptr());
                codecvt_base::result __r;
                const char_type *__e = this->gptr();
                char *__extbe;
                do
                {
                    __r = __cv_->out(__st_, __e, this->egptr(), __e,
                                     __extbuf_, __extbuf_ + __ebs_, __extbe);
                    switch (__r)
                    {
                    case codecvt_base::noconv:
                        __c += this->egptr() - this->gptr();
                        break;
                    case codecvt_base::ok:
                    case codecvt_base::partial:
                        __c += __extbe - __extbuf_;
                        break;
                    default:
                        return -1;
                    }
                } while (__r == codecvt_base::partial);
            }
        }
}
if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))
        return -1;
this->setg(0, 0, 0);
__cm_ = 0;
    }
    return 0;
}
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Codecvt, class _Elem, class _Tr>
bool wbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode()
{
    if (!(__cm_ & ios_base::in))
    {
this->setp(0, 0);
if (__always_noconv_)
        this->setg((char_type *)__extbuf_,
                   (char_type *)__extbuf_ + __ebs_,
                   (char_type *)__extbuf_ + __ebs_);
else
        this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);
__cm_ = ios_base::in;
return true;
    }
    return false;
}
template <class _Codecvt, class _Elem, class _Tr>
void wbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode()
{
    if (!(__cm_ & ios_base::out))
    {
this->setg(0, 0, 0);
if (__ebs_ > sizeof(__extbuf_min_))
{
        if (__always_noconv_)
            this->setp((char_type *)__extbuf_,
                       (char_type *)__extbuf_ + (__ebs_ - 1));
        else
            this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));
}
else
        this->setp(0, 0);
__cm_ = ios_base::out;
    }
}
template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr> *
wbuffer_convert<_Codecvt, _Elem, _Tr>::__close()
{
    wbuffer_convert *__rt = __nullptr;
    if (__cv_ != __nullptr && __bufptr_ != __nullptr)
    {
__rt = this;
if ((__cm_ & ios_base::out) && sync())
        __rt = __nullptr;
    }
    return __rt;
}
#pragma GCC diagnostic pop
}
}
namespace std
{
    inline namespace __1
    {
template <class _CharT, class _Traits>
class basic_ostream
    : virtual public basic_ios<_CharT, _Traits>
{
    public:
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        inline explicit basic_ostream(basic_streambuf<char_type, traits_type> *__sb)
        {
            this->init(__sb);
        }
        virtual ~basic_ostream();

    protected:
        inline basic_ostream(basic_ostream &&__rhs);
        inline basic_ostream &operator=(basic_ostream &&__rhs);
        inline void swap(basic_ostream &__rhs)
        {
            basic_ios<char_type, traits_type>::swap(__rhs);
        }
        basic_ostream(const basic_ostream &__rhs) = delete;
        basic_ostream &operator=(const basic_ostream &__rhs) = delete;

    public:
        class sentry;
        inline basic_ostream &operator<<(basic_ostream &(*__pf)(basic_ostream &))
        {
            return __pf(*this);
        }
        inline basic_ostream &operator<<(basic_ios<char_type, traits_type> &(*__pf)(basic_ios<char_type, traits_type> &))
        {
            __pf(*this);
            return *this;
        }
        inline basic_ostream &operator<<(ios_base &(*__pf)(ios_base &))
        {
            __pf(*this);
            return *this;
        }
        basic_ostream &operator<<(bool __n);
        basic_ostream &operator<<(short __n);
        basic_ostream &operator<<(unsigned short __n);
        basic_ostream &operator<<(int __n);
        basic_ostream &operator<<(unsigned int __n);
        basic_ostream &operator<<(long __n);
        basic_ostream &operator<<(unsigned long __n);
        basic_ostream &operator<<(long long __n);
        basic_ostream &operator<<(unsigned long long __n);
        basic_ostream &operator<<(float __f);
        basic_ostream &operator<<(double __f);
        basic_ostream &operator<<(long double __f);
        basic_ostream &operator<<(const void *__p);
        basic_ostream &operator<<(basic_streambuf<char_type, traits_type> *__sb);
        basic_ostream &put(char_type __c);
        basic_ostream &write(const char_type *__s, streamsize __n);
        basic_ostream &flush();
        inline pos_type tellp();
        inline basic_ostream &seekp(pos_type __pos);
        inline basic_ostream &seekp(off_type __off, ios_base::seekdir __dir);

    protected:
        basic_ostream() {}
};
template <class _CharT, class _Traits>
class basic_ostream<_CharT, _Traits>::sentry
{
        bool __ok_;
        basic_ostream<_CharT, _Traits> &__os_;

    public:
        explicit sentry(basic_ostream<_CharT, _Traits> &__os);
        ~sentry();
        sentry(const sentry &) = delete;
        sentry &operator=(const sentry &) = delete;

        explicit operator bool() const { return __ok_; }
};
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits> &__os)
    : __ok_(false),
      __os_(__os)
{
        if (__os.good())
        {
            if (__os.tie())
                __os.tie()->flush();
            __ok_ = true;
        }
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::sentry::~sentry()
{
        if (__os_.rdbuf() && __os_.good() && (__os_.flags() & ios_base::unitbuf) && !uncaught_exception())
        {
            try
            {
                if (__os_.rdbuf()->pubsync() == -1)
                    __os_.setstate(ios_base::badbit);
            }
            catch (...)
            {
            }
        }
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::basic_ostream(basic_ostream &&__rhs)
{
        this->move(__rhs);
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
basic_ostream<_CharT, _Traits>::operator=(basic_ostream &&__rhs)
{
        swap(__rhs);
        return *this;
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::~basic_ostream()
{
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
basic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<char_type, traits_type> *__sb)
{
        try
        {
            sentry __s(*this);
            if (__s)
            {
                if (__sb)
                {
                    try
                    {
                        typedef istreambuf_iterator<_CharT, _Traits> _Ip;
                        typedef ostreambuf_iterator<_CharT, _Traits> _Op;
                        _Ip __i(__sb);
                        _Ip __eof;
                        _Op __o(*this);
                        size_t __c = 0;
                        for (; __i != __eof; ++__i, ++__o, ++__c)
                        {
                            *__o = *__i;
                            if (__o.failed())
                                break;
                        }
                        if (__c == 0)
                            this->setstate(ios_base::failbit);
                    }
                    catch (...)
                    {
                        this->__set_failbit_and_consider_rethrow();
                    }
                }
                else
                    this->setstate(ios_base::badbit);
            }
        }
        catch (...)
        {
            this->__set_badbit_and_consider_rethrow();
        }
        return *this;
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
basic_ostream<_CharT, _Traits>::operator<<(bool __n)
{
        try
        {
            sentry __s(*this);
            if (__s)
            {
                typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>> _Fp;
                const _Fp &__f = use_facet<_Fp>(this->getloc());
                if (__f.put(*this, *this, this->fill(), __n).failed())
                    this->setstate(ios_base::badbit | ios_base::failbit);
            }
        }
        catch (...)
        {
            this->__set_badbit_and_consider_rethrow();
        }
        return *this;
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
basic_ostream<_CharT, _Traits>::operator<<(short __n)
{
        try
        {
            sentry __s(*this);
            if (__s)
            {
                ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
                typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>> _Fp;
                const _Fp &__f = use_facet<_Fp>(this->getloc());
                if (__f.put(*this, *this, this->fill(),
                            __flags == ios_base::oct || __flags == ios_base::hex ? static_cast<long>(static_cast<unsigned short>(__n)) : static_cast<long>(__n))
                        .failed())
                    this->setstate(ios_base::badbit | ios_base::failbit);
            }
        }
        catch (...)
        {
            this->__set_badbit_and_consider_rethrow();
        }
        return *this;
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
basic_ostream<_CharT, _Traits>::operator<<(unsigned short __n)
{
        try
        {
            sentry __s(*this);
            if (__s)
            {
                typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>> _Fp;
                const _Fp &__f = use_facet<_Fp>(this->getloc());
                if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
                    this->setstate(ios_base::badbit | ios_base::failbit);
            }
        }
        catch (...)
        {
            this->__set_badbit_and_consider_rethrow();
        }
        return *this;
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
basic_ostream<_CharT, _Traits>::operator<<(int __n)
{
        try
        {
            sentry __s(*this);
            if (__s)
            {
                ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
                typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>> _Fp;
                const _Fp &__f = use_facet<_Fp>(this->getloc());
                if (__f.put(*this, *this, this->fill(),
                            __flags == ios_base::oct || __flags == ios_base::hex ? static_cast<long>(static_cast<unsigned int>(__n)) : static_cast<long>(__n))
                        .failed())
                    this->setstate(ios_base::badbit | ios_base::failbit);
            }
        }
        catch (...)
        {
            this->__set_badbit_and_consider_rethrow();
        }
        return *this;
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
basic_ostream<_CharT, _Traits>::operator<<(unsigned int __n)
{
        try
        {
            sentry __s(*this);
            if (__s)
            {
                typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>> _Fp;
                const _Fp &__f = use_facet<_Fp>(this->getloc());
                if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
                    this->setstate(ios_base::badbit | ios_base::failbit);
            }
        }
        catch (...)
        {
            this->__set_badbit_and_consider_rethrow();
        }
        return *this;
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
basic_ostream<_CharT, _Traits>::operator<<(long __n)
{
        try
        {
            sentry __s(*this);
            if (__s)
            {
                typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>> _Fp;
                const _Fp &__f = use_facet<_Fp>(this->getloc());
                if (__f.put(*this, *this, this->fill(), __n).failed())
                    this->setstate(ios_base::badbit | ios_base::failbit);
            }
        }
        catch (...)
        {
            this->__set_badbit_and_consider_rethrow();
        }
        return *this;
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
basic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)
{
        try
        {
            sentry __s(*this);
            if (__s)
            {
                typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>> _Fp;
                const _Fp &__f = use_facet<_Fp>(this->getloc());
                if (__f.put(*this, *this, this->fill(), __n).failed())
                    this->setstate(ios_base::badbit | ios_base::failbit);
            }
        }
        catch (...)
        {
            this->__set_badbit_and_consider_rethrow();
        }
        return *this;
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
basic_ostream<_CharT, _Traits>::operator<<(long long __n)
{
        try
        {
            sentry __s(*this);
            if (__s)
            {
                typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>> _Fp;
                const _Fp &__f = use_facet<_Fp>(this->getloc());
                if (__f.put(*this, *this, this->fill(), __n).failed())
                    this->setstate(ios_base::badbit | ios_base::failbit);
            }
        }
        catch (...)
        {
            this->__set_badbit_and_consider_rethrow();
        }
        return *this;
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
basic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)
{
        try
        {
            sentry __s(*this);
            if (__s)
            {
                typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>> _Fp;
                const _Fp &__f = use_facet<_Fp>(this->getloc());
                if (__f.put(*this, *this, this->fill(), __n).failed())
                    this->setstate(ios_base::badbit | ios_base::failbit);
            }
        }
        catch (...)
        {
            this->__set_badbit_and_consider_rethrow();
        }
        return *this;
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
basic_ostream<_CharT, _Traits>::operator<<(float __n)
{
        try
        {
            sentry __s(*this);
            if (__s)
            {
                typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>> _Fp;
                const _Fp &__f = use_facet<_Fp>(this->getloc());
                if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())
                    this->setstate(ios_base::badbit | ios_base::failbit);
            }
        }
        catch (...)
        {
            this->__set_badbit_and_consider_rethrow();
        }
        return *this;
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
basic_ostream<_CharT, _Traits>::operator<<(double __n)
{
        try
        {
            sentry __s(*this);
            if (__s)
            {
                typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>> _Fp;
                const _Fp &__f = use_facet<_Fp>(this->getloc());
                if (__f.put(*this, *this, this->fill(), __n).failed())
                    this->setstate(ios_base::badbit | ios_base::failbit);
            }
        }
        catch (...)
        {
            this->__set_badbit_and_consider_rethrow();
        }
        return *this;
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
basic_ostream<_CharT, _Traits>::operator<<(long double __n)
{
        try
        {
            sentry __s(*this);
            if (__s)
            {
                typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>> _Fp;
                const _Fp &__f = use_facet<_Fp>(this->getloc());
                if (__f.put(*this, *this, this->fill(), __n).failed())
                    this->setstate(ios_base::badbit | ios_base::failbit);
            }
        }
        catch (...)
        {
            this->__set_badbit_and_consider_rethrow();
        }
        return *this;
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
basic_ostream<_CharT, _Traits>::operator<<(const void *__n)
{
        try
        {
            sentry __s(*this);
            if (__s)
            {
                typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>> _Fp;
                const _Fp &__f = use_facet<_Fp>(this->getloc());
                if (__f.put(*this, *this, this->fill(), __n).failed())
                    this->setstate(ios_base::badbit | ios_base::failbit);
            }
        }
        catch (...)
        {
            this->__set_badbit_and_consider_rethrow();
        }
        return *this;
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
__put_character_sequence(basic_ostream<_CharT, _Traits> &__os,
                         const _CharT *__str, size_t __len)
{
        try
        {
            typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
            if (__s)
            {
                typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
                if (__pad_and_output(_Ip(__os),
                                     __str,
                                     (__os.flags() & ios_base::adjustfield) == ios_base::left ? __str + __len : __str,
                                     __str + __len,
                                     __os,
                                     __os.fill())
                        .failed())
                    __os.setstate(ios_base::badbit | ios_base::failbit);
            }
        }
        catch (...)
        {
            __os.__set_badbit_and_consider_rethrow();
        }
        return __os;
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os, _CharT __c)
{
        return std::__put_character_sequence(__os, &__c, 1);
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os, char __cn)
{
        try
        {
            typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
            if (__s)
            {
                _CharT __c = __os.widen(__cn);
                typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
                if (__pad_and_output(_Ip(__os),
                                     &__c,
                                     (__os.flags() & ios_base::adjustfield) == ios_base::left ? &__c + 1 : &__c,
                                     &__c + 1,
                                     __os,
                                     __os.fill())
                        .failed())
                    __os.setstate(ios_base::badbit | ios_base::failbit);
            }
        }
        catch (...)
        {
            __os.__set_badbit_and_consider_rethrow();
        }
        return __os;
}
template <class _Traits>
basic_ostream<char, _Traits> &
operator<<(basic_ostream<char, _Traits> &__os, char __c)
{
        return std::__put_character_sequence(__os, &__c, 1);
}
template <class _Traits>
basic_ostream<char, _Traits> &
operator<<(basic_ostream<char, _Traits> &__os, signed char __c)
{
        return std::__put_character_sequence(__os, (char *)&__c, 1);
}
template <class _Traits>
basic_ostream<char, _Traits> &
operator<<(basic_ostream<char, _Traits> &__os, unsigned char __c)
{
        return std::__put_character_sequence(__os, (char *)&__c, 1);
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os, const _CharT *__str)
{
        return std::__put_character_sequence(__os, __str, _Traits::length(__str));
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os, const char *__strn)
{
        try
        {
            typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
            if (__s)
            {
                typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
                size_t __len = char_traits<char>::length(__strn);
                const int __bs = 100;
                _CharT __wbb[__bs];
                _CharT *__wb = __wbb;
                unique_ptr<_CharT, void (*)(void *)> __h(0, free);
                if (__len > __bs)
                {
                    __wb = (_CharT *)malloc(__len * sizeof(_CharT));
                    if (__wb == 0)
                        __throw_bad_alloc();
                    __h.reset(__wb);
                }
                for (_CharT *__p = __wb; *__strn != '\0'; ++__strn, ++__p)
                    *__p = __os.widen(*__strn);
                if (__pad_and_output(_Ip(__os),
                                     __wb,
                                     (__os.flags() & ios_base::adjustfield) == ios_base::left ? __wb + __len : __wb,
                                     __wb + __len,
                                     __os,
                                     __os.fill())
                        .failed())
                    __os.setstate(ios_base::badbit | ios_base::failbit);
            }
        }
        catch (...)
        {
            __os.__set_badbit_and_consider_rethrow();
        }
        return __os;
}
template <class _Traits>
basic_ostream<char, _Traits> &
operator<<(basic_ostream<char, _Traits> &__os, const char *__str)
{
        return std::__put_character_sequence(__os, __str, _Traits::length(__str));
}
template <class _Traits>
basic_ostream<char, _Traits> &
operator<<(basic_ostream<char, _Traits> &__os, const signed char *__str)
{
        const char *__s = (const char *)__str;
        return std::__put_character_sequence(__os, __s, _Traits::length(__s));
}
template <class _Traits>
basic_ostream<char, _Traits> &
operator<<(basic_ostream<char, _Traits> &__os, const unsigned char *__str)
{
        const char *__s = (const char *)__str;
        return std::__put_character_sequence(__os, __s, _Traits::length(__s));
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
basic_ostream<_CharT, _Traits>::put(char_type __c)
{
        try
        {
            sentry __s(*this);
            if (__s)
            {
                typedef ostreambuf_iterator<_CharT, _Traits> _Op;
                _Op __o(*this);
                *__o = __c;
                if (__o.failed())
                    this->setstate(ios_base::badbit);
            }
        }
        catch (...)
        {
            this->__set_badbit_and_consider_rethrow();
        }
        return *this;
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
basic_ostream<_CharT, _Traits>::write(const char_type *__s, streamsize __n)
{
        try
        {
            sentry __sen(*this);
            if (__sen && __n)
            {
                if (this->rdbuf()->sputn(__s, __n) != __n)
                    this->setstate(ios_base::badbit);
            }
        }
        catch (...)
        {
            this->__set_badbit_and_consider_rethrow();
        }
        return *this;
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
basic_ostream<_CharT, _Traits>::flush()
{
        try
        {
            if (this->rdbuf())
            {
                sentry __s(*this);
                if (__s)
                {
                    if (this->rdbuf()->pubsync() == -1)
                        this->setstate(ios_base::badbit);
                }
            }
        }
        catch (...)
        {
            this->__set_badbit_and_consider_rethrow();
        }
        return *this;
}
template <class _CharT, class _Traits>
typename basic_ostream<_CharT, _Traits>::pos_type
basic_ostream<_CharT, _Traits>::tellp()
{
        if (this->fail())
            return pos_type(-1);
        return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
basic_ostream<_CharT, _Traits>::seekp(pos_type __pos)
{
        sentry __s(*this);
        if (!this->fail())
        {
            if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))
                this->setstate(ios_base::failbit);
        }
        return *this;
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
basic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir)
{
        sentry __s(*this);
        if (!this->fail())
        {
            if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))
                this->setstate(ios_base::failbit);
        }
        return *this;
}
template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits> &
endl(basic_ostream<_CharT, _Traits> &__os)
{
        __os.put(__os.widen('\n'));
        __os.flush();
        return __os;
}
template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits> &
ends(basic_ostream<_CharT, _Traits> &__os)
{
        __os.put(_CharT());
        return __os;
}
template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits> &
flush(basic_ostream<_CharT, _Traits> &__os)
{
        __os.flush();
        return __os;
}
template <class _Stream, class _Tp, class = void>
struct __is_ostreamable : false_type
{
};
template <class _Stream, class _Tp>
struct __is_ostreamable<_Stream, _Tp, __decltype(declval<_Stream>() << declval<_Tp>(), void())> : true_type
{
};
template <class _Stream, class _Tp, class = typename enable_if<_And<is_base_of<ios_base, _Stream>, __is_ostreamable<_Stream &, const _Tp &>>::value>::type>

_Stream &&operator<<(_Stream &&__os, const _Tp &__x)
{
        __os << __x;
        return std::move(__os);
}
template <class _CharT, class _Traits, class _Allocator>
basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os,
           const basic_string<_CharT, _Traits, _Allocator> &__str)
{
        return std::__put_character_sequence(__os, __str.data(), __str.size());
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os,
           basic_string_view<_CharT, _Traits> __sv)
{
        return std::__put_character_sequence(__os, __sv.data(), __sv.size());
}
template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os, const error_code &__ec)
{
        return __os << __ec.category().name() << ':' << __ec.value();
}
template <class _CharT, class _Traits, class _Yp>
inline basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os, shared_ptr<_Yp> const &__p)
{
        return __os << __p.get();
}
template <class _CharT, class _Traits, class _Yp, class _Dp>
inline
    typename enable_if<
        is_same<void, typename __void_t<__decltype((declval<basic_ostream<_CharT, _Traits> &>() << declval<typename unique_ptr<_Yp, _Dp>::pointer>()))>::type>::value,
        basic_ostream<_CharT, _Traits> &>::type
    operator<<(basic_ostream<_CharT, _Traits> &__os, unique_ptr<_Yp, _Dp> const &__p)
{
        return __os << __p.get();
}
template <class _CharT, class _Traits, size_t _Size>
basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os, const bitset<_Size> &__x)
{
        return __os << __x.template to_string<_CharT, _Traits>(use_facet<ctype<_CharT>>(__os.getloc()).widen('0'),
                                                               use_facet<ctype<_CharT>>(__os.getloc()).widen('1'));
}
extern template class basic_ostream<char>;
extern template class basic_ostream<wchar_t>;
    }
}
namespace boost
{
    namespace date_time
    {
template <typename int_type_>
class int_adapter
{
    public:
        typedef int_type_ int_type;
        int_adapter(int_type v) : value_(v)
        {
        }
        static bool has_infinity()
        {
            return true;
        }
        static int_adapter pos_infinity()
        {
            return (::std::numeric_limits<int_type>::max)();
        }
        static int_adapter neg_infinity()
        {
            return (::std::numeric_limits<int_type>::min)();
        }
        static int_adapter not_a_number()
        {
            return (::std::numeric_limits<int_type>::max)() - 1;
        }
        static int_adapter max()
        {
            return (::std::numeric_limits<int_type>::max)() - 2;
        }
        static int_adapter min()
        {
            return (::std::numeric_limits<int_type>::min)() + 1;
        }
        static int_adapter from_special(special_values sv)
        {
            switch (sv)
            {
            case not_a_date_time:
                return not_a_number();
            case neg_infin:
                return neg_infinity();
            case pos_infin:
                return pos_infinity();
            case max_date_time:
                return (max)();
            case min_date_time:
                return (min)();
            default:
                return not_a_number();
            }
        }
        static bool is_inf(int_type v)
        {
            return (v == neg_infinity().as_number() ||
                    v == pos_infinity().as_number());
        }
        static bool is_neg_inf(int_type v)
        {
            return (v == neg_infinity().as_number());
        }
        static bool is_pos_inf(int_type v)
        {
            return (v == pos_infinity().as_number());
        }
        static bool is_not_a_number(int_type v)
        {
            return (v == not_a_number().as_number());
        }
        static special_values to_special(int_type v)
        {
            if (is_not_a_number(v))
                return not_a_date_time;
            if (is_neg_inf(v))
                return neg_infin;
            if (is_pos_inf(v))
                return pos_infin;
            return not_special;
        }
        static int_type maxcount()
        {
            return (::std::numeric_limits<int_type>::max)() - 3;
        }
        bool is_infinity() const
        {
            return (value_ == neg_infinity().as_number() ||
                    value_ == pos_infinity().as_number());
        }
        bool is_pos_infinity() const
        {
            return (value_ == pos_infinity().as_number());
        }
        bool is_neg_infinity() const
        {
            return (value_ == neg_infinity().as_number());
        }
        bool is_nan() const
        {
            return (value_ == not_a_number().as_number());
        }
        bool is_special() const
        {
            return (is_infinity() || is_nan());
        }
        bool operator==(const int_adapter &rhs) const
        {
            return (compare(rhs) == 0);
        }
        bool operator==(const int &rhs) const
        {
            if (!std::numeric_limits<int_type>::is_signed)
            {
                if (is_neg_inf(value_) && rhs == 0)
                {
                    return false;
                }
            }
            return (compare(rhs) == 0);
        }
        bool operator!=(const int_adapter &rhs) const
        {
            return (compare(rhs) != 0);
        }
        bool operator!=(const int &rhs) const
        {
            if (!std::numeric_limits<int_type>::is_signed)
            {
                if (is_neg_inf(value_) && rhs == 0)
                {
                    return true;
                }
            }
            return (compare(rhs) != 0);
        }
        bool operator<(const int_adapter &rhs) const
        {
            return (compare(rhs) == -1);
        }
        bool operator<(const int &rhs) const
        {
            if (!std::numeric_limits<int_type>::is_signed)
            {
                if (is_neg_inf(value_) && rhs == 0)
                {
                    return true;
                }
            }
            return (compare(rhs) == -1);
        }
        bool operator>(const int_adapter &rhs) const
        {
            return (compare(rhs) == 1);
        }
        int_type as_number() const
        {
            return value_;
        }
        special_values as_special() const
        {
            return int_adapter::to_special(value_);
        }
        template <class rhs_type>
        int_adapter operator+(const int_adapter<rhs_type> &rhs) const
        {
            if (is_special() || rhs.is_special())
            {
                if (is_nan() || rhs.is_nan())
                {
                    return int_adapter::not_a_number();
                }
                if ((is_pos_inf(value_) && rhs.is_neg_inf(rhs.as_number())) ||
                    (is_neg_inf(value_) && rhs.is_pos_inf(rhs.as_number())))
                {
                    return int_adapter::not_a_number();
                }
                if (is_infinity())
                {
                    return *this;
                }
                if (rhs.is_pos_inf(rhs.as_number()))
                {
                    return int_adapter::pos_infinity();
                }
                if (rhs.is_neg_inf(rhs.as_number()))
                {
                    return int_adapter::neg_infinity();
                }
            }
            return int_adapter<int_type>(value_ + static_cast<int_type>(rhs.as_number()));
        }
        int_adapter operator+(const int_type rhs) const
        {
            if (is_special())
            {
                if (is_nan())
                {
                    return int_adapter<int_type>(not_a_number());
                }
                if (is_infinity())
                {
                    return *this;
                }
            }
            return int_adapter<int_type>(value_ + rhs);
        }
        template <class rhs_type>
        int_adapter operator-(const int_adapter<rhs_type> &rhs) const
        {
            if (is_special() || rhs.is_special())
            {
                if (is_nan() || rhs.is_nan())
                {
                    return int_adapter::not_a_number();
                }
                if ((is_pos_inf(value_) && rhs.is_pos_inf(rhs.as_number())) ||
                    (is_neg_inf(value_) && rhs.is_neg_inf(rhs.as_number())))
                {
                    return int_adapter::not_a_number();
                }
                if (is_infinity())
                {
                    return *this;
                }
                if (rhs.is_pos_inf(rhs.as_number()))
                {
                    return int_adapter::neg_infinity();
                }
                if (rhs.is_neg_inf(rhs.as_number()))
                {
                    return int_adapter::pos_infinity();
                }
            }
            return int_adapter<int_type>(value_ - static_cast<int_type>(rhs.as_number()));
        }
        int_adapter operator-(const int_type rhs) const
        {
            if (is_special())
            {
                if (is_nan())
                {
                    return int_adapter<int_type>(not_a_number());
                }
                if (is_infinity())
                {
                    return *this;
                }
            }
            return int_adapter<int_type>(value_ - rhs);
        }
        int_adapter operator*(const int_adapter &rhs) const
        {
            if (this->is_special() || rhs.is_special())
            {
                return mult_div_specials(rhs);
            }
            return int_adapter<int_type>(value_ * rhs.value_);
        }
        int_adapter operator*(const int rhs) const
        {
            if (is_special())
            {
                return mult_div_specials(rhs);
            }
            return int_adapter<int_type>(value_ * rhs);
        }
        int_adapter operator/(const int_adapter &rhs) const
        {
            if (this->is_special() || rhs.is_special())
            {
                if (is_infinity() && rhs.is_infinity())
                {
                    return int_adapter<int_type>(not_a_number());
                }
                if (rhs != 0)
                {
                    return mult_div_specials(rhs);
                }
                else
                {
                    return int_adapter<int_type>(value_ / rhs.value_);
                }
            }
            return int_adapter<int_type>(value_ / rhs.value_);
        }
        int_adapter operator/(const int rhs) const
        {
            if (is_special() && rhs != 0)
            {
                return mult_div_specials(rhs);
            }
            return int_adapter<int_type>(value_ / rhs);
        }
        int_adapter operator%(const int_adapter &rhs) const
        {
            if (this->is_special() || rhs.is_special())
            {
                if (is_infinity() && rhs.is_infinity())
                {
                    return int_adapter<int_type>(not_a_number());
                }
                if (rhs != 0)
                {
                    return mult_div_specials(rhs);
                }
                else
                {
                    return int_adapter<int_type>(value_ % rhs.value_);
                }
            }
            return int_adapter<int_type>(value_ % rhs.value_);
        }
        int_adapter operator%(const int rhs) const
        {
            if (is_special() && rhs != 0)
            {
                return mult_div_specials(rhs);
            }
            return int_adapter<int_type>(value_ % rhs);
        }

    private:
        int_type value_;
        int compare(const int_adapter &rhs) const
        {
            if (this->is_special() || rhs.is_special())
            {
                if (this->is_nan() || rhs.is_nan())
                {
                    if (this->is_nan() && rhs.is_nan())
                    {
                        return 0;
                    }
                    else
                    {
                        return 2;
                    }
                }
                if ((is_neg_inf(value_) && !is_neg_inf(rhs.value_)) ||
                    (is_pos_inf(rhs.value_) && !is_pos_inf(value_)))
                {
                    return -1;
                }
                if ((is_pos_inf(value_) && !is_pos_inf(rhs.value_)) ||
                    (is_neg_inf(rhs.value_) && !is_neg_inf(value_)))
                {
                    return 1;
                }
            }
            if (value_ < rhs.value_)
                return -1;
            if (value_ > rhs.value_)
                return 1;
            return 0;
        }
        int_adapter mult_div_specials(const int_adapter &rhs) const
        {
            if (this->is_nan() || rhs.is_nan())
            {
                return int_adapter<int_type>(not_a_number());
            }
            const int min_value = std::numeric_limits<int_type>::is_signed ? 0 : 1;
            if ((*this > 0 && rhs > 0) || (*this < min_value && rhs < min_value))
            {
                return int_adapter<int_type>(pos_infinity());
            }
            if ((*this > 0 && rhs < min_value) || (*this < min_value && rhs > 0))
            {
                return int_adapter<int_type>(neg_infinity());
            }
            return int_adapter<int_type>(not_a_number());
        }
        int_adapter mult_div_specials(const int &rhs) const
        {
            if (this->is_nan())
            {
                return int_adapter<int_type>(not_a_number());
            }
            const int min_value = std::numeric_limits<int_type>::is_signed ? 0 : 1;
            if ((*this > 0 && rhs > 0) || (*this < min_value && rhs < 0))
            {
                return int_adapter<int_type>(pos_infinity());
            }
            if ((*this > 0 && rhs < 0) || (*this < min_value && rhs > 0))
            {
                return int_adapter<int_type>(neg_infinity());
            }
            return int_adapter<int_type>(not_a_number());
        }
};
template <class charT, class traits, typename int_type>
inline std::basic_ostream<charT, traits> &
operator<<(std::basic_ostream<charT, traits> &os, const int_adapter<int_type> &ia)
{
        if (ia.is_special())
        {
            switch (ia.as_special())
            {
            case not_a_date_time:
                os << "not-a-number";
                break;
            case pos_infin:
                os << "+infinity";
                break;
            case neg_infin:
                os << "-infinity";
                break;
            default:
                os << "";
            }
        }
        else
        {
            os << ia.as_number();
        }
        return os;
}
    }
}

namespace boost
{
    namespace gregorian
    {
typedef date_time::int_adapter<uint32_t> fancy_date_rep;
class gregorian_calendar : public date_time::gregorian_calendar_base<greg_year_month_day, fancy_date_rep::int_type> //FIXME:public base
{
    public:
        typedef greg_weekday day_of_week_type;
        typedef greg_day_of_year_rep day_of_year_type;
        typedef fancy_date_rep date_rep_type;
        typedef fancy_date_rep date_traits_type;

    private:
};
    }
}
namespace boost
{
    namespace date_time
    {
template <class duration_rep_traits>
class date_duration : private boost::less_than_comparable1<date_duration<duration_rep_traits>, boost::equality_comparable1<date_duration<duration_rep_traits>, boost::addable1<date_duration<duration_rep_traits>, boost::subtractable1<date_duration<duration_rep_traits>, boost::dividable2<date_duration<duration_rep_traits>, int>>>>>
{
    public:
        typedef typename duration_rep_traits::int_type duration_rep_type;
        typedef typename duration_rep_traits::impl_type duration_rep;
        explicit date_duration(duration_rep day_count) : days_(day_count) {}
        date_duration(special_values sv) : days_(duration_rep::from_special(sv))
        {
        }
        duration_rep get_rep() const
        {
            return days_;
        }
        special_values as_special() const
        {
            return days_.as_special();
        }
        bool is_special() const
        {
            return days_.is_special();
        }
        duration_rep_type days() const
        {
            return duration_rep_traits::as_number(days_);
        }
        static date_duration unit()
        {
            return date_duration<duration_rep_traits>(1);
        }
        bool operator==(const date_duration &rhs) const
        {
            return days_ == rhs.days_;
        }
        bool operator<(const date_duration &rhs) const
        {
            return days_ < rhs.days_;
        }
        date_duration &operator-=(const date_duration &rhs)
        {
            days_ = days_ - rhs.days_;
            return *this;
        }
        date_duration &operator+=(const date_duration &rhs)
        {
            days_ = days_ + rhs.days_;
            return *this;
        }
        date_duration operator-() const
        {
            return date_duration<duration_rep_traits>(get_rep() * (-1));
        }
        date_duration &operator/=(int divisor)
        {
            days_ = days_ / divisor;
            return *this;
        }
        bool is_negative() const
        {
            return days_ < 0;
        }

    private:
        duration_rep days_;
};
struct duration_traits_long
{
        typedef long int_type;
        typedef long impl_type;
        static int_type as_number(impl_type i) { return i; }
};
struct duration_traits_adapted
{
        typedef long int_type;
        typedef boost::date_time::int_adapter<long> impl_type;
        static int_type as_number(impl_type i) { return i.as_number(); }
};
    }
}
namespace boost
{
    namespace gregorian
    {
typedef boost::date_time::duration_traits_adapted date_duration_rep;
class date_duration : public boost::date_time::date_duration<date_duration_rep>
{
        typedef boost::date_time::date_duration<date_duration_rep> base_type;

    public:
        typedef base_type::duration_rep duration_rep;
        explicit date_duration(duration_rep day_count = 0) : base_type(day_count) {}
        date_duration(date_time::special_values sv) : base_type(sv) {}
        date_duration(const base_type &other) : base_type(other)
        {
        }
        bool operator==(const date_duration &rhs) const
        {
            return base_type::operator==(rhs);
        }
        bool operator!=(const date_duration &rhs) const
        {
            return !operator==(rhs);
        }
        bool operator<(const date_duration &rhs) const
        {
            return base_type::operator<(rhs);
        }
        bool operator>(const date_duration &rhs) const
        {
            return !(base_type::operator<(rhs) || base_type::operator==(rhs));
        }
        bool operator<=(const date_duration &rhs) const
        {
            return (base_type::operator<(rhs) || base_type::operator==(rhs));
        }
        bool operator>=(const date_duration &rhs) const
        {
            return !base_type::operator<(rhs);
        }
        date_duration &operator-=(const date_duration &rhs)
        {
            base_type::operator-=(rhs);
            return *this;
        }
        friend date_duration operator-(date_duration rhs, date_duration const &lhs);
        date_duration &operator+=(const date_duration &rhs)
        {
            base_type::operator+=(rhs);
            return *this;
        }
        friend date_duration operator+(date_duration rhs, date_duration const &lhs);
        date_duration operator-() const
        {
            return date_duration(get_rep() * (-1));
        }
        date_duration &operator/=(int divisor)
        {
            base_type::operator/=(divisor);
            return *this;
        }
        friend date_duration operator/(date_duration rhs, int lhs);
        static date_duration unit()
        {
            return date_duration(base_type::unit().get_rep());
        }
};
inline date_duration operator-(date_duration rhs, date_duration const &lhs)
{
        rhs -= lhs;
        return rhs;
}
inline date_duration operator+(date_duration rhs, date_duration const &lhs)
{
        rhs += lhs;
        return rhs;
}
inline date_duration operator/(date_duration rhs, int lhs)
{
        rhs /= lhs;
        return rhs;
}
typedef date_duration days;
    }
}
namespace boost
{
    namespace date_time
    {
template <class duration_config>
class weeks_duration : public date_duration<duration_config>
{
    public:
        weeks_duration(typename duration_config::impl_type w)
            : date_duration<duration_config>(w * 7) {}
        weeks_duration(special_values sv)
            : date_duration<duration_config>(sv) {}
};
template <class t>
class years_duration;
template <class base_config>
class months_duration
{
    private:
        typedef typename base_config::int_rep int_rep;
        typedef typename int_rep::int_type int_type;
        typedef typename base_config::date_type date_type;
        typedef typename date_type::duration_type duration_type;
        typedef typename base_config::month_adjustor_type month_adjustor_type;
        typedef months_duration<base_config> months_type;
        typedef years_duration<base_config> years_type;

    public:
        months_duration(int_rep num) : _m(num) {}
        months_duration(special_values sv) : _m(sv)
        {
            _m = int_rep::from_special(sv);
        }
        int_rep number_of_months() const { return _m; }
        duration_type get_neg_offset(const date_type &d) const
        {
            month_adjustor_type m_adj(_m.as_number());
            return duration_type(m_adj.get_neg_offset(d));
        }
        duration_type get_offset(const date_type &d) const
        {
            month_adjustor_type m_adj(_m.as_number());
            return duration_type(m_adj.get_offset(d));
        }
        bool operator==(const months_type &rhs) const
        {
            return (_m == rhs._m);
        }
        bool operator!=(const months_type &rhs) const
        {
            return (_m != rhs._m);
        }
        months_type operator+(const months_type &rhs) const
        {
            return months_type(_m + rhs._m);
        }
        months_type &operator+=(const months_type &rhs)
        {
            _m = _m + rhs._m;
            return *this;
        }
        months_type operator-(const months_type &rhs) const
        {
            return months_type(_m - rhs._m);
        }
        months_type &operator-=(const months_type &rhs)
        {
            _m = _m - rhs._m;
            return *this;
        }
        months_type operator*(const int_type rhs) const
        {
            return months_type(_m * rhs);
        }
        months_type &operator*=(const int_type rhs)
        {
            _m = _m * rhs;
            return *this;
        }
        months_type operator/(const int_type rhs) const
        {
            return months_type(_m / rhs);
        }
        months_type &operator/=(const int_type rhs)
        {
            _m = _m / rhs;
            return *this;
        }
        months_type operator+(const years_type &y) const
        {
            return months_type(y.number_of_years() * 12 + _m);
        }
        months_type &operator+=(const years_type &y)
        {
            _m = y.number_of_years() * 12 + _m;
            return *this;
        }
        months_type operator-(const years_type &y) const
        {
            return months_type(_m - y.number_of_years() * 12);
        }
        months_type &operator-=(const years_type &y)
        {
            _m = _m - y.number_of_years() * 12;
            return *this;
        }
        friend date_type operator+(const date_type &d, const months_type &m)
        {
            return d + m.get_offset(d);
        }
        friend date_type operator+=(date_type &d, const months_type &m)
        {
            return d += m.get_offset(d);
        }
        friend date_type operator-(const date_type &d, const months_type &m)
        {
            return d + m.get_neg_offset(d);
        }
        friend date_type operator-=(date_type &d, const months_type &m)
        {
            return d += m.get_neg_offset(d);
        }

    private:
        int_rep _m;
};
template <class base_config>
class years_duration
{
    private:
        typedef typename base_config::int_rep int_rep;
        typedef typename int_rep::int_type int_type;
        typedef typename base_config::date_type date_type;
        typedef typename date_type::duration_type duration_type;
        typedef typename base_config::month_adjustor_type month_adjustor_type;
        typedef years_duration<base_config> years_type;
        typedef months_duration<base_config> months_type;

    public:
        years_duration(int_rep num) : _y(num) {}
        years_duration(special_values sv) : _y(sv)
        {
            _y = int_rep::from_special(sv);
        }
        int_rep number_of_years() const { return _y; }
        duration_type get_neg_offset(const date_type &d) const
        {
            month_adjustor_type m_adj(_y.as_number() * 12);
            return duration_type(m_adj.get_neg_offset(d));
        }
        duration_type get_offset(const date_type &d) const
        {
            month_adjustor_type m_adj(_y.as_number() * 12);
            return duration_type(m_adj.get_offset(d));
        }
        bool operator==(const years_type &rhs) const
        {
            return (_y == rhs._y);
        }
        bool operator!=(const years_type &rhs) const
        {
            return (_y != rhs._y);
        }
        years_type operator+(const years_type &rhs) const
        {
            return years_type(_y + rhs._y);
        }
        years_type &operator+=(const years_type &rhs)
        {
            _y = _y + rhs._y;
            return *this;
        }
        years_type operator-(const years_type &rhs) const
        {
            return years_type(_y - rhs._y);
        }
        years_type &operator-=(const years_type &rhs)
        {
            _y = _y - rhs._y;
            return *this;
        }
        years_type operator*(const int_type rhs) const
        {
            return years_type(_y * rhs);
        }
        years_type &operator*=(const int_type rhs)
        {
            _y = _y * rhs;
            return *this;
        }
        years_type operator/(const int_type rhs) const
        {
            return years_type(_y / rhs);
        }
        years_type &operator/=(const int_type rhs)
        {
            _y = _y / rhs;
            return *this;
        }
        months_type operator+(const months_type &m) const
        {
            return (months_type(_y * 12 + m.number_of_months()));
        }
        months_type operator-(const months_type &m) const
        {
            return (months_type(_y * 12 - m.number_of_months()));
        }
        friend date_type operator+(const date_type &d, const years_type &y)
        {
            return d + y.get_offset(d);
        }
        friend date_type operator+=(date_type &d, const years_type &y)
        {
            return d += y.get_offset(d);
        }
        friend date_type operator-(const date_type &d, const years_type &y)
        {
            return d + y.get_neg_offset(d);
        }
        friend date_type operator-=(date_type &d, const years_type &y)
        {
            return d += y.get_neg_offset(d);
        }

    private:
        int_rep _y;
};
    }
}

namespace boost
{
    namespace gregorian
    {
using date_time::max_date_time;
using date_time::min_date_time;
using date_time::neg_infin;
using date_time::not_a_date_time;
using date_time::not_special;
using date_time::pos_infin;
using date_time::special_values;
class date : public date_time::date<date, gregorian_calendar, date_duration>
{
    public:
        typedef gregorian_calendar::year_type year_type;
        typedef gregorian_calendar::month_type month_type;
        typedef gregorian_calendar::day_type day_type;
        typedef gregorian_calendar::day_of_year_type day_of_year_type;
        typedef gregorian_calendar::ymd_type ymd_type;
        typedef gregorian_calendar::date_rep_type date_rep_type;
        typedef gregorian_calendar::date_int_type date_int_type;
        typedef date_duration duration_type;
        date() : date_time::date<date, gregorian_calendar, date_duration>(date_rep_type::from_special(not_a_date_time))
        {
        }
        date(year_type y, month_type m, day_type d)
            : date_time::date<date, gregorian_calendar, date_duration>(y, m, d)
        {
            if (gregorian_calendar::end_of_month_day(y, m) < d)
            {
                boost::throw_exception(bad_day_of_month(std::string("Day of month is not valid for year")));
            }
        }
        explicit date(const ymd_type &ymd)
            : date_time::date<date, gregorian_calendar, date_duration>(ymd)
        {
        }
        explicit date(const date_int_type &rhs) : date_time::date<date, gregorian_calendar, date_duration>(rhs)
        {
        }
        explicit date(date_rep_type rhs) : date_time::date<date, gregorian_calendar, date_duration>(rhs)
        {
        }
        explicit date(special_values sv) : date_time::date<date, gregorian_calendar, date_duration>(from_special_adjusted(sv))
        {
        }
        date_int_type julian_day() const
        {
            ymd_type ymd = year_month_day();
            return gregorian_calendar::julian_day_number(ymd);
        }
        day_of_year_type day_of_year() const
        {
            date start_of_year(year(), 1, 1);
            unsigned short doy = static_cast<unsigned short>((*this - start_of_year).days() + 1);
            return day_of_year_type(doy);
        }
        date_int_type modjulian_day() const
        {
            ymd_type ymd = year_month_day();
            return gregorian_calendar::modjulian_day_number(ymd);
        }
        int week_number() const
        {
            ymd_type ymd = year_month_day();
            return gregorian_calendar::week_number(ymd);
        }
        date_int_type day_number() const
        {
            return days_;
        }
        date end_of_month() const
        {
            ymd_type ymd = year_month_day();
            unsigned short eom_day = gregorian_calendar::end_of_month_day(ymd.year, ymd.month);
            return date(ymd.year, ymd.month, eom_day);
        }
        friend bool operator==(const date &lhs, const date &rhs);

    private:
        date_rep_type from_special_adjusted(special_values sv)
        {
            switch (sv)
            {
            case min_date_time:
                return gregorian_calendar::day_number(ymd_type(1400, 1, 1));
            case max_date_time:
                return gregorian_calendar::day_number(ymd_type(9999, 12, 31));
            default:
                return date_rep_type::from_special(sv);
            }
        }
};
inline bool operator==(const date &lhs, const date &rhs)
{
        return lhs.days_ == rhs.days_;
}
    }
}

namespace boost
{
    namespace date_time
    {
template <typename int_type_, int_type_ wrap_val>
class wrapping_int
{
    public:
        typedef int_type_ int_type;
        static int_type wrap_value() { return wrap_val; }
        wrapping_int(int_type v) : value_(v) {}
        int_type as_int() const { return value_; }
        operator int_type() const { return value_; }
        template <typename IntT>
        IntT add(IntT v)
        {
            int_type remainder = static_cast<int_type>(v % (wrap_val));
            IntT overflow = static_cast<IntT>(v / (wrap_val));
            value_ = static_cast<int_type>(value_ + remainder);
            return calculate_wrap(overflow);
        }
        template <typename IntT>
        IntT subtract(IntT v)
        {
            int_type remainder = static_cast<int_type>(v % (wrap_val));
            IntT underflow = static_cast<IntT>(-(v / (wrap_val)));
            value_ = static_cast<int_type>(value_ - remainder);
            return calculate_wrap(underflow) * -1;
        }

    private:
        int_type value_;
        template <typename IntT>
        IntT calculate_wrap(IntT wrap)
        {
            if ((value_) >= wrap_val)
            {
                ++wrap;
                value_ -= (wrap_val);
            }
            else if (value_ < 0)
            {
                --wrap;
                value_ += (wrap_val);
            }
            return wrap;
        }
};
template <typename int_type_, int_type_ wrap_min, int_type_ wrap_max>
class wrapping_int2
{
    public:
        typedef int_type_ int_type;
        static int_type wrap_value() { return wrap_max; }
        static int_type min_value() { return wrap_min; }
        wrapping_int2(int_type v) : value_(v)
        {
            if (value_ < wrap_min)
            {
                value_ = wrap_min;
            }
            if (value_ > wrap_max)
            {
                value_ = wrap_max;
            }
        }
        int_type as_int() const { return value_; }
        operator int_type() const { return value_; }
        template <typename IntT>
        IntT add(IntT v)
        {
            int_type remainder = static_cast<int_type>(v % (wrap_max - wrap_min + 1));
            IntT overflow = static_cast<IntT>(v / (wrap_max - wrap_min + 1));
            value_ = static_cast<int_type>(value_ + remainder);
            return calculate_wrap(overflow);
        }
        template <typename IntT>
        IntT subtract(IntT v)
        {
            int_type remainder = static_cast<int_type>(v % (wrap_max - wrap_min + 1));
            IntT underflow = static_cast<IntT>(-(v / (wrap_max - wrap_min + 1)));
            value_ = static_cast<int_type>(value_ - remainder);
            return calculate_wrap(underflow);
        }

    private:
        int_type value_;
        template <typename IntT>
        IntT calculate_wrap(IntT wrap)
        {
            if ((value_) > wrap_max)
            {
                ++wrap;
                value_ -= (wrap_max - wrap_min + 1);
            }
            else if ((value_) < wrap_min)
            {
                --wrap;
                value_ += (wrap_max - wrap_min + 1);
            }
            return wrap;
        }
};
    }
}

namespace boost
{
    namespace date_time
    {
template <class date_type>
class day_functor
{
    public:
        typedef typename date_type::duration_type duration_type;
        day_functor(int f) : f_(f) {}
        duration_type get_offset(const date_type &) const
        {
            return duration_type(f_);
        }
        duration_type get_neg_offset(const date_type &) const
        {
            return duration_type(-f_);
        }

    private:
        int f_;
};
template <class date_type>
class month_functor
{
    public:
        typedef typename date_type::duration_type duration_type;
        typedef typename date_type::calendar_type cal_type;
        typedef typename cal_type::ymd_type ymd_type;
        typedef typename cal_type::day_type day_type;
        month_functor(int f) : f_(f), origDayOfMonth_(0) {}
        duration_type get_offset(const date_type &d) const
        {
            ymd_type ymd(d.year_month_day());
            if (origDayOfMonth_ == 0)
            {
                origDayOfMonth_ = ymd.day;
                day_type endOfMonthDay(cal_type::end_of_month_day(ymd.year, ymd.month));
                if (endOfMonthDay == ymd.day)
                {
                    origDayOfMonth_ = -1;
                }
            }
            typedef date_time::wrapping_int2<short, 1, 12> wrap_int2;
            wrap_int2 wi(ymd.month);
            const typename ymd_type::year_type year(static_cast<typename ymd_type::year_type::value_type>(ymd.year + wi.add(f_)));
            day_type resultingEndOfMonthDay(cal_type::end_of_month_day(year, wi.as_int()));
            if (origDayOfMonth_ == -1)
            {
                return date_type(year, wi.as_int(), resultingEndOfMonthDay) - d;
            }
            day_type dayOfMonth = origDayOfMonth_;
            if (dayOfMonth > resultingEndOfMonthDay)
            {
                dayOfMonth = resultingEndOfMonthDay;
            }
            return date_type(year, wi.as_int(), dayOfMonth) - d;
        }
        duration_type get_neg_offset(const date_type &d) const
        {
            ymd_type ymd(d.year_month_day());
            if (origDayOfMonth_ == 0)
            {
                origDayOfMonth_ = ymd.day;
                day_type endOfMonthDay(cal_type::end_of_month_day(ymd.year, ymd.month));
                if (endOfMonthDay == ymd.day)
                {
                    origDayOfMonth_ = -1;
                }
            }
            typedef date_time::wrapping_int2<short, 1, 12> wrap_int2;
            wrap_int2 wi(ymd.month);
            const typename ymd_type::year_type year(static_cast<typename ymd_type::year_type::value_type>(ymd.year + wi.subtract(f_)));
            day_type resultingEndOfMonthDay(cal_type::end_of_month_day(year, wi.as_int()));
            if (origDayOfMonth_ == -1)
            {
                return date_type(year, wi.as_int(), resultingEndOfMonthDay) - d;
            }
            day_type dayOfMonth = origDayOfMonth_;
            if (dayOfMonth > resultingEndOfMonthDay)
            {
                dayOfMonth = resultingEndOfMonthDay;
            }
            return date_type(year, wi.as_int(), dayOfMonth) - d;
        }

    private:
        int f_;
        mutable short origDayOfMonth_;
};
template <class date_type>
class week_functor
{
    public:
        typedef typename date_type::duration_type duration_type;
        typedef typename date_type::calendar_type calendar_type;
        week_functor(int f) : f_(f) {}
        duration_type get_offset(const date_type &) const
        {
            return duration_type(f_ * static_cast<int>(calendar_type::days_in_week()));
        }
        duration_type get_neg_offset(const date_type &) const
        {
            return duration_type(-f_ * static_cast<int>(calendar_type::days_in_week()));
        }

    private:
        int f_;
};
template <class date_type>
class year_functor
{
    public:
        typedef typename date_type::duration_type duration_type;
        year_functor(int f) : _mf(f * 12) {}
        duration_type get_offset(const date_type &d) const
        {
            return _mf.get_offset(d);
        }
        duration_type get_neg_offset(const date_type &d) const
        {
            return _mf.get_neg_offset(d);
        }

    private:
        month_functor<date_type> _mf;
};
    }
}
namespace boost
{
    namespace gregorian
    {
struct greg_durations_config
{
        typedef date date_type;
        typedef date_time::int_adapter<int> int_rep;
        typedef date_time::month_functor<date_type> month_adjustor_type;
};
typedef date_time::months_duration<greg_durations_config> months;
typedef date_time::years_duration<greg_durations_config> years;
class weeks_duration : public date_duration
{
    public:
        weeks_duration(duration_rep w)
            : date_duration(w * 7) {}
        weeks_duration(date_time::special_values sv)
            : date_duration(sv) {}
};
typedef weeks_duration weeks;
    }
}
namespace std
{
    inline namespace __1
    {
template <class _CharT, class _Traits>
class basic_istream
    : virtual public basic_ios<_CharT, _Traits>
{
        streamsize __gc_;

    public:
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        inline explicit basic_istream(basic_streambuf<char_type, traits_type> *__sb) : __gc_(0)
        {
            this->init(__sb);
        }
        virtual ~basic_istream();

    protected:
        inline basic_istream(basic_istream &&__rhs);
        inline basic_istream &operator=(basic_istream &&__rhs);
        inline void swap(basic_istream &__rhs)
        {
            std::swap(__gc_, __rhs.__gc_);
            basic_ios<char_type, traits_type>::swap(__rhs);
        }
        basic_istream(const basic_istream &__rhs) = delete;
        basic_istream &operator=(const basic_istream &__rhs) = delete;

    public:
        class sentry;
        inline basic_istream &operator>>(basic_istream &(*__pf)(basic_istream &))
        {
            return __pf(*this);
        }
        inline basic_istream &operator>>(basic_ios<char_type, traits_type> &(*__pf)(basic_ios<char_type, traits_type> &))
        {
            __pf(*this);
            return *this;
        }
        inline basic_istream &operator>>(ios_base &(*__pf)(ios_base &))
        {
            __pf(*this);
            return *this;
        }
        basic_istream &operator>>(basic_streambuf<char_type, traits_type> *__sb);
        basic_istream &operator>>(bool &__n);
        basic_istream &operator>>(short &__n);
        basic_istream &operator>>(unsigned short &__n);
        basic_istream &operator>>(int &__n);
        basic_istream &operator>>(unsigned int &__n);
        basic_istream &operator>>(long &__n);
        basic_istream &operator>>(unsigned long &__n);
        basic_istream &operator>>(long long &__n);
        basic_istream &operator>>(unsigned long long &__n);
        basic_istream &operator>>(float &__f);
        basic_istream &operator>>(double &__f);
        basic_istream &operator>>(long double &__f);
        basic_istream &operator>>(void *&__p);

        streamsize gcount() const { return __gc_; }
        int_type get();
        inline basic_istream &get(char_type &__c)
        {
            int_type __ch = get();
            if (__ch != traits_type::eof())
                __c = traits_type::to_char_type(__ch);
            return *this;
        }
        inline basic_istream &get(char_type *__s, streamsize __n)
        {
            return get(__s, __n, this->widen('\n'));
        }
        basic_istream &get(char_type *__s, streamsize __n, char_type __dlm);
        inline basic_istream &get(basic_streambuf<char_type, traits_type> &__sb)
        {
            return get(__sb, this->widen('\n'));
        }
        basic_istream &get(basic_streambuf<char_type, traits_type> &__sb, char_type __dlm);
        inline basic_istream &getline(char_type *__s, streamsize __n)
        {
            return getline(__s, __n, this->widen('\n'));
        }
        basic_istream &getline(char_type *__s, streamsize __n, char_type __dlm);
        basic_istream &ignore(streamsize __n = 1, int_type __dlm = traits_type::eof());
        int_type peek();
        basic_istream &read(char_type *__s, streamsize __n);
        streamsize readsome(char_type *__s, streamsize __n);
        basic_istream &putback(char_type __c);
        basic_istream &unget();
        int sync();
        pos_type tellg();
        basic_istream &seekg(pos_type __pos);
        basic_istream &seekg(off_type __off, ios_base::seekdir __dir);
};
template <class _CharT, class _Traits>
class basic_istream<_CharT, _Traits>::sentry
{
        bool __ok_;

    public:
        explicit sentry(basic_istream<_CharT, _Traits> &__is, bool __noskipws = false);

        explicit operator bool() const { return __ok_; }
        sentry(const sentry &) = delete;
        sentry &operator=(const sentry &) = delete;
};
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::sentry::sentry(basic_istream<_CharT, _Traits> &__is,
                                               bool __noskipws)
    : __ok_(false)
{
        if (__is.good())
        {
            if (__is.tie())
                __is.tie()->flush();
            if (!__noskipws && (__is.flags() & ios_base::skipws))
            {
                typedef istreambuf_iterator<_CharT, _Traits> _Ip;
                const ctype<_CharT> &__ct = use_facet<ctype<_CharT>>(__is.getloc());
                _Ip __i(__is);
                _Ip __eof;
                for (; __i != __eof; ++__i)
                    if (!__ct.is(__ct.space, *__i))
                        break;
                if (__i == __eof)
                    __is.setstate(ios_base::failbit | ios_base::eofbit);
            }
            __ok_ = __is.good();
        }
        else
            __is.setstate(ios_base::failbit);
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::basic_istream(basic_istream &&__rhs)
    : __gc_(__rhs.__gc_)
{
        __rhs.__gc_ = 0;
        this->move(__rhs);
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::operator=(basic_istream &&__rhs)
{
        swap(__rhs);
        return *this;
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::~basic_istream()
{
}
template <class _Tp, class _CharT, class _Traits>

basic_istream<_CharT, _Traits> &
__input_arithmetic(basic_istream<_CharT, _Traits> &__is, _Tp &__n)
{
        ios_base::iostate __state = ios_base::goodbit;
        typename basic_istream<_CharT, _Traits>::sentry __s(__is);
        if (__s)
        {
            try
            {
                typedef istreambuf_iterator<_CharT, _Traits> _Ip;
                typedef num_get<_CharT, _Ip> _Fp;
                use_facet<_Fp>(__is.getloc()).get(_Ip(__is), _Ip(), __is, __state, __n);
            }
            catch (...)
            {
                __state |= ios_base::badbit;
                __is.__setstate_nothrow(__state);
                if (__is.exceptions() & ios_base::badbit)
                {
                    throw;
                }
            }
            __is.setstate(__state);
        }
        return __is;
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::operator>>(unsigned short &__n)
{
        return std::__input_arithmetic<unsigned short>(*this, __n);
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::operator>>(unsigned int &__n)
{
        return std::__input_arithmetic<unsigned int>(*this, __n);
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::operator>>(long &__n)
{
        return std::__input_arithmetic<long>(*this, __n);
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::operator>>(unsigned long &__n)
{
        return std::__input_arithmetic<unsigned long>(*this, __n);
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::operator>>(long long &__n)
{
        return std::__input_arithmetic<long long>(*this, __n);
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::operator>>(unsigned long long &__n)
{
        return std::__input_arithmetic<unsigned long long>(*this, __n);
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::operator>>(float &__n)
{
        return std::__input_arithmetic<float>(*this, __n);
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::operator>>(double &__n)
{
        return std::__input_arithmetic<double>(*this, __n);
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::operator>>(long double &__n)
{
        return std::__input_arithmetic<long double>(*this, __n);
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::operator>>(bool &__n)
{
        return std::__input_arithmetic<bool>(*this, __n);
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::operator>>(void *&__n)
{
        return std::__input_arithmetic<void *>(*this, __n);
}
template <class _Tp, class _CharT, class _Traits>

basic_istream<_CharT, _Traits> &
__input_arithmetic_with_numeric_limits(basic_istream<_CharT, _Traits> &__is, _Tp &__n)
{
        ios_base::iostate __state = ios_base::goodbit;
        typename basic_istream<_CharT, _Traits>::sentry __s(__is);
        if (__s)
        {
            try
            {
                typedef istreambuf_iterator<_CharT, _Traits> _Ip;
                typedef num_get<_CharT, _Ip> _Fp;
                long __temp;
                use_facet<_Fp>(__is.getloc()).get(_Ip(__is), _Ip(), __is, __state, __temp);
                if (__temp < numeric_limits<_Tp>::min())
                {
                    __state |= ios_base::failbit;
                    __n = numeric_limits<_Tp>::min();
                }
                else if (__temp > numeric_limits<_Tp>::max())
                {
                    __state |= ios_base::failbit;
                    __n = numeric_limits<_Tp>::max();
                }
                else
                {
                    __n = static_cast<_Tp>(__temp);
                }
            }
            catch (...)
            {
                __state |= ios_base::badbit;
                __is.__setstate_nothrow(__state);
                if (__is.exceptions() & ios_base::badbit)
                {
                    throw;
                }
            }
            __is.setstate(__state);
        }
        return __is;
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::operator>>(short &__n)
{
        return std::__input_arithmetic_with_numeric_limits<short>(*this, __n);
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::operator>>(int &__n)
{
        return std::__input_arithmetic_with_numeric_limits<int>(*this, __n);
}
template <class _CharT, class _Traits>

basic_istream<_CharT, _Traits> &
__input_c_string(basic_istream<_CharT, _Traits> &__is, _CharT *__p, size_t __n)
{
        ios_base::iostate __state = ios_base::goodbit;
        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
        if (__sen)
        {
            try
            {
                _CharT *__s = __p;
                const ctype<_CharT> &__ct = use_facet<ctype<_CharT>>(__is.getloc());
                while (__s != __p + (__n - 1))
                {
                    typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                    if (_Traits::eq_int_type(__i, _Traits::eof()))
                    {
                        __state |= ios_base::eofbit;
                        break;
                    }
                    _CharT __ch = _Traits::to_char_type(__i);
                    if (__ct.is(__ct.space, __ch))
                        break;
                    *__s++ = __ch;
                    __is.rdbuf()->sbumpc();
                }
                *__s = _CharT();
                __is.width(0);
                if (__s == __p)
                    __state |= ios_base::failbit;
            }
            catch (...)
            {
                __state |= ios_base::badbit;
                __is.__setstate_nothrow(__state);
                if (__is.exceptions() & ios_base::badbit)
                {
                    throw;
                }
            }
            __is.setstate(__state);
        }
        return __is;
}
template <class _CharT, class _Traits>
inline basic_istream<_CharT, _Traits> &
operator>>(basic_istream<_CharT, _Traits> &__is, _CharT *__s)
{
        streamsize __n = __is.width();
        if (__n <= 0)
            __n = numeric_limits<streamsize>::max() / sizeof(_CharT) - 1;
        return std::__input_c_string(__is, __s, size_t(__n));
}
template <class _Traits>
inline basic_istream<char, _Traits> &
operator>>(basic_istream<char, _Traits> &__is, unsigned char *__s)
{
        return __is >> (char *)__s;
}
template <class _Traits>
inline basic_istream<char, _Traits> &
operator>>(basic_istream<char, _Traits> &__is, signed char *__s)
{
        return __is >> (char *)__s;
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
operator>>(basic_istream<_CharT, _Traits> &__is, _CharT &__c)
{
        ios_base::iostate __state = ios_base::goodbit;
        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
        if (__sen)
        {
            try
            {
                typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                    __state |= ios_base::eofbit | ios_base::failbit;
                else
                    __c = _Traits::to_char_type(__i);
            }
            catch (...)
            {
                __state |= ios_base::badbit;
                __is.__setstate_nothrow(__state);
                if (__is.exceptions() & ios_base::badbit)
                {
                    throw;
                }
            }
            __is.setstate(__state);
        }
        return __is;
}
template <class _Traits>
inline basic_istream<char, _Traits> &
operator>>(basic_istream<char, _Traits> &__is, unsigned char &__c)
{
        return __is >> (char &)__c;
}
template <class _Traits>
inline basic_istream<char, _Traits> &
operator>>(basic_istream<char, _Traits> &__is, signed char &__c)
{
        return __is >> (char &)__c;
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::operator>>(basic_streambuf<char_type, traits_type> *__sb)
{
        ios_base::iostate __state = ios_base::goodbit;
        __gc_ = 0;
        sentry __s(*this, true);
        if (__s)
        {
            if (__sb)
            {
                try
                {
                    while (true)
                    {
                        typename traits_type::int_type __i = this->rdbuf()->sgetc();
                        if (traits_type::eq_int_type(__i, _Traits::eof()))
                        {
                            __state |= ios_base::eofbit;
                            break;
                        }
                        if (traits_type::eq_int_type(
                                __sb->sputc(traits_type::to_char_type(__i)),
                                traits_type::eof()))
                            break;
                        ++__gc_;
                        this->rdbuf()->sbumpc();
                    }
                    if (__gc_ == 0)
                        __state |= ios_base::failbit;
                }
                catch (...)
                {
                    __state |= ios_base::badbit;
                    if (__gc_ == 0)
                        __state |= ios_base::failbit;
                    this->__setstate_nothrow(__state);
                    if (this->exceptions() & ios_base::failbit || this->exceptions() & ios_base::badbit)
                    {
                        throw;
                    }
                }
            }
            else
            {
                __state |= ios_base::failbit;
            }
            this->setstate(__state);
        }
        return *this;
}
template <class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::get()
{
        ios_base::iostate __state = ios_base::goodbit;
        __gc_ = 0;
        int_type __r = traits_type::eof();
        sentry __s(*this, true);
        if (__s)
        {
            try
            {
                __r = this->rdbuf()->sbumpc();
                if (traits_type::eq_int_type(__r, traits_type::eof()))
                    __state |= ios_base::failbit | ios_base::eofbit;
                else
                    __gc_ = 1;
            }
            catch (...)
            {
                this->__setstate_nothrow(this->rdstate() | ios_base::badbit);
                if (this->exceptions() & ios_base::badbit)
                {
                    throw;
                }
            }
            this->setstate(__state);
        }
        return __r;
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::get(char_type *__s, streamsize __n, char_type __dlm)
{
        ios_base::iostate __state = ios_base::goodbit;
        __gc_ = 0;
        sentry __sen(*this, true);
        if (__sen)
        {
            if (__n > 0)
            {
                try
                {
                    while (__gc_ < __n - 1)
                    {
                        int_type __i = this->rdbuf()->sgetc();
                        if (traits_type::eq_int_type(__i, traits_type::eof()))
                        {
                            __state |= ios_base::eofbit;
                            break;
                        }
                        char_type __ch = traits_type::to_char_type(__i);
                        if (traits_type::eq(__ch, __dlm))
                            break;
                        *__s++ = __ch;
                        ++__gc_;
                        this->rdbuf()->sbumpc();
                    }
                    if (__gc_ == 0)
                        __state |= ios_base::failbit;
                }
                catch (...)
                {
                    __state |= ios_base::badbit;
                    this->__setstate_nothrow(__state);
                    if (this->exceptions() & ios_base::badbit)
                    {
                        if (__n > 0)
                            *__s = char_type();
                        throw;
                    }
                }
            }
            else
            {
                __state |= ios_base::failbit;
            }
            if (__n > 0)
                *__s = char_type();
            this->setstate(__state);
        }
        if (__n > 0)
            *__s = char_type();
        return *this;
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::get(basic_streambuf<char_type, traits_type> &__sb,
                                    char_type __dlm)
{
        ios_base::iostate __state = ios_base::goodbit;
        __gc_ = 0;
        sentry __sen(*this, true);
        if (__sen)
        {
            try
            {
                while (true)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sgetc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                        __state |= ios_base::eofbit;
                        break;
                    }
                    char_type __ch = traits_type::to_char_type(__i);
                    if (traits_type::eq(__ch, __dlm))
                        break;
                    if (traits_type::eq_int_type(__sb.sputc(__ch), traits_type::eof()))
                        break;
                    ++__gc_;
                    this->rdbuf()->sbumpc();
                }
            }
            catch (...)
            {
                __state |= ios_base::badbit;
            }
            if (__gc_ == 0)
                __state |= ios_base::failbit;
            this->setstate(__state);
        }
        return *this;
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::getline(char_type *__s, streamsize __n, char_type __dlm)
{
        ios_base::iostate __state = ios_base::goodbit;
        __gc_ = 0;
        sentry __sen(*this, true);
        if (__sen)
        {
            try
            {
                while (true)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sgetc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                        __state |= ios_base::eofbit;
                        break;
                    }
                    char_type __ch = traits_type::to_char_type(__i);
                    if (traits_type::eq(__ch, __dlm))
                    {
                        this->rdbuf()->sbumpc();
                        ++__gc_;
                        break;
                    }
                    if (__gc_ >= __n - 1)
                    {
                        __state |= ios_base::failbit;
                        break;
                    }
                    *__s++ = __ch;
                    this->rdbuf()->sbumpc();
                    ++__gc_;
                }
            }
            catch (...)
            {
                __state |= ios_base::badbit;
                this->__setstate_nothrow(__state);
                if (this->exceptions() & ios_base::badbit)
                {
                    if (__n > 0)
                        *__s = char_type();
                    if (__gc_ == 0)
                        __state |= ios_base::failbit;
                    throw;
                }
            }
        }
        if (__n > 0)
            *__s = char_type();
        if (__gc_ == 0)
            __state |= ios_base::failbit;
        this->setstate(__state);
        return *this;
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::ignore(streamsize __n, int_type __dlm)
{
        ios_base::iostate __state = ios_base::goodbit;
        __gc_ = 0;
        sentry __sen(*this, true);
        if (__sen)
        {
            try
            {
                if (__n == numeric_limits<streamsize>::max())
                {
                    while (true)
                    {
                        typename traits_type::int_type __i = this->rdbuf()->sbumpc();
                        if (traits_type::eq_int_type(__i, traits_type::eof()))
                        {
                            __state |= ios_base::eofbit;
                            break;
                        }
                        ++__gc_;
                        if (traits_type::eq_int_type(__i, __dlm))
                            break;
                    }
                }
                else
                {
                    while (__gc_ < __n)
                    {
                        typename traits_type::int_type __i = this->rdbuf()->sbumpc();
                        if (traits_type::eq_int_type(__i, traits_type::eof()))
                        {
                            __state |= ios_base::eofbit;
                            break;
                        }
                        ++__gc_;
                        if (traits_type::eq_int_type(__i, __dlm))
                            break;
                    }
                }
            }
            catch (...)
            {
                __state |= ios_base::badbit;
                this->__setstate_nothrow(__state);
                if (this->exceptions() & ios_base::badbit)
                {
                    throw;
                }
            }
            this->setstate(__state);
        }
        return *this;
}
template <class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::peek()
{
        ios_base::iostate __state = ios_base::goodbit;
        __gc_ = 0;
        int_type __r = traits_type::eof();
        sentry __sen(*this, true);
        if (__sen)
        {
            try
            {
                __r = this->rdbuf()->sgetc();
                if (traits_type::eq_int_type(__r, traits_type::eof()))
                    __state |= ios_base::eofbit;
            }
            catch (...)
            {
                __state |= ios_base::badbit;
                this->__setstate_nothrow(__state);
                if (this->exceptions() & ios_base::badbit)
                {
                    throw;
                }
            }
            this->setstate(__state);
        }
        return __r;
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::read(char_type *__s, streamsize __n)
{
        ios_base::iostate __state = ios_base::goodbit;
        __gc_ = 0;
        sentry __sen(*this, true);
        if (__sen)
        {
            try
            {
                __gc_ = this->rdbuf()->sgetn(__s, __n);
                if (__gc_ != __n)
                    __state |= ios_base::failbit | ios_base::eofbit;
            }
            catch (...)
            {
                __state |= ios_base::badbit;
                this->__setstate_nothrow(__state);
                if (this->exceptions() & ios_base::badbit)
                {
                    throw;
                }
            }
        }
        else
        {
            __state |= ios_base::failbit;
        }
        this->setstate(__state);
        return *this;
}
template <class _CharT, class _Traits>
streamsize
basic_istream<_CharT, _Traits>::readsome(char_type *__s, streamsize __n)
{
        ios_base::iostate __state = ios_base::goodbit;
        __gc_ = 0;
        sentry __sen(*this, true);
        if (__sen)
        {
            try
            {
                streamsize __c = this->rdbuf()->in_avail();
                switch (__c)
                {
                case -1:
                    __state |= ios_base::eofbit;
                    break;
                case 0:
                    break;
                default:
                    __n = std::min(__c, __n);
                    __gc_ = this->rdbuf()->sgetn(__s, __n);
                    if (__gc_ != __n)
                        __state |= ios_base::failbit | ios_base::eofbit;
                    break;
                }
            }
            catch (...)
            {
                __state |= ios_base::badbit;
                this->__setstate_nothrow(__state);
                if (this->exceptions() & ios_base::badbit)
                {
                    throw;
                }
            }
        }
        else
        {
            __state |= ios_base::failbit;
        }
        this->setstate(__state);
        return __gc_;
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::putback(char_type __c)
{
        ios_base::iostate __state = this->rdstate() & ~ios_base::eofbit;
        __gc_ = 0;
        this->clear(__state);
        sentry __sen(*this, true);
        if (__sen)
        {
            try
            {
                if (this->rdbuf() == __nullptr || this->rdbuf()->sputbackc(__c) == traits_type::eof())
                    __state |= ios_base::badbit;
            }
            catch (...)
            {
                __state |= ios_base::badbit;
                this->__setstate_nothrow(__state);
                if (this->exceptions() & ios_base::badbit)
                {
                    throw;
                }
            }
        }
        else
        {
            __state |= ios_base::failbit;
        }
        this->setstate(__state);
        return *this;
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::unget()
{
        ios_base::iostate __state = this->rdstate() & ~ios_base::eofbit;
        __gc_ = 0;
        this->clear(__state);
        sentry __sen(*this, true);
        if (__sen)
        {
            try
            {
                if (this->rdbuf() == __nullptr || this->rdbuf()->sungetc() == traits_type::eof())
                    __state |= ios_base::badbit;
            }
            catch (...)
            {
                __state |= ios_base::badbit;
                this->__setstate_nothrow(__state);
                if (this->exceptions() & ios_base::badbit)
                {
                    throw;
                }
            }
        }
        else
        {
            __state |= ios_base::failbit;
        }
        this->setstate(__state);
        return *this;
}
template <class _CharT, class _Traits>
int basic_istream<_CharT, _Traits>::sync()
{
        ios_base::iostate __state = ios_base::goodbit;
        int __r = 0;
        sentry __sen(*this, true);
        if (__sen)
        {
            try
            {
                if (this->rdbuf() == __nullptr)
                    return -1;
                if (this->rdbuf()->pubsync() == -1)
                {
                    __state |= ios_base::badbit;
                    return -1;
                }
            }
            catch (...)
            {
                __state |= ios_base::badbit;
                this->__setstate_nothrow(__state);
                if (this->exceptions() & ios_base::badbit)
                {
                    throw;
                }
            }
            this->setstate(__state);
        }
        return __r;
}
template <class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::pos_type
basic_istream<_CharT, _Traits>::tellg()
{
        ios_base::iostate __state = ios_base::goodbit;
        pos_type __r(-1);
        sentry __sen(*this, true);
        if (__sen)
        {
            try
            {
                __r = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
            }
            catch (...)
            {
                __state |= ios_base::badbit;
                this->__setstate_nothrow(__state);
                if (this->exceptions() & ios_base::badbit)
                {
                    throw;
                }
            }
            this->setstate(__state);
        }
        return __r;
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::seekg(pos_type __pos)
{
        ios_base::iostate __state = this->rdstate() & ~ios_base::eofbit;
        this->clear(__state);
        sentry __sen(*this, true);
        if (__sen)
        {
            try
            {
                if (this->rdbuf()->pubseekpos(__pos, ios_base::in) == pos_type(-1))
                    __state |= ios_base::failbit;
            }
            catch (...)
            {
                __state |= ios_base::badbit;
                this->__setstate_nothrow(__state);
                if (this->exceptions() & ios_base::badbit)
                {
                    throw;
                }
            }
            this->setstate(__state);
        }
        return *this;
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::seekg(off_type __off, ios_base::seekdir __dir)
{
        ios_base::iostate __state = this->rdstate() & ~ios_base::eofbit;
        this->clear(__state);
        sentry __sen(*this, true);
        if (__sen)
        {
            try
            {
                if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::in) == pos_type(-1))
                    __state |= ios_base::failbit;
            }
            catch (...)
            {
                __state |= ios_base::badbit;
                this->__setstate_nothrow(__state);
                if (this->exceptions() & ios_base::badbit)
                {
                    throw;
                }
            }
            this->setstate(__state);
        }
        return *this;
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
ws(basic_istream<_CharT, _Traits> &__is)
{
        ios_base::iostate __state = ios_base::goodbit;
        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
        if (__sen)
        {
            try
            {
                const ctype<_CharT> &__ct = use_facet<ctype<_CharT>>(__is.getloc());
                while (true)
                {
                    typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                    if (_Traits::eq_int_type(__i, _Traits::eof()))
                    {
                        __state |= ios_base::eofbit;
                        break;
                    }
                    if (!__ct.is(__ct.space, _Traits::to_char_type(__i)))
                        break;
                    __is.rdbuf()->sbumpc();
                }
            }
            catch (...)
            {
                __state |= ios_base::badbit;
                __is.__setstate_nothrow(__state);
                if (__is.exceptions() & ios_base::badbit)
                {
                    throw;
                }
            }
            __is.setstate(__state);
        }
        return __is;
}
template <class _Stream, class _Tp, class = void>
struct __is_istreamable : false_type
{
};
template <class _Stream, class _Tp>
struct __is_istreamable<_Stream, _Tp, __decltype(declval<_Stream>() >> declval<_Tp>(), void())> : true_type
{
};
template <class _Stream, class _Tp, class = typename enable_if<_And<is_base_of<ios_base, _Stream>, __is_istreamable<_Stream &, _Tp &&>>::value>::type>

_Stream &&operator>>(_Stream &&__is, _Tp &&__x)
{
        __is >> std::forward<_Tp>(__x);
        return std::move(__is);
}
template <class _CharT, class _Traits>
class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
{
    public:
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        inline explicit basic_iostream(basic_streambuf<char_type, traits_type> *__sb)
            : basic_istream<_CharT, _Traits>(__sb)
        {
        }
        virtual ~basic_iostream();

    protected:
        inline basic_iostream(basic_iostream &&__rhs);
        inline basic_iostream &operator=(basic_iostream &&__rhs);
        inline void swap(basic_iostream &__rhs)
        {
            basic_istream<char_type, traits_type>::swap(__rhs);
        }
};
template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>::basic_iostream(basic_iostream &&__rhs)
    : basic_istream<_CharT, _Traits>(std::move(__rhs))
{
}
template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits> &
basic_iostream<_CharT, _Traits>::operator=(basic_iostream &&__rhs)
{
        swap(__rhs);
        return *this;
}
template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>::~basic_iostream()
{
}
template <class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits> &
operator>>(basic_istream<_CharT, _Traits> &__is,
           basic_string<_CharT, _Traits, _Allocator> &__str)
{
        ios_base::iostate __state = ios_base::goodbit;
        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
        if (__sen)
        {
            try
            {
                __str.clear();
                streamsize __n = __is.width();
                if (__n <= 0)
                    __n = __str.max_size();
                if (__n <= 0)
                    __n = numeric_limits<streamsize>::max();
                streamsize __c = 0;
                const ctype<_CharT> &__ct = use_facet<ctype<_CharT>>(__is.getloc());
                while (__c < __n)
                {
                    typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                    if (_Traits::eq_int_type(__i, _Traits::eof()))
                    {
                        __state |= ios_base::eofbit;
                        break;
                    }
                    _CharT __ch = _Traits::to_char_type(__i);
                    if (__ct.is(__ct.space, __ch))
                        break;
                    __str.push_back(__ch);
                    ++__c;
                    __is.rdbuf()->sbumpc();
                }
                __is.width(0);
                if (__c == 0)
                    __state |= ios_base::failbit;
            }
            catch (...)
            {
                __state |= ios_base::badbit;
                __is.__setstate_nothrow(__state);
                if (__is.exceptions() & ios_base::badbit)
                {
                    throw;
                }
            }
            __is.setstate(__state);
        }
        return __is;
}
template <class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits> &
getline(basic_istream<_CharT, _Traits> &__is,
        basic_string<_CharT, _Traits, _Allocator> &__str, _CharT __dlm)
{
        ios_base::iostate __state = ios_base::goodbit;
        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
        if (__sen)
        {
            try
            {
                __str.clear();
                streamsize __extr = 0;
                while (true)
                {
                    typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
                    if (_Traits::eq_int_type(__i, _Traits::eof()))
                    {
                        __state |= ios_base::eofbit;
                        break;
                    }
                    ++__extr;
                    _CharT __ch = _Traits::to_char_type(__i);
                    if (_Traits::eq(__ch, __dlm))
                        break;
                    __str.push_back(__ch);
                    if (__str.size() == __str.max_size())
                    {
                        __state |= ios_base::failbit;
                        break;
                    }
                }
                if (__extr == 0)
                    __state |= ios_base::failbit;
            }
            catch (...)
            {
                __state |= ios_base::badbit;
                __is.__setstate_nothrow(__state);
                if (__is.exceptions() & ios_base::badbit)
                {
                    throw;
                }
            }
            __is.setstate(__state);
        }
        return __is;
}
template <class _CharT, class _Traits, class _Allocator>
inline basic_istream<_CharT, _Traits> &
getline(basic_istream<_CharT, _Traits> &__is,
        basic_string<_CharT, _Traits, _Allocator> &__str)
{
        return getline(__is, __str, __is.widen('\n'));
}
template <class _CharT, class _Traits, class _Allocator>
inline basic_istream<_CharT, _Traits> &
getline(basic_istream<_CharT, _Traits> &&__is,
        basic_string<_CharT, _Traits, _Allocator> &__str, _CharT __dlm)
{
        return getline(__is, __str, __dlm);
}
template <class _CharT, class _Traits, class _Allocator>
inline basic_istream<_CharT, _Traits> &
getline(basic_istream<_CharT, _Traits> &&__is,
        basic_string<_CharT, _Traits, _Allocator> &__str)
{
        return getline(__is, __str, __is.widen('\n'));
}
template <class _CharT, class _Traits, size_t _Size>
basic_istream<_CharT, _Traits> &
operator>>(basic_istream<_CharT, _Traits> &__is, bitset<_Size> &__x)
{
        ios_base::iostate __state = ios_base::goodbit;
        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
        if (__sen)
        {
            try
            {
                basic_string<_CharT, _Traits> __str;
                const ctype<_CharT> &__ct = use_facet<ctype<_CharT>>(__is.getloc());
                size_t __c = 0;
                _CharT __zero = __ct.widen('0');
                _CharT __one = __ct.widen('1');
                while (__c != _Size)
                {
                    typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                    if (_Traits::eq_int_type(__i, _Traits::eof()))
                    {
                        __state |= ios_base::eofbit;
                        break;
                    }
                    _CharT __ch = _Traits::to_char_type(__i);
                    if (!_Traits::eq(__ch, __zero) && !_Traits::eq(__ch, __one))
                        break;
                    __str.push_back(__ch);
                    ++__c;
                    __is.rdbuf()->sbumpc();
                }
                __x = bitset<_Size>(__str);
                if (_Size > 0 && __c == 0)
                    __state |= ios_base::failbit;
            }
            catch (...)
            {
                __state |= ios_base::badbit;
                __is.__setstate_nothrow(__state);
                if (__is.exceptions() & ios_base::badbit)
                {
                    throw;
                }
            }
            __is.setstate(__state);
        }
        return __is;
}
extern template class basic_istream<char>;
extern template class basic_istream<wchar_t>;
extern template class basic_iostream<char>;
    }
}
namespace std
{
    inline namespace __1
    {
template <class _CharT, class _Traits, class _Allocator>
class basic_stringbuf
    : public basic_streambuf<_CharT, _Traits>
{
    public:
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef _Allocator allocator_type;
        typedef basic_string<char_type, traits_type, allocator_type> string_type;

    private:
        string_type __str_;
        mutable char_type *__hm_;
        ios_base::openmode __mode_;

    public:
        basic_stringbuf()
            : __hm_(__nullptr), __mode_(ios_base::in | ios_base::out) {}

        explicit basic_stringbuf(ios_base::openmode __wch)
            : __hm_(__nullptr), __mode_(__wch) {}

        explicit basic_stringbuf(const string_type &__s,
                                 ios_base::openmode __wch = ios_base::in | ios_base::out)
            : __str_(__s.get_allocator()), __hm_(__nullptr), __mode_(__wch)
        {
            str(__s);
        }
        basic_stringbuf(basic_stringbuf &&__rhs);
        basic_stringbuf &operator=(basic_stringbuf &&__rhs);
        void swap(basic_stringbuf &__rhs);
        string_type str() const;
        void str(const string_type &__s);

    protected:
        virtual int_type underflow();
        virtual int_type pbackfail(int_type __c = traits_type::eof());
        virtual int_type overflow(int_type __c = traits_type::eof());
        virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                                 ios_base::openmode __wch = ios_base::in | ios_base::out);

        virtual pos_type seekpos(pos_type __sp,
                                 ios_base::openmode __wch = ios_base::in | ios_base::out)
        {
            return seekoff(__sp, ios_base::beg, __wch);
        }
};
template <class _CharT, class _Traits, class _Allocator>
basic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(basic_stringbuf &&__rhs)
    : __mode_(__rhs.__mode_)
{
        char_type *__p = const_cast<char_type *>(__rhs.__str_.data());
        ptrdiff_t __binp = -1;
        ptrdiff_t __ninp = -1;
        ptrdiff_t __einp = -1;
        if (__rhs.eback() != __nullptr)
        {
            __binp = __rhs.eback() - __p;
            __ninp = __rhs.gptr() - __p;
            __einp = __rhs.egptr() - __p;
        }
        ptrdiff_t __bout = -1;
        ptrdiff_t __nout = -1;
        ptrdiff_t __eout = -1;
        if (__rhs.pbase() != __nullptr)
        {
            __bout = __rhs.pbase() - __p;
            __nout = __rhs.pptr() - __p;
            __eout = __rhs.epptr() - __p;
        }
        ptrdiff_t __hm = __rhs.__hm_ == __nullptr ? -1 : __rhs.__hm_ - __p;
        __str_ = std::move(__rhs.__str_);
        __p = const_cast<char_type *>(__str_.data());
        if (__binp != -1)
            this->setg(__p + __binp, __p + __ninp, __p + __einp);
        if (__bout != -1)
        {
            this->setp(__p + __bout, __p + __eout);
            this->__pbump(__nout);
        }
        __hm_ = __hm == -1 ? __nullptr : __p + __hm;
        __p = const_cast<char_type *>(__rhs.__str_.data());
        __rhs.setg(__p, __p, __p);
        __rhs.setp(__p, __p);
        __rhs.__hm_ = __p;
        this->pubimbue(__rhs.getloc());
}
template <class _CharT, class _Traits, class _Allocator>
basic_stringbuf<_CharT, _Traits, _Allocator> &
basic_stringbuf<_CharT, _Traits, _Allocator>::operator=(basic_stringbuf &&__rhs)
{
        char_type *__p = const_cast<char_type *>(__rhs.__str_.data());
        ptrdiff_t __binp = -1;
        ptrdiff_t __ninp = -1;
        ptrdiff_t __einp = -1;
        if (__rhs.eback() != __nullptr)
        {
            __binp = __rhs.eback() - __p;
            __ninp = __rhs.gptr() - __p;
            __einp = __rhs.egptr() - __p;
        }
        ptrdiff_t __bout = -1;
        ptrdiff_t __nout = -1;
        ptrdiff_t __eout = -1;
        if (__rhs.pbase() != __nullptr)
        {
            __bout = __rhs.pbase() - __p;
            __nout = __rhs.pptr() - __p;
            __eout = __rhs.epptr() - __p;
        }
        ptrdiff_t __hm = __rhs.__hm_ == __nullptr ? -1 : __rhs.__hm_ - __p;
        __str_ = std::move(__rhs.__str_);
        __p = const_cast<char_type *>(__str_.data());
        if (__binp != -1)
            this->setg(__p + __binp, __p + __ninp, __p + __einp);
        else
            this->setg(__nullptr, __nullptr, __nullptr);
        if (__bout != -1)
        {
            this->setp(__p + __bout, __p + __eout);
            this->__pbump(__nout);
        }
        else
            this->setp(__nullptr, __nullptr);
        __hm_ = __hm == -1 ? __nullptr : __p + __hm;
        __mode_ = __rhs.__mode_;
        __p = const_cast<char_type *>(__rhs.__str_.data());
        __rhs.setg(__p, __p, __p);
        __rhs.setp(__p, __p);
        __rhs.__hm_ = __p;
        this->pubimbue(__rhs.getloc());
        return *this;
}
template <class _CharT, class _Traits, class _Allocator>
void basic_stringbuf<_CharT, _Traits, _Allocator>::swap(basic_stringbuf &__rhs)
{
        char_type *__p = const_cast<char_type *>(__rhs.__str_.data());
        ptrdiff_t __rbinp = -1;
        ptrdiff_t __rninp = -1;
        ptrdiff_t __reinp = -1;
        if (__rhs.eback() != __nullptr)
        {
            __rbinp = __rhs.eback() - __p;
            __rninp = __rhs.gptr() - __p;
            __reinp = __rhs.egptr() - __p;
        }
        ptrdiff_t __rbout = -1;
        ptrdiff_t __rnout = -1;
        ptrdiff_t __reout = -1;
        if (__rhs.pbase() != __nullptr)
        {
            __rbout = __rhs.pbase() - __p;
            __rnout = __rhs.pptr() - __p;
            __reout = __rhs.epptr() - __p;
        }
        ptrdiff_t __rhm = __rhs.__hm_ == __nullptr ? -1 : __rhs.__hm_ - __p;
        __p = const_cast<char_type *>(__str_.data());
        ptrdiff_t __lbinp = -1;
        ptrdiff_t __lninp = -1;
        ptrdiff_t __leinp = -1;
        if (this->eback() != __nullptr)
        {
            __lbinp = this->eback() - __p;
            __lninp = this->gptr() - __p;
            __leinp = this->egptr() - __p;
        }
        ptrdiff_t __lbout = -1;
        ptrdiff_t __lnout = -1;
        ptrdiff_t __leout = -1;
        if (this->pbase() != __nullptr)
        {
            __lbout = this->pbase() - __p;
            __lnout = this->pptr() - __p;
            __leout = this->epptr() - __p;
        }
        ptrdiff_t __lhm = __hm_ == __nullptr ? -1 : __hm_ - __p;
        std::swap(__mode_, __rhs.__mode_);
        __str_.swap(__rhs.__str_);
        __p = const_cast<char_type *>(__str_.data());
        if (__rbinp != -1)
            this->setg(__p + __rbinp, __p + __rninp, __p + __reinp);
        else
            this->setg(__nullptr, __nullptr, __nullptr);
        if (__rbout != -1)
        {
            this->setp(__p + __rbout, __p + __reout);
            this->__pbump(__rnout);
        }
        else
            this->setp(__nullptr, __nullptr);
        __hm_ = __rhm == -1 ? __nullptr : __p + __rhm;
        __p = const_cast<char_type *>(__rhs.__str_.data());
        if (__lbinp != -1)
            __rhs.setg(__p + __lbinp, __p + __lninp, __p + __leinp);
        else
            __rhs.setg(__nullptr, __nullptr, __nullptr);
        if (__lbout != -1)
        {
            __rhs.setp(__p + __lbout, __p + __leout);
            __rhs.__pbump(__lnout);
        }
        else
            __rhs.setp(__nullptr, __nullptr);
        __rhs.__hm_ = __lhm == -1 ? __nullptr : __p + __lhm;
        locale __tl = __rhs.getloc();
        __rhs.pubimbue(this->getloc());
        this->pubimbue(__tl);
}
template <class _CharT, class _Traits, class _Allocator>
inline void
swap(basic_stringbuf<_CharT, _Traits, _Allocator> &__x,
     basic_stringbuf<_CharT, _Traits, _Allocator> &__y)
{
        __x.swap(__y);
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
basic_stringbuf<_CharT, _Traits, _Allocator>::str() const
{
        if (__mode_ & ios_base::out)
        {
            if (__hm_ < this->pptr())
                __hm_ = this->pptr();
            return string_type(this->pbase(), __hm_, __str_.get_allocator());
        }
        else if (__mode_ & ios_base::in)
            return string_type(this->eback(), this->egptr(), __str_.get_allocator());
        return string_type(__str_.get_allocator());
}
template <class _CharT, class _Traits, class _Allocator>
void basic_stringbuf<_CharT, _Traits, _Allocator>::str(const string_type &__s)
{
        __str_ = __s;
        __hm_ = __nullptr;
        if (__mode_ & ios_base::in)
        {
            __hm_ = const_cast<char_type *>(__str_.data()) + __str_.size();
            this->setg(const_cast<char_type *>(__str_.data()),
                       const_cast<char_type *>(__str_.data()),
                       __hm_);
        }
        if (__mode_ & ios_base::out)
        {
            typename string_type::size_type __sz = __str_.size();
            __hm_ = const_cast<char_type *>(__str_.data()) + __sz;
            __str_.resize(__str_.capacity());
            this->setp(const_cast<char_type *>(__str_.data()),
                       const_cast<char_type *>(__str_.data()) + __str_.size());
            if (__mode_ & (ios_base::app | ios_base::ate))
            {
                while (__sz > 2147483647)
                {
                    this->pbump(2147483647);
                    __sz -= 2147483647;
                }
                if (__sz > 0)
                    this->pbump(__sz);
            }
        }
}
template <class _CharT, class _Traits, class _Allocator>
typename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type
basic_stringbuf<_CharT, _Traits, _Allocator>::underflow()
{
        if (__hm_ < this->pptr())
            __hm_ = this->pptr();
        if (__mode_ & ios_base::in)
        {
            if (this->egptr() < __hm_)
                this->setg(this->eback(), this->gptr(), __hm_);
            if (this->gptr() < this->egptr())
                return traits_type::to_int_type(*this->gptr());
        }
        return traits_type::eof();
}
template <class _CharT, class _Traits, class _Allocator>
typename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type
basic_stringbuf<_CharT, _Traits, _Allocator>::pbackfail(int_type __c)
{
        if (__hm_ < this->pptr())
            __hm_ = this->pptr();
        if (this->eback() < this->gptr())
        {
            if (traits_type::eq_int_type(__c, traits_type::eof()))
            {
                this->setg(this->eback(), this->gptr() - 1, __hm_);
                return traits_type::not_eof(__c);
            }
            if ((__mode_ & ios_base::out) ||
                traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))
            {
                this->setg(this->eback(), this->gptr() - 1, __hm_);
                *this->gptr() = traits_type::to_char_type(__c);
                return __c;
            }
        }
        return traits_type::eof();
}
template <class _CharT, class _Traits, class _Allocator>
typename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type
basic_stringbuf<_CharT, _Traits, _Allocator>::overflow(int_type __c)
{
        if (!traits_type::eq_int_type(__c, traits_type::eof()))
        {
            ptrdiff_t __ninp = this->gptr() - this->eback();
            if (this->pptr() == this->epptr())
            {
                if (!(__mode_ & ios_base::out))
                    return traits_type::eof();
                try
                {
                    ptrdiff_t __nout = this->pptr() - this->pbase();
                    ptrdiff_t __hm = __hm_ - this->pbase();
                    __str_.push_back(char_type());
                    __str_.resize(__str_.capacity());
                    char_type *__p = const_cast<char_type *>(__str_.data());
                    this->setp(__p, __p + __str_.size());
                    this->__pbump(__nout);
                    __hm_ = this->pbase() + __hm;
                }
                catch (...)
                {
                    return traits_type::eof();
                }
            }
            __hm_ = std::max(this->pptr() + 1, __hm_);
            if (__mode_ & ios_base::in)
            {
                char_type *__p = const_cast<char_type *>(__str_.data());
                this->setg(__p, __p + __ninp, __hm_);
            }
            return this->sputc(traits_type::to_char_type(__c));
        }
        return traits_type::not_eof(__c);
}
template <class _CharT, class _Traits, class _Allocator>
typename basic_stringbuf<_CharT, _Traits, _Allocator>::pos_type
basic_stringbuf<_CharT, _Traits, _Allocator>::seekoff(off_type __off,
                                                      ios_base::seekdir __way,
                                                      ios_base::openmode __wch)
{
        if (__hm_ < this->pptr())
            __hm_ = this->pptr();
        if ((__wch & (ios_base::in | ios_base::out)) == 0)
            return pos_type(-1);
        if ((__wch & (ios_base::in | ios_base::out)) == (ios_base::in | ios_base::out) && __way == ios_base::cur)
            return pos_type(-1);
        const ptrdiff_t __hm = __hm_ == __nullptr ? 0 : __hm_ - __str_.data();
        off_type __noff;
        switch (__way)
        {
        case ios_base::beg:
            __noff = 0;
            break;
        case ios_base::cur:
            if (__wch & ios_base::in)
                __noff = this->gptr() - this->eback();
            else
                __noff = this->pptr() - this->pbase();
            break;
        case ios_base::end:
            __noff = __hm;
            break;
        default:
            return pos_type(-1);
        }
        __noff += __off;
        if (__noff < 0 || __hm < __noff)
            return pos_type(-1);
        if (__noff != 0)
        {
            if ((__wch & ios_base::in) && this->gptr() == __nullptr)
                return pos_type(-1);
            if ((__wch & ios_base::out) && this->pptr() == __nullptr)
                return pos_type(-1);
        }
        if (__wch & ios_base::in)
            this->setg(this->eback(), this->eback() + __noff, __hm_);
        if (__wch & ios_base::out)
        {
            this->setp(this->pbase(), this->epptr());
            this->pbump(__noff);
        }
        return pos_type(__noff);
}
template <class _CharT, class _Traits, class _Allocator>
class basic_istringstream
    : public basic_istream<_CharT, _Traits>
{
    public:
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef _Allocator allocator_type;
        typedef basic_string<char_type, traits_type, allocator_type> string_type;

    private:
        basic_stringbuf<char_type, traits_type, allocator_type> __sb_;

    public:
        basic_istringstream()
            : basic_istream<_CharT, _Traits>(&__sb_), __sb_(ios_base::in) {}

        explicit basic_istringstream(ios_base::openmode __wch)
            : basic_istream<_CharT, _Traits>(&__sb_), __sb_(__wch | ios_base::in) {}

        explicit basic_istringstream(const string_type &__s,
                                     ios_base::openmode __wch = ios_base::in)
            : basic_istream<_CharT, _Traits>(&__sb_), __sb_(__s, __wch | ios_base::in)
        {
        }

        basic_istringstream(basic_istringstream &&__rhs)
            : basic_istream<_CharT, _Traits>(std::move(__rhs)), __sb_(std::move(__rhs.__sb_))
        {
            basic_istream<_CharT, _Traits>::set_rdbuf(&__sb_);
        }
        basic_istringstream &operator=(basic_istringstream &&__rhs)
        {
            basic_istream<char_type, traits_type>::operator=(std::move(__rhs));
            __sb_ = std::move(__rhs.__sb_);
            return *this;
        }

        void swap(basic_istringstream &__rhs)
        {
            basic_istream<char_type, traits_type>::swap(__rhs);
            __sb_.swap(__rhs.__sb_);
        }

        basic_stringbuf<char_type, traits_type, allocator_type> *rdbuf() const
        {
            return const_cast<basic_stringbuf<char_type, traits_type, allocator_type> *>(&__sb_);
        }

        string_type str() const
        {
            return __sb_.str();
        }

        void str(const string_type &__s)
        {
            __sb_.str(__s);
        }
};
template <class _CharT, class _Traits, class _Allocator>
inline void
swap(basic_istringstream<_CharT, _Traits, _Allocator> &__x,
     basic_istringstream<_CharT, _Traits, _Allocator> &__y)
{
        __x.swap(__y);
}
template <class _CharT, class _Traits, class _Allocator>
class basic_ostringstream
    : public basic_ostream<_CharT, _Traits>
{
    public:
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef _Allocator allocator_type;
        typedef basic_string<char_type, traits_type, allocator_type> string_type;

    private:
        basic_stringbuf<char_type, traits_type, allocator_type> __sb_;

    public:
        basic_ostringstream()
            : basic_ostream<_CharT, _Traits>(&__sb_), __sb_(ios_base::out) {}

        explicit basic_ostringstream(ios_base::openmode __wch)
            : basic_ostream<_CharT, _Traits>(&__sb_), __sb_(__wch | ios_base::out) {}

        explicit basic_ostringstream(const string_type &__s,
                                     ios_base::openmode __wch = ios_base::out)
            : basic_ostream<_CharT, _Traits>(&__sb_), __sb_(__s, __wch | ios_base::out)
        {
        }

        basic_ostringstream(basic_ostringstream &&__rhs)
            : basic_ostream<_CharT, _Traits>(std::move(__rhs)), __sb_(std::move(__rhs.__sb_))
        {
            basic_ostream<_CharT, _Traits>::set_rdbuf(&__sb_);
        }
        basic_ostringstream &operator=(basic_ostringstream &&__rhs)
        {
            basic_ostream<char_type, traits_type>::operator=(std::move(__rhs));
            __sb_ = std::move(__rhs.__sb_);
            return *this;
        }

        void swap(basic_ostringstream &__rhs)
        {
            basic_ostream<char_type, traits_type>::swap(__rhs);
            __sb_.swap(__rhs.__sb_);
        }

        basic_stringbuf<char_type, traits_type, allocator_type> *rdbuf() const
        {
            return const_cast<basic_stringbuf<char_type, traits_type, allocator_type> *>(&__sb_);
        }

        string_type str() const
        {
            return __sb_.str();
        }

        void str(const string_type &__s)
        {
            __sb_.str(__s);
        }
};
template <class _CharT, class _Traits, class _Allocator>
inline void
swap(basic_ostringstream<_CharT, _Traits, _Allocator> &__x,
     basic_ostringstream<_CharT, _Traits, _Allocator> &__y)
{
        __x.swap(__y);
}
template <class _CharT, class _Traits, class _Allocator>
class basic_stringstream
    : public basic_iostream<_CharT, _Traits>
{
    public:
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef _Allocator allocator_type;
        typedef basic_string<char_type, traits_type, allocator_type> string_type;

    private:
        basic_stringbuf<char_type, traits_type, allocator_type> __sb_;

    public:
        basic_stringstream()
            : basic_iostream<_CharT, _Traits>(&__sb_), __sb_(ios_base::in | ios_base::out) {}

        explicit basic_stringstream(ios_base::openmode __wch)
            : basic_iostream<_CharT, _Traits>(&__sb_), __sb_(__wch) {}

        explicit basic_stringstream(const string_type &__s,
                                    ios_base::openmode __wch = ios_base::in | ios_base::out)
            : basic_iostream<_CharT, _Traits>(&__sb_), __sb_(__s, __wch)
        {
        }

        basic_stringstream(basic_stringstream &&__rhs)
            : basic_iostream<_CharT, _Traits>(std::move(__rhs)), __sb_(std::move(__rhs.__sb_))
        {
            basic_istream<_CharT, _Traits>::set_rdbuf(&__sb_);
        }
        basic_stringstream &operator=(basic_stringstream &&__rhs)
        {
            basic_iostream<char_type, traits_type>::operator=(std::move(__rhs));
            __sb_ = std::move(__rhs.__sb_);
            return *this;
        }

        void swap(basic_stringstream &__rhs)
        {
            basic_iostream<char_type, traits_type>::swap(__rhs);
            __sb_.swap(__rhs.__sb_);
        }

        basic_stringbuf<char_type, traits_type, allocator_type> *rdbuf() const
        {
            return const_cast<basic_stringbuf<char_type, traits_type, allocator_type> *>(&__sb_);
        }

        string_type str() const
        {
            return __sb_.str();
        }

        void str(const string_type &__s)
        {
            __sb_.str(__s);
        }
};
template <class _CharT, class _Traits, class _Allocator>
inline void
swap(basic_stringstream<_CharT, _Traits, _Allocator> &__x,
     basic_stringstream<_CharT, _Traits, _Allocator> &__y)
{
        __x.swap(__y);
}
extern template class basic_stringbuf<char>;
extern template class basic_stringstream<char>;
extern template class basic_ostringstream<char>;
extern template class basic_istringstream<char>;
    }
}
namespace boost
{
    namespace date_time
    {
template <class date_type>
class year_based_generator
{
    public:
        typedef typename date_type::calendar_type calendar_type;
        typedef typename calendar_type::year_type year_type;
        year_based_generator() {}
        virtual ~year_based_generator() {}
        virtual date_type get_date(year_type y) const = 0;
        virtual std::string to_string() const = 0;
};
template <class date_type>
class partial_date : public year_based_generator<date_type>
{
    public:
        typedef typename date_type::calendar_type calendar_type;
        typedef typename calendar_type::day_type day_type;
        typedef typename calendar_type::month_type month_type;
        typedef typename calendar_type::year_type year_type;
        typedef typename date_type::duration_type duration_type;
        typedef typename duration_type::duration_rep duration_rep;
        partial_date(day_type d, month_type m) : day_(d),
                                                 month_(m)
        {
        }
        partial_date(duration_rep days) : day_(1),
                                          month_(1)
        {
            date_type d1(2000, 1, 1);
            if (days > 1)
            {
                if (days > 366)
                {
                    days = 366;
                }
                days = days - 1;
                duration_type dd(days);
                d1 = d1 + dd;
            }
            day_ = d1.day();
            month_ = d1.month();
        }
        date_type get_date(year_type y) const
        {
            if ((day_ == 29) && (month_ == 2) && !(calendar_type::is_leap_year(y)))
            {
                std::ostringstream ss;
                ss << "No Feb 29th in given year of " << y << ".";
                boost::throw_exception(std::invalid_argument(ss.str()));
            }
            return date_type(y, month_, day_);
        }
        date_type operator()(year_type y) const
        {
            return get_date(y);
        }
        bool operator==(const partial_date &rhs) const
        {
            return (month_ == rhs.month_) && (day_ == rhs.day_);
        }
        bool operator<(const partial_date &rhs) const
        {
            if (month_ < rhs.month_)
                return true;
            if (month_ > rhs.month_)
                return false;
            return (day_ < rhs.day_);
        }
        month_type month() const
        {
            return month_;
        }
        day_type day() const
        {
            return day_;
        }
        std::string to_string() const
        {
            std::ostringstream ss;
            date_type d(2004, month_, day_);
            unsigned short c = d.day_of_year();
            c--;
            ss << c;
            return ss.str();
        }

    private:
        day_type day_;
        month_type month_;
};
inline const char *nth_as_str(int ele)
{
        static const char *const _nth_as_str[] = {"out of range", "first", "second",
                                                  "third", "fourth", "fifth"};
        if (ele >= 1 && ele <= 5)
        {
            return _nth_as_str[ele];
        }
        else
        {
            return _nth_as_str[0];
        }
}
template <class date_type>
class nth_kday_of_month : public year_based_generator<date_type>
{
    public:
        typedef typename date_type::calendar_type calendar_type;
        typedef typename calendar_type::day_of_week_type day_of_week_type;
        typedef typename calendar_type::month_type month_type;
        typedef typename calendar_type::year_type year_type;
        typedef typename date_type::duration_type duration_type;
        enum week_num
        {
            first = 1,
            second,
            third,
            fourth,
            fifth
        };
        nth_kday_of_month(week_num week_no,
                          day_of_week_type dow,
                          month_type m) : month_(m),
                                          wn_(week_no),
                                          dow_(dow)
        {
        }
        date_type get_date(year_type y) const
        {
            date_type d(y, month_, 1);
            duration_type one_day(1);
            duration_type one_week(7);
            while (dow_ != d.day_of_week())
            {
                d = d + one_day;
            }
            int week = 1;
            while (week < wn_)
            {
                d = d + one_week;
                week++;
            }
            if (d.month() != month_)
            {
                d = d - one_week;
            }
            return d;
        }
        month_type month() const
        {
            return month_;
        }
        week_num nth_week() const
        {
            return wn_;
        }
        day_of_week_type day_of_week() const
        {
            return dow_;
        }
        const char *nth_week_as_str() const
        {
            return nth_as_str(wn_);
        }
        std::string to_string() const
        {
            std::ostringstream ss;
            ss << 'M'
               << static_cast<int>(month_) << '.'
               << static_cast<int>(wn_) << '.'
               << static_cast<int>(dow_);
            return ss.str();
        }

    private:
        month_type month_;
        week_num wn_;
        day_of_week_type dow_;
};
template <class date_type>
class first_kday_of_month : public year_based_generator<date_type>
{
    public:
        typedef typename date_type::calendar_type calendar_type;
        typedef typename calendar_type::day_of_week_type day_of_week_type;
        typedef typename calendar_type::month_type month_type;
        typedef typename calendar_type::year_type year_type;
        typedef typename date_type::duration_type duration_type;
        first_kday_of_month(day_of_week_type dow, month_type m) : month_(m),
                                                                  dow_(dow)
        {
        }
        date_type get_date(year_type year) const
        {
            date_type d(year, month_, 1);
            duration_type one_day(1);
            while (dow_ != d.day_of_week())
            {
                d = d + one_day;
            }
            return d;
        }
        month_type month() const
        {
            return month_;
        }
        day_of_week_type day_of_week() const
        {
            return dow_;
        }
        std::string to_string() const
        {
            std::ostringstream ss;
            ss << 'M'
               << static_cast<int>(month_) << '.'
               << 1 << '.'
               << static_cast<int>(dow_);
            return ss.str();
        }

    private:
        month_type month_;
        day_of_week_type dow_;
};
template <class date_type>
class last_kday_of_month : public year_based_generator<date_type>
{
    public:
        typedef typename date_type::calendar_type calendar_type;
        typedef typename calendar_type::day_of_week_type day_of_week_type;
        typedef typename calendar_type::month_type month_type;
        typedef typename calendar_type::year_type year_type;
        typedef typename date_type::duration_type duration_type;
        last_kday_of_month(day_of_week_type dow, month_type m) : month_(m),
                                                                 dow_(dow)
        {
        }
        date_type get_date(year_type year) const
        {
            date_type d(year, month_, calendar_type::end_of_month_day(year, month_));
            duration_type one_day(1);
            while (dow_ != d.day_of_week())
            {
                d = d - one_day;
            }
            return d;
        }
        month_type month() const
        {
            return month_;
        }
        day_of_week_type day_of_week() const
        {
            return dow_;
        }
        std::string to_string() const
        {
            std::ostringstream ss;
            ss << 'M'
               << static_cast<int>(month_) << '.'
               << 5 << '.'
               << static_cast<int>(dow_);
            return ss.str();
        }

    private:
        month_type month_;
        day_of_week_type dow_;
};
template <class date_type>
class first_kday_after
{
    public:
        typedef typename date_type::calendar_type calendar_type;
        typedef typename calendar_type::day_of_week_type day_of_week_type;
        typedef typename date_type::duration_type duration_type;
        first_kday_after(day_of_week_type dow) : dow_(dow)
        {
        }
        date_type get_date(date_type start_day) const
        {
            duration_type one_day(1);
            date_type d = start_day + one_day;
            while (dow_ != d.day_of_week())
            {
                d = d + one_day;
            }
            return d;
        }
        day_of_week_type day_of_week() const
        {
            return dow_;
        }

    private:
        day_of_week_type dow_;
};
template <class date_type>
class first_kday_before
{
    public:
        typedef typename date_type::calendar_type calendar_type;
        typedef typename calendar_type::day_of_week_type day_of_week_type;
        typedef typename date_type::duration_type duration_type;
        first_kday_before(day_of_week_type dow) : dow_(dow)
        {
        }
        date_type get_date(date_type start_day) const
        {
            duration_type one_day(1);
            date_type d = start_day - one_day;
            while (dow_ != d.day_of_week())
            {
                d = d - one_day;
            }
            return d;
        }
        day_of_week_type day_of_week() const
        {
            return dow_;
        }

    private:
        day_of_week_type dow_;
};
template <typename date_type, class weekday_type>
inline
    typename date_type::duration_type
    days_until_weekday(const date_type &d, const weekday_type &wd)
{
        typedef typename date_type::duration_type duration_type;
        duration_type wks(0);
        duration_type dd(wd.as_number() - d.day_of_week().as_number());
        if (dd.is_negative())
        {
            wks = duration_type(7);
        }
        return dd + wks;
}
template <typename date_type, class weekday_type>
inline
    typename date_type::duration_type
    days_before_weekday(const date_type &d, const weekday_type &wd)
{
        typedef typename date_type::duration_type duration_type;
        duration_type wks(0);
        duration_type dd(wd.as_number() - d.day_of_week().as_number());
        if (dd.days() > 0)
        {
            wks = duration_type(7);
        }
        return (-dd + wks);
}
template <class date_type, class weekday_type>
inline date_type next_weekday(const date_type &d, const weekday_type &wd)
{
        return d + days_until_weekday(d, wd);
}
template <class date_type, class weekday_type>
inline date_type previous_weekday(const date_type &d, const weekday_type &wd)
{
        return d - days_before_weekday(d, wd);
}
    }
}
struct timeval64
{
    __int64_t tv_sec;
    __int64_t tv_usec;
};
struct itimerval
{
    struct timeval it_interval;
    struct timeval it_value;
};
struct timezone
{
    int tz_minuteswest;
    int tz_dsttime;
};
struct clockinfo
{
    int hz;
    int tick;
    int tickadj;
    int stathz;
    int profhz;
};
extern "C"
{
    int adjtime(const struct timeval *, struct timeval *);
    int futimes(int, const struct timeval *);
    int lutimes(const char *, const struct timeval *);
    int settimeofday(const struct timeval *, const struct timezone *);
    int getitimer(int, struct itimerval *);
    int gettimeofday(struct timeval *, void *);
    int setitimer(int, const struct itimerval *,
                  struct itimerval *);
    int utimes(const char *, const struct timeval *);
}
namespace boost
{
    namespace date_time
    {
struct c_time
{
    public:
        inline static std::tm *localtime(const std::time_t *t, std::tm *result)
        {
            result = localtime_r(t, result);
            if (!result)
                boost::throw_exception(std::runtime_error("could not convert calendar time to local time"));
            return result;
        }
        inline static std::tm *gmtime(const std::time_t *t, std::tm *result)
        {
            result = gmtime_r(t, result);
            if (!result)
                boost::throw_exception(std::runtime_error("could not convert calendar time to UTC time"));
            return result;
        }
};
    }
}
namespace boost
{
    namespace date_time
    {
template <class date_type>
class day_clock
{
    public:
        typedef typename date_type::ymd_type ymd_type;
        static date_type local_day()
        {
            return date_type(local_day_ymd());
        }
        static typename date_type::ymd_type local_day_ymd()
        {
            ::std::tm result;
            ::std::tm *curr = get_local_time(result);
            return ymd_type(static_cast<unsigned short>(curr->tm_year + 1900),
                            static_cast<unsigned short>(curr->tm_mon + 1),
                            static_cast<unsigned short>(curr->tm_mday));
        }
        static typename date_type::ymd_type universal_day_ymd()
        {
            ::std::tm result;
            ::std::tm *curr = get_universal_time(result);
            return ymd_type(static_cast<unsigned short>(curr->tm_year + 1900),
                            static_cast<unsigned short>(curr->tm_mon + 1),
                            static_cast<unsigned short>(curr->tm_mday));
        }
        static date_type universal_day()
        {
            return date_type(universal_day_ymd());
        }

    private:
        static ::std::tm *get_local_time(std::tm &result)
        {
            ::std::time_t t;
            ::std::time(&t);
            return c_time::localtime(&t, &result);
        }
        static ::std::tm *get_universal_time(std::tm &result)
        {
            ::std::time_t t;
            ::std::time(&t);
            return c_time::gmtime(&t, &result);
        }
};
    }
}
namespace boost
{
    namespace date_time
    {
enum date_resolutions
{
    day,
    week,
    months,
    year,
    decade,
    century,
    NumDateResolutions
};
template <class date_type>
class date_itr_base
{
    public:
        typedef typename date_type::duration_type duration_type;
        typedef date_type value_type;
        typedef std::input_iterator_tag iterator_category;
        date_itr_base(date_type d) : current_(d) {}
        virtual ~date_itr_base() {}
        date_itr_base &operator++()
        {
            current_ = current_ + get_offset(current_);
            return *this;
        }
        date_itr_base &operator--()
        {
            current_ = current_ + get_neg_offset(current_);
            return *this;
        }
        virtual duration_type get_offset(const date_type &current) const = 0;
        virtual duration_type get_neg_offset(const date_type &current) const = 0;
        const date_type &operator*() const { return current_; }
        const date_type *operator->() const { return &current_; }
        bool operator<(const date_type &d) const { return current_ < d; }
        bool operator<=(const date_type &d) const { return current_ <= d; }
        bool operator>(const date_type &d) const { return current_ > d; }
        bool operator>=(const date_type &d) const { return current_ >= d; }
        bool operator==(const date_type &d) const { return current_ == d; }
        bool operator!=(const date_type &d) const { return current_ != d; }

    private:
        date_type current_;
};
template <class offset_functor, class date_type>
class date_itr : public date_itr_base<date_type>
{
    public:
        typedef typename date_type::duration_type duration_type;
        date_itr(date_type d, int factor = 1) : date_itr_base<date_type>(d),
                                                of_(factor)
        {
        }

    private:
        virtual duration_type get_offset(const date_type &current) const
        {
            return of_.get_offset(current);
        }
        virtual duration_type get_neg_offset(const date_type &current) const
        {
            return of_.get_neg_offset(current);
        }
        offset_functor of_;
};
    }
}
namespace boost
{
    namespace gregorian
    {
typedef date_time::period<date, date_duration> date_period;
typedef date_time::year_based_generator<date> year_based_generator;
typedef date_time::partial_date<date> partial_date;
typedef date_time::nth_kday_of_month<date> nth_kday_of_month;
typedef nth_kday_of_month nth_day_of_the_week_in_month;
typedef date_time::first_kday_of_month<date> first_kday_of_month;
typedef first_kday_of_month first_day_of_the_week_in_month;
typedef date_time::last_kday_of_month<date> last_kday_of_month;
typedef last_kday_of_month last_day_of_the_week_in_month;
typedef date_time::first_kday_after<date> first_kday_after;
typedef first_kday_after first_day_of_the_week_after;
typedef date_time::first_kday_before<date> first_kday_before;
typedef first_kday_before first_day_of_the_week_before;
typedef date_time::day_clock<date> day_clock;
typedef date_time::date_itr_base<date> date_iterator;
typedef date_time::date_itr<date_time::day_functor<date>,
                            date>
    day_iterator;
typedef date_time::date_itr<date_time::week_functor<date>,
                            date>
    week_iterator;
typedef date_time::date_itr<date_time::month_functor<date>,
                            date>
    month_iterator;
typedef date_time::date_itr<date_time::year_functor<date>,
                            date>
    year_iterator;
using date_time::days_before_weekday;
using date_time::days_until_weekday;
using date_time::next_weekday;
using date_time::previous_weekday;
    }
}
namespace boost
{
    namespace gregorian
    {
inline std::tm to_tm(const date &d)
{
        if (d.is_special())
        {
            std::string s = "tm unable to handle ";
            switch (d.as_special())
            {
            case date_time::not_a_date_time:
                s += "not-a-date-time value";
                break;
            case date_time::neg_infin:
                s += "-infinity date value";
                break;
            case date_time::pos_infin:
                s += "+infinity date value";
                break;
            default:
                s += "a special date value";
                break;
            }
            boost::throw_exception(std::out_of_range(s));
        }
        std::tm datetm;
        std::memset(&datetm, 0, sizeof(datetm));
        boost::gregorian::date::ymd_type ymd = d.year_month_day();
        datetm.tm_year = ymd.year - 1900;
        datetm.tm_mon = ymd.month - 1;
        datetm.tm_mday = ymd.day;
        datetm.tm_wday = d.day_of_week();
        datetm.tm_yday = d.day_of_year() - 1;
        datetm.tm_isdst = -1;
        return datetm;
}
inline date date_from_tm(const std::tm &datetm)
{
        return date(static_cast<unsigned short>(datetm.tm_year + 1900),
                    static_cast<unsigned short>(datetm.tm_mon + 1),
                    static_cast<unsigned short>(datetm.tm_mday));
}
    }
}
namespace boost
{
    namespace date_time
    {
enum month_format_spec
{
    month_as_integer,
    month_as_short_string,
    month_as_long_string
};
enum ymd_order_spec
{
    ymd_order_iso,
    ymd_order_dmy,
    ymd_order_us
};
    }
}

namespace boost
{
    namespace date_time
    {
template <class charT>
class iso_format_base
{
    public:
        static month_format_spec month_format()
        {
            return month_as_integer;
        }
        static const charT *not_a_date()
        {
            return "not-a-date-time";
        }
        static const charT *pos_infinity()
        {
            return "+infinity";
        }
        static const charT *neg_infinity()
        {
            return "-infinity";
        }
        static charT year_sep_char()
        {
            return 'Y';
        }
        static charT month_sep_char()
        {
            return '-';
        }
        static charT day_sep_char()
        {
            return '-';
        }
        static charT hour_sep_char()
        {
            return ':';
        }
        static charT minute_sep_char()
        {
            return ':';
        }
        static charT second_sep_char()
        {
            return ':';
        }
        static charT period_start_char()
        {
            return 'P';
        }
        static charT time_start_char()
        {
            return 'T';
        }
        static charT week_start_char()
        {
            return 'W';
        }
        static charT period_sep_char()
        {
            return '/';
        }
        static charT time_sep_char()
        {
            return ':';
        }
        static charT fractional_time_sep_char()
        {
            return ',';
        }
        static bool is_component_sep(charT sep)
        {
            switch (sep)
            {
            case 'H':
            case 'M':
            case 'S':
            case 'W':
            case 'T':
            case 'Y':
            case 'D':
                return true;
            default:
                return false;
            }
        }
        static bool is_fractional_time_sep(charT sep)
        {
            switch (sep)
            {
            case ',':
            case '.':
                return true;
            default:
                return false;
            }
        }
        static bool is_timezone_sep(charT sep)
        {
            switch (sep)
            {
            case '+':
            case '-':
                return true;
            default:
                return false;
            }
        }
        static charT element_sep_char()
        {
            return '-';
        }
};
template <>
class iso_format_base<wchar_t>
{
    public:
        static month_format_spec month_format()
        {
            return month_as_integer;
        }
        static const wchar_t *not_a_date()
        {
            return L"not-a-date-time";
        }
        static const wchar_t *pos_infinity()
        {
            return L"+infinity";
        }
        static const wchar_t *neg_infinity()
        {
            return L"-infinity";
        }
        static wchar_t year_sep_char()
        {
            return 'Y';
        }
        static wchar_t month_sep_char()
        {
            return '-';
        }
        static wchar_t day_sep_char()
        {
            return '-';
        }
        static wchar_t hour_sep_char()
        {
            return ':';
        }
        static wchar_t minute_sep_char()
        {
            return ':';
        }
        static wchar_t second_sep_char()
        {
            return ':';
        }
        static wchar_t period_start_char()
        {
            return 'P';
        }
        static wchar_t time_start_char()
        {
            return 'T';
        }
        static wchar_t week_start_char()
        {
            return 'W';
        }
        static wchar_t period_sep_char()
        {
            return '/';
        }
        static wchar_t time_sep_char()
        {
            return ':';
        }
        static wchar_t fractional_time_sep_char()
        {
            return ',';
        }
        static bool is_component_sep(wchar_t sep)
        {
            switch (sep)
            {
            case 'H':
            case 'M':
            case 'S':
            case 'W':
            case 'T':
            case 'Y':
            case 'D':
                return true;
            default:
                return false;
            }
        }
        static bool is_fractional_time_sep(wchar_t sep)
        {
            switch (sep)
            {
            case ',':
            case '.':
                return true;
            default:
                return false;
            }
        }
        static bool is_timezone_sep(wchar_t sep)
        {
            switch (sep)
            {
            case '+':
            case '-':
                return true;
            default:
                return false;
            }
        }
        static wchar_t element_sep_char()
        {
            return '-';
        }
};
template <class charT>
class iso_format : public iso_format_base<charT>
{
    public:
        static bool has_date_sep_chars()
        {
            return false;
        }
};
template <class charT>
class iso_extended_format : public iso_format_base<charT>
{
    public:
        static bool has_date_sep_chars()
        {
            return true;
        }
};
    }
}

namespace boost
{
    namespace io
    {
class ios_flags_saver;
class ios_precision_saver;
class ios_width_saver;
class ios_base_all_saver;
template <class Ch, class Tr = std::char_traits<Ch>>
class basic_ios_iostate_saver;
template <class Ch, class Tr = std::char_traits<Ch>>
class basic_ios_exception_saver;
template <class Ch, class Tr = std::char_traits<Ch>>
class basic_ios_tie_saver;
template <class Ch, class Tr = std::char_traits<Ch>>
class basic_ios_rdbuf_saver;
template <class Ch, class Tr = std::char_traits<Ch>>
class basic_ios_fill_saver;
template <class Ch, class Tr = std::char_traits<Ch>>
class basic_ios_locale_saver;
template <class Ch, class Tr = std::char_traits<Ch>>
class basic_ios_all_saver;
typedef basic_ios_iostate_saver<char> ios_iostate_saver;
typedef basic_ios_iostate_saver<wchar_t> wios_iostate_saver;
typedef basic_ios_exception_saver<char> ios_exception_saver;
typedef basic_ios_exception_saver<wchar_t> wios_exception_saver;
typedef basic_ios_tie_saver<char> ios_tie_saver;
typedef basic_ios_tie_saver<wchar_t> wios_tie_saver;
typedef basic_ios_rdbuf_saver<char> ios_rdbuf_saver;
typedef basic_ios_rdbuf_saver<wchar_t> wios_rdbuf_saver;
typedef basic_ios_fill_saver<char> ios_fill_saver;
typedef basic_ios_fill_saver<wchar_t> wios_fill_saver;
typedef basic_ios_locale_saver<char> ios_locale_saver;
typedef basic_ios_locale_saver<wchar_t> wios_locale_saver;
typedef basic_ios_all_saver<char> ios_all_saver;
typedef basic_ios_all_saver<wchar_t> wios_all_saver;
class ios_iword_saver;
class ios_pword_saver;
class ios_all_word_saver;
    }
}
namespace boost
{
    namespace io
    {
class ios_flags_saver
{
    public:
        typedef std::ios_base state_type;
        typedef std::ios_base::fmtflags aspect_type;
        explicit ios_flags_saver(state_type &s)
            : s_save_(s), a_save_(s.flags()) {}
        ios_flags_saver(state_type &s, aspect_type a)
            : s_save_(s), a_save_(s.flags(a)) {}
        ~ios_flags_saver()
        {
            this->restore();
        }
        void restore()
        {
            s_save_.flags(a_save_);
        }

    private:
        ios_flags_saver(const ios_flags_saver &);
        ios_flags_saver &operator=(const ios_flags_saver &);
        state_type &s_save_;
        aspect_type a_save_;
};
class ios_precision_saver
{
    public:
        typedef std::ios_base state_type;
        typedef std::streamsize aspect_type;
        explicit ios_precision_saver(state_type &s)
            : s_save_(s), a_save_(s.precision()) {}
        ios_precision_saver(state_type &s, aspect_type a)
            : s_save_(s), a_save_(s.precision(a)) {}
        ~ios_precision_saver()
        {
            this->restore();
        }
        void restore()
        {
            s_save_.precision(a_save_);
        }

    private:
        ios_precision_saver(const ios_precision_saver &);
        ios_precision_saver &operator=(const ios_precision_saver &);
        state_type &s_save_;
        aspect_type a_save_;
};
class ios_width_saver
{
    public:
        typedef std::ios_base state_type;
        typedef std::streamsize aspect_type;
        explicit ios_width_saver(state_type &s)
            : s_save_(s), a_save_(s.width()) {}
        ios_width_saver(state_type &s, aspect_type a)
            : s_save_(s), a_save_(s.width(a)) {}
        ~ios_width_saver()
        {
            this->restore();
        }
        void restore()
        {
            s_save_.width(a_save_);
        }

    private:
        ios_width_saver(const ios_width_saver &);
        ios_width_saver &operator=(const ios_width_saver &);
        state_type &s_save_;
        aspect_type a_save_;
};
template <class Ch, class Tr>
class basic_ios_iostate_saver
{
    public:
        typedef std::basic_ios<Ch, Tr> state_type;
        typedef std::ios_base::iostate aspect_type;
        explicit basic_ios_iostate_saver(state_type &s)
            : s_save_(s), a_save_(s.rdstate()) {}
        basic_ios_iostate_saver(state_type &s, aspect_type a)
            : s_save_(s), a_save_(s.rdstate())
        {
            s.clear(a);
        }
        ~basic_ios_iostate_saver()
        {
            this->restore();
        }
        void restore()
        {
            s_save_.clear(a_save_);
        }

    private:
        basic_ios_iostate_saver(const basic_ios_iostate_saver &);
        basic_ios_iostate_saver &operator=(const basic_ios_iostate_saver &);
        state_type &s_save_;
        aspect_type a_save_;
};
template <class Ch, class Tr>
class basic_ios_exception_saver
{
    public:
        typedef std::basic_ios<Ch, Tr> state_type;
        typedef std::ios_base::iostate aspect_type;
        explicit basic_ios_exception_saver(state_type &s)
            : s_save_(s), a_save_(s.exceptions()) {}
        basic_ios_exception_saver(state_type &s, aspect_type a)
            : s_save_(s), a_save_(s.exceptions())
        {
            s.exceptions(a);
        }
        ~basic_ios_exception_saver()
        {
            this->restore();
        }
        void restore()
        {
            s_save_.exceptions(a_save_);
        }

    private:
        basic_ios_exception_saver(const basic_ios_exception_saver &);
        basic_ios_exception_saver &operator=(const basic_ios_exception_saver &);
        state_type &s_save_;
        aspect_type a_save_;
};
template <class Ch, class Tr>
class basic_ios_tie_saver
{
    public:
        typedef std::basic_ios<Ch, Tr> state_type;
        typedef std::basic_ostream<Ch, Tr> *aspect_type;
        explicit basic_ios_tie_saver(state_type &s)
            : s_save_(s), a_save_(s.tie()) {}
        basic_ios_tie_saver(state_type &s, aspect_type a)
            : s_save_(s), a_save_(s.tie(a)) {}
        ~basic_ios_tie_saver()
        {
            this->restore();
        }
        void restore()
        {
            s_save_.tie(a_save_);
        }

    private:
        basic_ios_tie_saver(const basic_ios_tie_saver &);
        basic_ios_tie_saver &operator=(const basic_ios_tie_saver &);
        state_type &s_save_;
        aspect_type a_save_;
};
template <class Ch, class Tr>
class basic_ios_rdbuf_saver
{
    public:
        typedef std::basic_ios<Ch, Tr> state_type;
        typedef std::basic_streambuf<Ch, Tr> *aspect_type;
        explicit basic_ios_rdbuf_saver(state_type &s)
            : s_save_(s), a_save_(s.rdbuf()) {}
        basic_ios_rdbuf_saver(state_type &s, aspect_type a)
            : s_save_(s), a_save_(s.rdbuf(a)) {}
        ~basic_ios_rdbuf_saver()
        {
            this->restore();
        }
        void restore()
        {
            s_save_.rdbuf(a_save_);
        }

    private:
        basic_ios_rdbuf_saver(const basic_ios_rdbuf_saver &);
        basic_ios_rdbuf_saver &operator=(const basic_ios_rdbuf_saver &);
        state_type &s_save_;
        aspect_type a_save_;
};
template <class Ch, class Tr>
class basic_ios_fill_saver
{
    public:
        typedef std::basic_ios<Ch, Tr> state_type;
        typedef typename state_type::char_type aspect_type;
        explicit basic_ios_fill_saver(state_type &s)
            : s_save_(s), a_save_(s.fill()) {}
        basic_ios_fill_saver(state_type &s, aspect_type a)
            : s_save_(s), a_save_(s.fill(a)) {}
        ~basic_ios_fill_saver()
        {
            this->restore();
        }
        void restore()
        {
            s_save_.fill(a_save_);
        }

    private:
        basic_ios_fill_saver(const basic_ios_fill_saver &);
        basic_ios_fill_saver &operator=(const basic_ios_fill_saver &);
        state_type &s_save_;
        aspect_type a_save_;
};
template <class Ch, class Tr>
class basic_ios_locale_saver
{
    public:
        typedef std::basic_ios<Ch, Tr> state_type;
        typedef std::locale aspect_type;
        explicit basic_ios_locale_saver(state_type &s)
            : s_save_(s), a_save_(s.getloc()) {}
        basic_ios_locale_saver(state_type &s, const aspect_type &a)
            : s_save_(s), a_save_(s.imbue(a)) {}
        ~basic_ios_locale_saver()
        {
            this->restore();
        }
        void restore()
        {
            s_save_.imbue(a_save_);
        }

    private:
        basic_ios_locale_saver(const basic_ios_locale_saver &);
        basic_ios_locale_saver &operator=(const basic_ios_locale_saver &);
        state_type &s_save_;
        aspect_type a_save_;
};
class ios_iword_saver
{
    public:
        typedef std::ios_base state_type;
        typedef int index_type;
        typedef long aspect_type;
        explicit ios_iword_saver(state_type &s, index_type i)
            : s_save_(s), a_save_(s.iword(i)), i_save_(i) {}
        ios_iword_saver(state_type &s, index_type i, aspect_type a)
            : s_save_(s), a_save_(s.iword(i)), i_save_(i)
        {
            s.iword(i) = a;
        }
        ~ios_iword_saver()
        {
            this->restore();
        }
        void restore()
        {
            s_save_.iword(i_save_) = a_save_;
        }

    private:
        ios_iword_saver(const ios_iword_saver &);
        ios_iword_saver &operator=(const ios_iword_saver &);
        state_type &s_save_;
        aspect_type a_save_;
        index_type i_save_;
};
class ios_pword_saver
{
    public:
        typedef std::ios_base state_type;
        typedef int index_type;
        typedef void *aspect_type;
        explicit ios_pword_saver(state_type &s, index_type i)
            : s_save_(s), a_save_(s.pword(i)), i_save_(i) {}
        ios_pword_saver(state_type &s, index_type i, aspect_type a)
            : s_save_(s), a_save_(s.pword(i)), i_save_(i)
        {
            s.pword(i) = a;
        }
        ~ios_pword_saver()
        {
            this->restore();
        }
        void restore()
        {
            s_save_.pword(i_save_) = a_save_;
        }

    private:
        ios_pword_saver(const ios_pword_saver &);
        ios_pword_saver operator=(const ios_pword_saver &);
        state_type &s_save_;
        aspect_type a_save_;
        index_type i_save_;
};
class ios_base_all_saver
{
    public:
        typedef std::ios_base state_type;
        explicit ios_base_all_saver(state_type &s)
            : s_save_(s), a1_save_(s.flags()), a2_save_(s.precision()), a3_save_(s.width()) {}
        ~ios_base_all_saver()
        {
            this->restore();
        }
        void restore()
        {
            s_save_.width(a3_save_);
            s_save_.precision(a2_save_);
            s_save_.flags(a1_save_);
        }

    private:
        ios_base_all_saver(const ios_base_all_saver &);
        ios_base_all_saver &operator=(const ios_base_all_saver &);
        state_type &s_save_;
        state_type::fmtflags a1_save_;
        std::streamsize a2_save_;
        std::streamsize a3_save_;
};
template <class Ch, class Tr>
class basic_ios_all_saver
{
    public:
        typedef std::basic_ios<Ch, Tr> state_type;
        explicit basic_ios_all_saver(state_type &s)
            : s_save_(s), a1_save_(s.flags()), a2_save_(s.precision()), a3_save_(s.width()), a4_save_(s.rdstate()), a5_save_(s.exceptions()), a6_save_(s.tie()), a7_save_(s.rdbuf()), a8_save_(s.fill()), a9_save_(s.getloc())
        {
        }
        ~basic_ios_all_saver()
        {
            this->restore();
        }
        void restore()
        {
            s_save_.imbue(a9_save_);
            s_save_.fill(a8_save_);
            s_save_.rdbuf(a7_save_);
            s_save_.tie(a6_save_);
            s_save_.exceptions(a5_save_);
            s_save_.clear(a4_save_);
            s_save_.width(a3_save_);
            s_save_.precision(a2_save_);
            s_save_.flags(a1_save_);
        }

    private:
        basic_ios_all_saver(const basic_ios_all_saver &);
        basic_ios_all_saver &operator=(const basic_ios_all_saver &);
        state_type &s_save_;
        typename state_type::fmtflags a1_save_;
        std::streamsize a2_save_;
        std::streamsize a3_save_;
        typename state_type::iostate a4_save_;
        typename state_type::iostate a5_save_;
        std::basic_ostream<Ch, Tr> *a6_save_;
        std::basic_streambuf<Ch, Tr> *a7_save_;
        typename state_type::char_type a8_save_;
        std::locale a9_save_;
};
class ios_all_word_saver
{
    public:
        typedef std::ios_base state_type;
        typedef int index_type;
        ios_all_word_saver(state_type &s, index_type i)
            : s_save_(s), i_save_(i), a1_save_(s.iword(i)), a2_save_(s.pword(i)) {}
        ~ios_all_word_saver()
        {
            this->restore();
        }
        void restore()
        {
            s_save_.pword(i_save_) = a2_save_;
            s_save_.iword(i_save_) = a1_save_;
        }

    private:
        ios_all_word_saver(const ios_all_word_saver &);
        ios_all_word_saver &operator=(const ios_all_word_saver &);
        state_type &s_save_;
        index_type i_save_;
        long a1_save_;
        void *a2_save_;
};
    }
}
namespace std
{
    inline namespace __1
    {
class __iom_t1
{
        ios_base::fmtflags __mask_;

    public:
        explicit __iom_t1(ios_base::fmtflags __m) : __mask_(__m) {}
        template <class _CharT, class _Traits>
        friend

            basic_istream<_CharT, _Traits> &
            operator>>(basic_istream<_CharT, _Traits> &__is, const __iom_t1 &__x)
        {
            __is.unsetf(__x.__mask_);
            return __is;
        }
        template <class _CharT, class _Traits>
        friend

            basic_ostream<_CharT, _Traits> &
            operator<<(basic_ostream<_CharT, _Traits> &__os, const __iom_t1 &__x)
        {
            __os.unsetf(__x.__mask_);
            return __os;
        }
};
inline __iom_t1
resetiosflags(ios_base::fmtflags __mask)
{
        return __iom_t1(__mask);
}
class __iom_t2
{
        ios_base::fmtflags __mask_;

    public:
        explicit __iom_t2(ios_base::fmtflags __m) : __mask_(__m) {}
        template <class _CharT, class _Traits>
        friend

            basic_istream<_CharT, _Traits> &
            operator>>(basic_istream<_CharT, _Traits> &__is, const __iom_t2 &__x)
        {
            __is.setf(__x.__mask_);
            return __is;
        }
        template <class _CharT, class _Traits>
        friend

            basic_ostream<_CharT, _Traits> &
            operator<<(basic_ostream<_CharT, _Traits> &__os, const __iom_t2 &__x)
        {
            __os.setf(__x.__mask_);
            return __os;
        }
};
inline __iom_t2
setiosflags(ios_base::fmtflags __mask)
{
        return __iom_t2(__mask);
}
class __iom_t3
{
        int __base_;

    public:
        explicit __iom_t3(int __b) : __base_(__b) {}
        template <class _CharT, class _Traits>
        friend

            basic_istream<_CharT, _Traits> &
            operator>>(basic_istream<_CharT, _Traits> &__is, const __iom_t3 &__x)
        {
            __is.setf(__x.__base_ == 8 ? ios_base::oct : __x.__base_ == 10 ? ios_base::dec
                                                     : __x.__base_ == 16   ? ios_base::hex
                                                                           : ios_base::fmtflags(0),
                      ios_base::basefield);
            return __is;
        }
        template <class _CharT, class _Traits>
        friend

            basic_ostream<_CharT, _Traits> &
            operator<<(basic_ostream<_CharT, _Traits> &__os, const __iom_t3 &__x)
        {
            __os.setf(__x.__base_ == 8 ? ios_base::oct : __x.__base_ == 10 ? ios_base::dec
                                                     : __x.__base_ == 16   ? ios_base::hex
                                                                           : ios_base::fmtflags(0),
                      ios_base::basefield);
            return __os;
        }
};
inline __iom_t3
setbase(int __base)
{
        return __iom_t3(__base);
}
template <class _CharT>
class __iom_t4
{
        _CharT __fill_;

    public:
        explicit __iom_t4(_CharT __c) : __fill_(__c) {}
        template <class _Traits>
        friend

            basic_ostream<_CharT, _Traits> &
            operator<<(basic_ostream<_CharT, _Traits> &__os, const __iom_t4 &__x)
        {
            __os.fill(__x.__fill_);
            return __os;
        }
};
template <class _CharT>
inline __iom_t4<_CharT>
setfill(_CharT __c)
{
        return __iom_t4<_CharT>(__c);
}
class __iom_t5
{
        int __n_;

    public:
        explicit __iom_t5(int __n) : __n_(__n) {}
        template <class _CharT, class _Traits>
        friend

            basic_istream<_CharT, _Traits> &
            operator>>(basic_istream<_CharT, _Traits> &__is, const __iom_t5 &__x)
        {
            __is.precision(__x.__n_);
            return __is;
        }
        template <class _CharT, class _Traits>
        friend

            basic_ostream<_CharT, _Traits> &
            operator<<(basic_ostream<_CharT, _Traits> &__os, const __iom_t5 &__x)
        {
            __os.precision(__x.__n_);
            return __os;
        }
};
inline __iom_t5
setprecision(int __n)
{
        return __iom_t5(__n);
}
class __iom_t6
{
        int __n_;

    public:
        explicit __iom_t6(int __n) : __n_(__n) {}
        template <class _CharT, class _Traits>
        friend

            basic_istream<_CharT, _Traits> &
            operator>>(basic_istream<_CharT, _Traits> &__is, const __iom_t6 &__x)
        {
            __is.width(__x.__n_);
            return __is;
        }
        template <class _CharT, class _Traits>
        friend

            basic_ostream<_CharT, _Traits> &
            operator<<(basic_ostream<_CharT, _Traits> &__os, const __iom_t6 &__x)
        {
            __os.width(__x.__n_);
            return __os;
        }
};
inline __iom_t6
setw(int __n)
{
        return __iom_t6(__n);
}
template <class _MoneyT>
class __iom_t7;
template <class _CharT, class _Traits, class _MoneyT>
basic_istream<_CharT, _Traits> &
operator>>(basic_istream<_CharT, _Traits> &__is, const __iom_t7<_MoneyT> &__x);
template <class _MoneyT>
class __iom_t7
{
        _MoneyT &__mon_;
        bool __intl_;

    public:
        __iom_t7(_MoneyT &__mon, bool __intl)
            : __mon_(__mon), __intl_(__intl) {}
        template <class _CharT, class _Traits, class _Mp>
        friend basic_istream<_CharT, _Traits> &
        operator>>(basic_istream<_CharT, _Traits> &__is, const __iom_t7<_Mp> &__x);
};
template <class _CharT, class _Traits, class _MoneyT>
basic_istream<_CharT, _Traits> &
operator>>(basic_istream<_CharT, _Traits> &__is, const __iom_t7<_MoneyT> &__x)
{
        try
        {
            typename basic_istream<_CharT, _Traits>::sentry __s(__is);
            if (__s)
            {
                typedef istreambuf_iterator<_CharT, _Traits> _Ip;
                typedef money_get<_CharT, _Ip> _Fp;
                ios_base::iostate __err = ios_base::goodbit;
                const _Fp &__mf = use_facet<_Fp>(__is.getloc());
                __mf.get(_Ip(__is), _Ip(), __x.__intl_, __is, __err, __x.__mon_);
                __is.setstate(__err);
            }
        }
        catch (...)
        {
            __is.__set_badbit_and_consider_rethrow();
        }
        return __is;
}
template <class _MoneyT>
inline __iom_t7<_MoneyT>
get_money(_MoneyT &__mon, bool __intl = false)
{
        return __iom_t7<_MoneyT>(__mon, __intl);
}
template <class _MoneyT>
class __iom_t8;
template <class _CharT, class _Traits, class _MoneyT>
basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os, const __iom_t8<_MoneyT> &__x);
template <class _MoneyT>
class __iom_t8
{
        const _MoneyT &__mon_;
        bool __intl_;

    public:
        __iom_t8(const _MoneyT &__mon, bool __intl)
            : __mon_(__mon), __intl_(__intl) {}
        template <class _CharT, class _Traits, class _Mp>
        friend basic_ostream<_CharT, _Traits> &
        operator<<(basic_ostream<_CharT, _Traits> &__os, const __iom_t8<_Mp> &__x);
};
template <class _CharT, class _Traits, class _MoneyT>
basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os, const __iom_t8<_MoneyT> &__x)
{
        try
        {
            typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
            if (__s)
            {
                typedef ostreambuf_iterator<_CharT, _Traits> _Op;
                typedef money_put<_CharT, _Op> _Fp;
                const _Fp &__mf = use_facet<_Fp>(__os.getloc());
                if (__mf.put(_Op(__os), __x.__intl_, __os, __os.fill(), __x.__mon_).failed())
                    __os.setstate(ios_base::badbit);
            }
        }
        catch (...)
        {
            __os.__set_badbit_and_consider_rethrow();
        }
        return __os;
}
template <class _MoneyT>
inline __iom_t8<_MoneyT>
put_money(const _MoneyT &__mon, bool __intl = false)
{
        return __iom_t8<_MoneyT>(__mon, __intl);
}
template <class _CharT>
class __iom_t9;
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
operator>>(basic_istream<_CharT, _Traits> &__is, const __iom_t9<_CharT> &__x);
template <class _CharT>
class __iom_t9
{
        tm *__tm_;
        const _CharT *__fmt_;

    public:
        __iom_t9(tm *__tm, const _CharT *__fmt)
            : __tm_(__tm), __fmt_(__fmt) {}
        template <class _Cp, class _Traits>
        friend basic_istream<_Cp, _Traits> &
        operator>>(basic_istream<_Cp, _Traits> &__is, const __iom_t9<_Cp> &__x);
};
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
operator>>(basic_istream<_CharT, _Traits> &__is, const __iom_t9<_CharT> &__x)
{
        try
        {
            typename basic_istream<_CharT, _Traits>::sentry __s(__is);
            if (__s)
            {
                typedef istreambuf_iterator<_CharT, _Traits> _Ip;
                typedef time_get<_CharT, _Ip> _Fp;
                ios_base::iostate __err = ios_base::goodbit;
                const _Fp &__tf = use_facet<_Fp>(__is.getloc());
                __tf.get(_Ip(__is), _Ip(), __is, __err, __x.__tm_,
                         __x.__fmt_, __x.__fmt_ + _Traits::length(__x.__fmt_));
                __is.setstate(__err);
            }
        }
        catch (...)
        {
            __is.__set_badbit_and_consider_rethrow();
        }
        return __is;
}
template <class _CharT>
inline __iom_t9<_CharT>
get_time(tm *__tm, const _CharT *__fmt)
{
        return __iom_t9<_CharT>(__tm, __fmt);
}
template <class _CharT>
class __iom_t10;
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os, const __iom_t10<_CharT> &__x);
template <class _CharT>
class __iom_t10
{
        const tm *__tm_;
        const _CharT *__fmt_;

    public:
        __iom_t10(const tm *__tm, const _CharT *__fmt)
            : __tm_(__tm), __fmt_(__fmt) {}
        template <class _Cp, class _Traits>
        friend basic_ostream<_Cp, _Traits> &
        operator<<(basic_ostream<_Cp, _Traits> &__os, const __iom_t10<_Cp> &__x);
};
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os, const __iom_t10<_CharT> &__x)
{
        try
        {
            typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
            if (__s)
            {
                typedef ostreambuf_iterator<_CharT, _Traits> _Op;
                typedef time_put<_CharT, _Op> _Fp;
                const _Fp &__tf = use_facet<_Fp>(__os.getloc());
                if (__tf.put(_Op(__os), __os, __os.fill(), __x.__tm_,
                             __x.__fmt_, __x.__fmt_ + _Traits::length(__x.__fmt_))
                        .failed())
                    __os.setstate(ios_base::badbit);
            }
        }
        catch (...)
        {
            __os.__set_badbit_and_consider_rethrow();
        }
        return __os;
}
template <class _CharT>
inline __iom_t10<_CharT>
put_time(const tm *__tm, const _CharT *__fmt)
{
        return __iom_t10<_CharT>(__tm, __fmt);
}
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
__quoted_output(basic_ostream<_CharT, _Traits> &__os,
                const _CharT *__first, const _CharT *__last, _CharT __delim, _CharT __escape)
{
        basic_string<_CharT, _Traits> __str;
        __str.push_back(__delim);
        for (; __first != __last; ++__first)
        {
            if (_Traits::eq(*__first, __escape) || _Traits::eq(*__first, __delim))
                __str.push_back(__escape);
            __str.push_back(*__first);
        }
        __str.push_back(__delim);
        return std::__put_character_sequence(__os, __str.data(), __str.size());
}
template <class _CharT, class _Traits, class _String>
basic_istream<_CharT, _Traits> &
__quoted_input(basic_istream<_CharT, _Traits> &__is, _String &__string, _CharT __delim, _CharT __escape)
{
        __string.clear();
        _CharT __c;
        __is >> __c;
        if (__is.fail())
            return __is;
        if (!_Traits::eq(__c, __delim))
        {
            __is.unget();
            __is >> __string;
            return __is;
        }
        __save_flags<_CharT, _Traits> __sf(__is);
        std::noskipws(__is);
        while (true)
        {
            __is >> __c;
            if (__is.fail())
                break;
            if (_Traits::eq(__c, __escape))
            {
                __is >> __c;
                if (__is.fail())
                    break;
            }
            else if (_Traits::eq(__c, __delim))
                break;
            __string.push_back(__c);
        }
        return __is;
}
template <class _CharT, class _Traits>
struct __quoted_output_proxy
{
        const _CharT *__first_;
        const _CharT *__last_;
        _CharT __delim_;
        _CharT __escape_;

        explicit __quoted_output_proxy(const _CharT *__f, const _CharT *__l, _CharT __d, _CharT __e)
            : __first_(__f), __last_(__l), __delim_(__d), __escape_(__e) {}
        template <class _T2, __enable_if_t<_IsSame<_Traits, void>::value || _IsSame<_Traits, _T2>::value> * = __nullptr>
        friend basic_ostream<_CharT, _T2> &
        operator<<(basic_ostream<_CharT, _T2> &__os, const __quoted_output_proxy &__p)
        {
            return std::__quoted_output(__os, __p.__first_, __p.__last_, __p.__delim_, __p.__escape_);
        }
};
template <class _CharT, class _Traits, class _Allocator>
struct __quoted_proxy
{
        basic_string<_CharT, _Traits, _Allocator> &__string_;
        _CharT __delim_;
        _CharT __escape_;

        explicit __quoted_proxy(basic_string<_CharT, _Traits, _Allocator> &__s, _CharT __d, _CharT __e)
            : __string_(__s), __delim_(__d), __escape_(__e) {}
        friend basic_ostream<_CharT, _Traits> &
        operator<<(basic_ostream<_CharT, _Traits> &__os, const __quoted_proxy &__p)
        {
            return std::__quoted_output(__os, __p.__string_.data(), __p.__string_.data() + __p.__string_.size(), __p.__delim_, __p.__escape_);
        }
        friend basic_istream<_CharT, _Traits> &
        operator>>(basic_istream<_CharT, _Traits> &__is, const __quoted_proxy &__p)
        {
            return std::__quoted_input(__is, __p.__string_, __p.__delim_, __p.__escape_);
        }
};
template <class _CharT, class _Traits, class _Allocator>

__quoted_output_proxy<_CharT, _Traits>
__quoted(const basic_string<_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
{
        return __quoted_output_proxy<_CharT, _Traits>(__s.data(), __s.data() + __s.size(), __delim, __escape);
}
template <class _CharT, class _Traits, class _Allocator>

__quoted_proxy<_CharT, _Traits, _Allocator>
__quoted(basic_string<_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
{
        return __quoted_proxy<_CharT, _Traits, _Allocator>(__s, __delim, __escape);
}
    }
}
namespace boost
{
    namespace date_time
    {
template <class month_type, class format_type, class charT = char>
class month_formatter
{
        typedef std::basic_ostream<charT> ostream_type;

    public:
        static ostream_type &format_month(const month_type &month,
                                          ostream_type &os)
        {
            switch (format_type::month_format())
            {
            case month_as_short_string:
            {
                os << month.as_short_string();
                break;
            }
            case month_as_long_string:
            {
                os << month.as_long_string();
                break;
            }
            case month_as_integer:
            {
                boost::io::basic_ios_fill_saver<charT> ifs(os);
                os << std::setw(2) << std::setfill(os.widen('0')) << month.as_number();
                break;
            }
            default:
                break;
            }
            return os;
        }
};
template <class ymd_type, class format_type, class charT = char>
class ymd_formatter
{
    public:
        static std::basic_string<charT> ymd_to_string(ymd_type ymd)
        {
            typedef typename ymd_type::month_type month_type;
            std::basic_ostringstream<charT> ss;
            ss.imbue(std::locale::classic());
            ss << ymd.year;
            ss.imbue(std::locale());
            if (format_type::has_date_sep_chars())
            {
                ss << format_type::month_sep_char();
            }
            month_formatter<month_type, format_type, charT>::format_month(ymd.month, ss);
            if (format_type::has_date_sep_chars())
            {
                ss << format_type::day_sep_char();
            }
            ss << std::setw(2) << std::setfill(ss.widen('0'))
               << ymd.day;
            return ss.str();
        }
};
template <class date_type, class format_type, class charT = char>
class date_formatter
{
    public:
        typedef std::basic_string<charT> string_type;
        static string_type date_to_string(date_type d)
        {
            typedef typename date_type::ymd_type ymd_type;
            if (d.is_not_a_date())
            {
                return string_type(format_type::not_a_date());
            }
            if (d.is_neg_infinity())
            {
                return string_type(format_type::neg_infinity());
            }
            if (d.is_pos_infinity())
            {
                return string_type(format_type::pos_infinity());
            }
            ymd_type ymd = d.year_month_day();
            return ymd_formatter<ymd_type, format_type, charT>::ymd_to_string(ymd);
        }
};
    }
}
namespace boost
{
    namespace date_time
    {
template <class charT>
class simple_format
{
    public:
        static const charT *not_a_date()
        {
            return "not-a-date-time";
        }
        static const charT *pos_infinity()
        {
            return "+infinity";
        }
        static const charT *neg_infinity()
        {
            return "-infinity";
        }
        static month_format_spec month_format()
        {
            return month_as_short_string;
        }
        static ymd_order_spec date_order()
        {
            return ymd_order_iso;
        }
        static bool has_date_sep_chars()
        {
            return true;
        }
        static charT year_sep_char()
        {
            return '-';
        }
        static charT month_sep_char()
        {
            return '-';
        }
        static charT day_sep_char()
        {
            return '-';
        }
        static charT hour_sep_char()
        {
            return ' ';
        }
        static charT minute_sep_char()
        {
            return ':';
        }
        static charT second_sep_char()
        {
            return ':';
        }
};
template <>
class simple_format<wchar_t>
{
    public:
        static const wchar_t *not_a_date()
        {
            return L"not-a-date-time";
        }
        static const wchar_t *pos_infinity()
        {
            return L"+infinity";
        }
        static const wchar_t *neg_infinity()
        {
            return L"-infinity";
        }
        static month_format_spec month_format()
        {
            return month_as_short_string;
        }
        static ymd_order_spec date_order()
        {
            return ymd_order_iso;
        }
        static bool has_date_sep_chars()
        {
            return true;
        }
        static wchar_t year_sep_char()
        {
            return '-';
        }
        static wchar_t month_sep_char()
        {
            return '-';
        }
        static wchar_t day_sep_char()
        {
            return '-';
        }
        static wchar_t hour_sep_char()
        {
            return ' ';
        }
        static wchar_t minute_sep_char()
        {
            return ':';
        }
        static wchar_t second_sep_char()
        {
            return ':';
        }
};
    }
}
namespace boost
{
    namespace gregorian
    {
template <class charT>
inline std::basic_string<charT> to_simple_string_type(const date &d)
{
        return date_time::date_formatter<date, date_time::simple_format<charT>, charT>::date_to_string(d);
}
inline std::string to_simple_string(const date &d)
{
        return to_simple_string_type<char>(d);
}
template <class charT>
inline std::basic_string<charT> to_simple_string_type(const date_period &d)
{
        typedef std::basic_string<charT> string_type;
        charT b = '[', m = '/', e = ']';
        string_type d1(date_time::date_formatter<date, date_time::simple_format<charT>, charT>::date_to_string(d.begin()));
        string_type d2(date_time::date_formatter<date, date_time::simple_format<charT>, charT>::date_to_string(d.last()));
        return string_type(b + d1 + m + d2 + e);
}
inline std::string to_simple_string(const date_period &d)
{
        return to_simple_string_type<char>(d);
}
template <class charT>
inline std::basic_string<charT> to_iso_string_type(const date_period &d)
{
        charT sep = '/';
        std::basic_string<charT> s(date_time::date_formatter<date, date_time::iso_format<charT>, charT>::date_to_string(d.begin()));
        return s + sep + date_time::date_formatter<date, date_time::iso_format<charT>, charT>::date_to_string(d.last());
}
inline std::string to_iso_string(const date_period &d)
{
        return to_iso_string_type<char>(d);
}
template <class charT>
inline std::basic_string<charT> to_iso_extended_string_type(const date &d)
{
        return date_time::date_formatter<date, date_time::iso_extended_format<charT>, charT>::date_to_string(d);
}
inline std::string to_iso_extended_string(const date &d)
{
        return to_iso_extended_string_type<char>(d);
}
template <class charT>
inline std::basic_string<charT> to_iso_string_type(const date &d)
{
        return date_time::date_formatter<date, date_time::iso_format<charT>, charT>::date_to_string(d);
}
inline std::string to_iso_string(const date &d)
{
        return to_iso_string_type<char>(d);
}
template <class charT>
inline std::basic_string<charT> to_sql_string_type(const date &d)
{
        date::ymd_type ymd = d.year_month_day();
        std::basic_ostringstream<charT> ss;
        ss << ymd.year << "-"
           << std::setw(2) << std::setfill(ss.widen('0'))
           << ymd.month.as_number()
           << "-"
           << std::setw(2) << std::setfill(ss.widen('0'))
           << ymd.day;
        return ss.str();
}
inline std::string to_sql_string(const date &d)
{
        return to_sql_string_type<char>(d);
}
inline std::wstring to_simple_wstring(const date_period &d)
{
        return to_simple_string_type<wchar_t>(d);
}
inline std::wstring to_simple_wstring(const date &d)
{
        return to_simple_string_type<wchar_t>(d);
}
inline std::wstring to_iso_wstring(const date_period &d)
{
        return to_iso_string_type<wchar_t>(d);
}
inline std::wstring to_iso_extended_wstring(const date &d)
{
        return to_iso_extended_string_type<wchar_t>(d);
}
inline std::wstring to_iso_wstring(const date &d)
{
        return to_iso_string_type<wchar_t>(d);
}
inline std::wstring to_sql_wstring(const date &d)
{
        return to_sql_string_type<wchar_t>(d);
}
    }
}
namespace std
{
    inline namespace __1
    {
extern istream cin;
extern ostream cout;
extern ostream cerr;
extern ostream clog;
extern wistream wcin;
extern wostream wcout;
extern wostream wcerr;
extern wostream wclog;
    }
}

extern "C"
{
    void __assert_rtn(const char *, const char *, int, const char *);
}
namespace boost
{
    namespace iterators
    {
template <class Iterator>
struct iterator_value
{
        typedef typename std::iterator_traits<Iterator>::value_type type;
};
template <class Iterator>
struct iterator_reference
{
        typedef typename std::iterator_traits<Iterator>::reference type;
};
template <class Iterator>
struct iterator_pointer
{
        typedef typename std::iterator_traits<Iterator>::pointer type;
};
template <class Iterator>
struct iterator_difference
{
        typedef typename std::iterator_traits<Iterator>::difference_type type;
};
template <class Iterator>
struct iterator_category
{
        typedef typename std::iterator_traits<Iterator>::iterator_category type;
};
    }
    using iterators::iterator_category;
    using iterators::iterator_difference;
    using iterators::iterator_pointer;
    using iterators::iterator_reference;
    using iterators::iterator_value;
}
namespace mpl_
{
    namespace aux
    {
    }
}
namespace boost
{
    namespace mpl
    {
using namespace mpl_;
namespace aux
{
        using namespace mpl_::aux;
}
    }
}

namespace mpl_
{
    template <bool C_>
    struct bool_;
    typedef bool_<true> true_;
    typedef bool_<false> false_;
}
namespace boost
{
    namespace mpl
    {
using ::mpl_::bool_;
    }
}
namespace boost
{
    namespace mpl
    {
using ::mpl_::true_;
    }
}
namespace boost
{
    namespace mpl
    {
using ::mpl_::false_;
    }
}

namespace mpl_
{
    struct integral_c_tag
    {
static const int value = 0;
    };
}
namespace boost
{
    namespace mpl
    {
using ::mpl_::integral_c_tag;
    }
}
namespace mpl_
{
    template <bool C_>
    struct bool_
    {
static const bool value = C_;
typedef integral_c_tag tag;
typedef bool_ type;
typedef bool value_type;
operator bool() const { return this->value; }
    };
    template <bool C_>
    bool const bool_<C_>::value;
}
namespace boost
{
    namespace mpl
    {
namespace aux
{
        template <typename T>
        struct nested_type_wknd
            : T::type
        {
        };
}
    }
}
namespace mpl_
{
    struct void_;
}
namespace boost
{
    namespace mpl
    {
using ::mpl_::void_;
    }
}
namespace mpl_
{
    struct na
    {
typedef na type;
enum
{
    value = 0
};
    };
}
namespace boost
{
    namespace mpl
    {
using ::mpl_::na;
    }
}

namespace boost
{
    namespace mpl
    {
template <typename T>
struct is_na
    : false_
{
};
template <>
struct is_na<na>
    : true_
{
};
template <typename T>
struct is_not_na
    : true_
{
};
template <>
struct is_not_na<na>
    : false_
{
};
template <typename T, typename U>
struct if_na
{
        typedef T type;
};
template <typename U>
struct if_na<na, U>
{
        typedef U type;
};
    }
}

namespace mpl_
{
    template <int N>
    struct int_;
}
namespace boost
{
    namespace mpl
    {
using ::mpl_::int_;
    }
}
namespace mpl_
{
    template <int N>
    struct int_
    {
static const int value = N;
typedef int_ type;
typedef int value_type;
typedef integral_c_tag tag;
typedef mpl_::int_<static_cast<int>((value + 1))> next;
typedef mpl_::int_<static_cast<int>((value - 1))> prior;
operator int() const { return static_cast<int>(this->value); }
    };
    template <int N>
    int const mpl_::int_<N>::value;
}
namespace boost
{
    namespace mpl
    {
namespace aux
{
        template <typename F>
        struct template_arity;
}
    }
}

namespace boost
{
    namespace mpl
    {
template <
    typename T = na, typename Tag = void_, typename Arity = int_<aux::template_arity<T>::value>>
struct lambda;
    }
}

namespace boost
{
    namespace mpl
    {
namespace aux
{
        template <bool C_, typename T1, typename T2, typename T3, typename T4>
        struct or_impl
            : true_
        {
        };
        template <typename T1, typename T2, typename T3, typename T4>
        struct or_impl<false, T1, T2, T3, T4>
            : or_impl<
                  ::boost::mpl::aux::nested_type_wknd<T1>::value, T2, T3, T4, false_>
        {
        };
        template <>
        struct or_impl<
            false, false_, false_, false_, false_>
            : false_
        {
        };
}
template <
    typename T1 = na, typename T2 = na, typename T3 = false_, typename T4 = false_, typename T5 = false_>
struct or_
    : aux::or_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value, T2, T3, T4, T5>
{
};
template <>
struct or_<na, na>
{
        template <typename T1, typename T2, typename T3 = na, typename T4 = na, typename T5 = na>
        struct apply : or_<T1, T2>
        {
        };
};
template <typename Tag>
struct lambda<or_<na, na>, Tag, int_<-1>>
{
        typedef false_ is_le;
        typedef or_<na, na> result_;
        typedef or_<na, na> type;
};
namespace aux
{
        template <typename T1, typename T2, typename T3, typename T4, typename T5>
        struct template_arity<or_<T1, T2, T3, T4, T5>> : int_<5>
        {
        };
        template <>
        struct template_arity<or_<na, na>> : int_<-1>
        {
        };
}
    }
}

namespace boost
{
    template <class T>
    struct is_void : public false_type
    {
    };
    template <>
    struct is_void<void> : public true_type
    {
    };
    template <>
    struct is_void<const void> : public true_type
    {
    };
    template <>
    struct is_void<const volatile void> : public true_type
    {
    };
    template <>
    struct is_void<volatile void> : public true_type
    {
    };
}
namespace boost
{
    template <class T>
    struct is_lvalue_reference : public false_type
    {
    };
    template <class T>
    struct is_lvalue_reference<T &> : public true_type
    {
    };
}
namespace boost
{
    template <class T>
    struct is_rvalue_reference : public false_type
    {
    };
}

namespace boost
{
    template <class T>
    struct is_reference
        : public integral_constant<
              bool,
              ::boost::is_lvalue_reference<T>::value || ::boost::is_rvalue_reference<T>::value>
    {
    };
}
namespace boost
{
    namespace type_traits_detail
    {
template <typename T, bool b>
struct add_rvalue_reference_helper
{
        typedef T type;
};
template <typename T>
struct add_rvalue_reference_imp
{
        typedef typename boost::type_traits_detail::add_rvalue_reference_helper<T, (is_void<T>::value == false && is_reference<T>::value == false)>::type type;
};
    }
    template <class T>
    struct add_rvalue_reference
    {
typedef typename boost::type_traits_detail::add_rvalue_reference_imp<T>::type type;
    };
}
namespace boost
{
    template <typename T>
    typename add_rvalue_reference<T>::type declval();
}

namespace boost
{
    namespace detail
    {
template <class T>
struct remove_rvalue_ref
{
        typedef T type;
};
    }
    template <class T>
    struct remove_reference
    {
typedef typename boost::detail::remove_rvalue_ref<T>::type type;
    };
    template <class T>
    struct remove_reference<T &>
    {
typedef T type;
    };
}
namespace boost
{
    namespace type_traits
    {
template <class R>
struct is_function_ptr_helper
{
        static const bool value = false;
};
template <class R>
struct is_function_ptr_helper<R (*)()>
{
        static const bool value = true;
};
template <class R>
struct is_function_ptr_helper<R (*)(...)>
{
        static const bool value = true;
};
template <class R, class T0>
struct is_function_ptr_helper<R (*)(T0)>
{
        static const bool value = true;
};
template <class R, class T0>
struct is_function_ptr_helper<R (*)(T0...)>
{
        static const bool value = true;
};
template <class R, class T0, class T1>
struct is_function_ptr_helper<R (*)(T0, T1)>
{
        static const bool value = true;
};
template <class R, class T0, class T1>
struct is_function_ptr_helper<R (*)(T0, T1...)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2>
struct is_function_ptr_helper<R (*)(T0, T1, T2)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2>
struct is_function_ptr_helper<R (*)(T0, T1, T2...)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3...)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4...)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5...)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6...)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7...)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8...)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9...)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10...)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11...)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12...)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13...)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14...)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15...)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16...)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17...)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18...)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19...)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20...)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21...)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22...)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23...)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24)>
{
        static const bool value = true;
};
template <class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
struct is_function_ptr_helper<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24...)>
{
        static const bool value = true;
};
    }
}
namespace boost
{
    namespace detail
    {
template <bool is_ref = true>
struct is_function_chooser
{
        template <typename T>
        struct result_
            : public false_type
        {
        };
};
template <>
struct is_function_chooser<false>
{
        template <typename T>
        struct result_
            : public ::boost::type_traits::is_function_ptr_helper<T *>
        {
        };
};
template <typename T>
struct is_function_impl
    : public is_function_chooser<::boost::is_reference<T>::value>::template result_<T>
{
};
    }
    template <class T>
    struct is_function : integral_constant<bool, ::boost::detail::is_function_impl<T>::value>
    {
    };
    template <class T>
    struct is_function<T &> : public false_type
    {
    };
}
namespace boost
{
    namespace type_traits
    {
typedef char yes_type;
struct no_type
{
        char padding[8];
};
    }
}
namespace boost
{
    namespace detail
    {
template <std::size_t N>
struct ok_tag
{
        double d;
        char c[N];
};
template <class T>
ok_tag<sizeof(T)> check_is_complete(int);
template <class T>
char check_is_complete(...);
    }
    template <class T>
    struct is_complete
        : public integral_constant<bool, ::boost::is_function<typename boost::remove_reference<T>::type>::value || (sizeof(boost::detail::check_is_complete<T>(0)) != sizeof(char))>
    {
    };
}

namespace boost
{
    template <class T>
    struct is_array : public false_type
    {
    };
    template <class T, std::size_t N>
    struct is_array<T[N]> : public true_type
    {
    };
    template <class T, std::size_t N>
    struct is_array<T const[N]> : public true_type
    {
    };
    template <class T, std::size_t N>
    struct is_array<T volatile[N]> : public true_type
    {
    };
    template <class T, std::size_t N>
    struct is_array<T const volatile[N]> : public true_type
    {
    };
    template <class T>
    struct is_array<T[]> : public true_type
    {
    };
    template <class T>
    struct is_array<T const[]> : public true_type{};
    template <class T>
    struct is_array<T const volatile[]> : public true_type{};
    template <class T>
    struct is_array<T volatile[]> : public true_type{};
}
namespace boost
{
    template <bool x>
    struct STATIC_ASSERTION_FAILURE;
    template <>
    struct STATIC_ASSERTION_FAILURE<true>
    {
enum
{
    value = 1
};
    };
    template <std::size_t x>
    struct static_assert_test
    {
    };
}
namespace boost
{
    template <class From, class To>
    struct is_convertible : public integral_constant<bool, __is_convertible_to(From, To)>
    {
typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<((boost::is_complete<To>::value || boost::is_void<To>::value || boost::is_array<To>::value) != 0)>)> boost_static_assert_typedef_497;
typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<((boost::is_complete<From>::value || boost::is_void<From>::value || boost::is_array<From>::value) != 0)>)> boost_static_assert_typedef_498;
    };
}

namespace boost
{
    namespace iterators
    {
template <typename A, typename B>
struct is_interoperable
    : mpl::or_<
          is_convertible<A, B>, is_convertible<B, A>>
{
};
    }
    using iterators::is_interoperable;
}

namespace boost
{
    namespace mpl
    {
namespace aux
{
        template <typename T>
        struct value_type_wknd
        {
            typedef typename T::value_type type;
        };
}
    }
}
namespace boost
{
    namespace mpl
    {
template <
    bool C, typename T1, typename T2>
struct if_c
{
        typedef T1 type;
};
template <
    typename T1, typename T2>
struct if_c<false, T1, T2>
{
        typedef T2 type;
};
template <
    typename T1 = na, typename T2 = na, typename T3 = na>
struct if_
{
    private:
        typedef if_c<
            static_cast<bool>(T1::value), T2, T3>
            almost_type_;

    public:
        typedef typename almost_type_::type type;
};
template <>
struct if_<na, na, na>
{
        template <typename T1, typename T2, typename T3, typename T4 = na, typename T5 = na>
        struct apply : if_<T1, T2, T3>
        {
        };
};
template <typename Tag>
struct lambda<if_<na, na, na>, Tag, int_<-1>>
{
        typedef false_ is_le;
        typedef if_<na, na, na> result_;
        typedef if_<na, na, na> type;
};
namespace aux
{
        template <typename T1, typename T2, typename T3>
        struct template_arity<if_<T1, T2, T3>> : int_<3>
        {
        };
        template <>
        struct template_arity<if_<na, na, na>> : int_<-1>
        {
        };
}
    }
}
namespace boost
{
    namespace mpl
    {
template <
    typename C = na, typename F1 = na, typename F2 = na>
struct eval_if
{
        typedef typename if_<C, F1, F2>::type f_;
        typedef typename f_::type type;
};
template <
    bool C, typename F1, typename F2>
struct eval_if_c
{
        typedef typename if_c<C, F1, F2>::type f_;
        typedef typename f_::type type;
};
template <>
struct eval_if<na, na, na>
{
        template <typename T1, typename T2, typename T3, typename T4 = na, typename T5 = na>
        struct apply : eval_if<T1, T2, T3>
        {
        };
};
template <typename Tag>
struct lambda<eval_if<na, na, na>, Tag, int_<-1>>
{
        typedef false_ is_le;
        typedef eval_if<na, na, na> result_;
        typedef eval_if<na, na, na> type;
};
namespace aux
{
        template <typename T1, typename T2, typename T3>
        struct template_arity<eval_if<T1, T2, T3>> : int_<3>
        {
        };
        template <>
        struct template_arity<eval_if<na, na, na>> : int_<-1>
        {
        };
}
    }
}
namespace boost
{
    namespace mpl
    {
template <
    typename T = na>
struct identity
{
        typedef T type;
};
template <
    typename T = na>
struct make_identity
{
        typedef identity<T> type;
};
template <>
struct identity<na>
{
        template <typename T1, typename T2 = na, typename T3 = na, typename T4 = na, typename T5 = na>
        struct apply : identity<T1>
        {
        };
};
template <typename Tag>
struct lambda<identity<na>, Tag, int_<-1>>
{
        typedef false_ is_le;
        typedef identity<na> result_;
        typedef identity<na> type;
};
namespace aux
{
        template <typename T1>
        struct template_arity<identity<T1>> : int_<1>
        {
        };
        template <>
        struct template_arity<identity<na>> : int_<-1>
        {
        };
}
template <>
struct make_identity<na>
{
        template <typename T1, typename T2 = na, typename T3 = na, typename T4 = na, typename T5 = na>
        struct apply : make_identity<T1>
        {
        };
};
template <typename Tag>
struct lambda<make_identity<na>, Tag, int_<-1>>
{
        typedef false_ is_le;
        typedef make_identity<na> result_;
        typedef make_identity<na> type;
};
namespace aux
{
        template <typename T1>
        struct template_arity<make_identity<T1>> : int_<1>
        {
        };
        template <>
        struct template_arity<make_identity<na>> : int_<-1>
        {
        };
}
    }
}
namespace mpl_
{
    template <int N>
    struct arg;
}
namespace boost
{
    namespace mpl
    {
using ::mpl_::arg;
    }
}

namespace boost
{
    namespace mpl
    {
namespace aux
{
        template <long C_>
        struct not_impl
            : bool_<!C_>
        {
        };
}
template <
    typename T = na>
struct not_
    : aux::not_impl<
          ::boost::mpl::aux::nested_type_wknd<T>::value>
{
};
template <>
struct not_<na>
{
        template <typename T1, typename T2 = na, typename T3 = na, typename T4 = na, typename T5 = na>
        struct apply : not_<T1>
        {
        };
};
template <typename Tag>
struct lambda<not_<na>, Tag, int_<-1>>
{
        typedef false_ is_le;
        typedef not_<na> result_;
        typedef not_<na> type;
};
namespace aux
{
        template <typename T1>
        struct template_arity<not_<T1>> : int_<1>
        {
        };
        template <>
        struct template_arity<not_<na>> : int_<-1>
        {
        };
}
    }
}
namespace boost
{
    namespace mpl
    {
namespace aux
{
        typedef char (&no_tag)[1];
        typedef char (&yes_tag)[2];
        template <bool C_>
        struct yes_no_tag
        {
            typedef no_tag type;
        };
        template <>
        struct yes_no_tag<true>
        {
            typedef yes_tag type;
        };
        template <std::size_t n>
        struct weighted_tag
        {
            typedef char (&type)[n];
        };
}
    }
}

namespace mpl_
{
    struct failed
    {
    };
    template <bool C>
    struct assert
    {
typedef void *type;
    };
    template <>
    struct assert<false>
    {
typedef assert type;
    };
    template <bool C>
    int assertion_failed(typename assert<C>::type);
    template <bool C>
    struct assertion
    {
static int failed(assert<false>);
    };
    template <>
    struct assertion<true>
    {
static int failed(void *);
    };
    struct assert_
    {
template <typename T1, typename T2 = na, typename T3 = na, typename T4 = na>
struct types
{
};
static assert_ const arg;
enum relations
{
    equal = 1,
    not_equal,
    greater,
    greater_equal,
    less,
    less_equal
};
    };
    boost::mpl::aux::weighted_tag<1>::type operator==(assert_, assert_);
    boost::mpl::aux::weighted_tag<2>::type operator!=(assert_, assert_);
    boost::mpl::aux::weighted_tag<3>::type operator>(assert_, assert_);
    boost::mpl::aux::weighted_tag<4>::type operator>=(assert_, assert_);
    boost::mpl::aux::weighted_tag<5>::type operator<(assert_, assert_);
    boost::mpl::aux::weighted_tag<6>::type operator<=(assert_, assert_);
    template <assert_::relations r, long x, long y>
    struct assert_relation
    {
    };
    template <bool>
    struct assert_arg_pred_impl
    {
typedef int type;
    };
    template <>
    struct assert_arg_pred_impl<true>
    {
typedef void *type;
    };
    template <typename P>
    struct assert_arg_pred
    {
typedef typename P::type p_type;
typedef typename assert_arg_pred_impl<p_type::value>::type type;
    };
    template <typename P>
    struct assert_arg_pred_not
    {
typedef typename P::type p_type;
enum
{
    p = !p_type::value
};
typedef typename assert_arg_pred_impl<p>::type type;
    };
    template <typename Pred>
    failed ************(Pred::************
                            assert_arg(void (*)(Pred), typename assert_arg_pred<Pred>::type));
    template <typename Pred>
    failed ************(boost::mpl::not_<Pred>::************
                            assert_not_arg(void (*)(Pred), typename assert_arg_pred_not<Pred>::type));
    template <typename Pred>
    assert<false>
    assert_arg(void (*)(Pred), typename assert_arg_pred_not<Pred>::type);
    template <typename Pred>
    assert<false>
    assert_not_arg(void (*)(Pred), typename assert_arg_pred<Pred>::type);
}
namespace mpl_
{
    template <>
    struct arg<-1>
    {
static const int value = -1;
template <
    typename U1 = na, typename U2 = na, typename U3 = na, typename U4 = na, typename U5 = na>
struct apply
{
        typedef U1 type;
        enum
        {
            mpl_assertion_in_line_27 = sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void (*)(boost::mpl::is_na<type>))0, 1)))
        };
};
    };
    template <>
    struct arg<1>
    {
static const int value = 1;
typedef arg<2> next;
template <
    typename U1 = na, typename U2 = na, typename U3 = na, typename U4 = na, typename U5 = na>
struct apply
{
        typedef U1 type;
        enum
        {
            mpl_assertion_in_line_45 = sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void (*)(boost::mpl::is_na<type>))0, 1)))
        };
};
    };
    template <>
    struct arg<2>
    {
static const int value = 2;
typedef arg<3> next;
template <
    typename U1 = na, typename U2 = na, typename U3 = na, typename U4 = na, typename U5 = na>
struct apply
{
        typedef U2 type;
        enum
        {
            mpl_assertion_in_line_63 = sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void (*)(boost::mpl::is_na<type>))0, 1)))
        };
};
    };
    template <>
    struct arg<3>
    {
static const int value = 3;
typedef arg<4> next;
template <
    typename U1 = na, typename U2 = na, typename U3 = na, typename U4 = na, typename U5 = na>
struct apply
{
        typedef U3 type;
        enum
        {
            mpl_assertion_in_line_81 = sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void (*)(boost::mpl::is_na<type>))0, 1)))
        };
};
    };
    template <>
    struct arg<4>
    {
static const int value = 4;
typedef arg<5> next;
template <
    typename U1 = na, typename U2 = na, typename U3 = na, typename U4 = na, typename U5 = na>
struct apply
{
        typedef U4 type;
        enum
        {
            mpl_assertion_in_line_99 = sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void (*)(boost::mpl::is_na<type>))0, 1)))
        };
};
    };
    template <>
    struct arg<5>
    {
static const int value = 5;
typedef arg<6> next;
template <
    typename U1 = na, typename U2 = na, typename U3 = na, typename U4 = na, typename U5 = na>
struct apply
{
        typedef U5 type;
        enum
        {
            mpl_assertion_in_line_117 = sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void (*)(boost::mpl::is_na<type>))0, 1)))
        };
};
    };
}
namespace mpl_
{
    typedef arg<-1> _;
}
namespace boost
{
    namespace mpl
    {
using ::mpl_::_;
namespace placeholders
{
        using mpl_::_;
}
    }
}
namespace mpl_
{
    typedef arg<1> _1;
}
namespace boost
{
    namespace mpl
    {
using ::mpl_::_1;
namespace placeholders
{
        using mpl_::_1;
}
    }
}
namespace mpl_
{
    typedef arg<2> _2;
}
namespace boost
{
    namespace mpl
    {
using ::mpl_::_2;
namespace placeholders
{
        using mpl_::_2;
}
    }
}
namespace mpl_
{
    typedef arg<3> _3;
}
namespace boost
{
    namespace mpl
    {
using ::mpl_::_3;
namespace placeholders
{
        using mpl_::_3;
}
    }
}
namespace mpl_
{
    typedef arg<4> _4;
}
namespace boost
{
    namespace mpl
    {
using ::mpl_::_4;
namespace placeholders
{
        using mpl_::_4;
}
    }
}
namespace mpl_
{
    typedef arg<5> _5;
}
namespace boost
{
    namespace mpl
    {
using ::mpl_::_5;
namespace placeholders
{
        using mpl_::_5;
}
    }
}
namespace mpl_
{
    typedef arg<6> _6;
}
namespace boost
{
    namespace mpl
    {
using ::mpl_::_6;
namespace placeholders
{
        using mpl_::_6;
}
    }
}
namespace boost
{
    namespace iterators
    {
struct no_traversal_tag
{
};
struct incrementable_traversal_tag
    : no_traversal_tag
{
};
struct single_pass_traversal_tag
    : incrementable_traversal_tag
{
};
struct forward_traversal_tag
    : single_pass_traversal_tag
{
};
struct bidirectional_traversal_tag
    : forward_traversal_tag
{
};
struct random_access_traversal_tag
    : bidirectional_traversal_tag
{
};
namespace detail
{
        template <class Cat>
        struct old_category_to_traversal
            : mpl::eval_if<
                  is_convertible<Cat, std::random_access_iterator_tag>, mpl::identity<random_access_traversal_tag>, mpl::eval_if<is_convertible<Cat, std::bidirectional_iterator_tag>, mpl::identity<bidirectional_traversal_tag>, mpl::eval_if<is_convertible<Cat, std::forward_iterator_tag>, mpl::identity<forward_traversal_tag>, mpl::eval_if<is_convertible<Cat, std::input_iterator_tag>, mpl::identity<single_pass_traversal_tag>, mpl::eval_if<is_convertible<Cat, std::output_iterator_tag>, mpl::identity<incrementable_traversal_tag>, void>>>>>
        {
        };
}
template <class Cat>
struct iterator_category_to_traversal
    : mpl::eval_if<
          is_convertible<Cat, incrementable_traversal_tag>, mpl::identity<Cat>, boost::iterators::detail::old_category_to_traversal<Cat>>
{
};
template <class Iterator = mpl::_1>
struct iterator_traversal
    : iterator_category_to_traversal<
          typename std::iterator_traits<Iterator>::iterator_category>
{
};
template <class Traversal>
struct pure_traversal_tag
    : mpl::eval_if<
          is_convertible<Traversal, random_access_traversal_tag>, mpl::identity<random_access_traversal_tag>, mpl::eval_if<is_convertible<Traversal, bidirectional_traversal_tag>, mpl::identity<bidirectional_traversal_tag>, mpl::eval_if<is_convertible<Traversal, forward_traversal_tag>, mpl::identity<forward_traversal_tag>, mpl::eval_if<is_convertible<Traversal, single_pass_traversal_tag>, mpl::identity<single_pass_traversal_tag>, mpl::eval_if<is_convertible<Traversal, incrementable_traversal_tag>, mpl::identity<incrementable_traversal_tag>, void>>>>>
{
};
template <class Iterator = mpl::_1>
struct pure_iterator_traversal
    : pure_traversal_tag<typename iterator_traversal<Iterator>::type>
{
};
    }
    using iterators::bidirectional_traversal_tag;
    using iterators::forward_traversal_tag;
    using iterators::incrementable_traversal_tag;
    using iterators::iterator_category_to_traversal;
    using iterators::iterator_traversal;
    using iterators::no_traversal_tag;
    using iterators::random_access_traversal_tag;
    using iterators::single_pass_traversal_tag;
    namespace detail
    {
using iterators::pure_traversal_tag;
    }
}

namespace boost
{
    struct use_default
    {
    };
}
namespace boost
{
    namespace mpl
    {
namespace aux
{
        template <bool C_, typename T1, typename T2, typename T3, typename T4>
        struct and_impl
            : false_
        {
        };
        template <typename T1, typename T2, typename T3, typename T4>
        struct and_impl<true, T1, T2, T3, T4>
            : and_impl<
                  ::boost::mpl::aux::nested_type_wknd<T1>::value, T2, T3, T4, true_>
        {
        };
        template <>
        struct and_impl<
            true, true_, true_, true_, true_>
            : true_
        {
        };
}
template <
    typename T1 = na, typename T2 = na, typename T3 = true_, typename T4 = true_, typename T5 = true_>
struct and_
    : aux::and_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value, T2, T3, T4, T5>
{
};
template <>
struct and_<na, na>
{
        template <typename T1, typename T2, typename T3 = na, typename T4 = na, typename T5 = na>
        struct apply : and_<T1, T2>
        {
        };
};
template <typename Tag>
struct lambda<and_<na, na>, Tag, int_<-1>>
{
        typedef false_ is_le;
        typedef and_<na, na> result_;
        typedef and_<na, na> type;
};
namespace aux
{
        template <typename T1, typename T2, typename T3, typename T4, typename T5>
        struct template_arity<and_<T1, T2, T3, T4, T5>> : int_<5>
        {
        };
        template <>
        struct template_arity<and_<na, na>> : int_<-1>
        {
        };
}
    }
}
namespace boost
{
    template <class T>
    struct is_const : public false_type
    {
    };
    template <class T>
    struct is_const<T const> : public true_type
    {
    };
    template <class T, std::size_t N>
    struct is_const<T const[N]> : public true_type
    {
    };
    template <class T>
    struct is_const<T const[]> : public true_type{};
}
namespace boost
{
    template <class T>
    struct is_pointer : public false_type
    {
    };
    template <class T>
    struct is_pointer<T *> : public true_type
    {
    };
    template <class T>
    struct is_pointer<T *const> : public true_type
    {
    };
    template <class T>
    struct is_pointer<T *const volatile> : public true_type
    {
    };
    template <class T>
    struct is_pointer<T *volatile> : public true_type
    {
    };
}
namespace boost
{
    template <class T>
    struct is_volatile : public false_type
    {
    };
    template <class T>
    struct is_volatile<T volatile> : public true_type
    {
    };
    template <class T, std::size_t N>
    struct is_volatile<T volatile[N]> : public true_type
    {
    };
    template <class T>
    struct is_volatile<T volatile[]> : public true_type{};
}
namespace boost
{
    namespace type_traits
    {
template <typename T>
struct is_mem_fun_pointer_impl
{
        static const bool value = false;
};
template <class R, class T>
struct is_mem_fun_pointer_impl<R (T::*)()>
{
        static const bool value = true;
};
template <class R, class T>
struct is_mem_fun_pointer_impl<R (T::*)(...)>
{
        static const bool value = true;
};
template <class R, class T>
struct is_mem_fun_pointer_impl<R (T::*)() const>
{
        static const bool value = true;
};
template <class R, class T>
struct is_mem_fun_pointer_impl<R (T::*)() volatile>
{
        static const bool value = true;
};
template <class R, class T>
struct is_mem_fun_pointer_impl<R (T::*)() const volatile>
{
        static const bool value = true;
};
template <class R, class T>
struct is_mem_fun_pointer_impl<R (T::*)(...) const>
{
        static const bool value = true;
};
template <class R, class T>
struct is_mem_fun_pointer_impl<R (T::*)(...) volatile>
{
        static const bool value = true;
};
template <class R, class T>
struct is_mem_fun_pointer_impl<R (T::*)(...) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0>
struct is_mem_fun_pointer_impl<R (T::*)(T0)>
{
        static const bool value = true;
};
template <class R, class T, class T0>
struct is_mem_fun_pointer_impl<R (T::*)(T0...)>
{
        static const bool value = true;
};
template <class R, class T, class T0>
struct is_mem_fun_pointer_impl<R (T::*)(T0) const>
{
        static const bool value = true;
};
template <class R, class T, class T0>
struct is_mem_fun_pointer_impl<R (T::*)(T0) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0>
struct is_mem_fun_pointer_impl<R (T::*)(T0) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0>
struct is_mem_fun_pointer_impl<R (T::*)(T0...) const>
{
        static const bool value = true;
};
template <class R, class T, class T0>
struct is_mem_fun_pointer_impl<R (T::*)(T0...) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0>
struct is_mem_fun_pointer_impl<R (T::*)(T0...) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1...)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1...) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1...) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1...) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2...)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2...) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2...) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2...) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3...)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3...) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3...) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3...) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4...)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4...) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4...) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4...) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5...)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5...) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5...) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5...) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6...)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6...) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6...) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6...) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7...)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7...) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7...) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7...) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8...)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8...) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8...) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8...) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9...)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9...) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9...) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9...) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10...)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10...) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10...) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10...) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11...)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11...) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11...) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11...) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12...)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12...) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12...) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12...) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13...)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13...) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13...) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13...) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14...)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14...) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14...) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14...) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15...)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15...) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15...) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15...) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16...)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16...) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16...) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16...) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17...)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17...) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17...) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17...) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18...)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18...) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18...) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18...) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19...)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19...) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19...) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19...) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20...)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20...) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20...) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20...) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21...)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21...) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21...) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21...) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22...)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22...) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22...) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22...) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23...)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23...) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23...) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23...) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24...)>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24) const volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24...) const>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24...) volatile>
{
        static const bool value = true;
};
template <class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
struct is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24...) const volatile>
{
        static const bool value = true;
};
    }
}
namespace boost
{
    template <class T>
    struct is_member_function_pointer
        : public ::boost::integral_constant<bool, ::boost::type_traits::is_mem_fun_pointer_impl<typename remove_cv<T>::type>::value>
    {
    };
}
namespace boost
{
    template <class T>
    struct is_member_pointer : public integral_constant<bool, ::boost::is_member_function_pointer<T>::value>
    {
    };
    template <class T, class U>
    struct is_member_pointer<U T::*> : public true_type
    {
    };
    template <class T, class U>
    struct is_member_pointer<U T::*const> : public true_type
    {
    };
    template <class T, class U>
    struct is_member_pointer<U T::*const volatile> : public true_type
    {
    };
    template <class T, class U>
    struct is_member_pointer<U T::*volatile> : public true_type
    {
    };
}
namespace boost
{
    template <class T>
    struct remove_pointer
    {
typedef T type;
    };
    template <class T>
    struct remove_pointer<T *>
    {
typedef T type;
    };
    template <class T>
    struct remove_pointer<T *const>
    {
typedef T type;
    };
    template <class T>
    struct remove_pointer<T *volatile>
    {
typedef T type;
    };
    template <class T>
    struct remove_pointer<T *const volatile>
    {
typedef T type;
    };
}
namespace boost
{
    namespace detail
    {
template <bool b>
struct if_true
{
        template <class T, class F>
        struct then
        {
            typedef T type;
        };
};
template <>
struct if_true<false>
{
        template <class T, class F>
        struct then
        {
            typedef F type;
        };
};
    }
}
namespace boost
{
    namespace detail
    {
namespace indirect_traits
{
        template <class T>
        struct is_reference_to_const : boost::false_type
        {
        };
        template <class T>
        struct is_reference_to_const<T const &> : boost::true_type
        {
        };
        template <class T>
        struct is_reference_to_function : boost::false_type
        {
        };
        template <class T>
        struct is_reference_to_function<T &> : is_function<T>
        {
        };
        template <class T>
        struct is_pointer_to_function : boost::false_type
        {
        };
        template <class T>
        struct is_pointer_to_function<T *> : is_function<T>
        {
        };
        template <class T>
        struct is_reference_to_member_function_pointer_impl : boost::false_type
        {
        };
        template <class T>
        struct is_reference_to_member_function_pointer_impl<T &>
            : is_member_function_pointer<typename remove_cv<T>::type>
        {
        };
        template <class T>
        struct is_reference_to_member_function_pointer
            : is_reference_to_member_function_pointer_impl<T>
        {
        };
        template <class T>
        struct is_reference_to_function_pointer_aux
            : boost::integral_constant<bool,
                                       is_reference<T>::value &&
                                           is_pointer_to_function<
                                               typename remove_cv<
                                                   typename remove_reference<T>::type>::type>::value>
        {
        };
        template <class T>
        struct is_reference_to_function_pointer
            : boost::detail::if_true<
                  is_reference_to_function<T>::value>::template then<boost::false_type, is_reference_to_function_pointer_aux<T>>::type
        {
        };
        template <class T>
        struct is_reference_to_non_const
            : boost::integral_constant<bool,
                                       is_reference<T>::value &&
                                           !is_reference_to_const<T>::value>
        {
        };
        template <class T>
        struct is_reference_to_volatile : boost::false_type
        {
        };
        template <class T>
        struct is_reference_to_volatile<T volatile &> : boost::true_type
        {
        };
        template <class T>
        struct is_reference_to_pointer : boost::false_type
        {
        };
        template <class T>
        struct is_reference_to_pointer<T *&> : boost::true_type
        {
        };
        template <class T>
        struct is_reference_to_pointer<T *const &> : boost::true_type
        {
        };
        template <class T>
        struct is_reference_to_pointer<T *volatile &> : boost::true_type
        {
        };
        template <class T>
        struct is_reference_to_pointer<T *const volatile &> : boost::true_type
        {
        };
        template <class T>
        struct is_reference_to_class
            : boost::integral_constant<bool,
                                       is_reference<T>::value &&
                                           is_class<
                                               typename remove_cv<
                                                   typename remove_reference<T>::type>::type>::value>
        {
        };
        template <class T>
        struct is_pointer_to_class
            : boost::integral_constant<bool,
                                       is_pointer<T>::value &&
                                           is_class<
                                               typename remove_cv<
                                                   typename remove_pointer<T>::type>::type>::value>
        {
        };
}
using namespace indirect_traits;
    }
}
namespace boost
{
    namespace iterators
    {
using boost::use_default;
namespace detail
{
        struct input_output_iterator_tag
            : std::input_iterator_tag
        {
            operator std::output_iterator_tag() const
            {
                return std::output_iterator_tag();
            }
        };
        template <class ValueParam, class Reference>
        struct iterator_writability_disabled
            : mpl::or_<
                  is_const<Reference>, boost::detail::indirect_traits::is_reference_to_const<Reference>, is_const<ValueParam>>
        {
        };
        template <class Traversal, class ValueParam, class Reference>
        struct iterator_facade_default_category
            : mpl::eval_if<
                  mpl::and_<
                      is_reference<Reference>, is_convertible<Traversal, forward_traversal_tag>>,
                  mpl::eval_if<
                      is_convertible<Traversal, random_access_traversal_tag>, mpl::identity<std::random_access_iterator_tag>, mpl::if_<is_convertible<Traversal, bidirectional_traversal_tag>, std::bidirectional_iterator_tag, std::forward_iterator_tag>>,
                  typename mpl::eval_if<
                      mpl::and_<
                          is_convertible<Traversal, single_pass_traversal_tag>, is_convertible<Reference, ValueParam>>,
                      mpl::identity<std::input_iterator_tag>, mpl::identity<Traversal>>>
        {
        };
        template <class T>
        struct is_iterator_category
            : mpl::or_<
                  is_convertible<T, std::input_iterator_tag>, is_convertible<T, std::output_iterator_tag>>
        {
        };
        template <class T>
        struct is_iterator_traversal
            : is_convertible<T, incrementable_traversal_tag>
        {
        };
        template <class Category, class Traversal>
        struct iterator_category_with_traversal
            : Category,
              Traversal
        {
            enum
            {
                mpl_assertion_in_line_146 = sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void (*)(is_convertible<typename iterator_category_to_traversal<Category>::type, Traversal>))0, 1)))
            };
            enum
            {
                mpl_assertion_in_line_148 = sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_arg((void (*)(is_iterator_category<Category>))0, 1)))
            };
            enum
            {
                mpl_assertion_in_line_149 = sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void (*)(is_iterator_category<Traversal>))0, 1)))
            };
            enum
            {
                mpl_assertion_in_line_150 = sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void (*)(is_iterator_traversal<Category>))0, 1)))
            };
            enum
            {
                mpl_assertion_in_line_152 = sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_arg((void (*)(is_iterator_traversal<Traversal>))0, 1)))
            };
        };
        template <class Traversal, class ValueParam, class Reference>
        struct facade_iterator_category_impl
        {
            enum
            {
                mpl_assertion_in_line_161 = sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void (*)(is_iterator_category<Traversal>))0, 1)))
            };
            typedef typename iterator_facade_default_category<
                Traversal, ValueParam, Reference>::type category;
            typedef typename mpl::if_<
                is_same<
                    Traversal, typename iterator_category_to_traversal<category>::type>,
                category, iterator_category_with_traversal<category, Traversal>>::type type;
        };
        template <class CategoryOrTraversal, class ValueParam, class Reference>
        struct facade_iterator_category
            : mpl::eval_if<
                  is_iterator_category<CategoryOrTraversal>, mpl::identity<CategoryOrTraversal>, facade_iterator_category_impl<CategoryOrTraversal, ValueParam, Reference>>
        {
        };
}
    }
}
namespace boost
{
    namespace iterators
    {
template <bool>
struct enabled
{
        template <typename T>
        struct base
        {
            typedef T type;
        };
};
template <>
struct enabled<false>
{
        template <typename T>
        struct base
        {
        };
};
template <class Cond,
          class Return>
struct enable_if
    : enabled<(Cond::value)>::template base<Return>
{
};
    }
}
namespace boost
{
    template <class T>
    struct add_const
    {
typedef T const type;
    };
    template <class T>
    struct add_const<T &>
    {
typedef T &type;
    };
}
namespace boost
{
    template <typename T>
    struct add_pointer
    {
typedef typename remove_reference<T>::type no_ref_type;
typedef no_ref_type *type;
    };
}
namespace boost
{
    namespace detail
    {
template <typename T>
struct add_reference_impl
{
        typedef T &type;
};
    }
    template <class T>
    struct add_reference
    {
typedef typename boost::detail::add_reference_impl<T>::type type;
    };
    template <class T>
    struct add_reference<T &>
    {
typedef T &type;
    };
    template <>
    struct add_reference<void>
    {
typedef void type;
    };
    template <>
    struct add_reference<const void>
    {
typedef const void type;
    };
    template <>
    struct add_reference<const volatile void>
    {
typedef const volatile void type;
    };
    template <>
    struct add_reference<volatile void>
    {
typedef volatile void type;
    };
}

namespace boost
{
    template <class T>
    struct add_lvalue_reference
    {
typedef typename boost::add_reference<T>::type type;
    };
}
namespace boost
{
    template <class T>
    struct remove_const
    {
typedef T type;
    };
    template <class T>
    struct remove_const<T const>
    {
typedef T type;
    };
    template <class T, std::size_t N>
    struct remove_const<T const [N]>
    { typedef T type[N]; };
    template <class T>
    struct remove_const<T const[]> { typedef T type[]; };
}
namespace boost
{
    template <class T>
    struct is_integral : public false_type
    {
    };
    template <class T>
    struct is_integral<const T> : public is_integral<T>
    {
    };
    template <class T>
    struct is_integral<volatile const T> : public is_integral<T>
    {
    };
    template <class T>
    struct is_integral<volatile T> : public is_integral<T>
    {
    };
    template <>
    struct is_integral<unsigned char> : public true_type
    {
    };
    template <>
    struct is_integral<unsigned short> : public true_type
    {
    };
    template <>
    struct is_integral<unsigned int> : public true_type
    {
    };
    template <>
    struct is_integral<unsigned long> : public true_type
    {
    };
    template <>
    struct is_integral<signed char> : public true_type
    {
    };
    template <>
    struct is_integral<short> : public true_type
    {
    };
    template <>
    struct is_integral<int> : public true_type
    {
    };
    template <>
    struct is_integral<long> : public true_type
    {
    };
    template <>
    struct is_integral<char> : public true_type
    {
    };
    template <>
    struct is_integral<bool> : public true_type
    {
    };
    template <>
    struct is_integral<wchar_t> : public true_type
    {
    };
    template <>
    struct is_integral<::boost::ulong_long_type> : public true_type
    {
    };
    template <>
    struct is_integral<::boost::long_long_type> : public true_type
    {
    };
    template <>
    struct is_integral<boost::int128_type> : public true_type
    {
    };
    template <>
    struct is_integral<boost::uint128_type> : public true_type
    {
    };
}
namespace boost
{
    template <class T>
    struct is_floating_point : public false_type
    {
    };
    template <class T>
    struct is_floating_point<const T> : public is_floating_point<T>
    {
    };
    template <class T>
    struct is_floating_point<volatile const T> : public is_floating_point<T>
    {
    };
    template <class T>
    struct is_floating_point<volatile T> : public is_floating_point<T>
    {
    };
    template <>
    struct is_floating_point<float> : public true_type
    {
    };
    template <>
    struct is_floating_point<double> : public true_type
    {
    };
    template <>
    struct is_floating_point<long double> : public true_type
    {
    };
}

namespace boost
{
    template <class T>
    struct is_arithmetic : public integral_constant<bool, is_integral<T>::value || is_floating_point<T>::value>
    {
    };
}
namespace boost
{
    template <class T>
    struct is_enum : public integral_constant<bool, __is_enum(T)>
    {
    };
}
namespace boost
{
    template <typename T>
    struct is_scalar
        : public integral_constant<bool, ::boost::is_arithmetic<T>::value || ::boost::is_enum<T>::value || ::boost::is_pointer<T>::value || ::boost::is_member_pointer<T>::value>
    {
    };
}
namespace boost
{
    template <typename T>
    struct is_POD;
    template <typename T>
    struct is_pod
        : public integral_constant<bool, ::boost::is_scalar<T>::value || ::boost::is_void<T>::value || __is_pod(T)>
    {
    };
    template <typename T, std::size_t sz>
    struct is_pod<T[sz]> : public is_pod<T>
    {
    };
    template <>
    struct is_pod<void> : public true_type
    {
    };
    template <>
    struct is_pod<void const> : public true_type
    {
    };
    template <>
    struct is_pod<void const volatile> : public true_type
    {
    };
    template <>
    struct is_pod<void volatile> : public true_type
    {
    };
    template <class T>
    struct is_POD : public is_pod<T>
    {
    };
}
namespace boost
{
    namespace mpl
    {
template <typename Value>
struct always
{
        template <
            typename T1 = na, typename T2 = na, typename T3 = na, typename T4 = na, typename T5 = na>
        struct apply
        {
            typedef Value type;
        };
};
    }
}
namespace boost
{
    namespace mpl
    {
template <
    typename F, typename T1 = na, typename T2 = na, typename T3 = na, typename T4 = na, typename T5 = na>
struct apply;
template <
    typename F>
struct apply0;
template <
    typename F, typename T1>
struct apply1;
template <
    typename F, typename T1, typename T2>
struct apply2;
template <
    typename F, typename T1, typename T2, typename T3>
struct apply3;
template <
    typename F, typename T1, typename T2, typename T3, typename T4>
struct apply4;
template <
    typename F, typename T1, typename T2, typename T3, typename T4, typename T5>
struct apply5;
    }
}
namespace boost
{
    namespace mpl
    {
namespace aux
{
        template <typename T>
        struct type_wrapper
        {
            typedef T type;
        };
        template <typename T>
        struct wrapped_type;
        template <typename T>
        struct wrapped_type<type_wrapper<T>>
        {
            typedef T type;
        };
}
    }
}

namespace boost
{
    namespace mpl
    {
namespace aux
{
        template <typename T, typename fallback_ = boost::mpl::bool_<false>>
        struct has_apply
        {
            struct gcc_3_2_wknd
            {
                template <typename U>
                static boost::mpl::aux::yes_tag test(boost::mpl::aux::type_wrapper<U> const volatile *, boost::mpl::aux::type_wrapper<typename U::apply> * = 0);
                static boost::mpl::aux::no_tag test(...);
            };
            typedef boost::mpl::aux::type_wrapper<T> t_;
            static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_ *>(0))) == sizeof(boost::mpl::aux::yes_tag);
            typedef boost::mpl::bool_<value> type;
        };
}
    }
}

namespace boost
{
    namespace mpl
    {
template <
    typename F, typename has_apply_ = typename aux::has_apply<F>::type>
struct apply_wrap0
    : F::template apply<>
{
};
template <typename F>
struct apply_wrap0<F, true_>
    : F::apply
{
};
template <
    typename F, typename T1>
struct apply_wrap1
    : F::template apply<T1>
{
};
template <
    typename F, typename T1, typename T2>
struct apply_wrap2
    : F::template apply<T1, T2>
{
};
template <
    typename F, typename T1, typename T2, typename T3>
struct apply_wrap3
    : F::template apply<T1, T2, T3>
{
};
template <
    typename F, typename T1, typename T2, typename T3, typename T4>
struct apply_wrap4
    : F::template apply<T1, T2, T3, T4>
{
};
template <
    typename F, typename T1, typename T2, typename T3, typename T4, typename T5>
struct apply_wrap5
    : F::template apply<T1, T2, T3, T4, T5>
{
};
    }
}
namespace boost
{
    namespace mpl
    {
template <
    typename F, typename T1 = na, typename T2 = na, typename T3 = na, typename T4 = na, typename T5 = na>
struct bind;
template <
    typename F>
struct bind0;
template <
    typename F, typename T1>
struct bind1;
template <
    typename F, typename T1, typename T2>
struct bind2;
template <
    typename F, typename T1, typename T2, typename T3>
struct bind3;
template <
    typename F, typename T1, typename T2, typename T3, typename T4>
struct bind4;
template <
    typename F, typename T1, typename T2, typename T3, typename T4, typename T5>
struct bind5;
    }
}
namespace boost
{
    namespace mpl
    {
template <
    typename T = na>
struct next
{
        typedef typename T::next type;
};
template <
    typename T = na>
struct prior
{
        typedef typename T::prior type;
};
template <>
struct next<na>
{
        template <typename T1, typename T2 = na, typename T3 = na, typename T4 = na, typename T5 = na>
        struct apply : next<T1>
        {
        };
};
template <typename Tag>
struct lambda<next<na>, Tag, int_<-1>>
{
        typedef false_ is_le;
        typedef next<na> result_;
        typedef next<na> type;
};
namespace aux
{
        template <typename T1>
        struct template_arity<next<T1>> : int_<1>
        {
        };
        template <>
        struct template_arity<next<na>> : int_<-1>
        {
        };
}
template <>
struct prior<na>
{
        template <typename T1, typename T2 = na, typename T3 = na, typename T4 = na, typename T5 = na>
        struct apply : prior<T1>
        {
        };
};
template <typename Tag>
struct lambda<prior<na>, Tag, int_<-1>>
{
        typedef false_ is_le;
        typedef prior<na> result_;
        typedef prior<na> type;
};
namespace aux
{
        template <typename T1>
        struct template_arity<prior<T1>> : int_<1>
        {
        };
        template <>
        struct template_arity<prior<na>> : int_<-1>
        {
        };
}
    }
}
namespace boost
{
    namespace mpl
    {
template <
    typename T = na, int not_le_ = 0>
struct protect : T
{
        typedef protect type;
};
template <>
struct protect<na>
{
        template <typename T1, typename T2 = na, typename T3 = na, typename T4 = na, typename T5 = na>
        struct apply : protect<T1>
        {
        };
};
namespace aux
{
        template <typename T1>
        struct template_arity<protect<T1>> : int_<1>
        {
        };
        template <>
        struct template_arity<protect<na>> : int_<-1>
        {
        };
}
    }
}
namespace boost
{
    namespace mpl
    {
namespace aux
{
        template <
            typename T, typename U1, typename U2, typename U3, typename U4, typename U5>
        struct resolve_bind_arg
        {
            typedef T type;
        };
        template <
            typename T, typename Arg>
        struct replace_unnamed_arg
        {
            typedef Arg next;
            typedef T type;
        };
        template <
            typename Arg>
        struct replace_unnamed_arg<arg<-1>, Arg>
        {
            typedef typename Arg::next next;
            typedef Arg type;
        };
        template <
            int N, typename U1, typename U2, typename U3, typename U4, typename U5>
        struct resolve_bind_arg<arg<N>, U1, U2, U3, U4, U5>
        {
            typedef typename apply_wrap5<mpl::arg<N>, U1, U2, U3, U4, U5>::type type;
        };
        template <
            typename F, typename T1, typename T2, typename T3, typename T4, typename T5, typename U1, typename U2, typename U3, typename U4, typename U5>
        struct resolve_bind_arg<bind<F, T1, T2, T3, T4, T5>, U1, U2, U3, U4, U5>
        {
            typedef bind<F, T1, T2, T3, T4, T5> f_;
            typedef typename apply_wrap5<f_, U1, U2, U3, U4, U5>::type type;
        };
}
template <
    typename F>
struct bind0
{
        template <
            typename U1 = na, typename U2 = na, typename U3 = na, typename U4 = na, typename U5 = na>
        struct apply
        {
        private:
            typedef aux::replace_unnamed_arg<F, mpl::arg<1>> r0;
            typedef typename r0::type a0;
            typedef typename r0::next n1;
            typedef typename aux::resolve_bind_arg<a0, U1, U2, U3, U4, U5>::type f_;

        public:
            typedef typename apply_wrap0<
                f_>::type type;
        };
};
namespace aux
{
        template <
            typename F, typename U1, typename U2, typename U3, typename U4, typename U5>
        struct resolve_bind_arg<
            bind0<F>, U1, U2, U3, U4, U5>
        {
            typedef bind0<F> f_;
            typedef typename apply_wrap5<f_, U1, U2, U3, U4, U5>::type type;
        };
}
namespace aux
{
        template <typename T1>
        struct template_arity<bind0<T1>> : int_<1>
        {
        };
}
template <
    typename F>
struct bind<F, na, na, na, na, na>
    : bind0<F>
{
};
template <
    typename F, typename T1>
struct bind1
{
        template <
            typename U1 = na, typename U2 = na, typename U3 = na, typename U4 = na, typename U5 = na>
        struct apply
        {
        private:
            typedef aux::replace_unnamed_arg<F, mpl::arg<1>> r0;
            typedef typename r0::type a0;
            typedef typename r0::next n1;
            typedef typename aux::resolve_bind_arg<a0, U1, U2, U3, U4, U5>::type f_;
            typedef aux::replace_unnamed_arg<T1, n1> r1;
            typedef typename r1::type a1;
            typedef typename r1::next n2;
            typedef aux::resolve_bind_arg<a1, U1, U2, U3, U4, U5> t1;

        public:
            typedef typename apply_wrap1<
                f_, typename t1::type>::type type;
        };
};
namespace aux
{
        template <
            typename F, typename T1, typename U1, typename U2, typename U3, typename U4, typename U5>
        struct resolve_bind_arg<
            bind1<F, T1>, U1, U2, U3, U4, U5>
        {
            typedef bind1<F, T1> f_;
            typedef typename apply_wrap5<f_, U1, U2, U3, U4, U5>::type type;
        };
}
namespace aux
{
        template <typename T1, typename T2>
        struct template_arity<bind1<T1, T2>> : int_<2>
        {
        };
}
template <
    typename F, typename T1>
struct bind<F, T1, na, na, na, na>
    : bind1<F, T1>
{
};
template <
    typename F, typename T1, typename T2>
struct bind2
{
        template <
            typename U1 = na, typename U2 = na, typename U3 = na, typename U4 = na, typename U5 = na>
        struct apply
        {
        private:
            typedef aux::replace_unnamed_arg<F, mpl::arg<1>> r0;
            typedef typename r0::type a0;
            typedef typename r0::next n1;
            typedef typename aux::resolve_bind_arg<a0, U1, U2, U3, U4, U5>::type f_;
            typedef aux::replace_unnamed_arg<T1, n1> r1;
            typedef typename r1::type a1;
            typedef typename r1::next n2;
            typedef aux::resolve_bind_arg<a1, U1, U2, U3, U4, U5> t1;
            typedef aux::replace_unnamed_arg<T2, n2> r2;
            typedef typename r2::type a2;
            typedef typename r2::next n3;
            typedef aux::resolve_bind_arg<a2, U1, U2, U3, U4, U5> t2;

        public:
            typedef typename apply_wrap2<
                f_, typename t1::type, typename t2::type>::type type;
        };
};
namespace aux
{
        template <
            typename F, typename T1, typename T2, typename U1, typename U2, typename U3, typename U4, typename U5>
        struct resolve_bind_arg<
            bind2<F, T1, T2>, U1, U2, U3, U4, U5>
        {
            typedef bind2<F, T1, T2> f_;
            typedef typename apply_wrap5<f_, U1, U2, U3, U4, U5>::type type;
        };
}
namespace aux
{
        template <typename T1, typename T2, typename T3>
        struct template_arity<bind2<T1, T2, T3>> : int_<3>
        {
        };
}
template <
    typename F, typename T1, typename T2>
struct bind<F, T1, T2, na, na, na>
    : bind2<F, T1, T2>
{
};
template <
    typename F, typename T1, typename T2, typename T3>
struct bind3
{
        template <
            typename U1 = na, typename U2 = na, typename U3 = na, typename U4 = na, typename U5 = na>
        struct apply
        {
        private:
            typedef aux::replace_unnamed_arg<F, mpl::arg<1>> r0;
            typedef typename r0::type a0;
            typedef typename r0::next n1;
            typedef typename aux::resolve_bind_arg<a0, U1, U2, U3, U4, U5>::type f_;
            typedef aux::replace_unnamed_arg<T1, n1> r1;
            typedef typename r1::type a1;
            typedef typename r1::next n2;
            typedef aux::resolve_bind_arg<a1, U1, U2, U3, U4, U5> t1;
            typedef aux::replace_unnamed_arg<T2, n2> r2;
            typedef typename r2::type a2;
            typedef typename r2::next n3;
            typedef aux::resolve_bind_arg<a2, U1, U2, U3, U4, U5> t2;
            typedef aux::replace_unnamed_arg<T3, n3> r3;
            typedef typename r3::type a3;
            typedef typename r3::next n4;
            typedef aux::resolve_bind_arg<a3, U1, U2, U3, U4, U5> t3;

        public:
            typedef typename apply_wrap3<
                f_, typename t1::type, typename t2::type, typename t3::type>::type type;
        };
};
namespace aux
{
        template <
            typename F, typename T1, typename T2, typename T3, typename U1, typename U2, typename U3, typename U4, typename U5>
        struct resolve_bind_arg<
            bind3<F, T1, T2, T3>, U1, U2, U3, U4, U5>
        {
            typedef bind3<F, T1, T2, T3> f_;
            typedef typename apply_wrap5<f_, U1, U2, U3, U4, U5>::type type;
        };
}
namespace aux
{
        template <typename T1, typename T2, typename T3, typename T4>
        struct template_arity<bind3<T1, T2, T3, T4>> : int_<4>
        {
        };
}
template <
    typename F, typename T1, typename T2, typename T3>
struct bind<F, T1, T2, T3, na, na>
    : bind3<F, T1, T2, T3>
{
};
template <
    typename F, typename T1, typename T2, typename T3, typename T4>
struct bind4
{
        template <
            typename U1 = na, typename U2 = na, typename U3 = na, typename U4 = na, typename U5 = na>
        struct apply
        {
        private:
            typedef aux::replace_unnamed_arg<F, mpl::arg<1>> r0;
            typedef typename r0::type a0;
            typedef typename r0::next n1;
            typedef typename aux::resolve_bind_arg<a0, U1, U2, U3, U4, U5>::type f_;
            typedef aux::replace_unnamed_arg<T1, n1> r1;
            typedef typename r1::type a1;
            typedef typename r1::next n2;
            typedef aux::resolve_bind_arg<a1, U1, U2, U3, U4, U5> t1;
            typedef aux::replace_unnamed_arg<T2, n2> r2;
            typedef typename r2::type a2;
            typedef typename r2::next n3;
            typedef aux::resolve_bind_arg<a2, U1, U2, U3, U4, U5> t2;
            typedef aux::replace_unnamed_arg<T3, n3> r3;
            typedef typename r3::type a3;
            typedef typename r3::next n4;
            typedef aux::resolve_bind_arg<a3, U1, U2, U3, U4, U5> t3;
            typedef aux::replace_unnamed_arg<T4, n4> r4;
            typedef typename r4::type a4;
            typedef typename r4::next n5;
            typedef aux::resolve_bind_arg<a4, U1, U2, U3, U4, U5> t4;

        public:
            typedef typename apply_wrap4<
                f_, typename t1::type, typename t2::type, typename t3::type, typename t4::type>::type type;
        };
};
namespace aux
{
        template <
            typename F, typename T1, typename T2, typename T3, typename T4, typename U1, typename U2, typename U3, typename U4, typename U5>
        struct resolve_bind_arg<
            bind4<F, T1, T2, T3, T4>, U1, U2, U3, U4, U5>
        {
            typedef bind4<F, T1, T2, T3, T4> f_;
            typedef typename apply_wrap5<f_, U1, U2, U3, U4, U5>::type type;
        };
}
namespace aux
{
        template <typename T1, typename T2, typename T3, typename T4, typename T5>
        struct template_arity<bind4<T1, T2, T3, T4, T5>> : int_<5>
        {
        };
}
template <
    typename F, typename T1, typename T2, typename T3, typename T4>
struct bind<F, T1, T2, T3, T4, na>
    : bind4<F, T1, T2, T3, T4>
{
};
template <
    typename F, typename T1, typename T2, typename T3, typename T4, typename T5>
struct bind5
{
        template <
            typename U1 = na, typename U2 = na, typename U3 = na, typename U4 = na, typename U5 = na>
        struct apply
        {
        private:
            typedef aux::replace_unnamed_arg<F, mpl::arg<1>> r0;
            typedef typename r0::type a0;
            typedef typename r0::next n1;
            typedef typename aux::resolve_bind_arg<a0, U1, U2, U3, U4, U5>::type f_;
            typedef aux::replace_unnamed_arg<T1, n1> r1;
            typedef typename r1::type a1;
            typedef typename r1::next n2;
            typedef aux::resolve_bind_arg<a1, U1, U2, U3, U4, U5> t1;
            typedef aux::replace_unnamed_arg<T2, n2> r2;
            typedef typename r2::type a2;
            typedef typename r2::next n3;
            typedef aux::resolve_bind_arg<a2, U1, U2, U3, U4, U5> t2;
            typedef aux::replace_unnamed_arg<T3, n3> r3;
            typedef typename r3::type a3;
            typedef typename r3::next n4;
            typedef aux::resolve_bind_arg<a3, U1, U2, U3, U4, U5> t3;
            typedef aux::replace_unnamed_arg<T4, n4> r4;
            typedef typename r4::type a4;
            typedef typename r4::next n5;
            typedef aux::resolve_bind_arg<a4, U1, U2, U3, U4, U5> t4;
            typedef aux::replace_unnamed_arg<T5, n5> r5;
            typedef typename r5::type a5;
            typedef typename r5::next n6;
            typedef aux::resolve_bind_arg<a5, U1, U2, U3, U4, U5> t5;

        public:
            typedef typename apply_wrap5<
                f_, typename t1::type, typename t2::type, typename t3::type, typename t4::type, typename t5::type>::type type;
        };
};
namespace aux
{
        template <
            typename F, typename T1, typename T2, typename T3, typename T4, typename T5, typename U1, typename U2, typename U3, typename U4, typename U5>
        struct resolve_bind_arg<
            bind5<F, T1, T2, T3, T4, T5>, U1, U2, U3, U4, U5>
        {
            typedef bind5<F, T1, T2, T3, T4, T5> f_;
            typedef typename apply_wrap5<f_, U1, U2, U3, U4, U5>::type type;
        };
}
namespace aux
{
        template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
        struct template_arity<bind5<T1, T2, T3, T4, T5, T6>> : int_<6>
        {
        };
}
template <
    typename F, typename T1, typename T2, typename T3, typename T4, typename T5>
struct bind
    : bind5<F, T1, T2, T3, T4, T5>
{
};
template <template <typename T1, typename T2, typename T3> class F, typename Tag>
struct quote3;
template <typename T1, typename T2, typename T3>
struct if_;
template <
    typename Tag, typename T1, typename T2, typename T3>
struct bind3<
    quote3<if_, Tag>, T1, T2, T3>
{
        template <
            typename U1 = na, typename U2 = na, typename U3 = na, typename U4 = na, typename U5 = na>
        struct apply
        {
        private:
            typedef mpl::arg<1> n1;
            typedef aux::replace_unnamed_arg<T1, n1> r1;
            typedef typename r1::type a1;
            typedef typename r1::next n2;
            typedef aux::resolve_bind_arg<a1, U1, U2, U3, U4, U5> t1;
            typedef aux::replace_unnamed_arg<T2, n2> r2;
            typedef typename r2::type a2;
            typedef typename r2::next n3;
            typedef aux::resolve_bind_arg<a2, U1, U2, U3, U4, U5> t2;
            typedef aux::replace_unnamed_arg<T3, n3> r3;
            typedef typename r3::type a3;
            typedef typename r3::next n4;
            typedef aux::resolve_bind_arg<a3, U1, U2, U3, U4, U5> t3;
            typedef typename if_<
                typename t1::type, t2, t3>::type f_;

        public:
            typedef typename f_::type type;
        };
};
template <
    template <typename T1, typename T2, typename T3> class F, typename Tag>
struct quote3;
template <typename T1, typename T2, typename T3>
struct eval_if;
template <
    typename Tag, typename T1, typename T2, typename T3>
struct bind3<
    quote3<eval_if, Tag>, T1, T2, T3>
{
        template <
            typename U1 = na, typename U2 = na, typename U3 = na, typename U4 = na, typename U5 = na>
        struct apply
        {
        private:
            typedef mpl::arg<1> n1;
            typedef aux::replace_unnamed_arg<T1, n1> r1;
            typedef typename r1::type a1;
            typedef typename r1::next n2;
            typedef aux::resolve_bind_arg<a1, U1, U2, U3, U4, U5> t1;
            typedef aux::replace_unnamed_arg<T2, n2> r2;
            typedef typename r2::type a2;
            typedef typename r2::next n3;
            typedef aux::resolve_bind_arg<a2, U1, U2, U3, U4, U5> t2;
            typedef aux::replace_unnamed_arg<T3, n3> r3;
            typedef typename r3::type a3;
            typedef typename r3::next n4;
            typedef aux::resolve_bind_arg<a3, U1, U2, U3, U4, U5> t3;
            typedef typename eval_if<
                typename t1::type, t2, t3>::type f_;

        public:
            typedef typename f_::type type;
        };
};
    }
}

namespace mpl_
{
    struct void_
    {
typedef void_ type;
    };
}
namespace boost
{
    namespace mpl
    {
template <typename T>
struct is_void_
    : false_
{
};
template <>
struct is_void_<void_>
    : true_
{
};
template <typename T>
struct is_not_void_
    : true_
{
};
template <>
struct is_not_void_<void_>
    : false_
{
};
template <>
struct is_void_<na>
{
        template <typename T1, typename T2 = na, typename T3 = na, typename T4 = na, typename T5 = na>
        struct apply : is_void_<T1>
        {
        };
};
template <typename Tag>
struct lambda<is_void_<na>, Tag, int_<-1>>
{
        typedef false_ is_le;
        typedef is_void_<na> result_;
        typedef is_void_<na> type;
};
namespace aux
{
        template <typename T1>
        struct template_arity<is_void_<T1>> : int_<1>
        {
        };
        template <>
        struct template_arity<is_void_<na>> : int_<-1>
        {
        };
}
template <>
struct is_not_void_<na>
{
        template <typename T1, typename T2 = na, typename T3 = na, typename T4 = na, typename T5 = na>
        struct apply : is_not_void_<T1>
        {
        };
};
template <typename Tag>
struct lambda<is_not_void_<na>, Tag, int_<-1>>
{
        typedef false_ is_le;
        typedef is_not_void_<na> result_;
        typedef is_not_void_<na> type;
};
namespace aux
{
        template <typename T1>
        struct template_arity<is_not_void_<T1>> : int_<1>
        {
        };
        template <>
        struct template_arity<is_not_void_<na>> : int_<-1>
        {
        };
}
    }
}
namespace boost
{
    namespace mpl
    {
namespace aux
{
        template <typename T, typename fallback_ = boost::mpl::bool_<true>>
        struct has_type
        {
            struct gcc_3_2_wknd
            {
                template <typename U>
                static boost::mpl::aux::yes_tag test(boost::mpl::aux::type_wrapper<U> const volatile *, boost::mpl::aux::type_wrapper<typename U::type> * = 0);
                static boost::mpl::aux::no_tag test(...);
            };
            typedef boost::mpl::aux::type_wrapper<T> t_;
            static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_ *>(0))) == sizeof(boost::mpl::aux::yes_tag);
            typedef boost::mpl::bool_<value> type;
        };
}
    }
}
namespace boost
{
    namespace mpl
    {
template <typename T, bool has_type_>
struct quote_impl
{
        typedef typename T::type type;
};
template <typename T>
struct quote_impl<T, false>
{
        typedef T type;
};
template <
    template <typename P1> class F, typename Tag = void_>
struct quote1
{
        template <typename U1>
        struct apply
            : quote_impl<
                  F<U1>, aux::has_type<F<U1>>::value>
        {
        };
};
template <
    template <typename P1, typename P2> class F, typename Tag = void_>
struct quote2
{
        template <typename U1, typename U2>
        struct apply
            : quote_impl<
                  F<U1, U2>, aux::has_type<F<U1, U2>>::value>
        {
        };
};
template <
    template <typename P1, typename P2, typename P3> class F, typename Tag = void_>
struct quote3
{
        template <typename U1, typename U2, typename U3>
        struct apply
            : quote_impl<
                  F<U1, U2, U3>, aux::has_type<F<U1, U2, U3>>::value>
        {
        };
};
template <
    template <typename P1, typename P2, typename P3, typename P4> class F, typename Tag = void_>
struct quote4
{
        template <
            typename U1, typename U2, typename U3, typename U4>
        struct apply
            : quote_impl<
                  F<U1, U2, U3, U4>, aux::has_type<F<U1, U2, U3, U4>>::value>
        {
        };
};
template <
    template <
        typename P1, typename P2, typename P3, typename P4, typename P5>
    class F,
    typename Tag = void_>
struct quote5
{
        template <
            typename U1, typename U2, typename U3, typename U4, typename U5>
        struct apply
            : quote_impl<
                  F<U1, U2, U3, U4, U5>, aux::has_type<F<U1, U2, U3, U4, U5>>::value>
        {
        };
};
    }
}
namespace boost
{
    namespace mpl
    {
namespace aux
{
        template <int N>
        struct arity_tag
        {
            typedef char (&type)[(unsigned)N + 1];
        };
        template <
            int C1, int C2, int C3, int C4, int C5, int C6>
        struct max_arity
        {
            static const int value = (C6 > 0 ? C6 : (C5 > 0 ? C5 : (C4 > 0 ? C4 : (C3 > 0 ? C3 : (C2 > 0 ? C2 : (C1 > 0 ? C1 : -1))))));
        };
        arity_tag<0>::type arity_helper(...);
        template <
            template <typename P1> class F, typename T1>
        typename arity_tag<1>::type
            arity_helper(type_wrapper<F<T1>>, arity_tag<1>);
        template <
            template <typename P1, typename P2> class F, typename T1, typename T2>
        typename arity_tag<2>::type
            arity_helper(type_wrapper<F<T1, T2>>, arity_tag<2>);
        template <
            template <typename P1, typename P2, typename P3> class F, typename T1, typename T2, typename T3>
        typename arity_tag<3>::type
            arity_helper(type_wrapper<F<T1, T2, T3>>, arity_tag<3>);
        template <
            template <typename P1, typename P2, typename P3, typename P4> class F, typename T1, typename T2, typename T3, typename T4>
        typename arity_tag<4>::type
            arity_helper(type_wrapper<F<T1, T2, T3, T4>>, arity_tag<4>);
        template <
            template <
                typename P1, typename P2, typename P3, typename P4, typename P5>
            class F,
            typename T1, typename T2, typename T3, typename T4, typename T5>
        typename arity_tag<5>::type
            arity_helper(type_wrapper<F<T1, T2, T3, T4, T5>>, arity_tag<5>);
        template <
            template <
                typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
            class F,
            typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
        typename arity_tag<6>::type
            arity_helper(type_wrapper<F<T1, T2, T3, T4, T5, T6>>, arity_tag<6>);
        template <typename F, int N>
        struct template_arity_impl
        {
            static const int value = sizeof(::boost::mpl::aux::arity_helper(type_wrapper<F>(), arity_tag<N>())) - 1;
        };
        template <typename F>
        struct template_arity
        {
            static const int value = (max_arity<template_arity_impl<F, 1>::value, template_arity_impl<F, 2>::value, template_arity_impl<F, 3>::value, template_arity_impl<F, 4>::value, template_arity_impl<F, 5>::value, template_arity_impl<F, 6>::value>::value);
            typedef mpl::int_<value> type;
        };
}
    }
}
namespace boost
{
    namespace mpl
    {
namespace aux
{
        template <
            bool C1 = false, bool C2 = false, bool C3 = false, bool C4 = false, bool C5 = false>
        struct lambda_or
            : true_
        {
        };
        template <>
        struct lambda_or<false, false, false, false, false>
            : false_
        {
        };
}
template <
    typename T, typename Tag, typename Arity>
struct lambda
{
        typedef false_ is_le;
        typedef T result_;
        typedef T type;
};
template <
    typename T>
struct is_lambda_expression
    : lambda<T>::is_le
{
};
template <int N, typename Tag>
struct lambda<arg<N>, Tag, int_<-1>>
{
        typedef true_ is_le;
        typedef mpl::arg<N> result_;
        typedef mpl::protect<result_> type;
};
template <
    typename F, typename Tag>
struct lambda<
    bind0<F>, Tag, int_<1>>
{
        typedef false_ is_le;
        typedef bind0<
            F>
            result_;
        typedef result_ type;
};
namespace aux
{
        template <
            typename IsLE, typename Tag, template <typename P1> class F, typename L1>
        struct le_result1
        {
            typedef F<
                typename L1::type>
                result_;
            typedef result_ type;
        };
        template <
            typename Tag, template <typename P1> class F, typename L1>
        struct le_result1<true_, Tag, F, L1>
        {
            typedef bind1<
                quote1<F, Tag>, typename L1::result_>
                result_;
            typedef mpl::protect<result_> type;
        };
}
template <
    template <typename P1> class F, typename T1, typename Tag>
struct lambda<
    F<T1>, Tag, int_<1>>
{
        typedef lambda<T1, Tag> l1;
        typedef typename l1::is_le is_le1;
        typedef typename aux::lambda_or<
            is_le1::value>::type is_le;
        typedef aux::le_result1<
            is_le, Tag, F, l1>
            le_result_;
        typedef typename le_result_::result_ result_;
        typedef typename le_result_::type type;
};
template <
    typename F, typename T1, typename Tag>
struct lambda<
    bind1<F, T1>, Tag, int_<2>>
{
        typedef false_ is_le;
        typedef bind1<
            F, T1>
            result_;
        typedef result_ type;
};
namespace aux
{
        template <
            typename IsLE, typename Tag, template <typename P1, typename P2> class F, typename L1, typename L2>
        struct le_result2
        {
            typedef F<
                typename L1::type, typename L2::type>
                result_;
            typedef result_ type;
        };
        template <
            typename Tag, template <typename P1, typename P2> class F, typename L1, typename L2>
        struct le_result2<true_, Tag, F, L1, L2>
        {
            typedef bind2<
                quote2<F, Tag>, typename L1::result_, typename L2::result_>
                result_;
            typedef mpl::protect<result_> type;
        };
}
template <
    template <typename P1, typename P2> class F, typename T1, typename T2, typename Tag>
struct lambda<
    F<T1, T2>, Tag, int_<2>>
{
        typedef lambda<T1, Tag> l1;
        typedef lambda<T2, Tag> l2;
        typedef typename l1::is_le is_le1;
        typedef typename l2::is_le is_le2;
        typedef typename aux::lambda_or<
            is_le1::value, is_le2::value>::type is_le;
        typedef aux::le_result2<
            is_le, Tag, F, l1, l2>
            le_result_;
        typedef typename le_result_::result_ result_;
        typedef typename le_result_::type type;
};
template <
    typename F, typename T1, typename T2, typename Tag>
struct lambda<
    bind2<F, T1, T2>, Tag, int_<3>>
{
        typedef false_ is_le;
        typedef bind2<
            F, T1, T2>
            result_;
        typedef result_ type;
};
namespace aux
{
        template <
            typename IsLE, typename Tag, template <typename P1, typename P2, typename P3> class F, typename L1, typename L2, typename L3>
        struct le_result3
        {
            typedef F<
                typename L1::type, typename L2::type, typename L3::type>
                result_;
            typedef result_ type;
        };
        template <
            typename Tag, template <typename P1, typename P2, typename P3> class F, typename L1, typename L2, typename L3>
        struct le_result3<true_, Tag, F, L1, L2, L3>
        {
            typedef bind3<
                quote3<F, Tag>, typename L1::result_, typename L2::result_, typename L3::result_>
                result_;
            typedef mpl::protect<result_> type;
        };
}
template <
    template <typename P1, typename P2, typename P3> class F, typename T1, typename T2, typename T3, typename Tag>
struct lambda<
    F<T1, T2, T3>, Tag, int_<3>>
{
        typedef lambda<T1, Tag> l1;
        typedef lambda<T2, Tag> l2;
        typedef lambda<T3, Tag> l3;
        typedef typename l1::is_le is_le1;
        typedef typename l2::is_le is_le2;
        typedef typename l3::is_le is_le3;
        typedef typename aux::lambda_or<
            is_le1::value, is_le2::value, is_le3::value>::type is_le;
        typedef aux::le_result3<
            is_le, Tag, F, l1, l2, l3>
            le_result_;
        typedef typename le_result_::result_ result_;
        typedef typename le_result_::type type;
};
template <
    typename F, typename T1, typename T2, typename T3, typename Tag>
struct lambda<
    bind3<F, T1, T2, T3>, Tag, int_<4>>
{
        typedef false_ is_le;
        typedef bind3<
            F, T1, T2, T3>
            result_;
        typedef result_ type;
};
namespace aux
{
        template <
            typename IsLE, typename Tag, template <typename P1, typename P2, typename P3, typename P4> class F, typename L1, typename L2, typename L3, typename L4>
        struct le_result4
        {
            typedef F<
                typename L1::type, typename L2::type, typename L3::type, typename L4::type>
                result_;
            typedef result_ type;
        };
        template <
            typename Tag, template <typename P1, typename P2, typename P3, typename P4> class F, typename L1, typename L2, typename L3, typename L4>
        struct le_result4<true_, Tag, F, L1, L2, L3, L4>
        {
            typedef bind4<
                quote4<F, Tag>, typename L1::result_, typename L2::result_, typename L3::result_, typename L4::result_>
                result_;
            typedef mpl::protect<result_> type;
        };
}
template <
    template <typename P1, typename P2, typename P3, typename P4> class F, typename T1, typename T2, typename T3, typename T4, typename Tag>
struct lambda<
    F<T1, T2, T3, T4>, Tag, int_<4>>
{
        typedef lambda<T1, Tag> l1;
        typedef lambda<T2, Tag> l2;
        typedef lambda<T3, Tag> l3;
        typedef lambda<T4, Tag> l4;
        typedef typename l1::is_le is_le1;
        typedef typename l2::is_le is_le2;
        typedef typename l3::is_le is_le3;
        typedef typename l4::is_le is_le4;
        typedef typename aux::lambda_or<
            is_le1::value, is_le2::value, is_le3::value, is_le4::value>::type is_le;
        typedef aux::le_result4<
            is_le, Tag, F, l1, l2, l3, l4>
            le_result_;
        typedef typename le_result_::result_ result_;
        typedef typename le_result_::type type;
};
template <
    typename F, typename T1, typename T2, typename T3, typename T4, typename Tag>
struct lambda<
    bind4<F, T1, T2, T3, T4>, Tag, int_<5>>
{
        typedef false_ is_le;
        typedef bind4<
            F, T1, T2, T3, T4>
            result_;
        typedef result_ type;
};
namespace aux
{
        template <
            typename IsLE, typename Tag, template <typename P1, typename P2, typename P3, typename P4, typename P5> class F, typename L1, typename L2, typename L3, typename L4, typename L5>
        struct le_result5
        {
            typedef F<
                typename L1::type, typename L2::type, typename L3::type, typename L4::type, typename L5::type>
                result_;
            typedef result_ type;
        };
        template <
            typename Tag, template <typename P1, typename P2, typename P3, typename P4, typename P5> class F, typename L1, typename L2, typename L3, typename L4, typename L5>
        struct le_result5<true_, Tag, F, L1, L2, L3, L4, L5>
        {
            typedef bind5<
                quote5<F, Tag>, typename L1::result_, typename L2::result_, typename L3::result_, typename L4::result_, typename L5::result_>
                result_;
            typedef mpl::protect<result_> type;
        };
}
template <
    template <
        typename P1, typename P2, typename P3, typename P4, typename P5>
    class F,
    typename T1, typename T2, typename T3, typename T4, typename T5, typename Tag>
struct lambda<
    F<T1, T2, T3, T4, T5>, Tag, int_<5>>
{
        typedef lambda<T1, Tag> l1;
        typedef lambda<T2, Tag> l2;
        typedef lambda<T3, Tag> l3;
        typedef lambda<T4, Tag> l4;
        typedef lambda<T5, Tag> l5;
        typedef typename l1::is_le is_le1;
        typedef typename l2::is_le is_le2;
        typedef typename l3::is_le is_le3;
        typedef typename l4::is_le is_le4;
        typedef typename l5::is_le is_le5;
        typedef typename aux::lambda_or<
            is_le1::value, is_le2::value, is_le3::value, is_le4::value, is_le5::value>::type is_le;
        typedef aux::le_result5<
            is_le, Tag, F, l1, l2, l3, l4, l5>
            le_result_;
        typedef typename le_result_::result_ result_;
        typedef typename le_result_::type type;
};
template <
    typename F, typename T1, typename T2, typename T3, typename T4, typename T5, typename Tag>
struct lambda<
    bind5<F, T1, T2, T3, T4, T5>, Tag, int_<6>>
{
        typedef false_ is_le;
        typedef bind5<
            F, T1, T2, T3, T4, T5>
            result_;
        typedef result_ type;
};
template <typename T, typename Tag>
struct lambda<mpl::protect<T>, Tag, int_<1>>
{
        typedef false_ is_le;
        typedef mpl::protect<T> result_;
        typedef result_ type;
};
template <
    typename F, typename T1, typename T2, typename T3, typename T4, typename T5, typename Tag>
struct lambda<
    bind<F, T1, T2, T3, T4, T5>, Tag, int_<6>>
{
        typedef false_ is_le;
        typedef bind<F, T1, T2, T3, T4, T5> result_;
        typedef result_ type;
};
template <
    typename F, typename Tag1, typename Tag2, typename Arity>
struct lambda<
    lambda<F, Tag1, Arity>, Tag2, int_<3>>
{
        typedef lambda<F, Tag2> l1;
        typedef lambda<Tag1, Tag2> l2;
        typedef typename l1::is_le is_le;
        typedef bind1<quote1<aux::template_arity>, typename l1::result_> arity_;
        typedef lambda<typename if_<is_le, arity_, Arity>::type, Tag2> l3;
        typedef aux::le_result3<is_le, Tag2, mpl::lambda, l1, l2, l3> le_result_;
        typedef typename le_result_::result_ result_;
        typedef typename le_result_::type type;
};
template <>
struct lambda<na, na>
{
        template <typename T1, typename T2, typename T3 = na, typename T4 = na, typename T5 = na>
        struct apply : lambda<T1, T2>
        {
        };
};
template <typename Tag>
struct lambda<lambda<na, na>, Tag, int_<-1>>
{
        typedef false_ is_le;
        typedef lambda<na, na> result_;
        typedef lambda<na, na> type;
};
namespace aux
{
        template <typename T1, typename T2, typename T3>
        struct template_arity<lambda<T1, T2, T3>> : int_<3>
        {
        };
        template <>
        struct template_arity<lambda<na, na>> : int_<-1>
        {
        };
}
    }
}
namespace boost
{
    namespace mpl
    {
template <
    typename F>
struct apply0
    : apply_wrap0<
          typename lambda<F>::type>
{
};
template <
    typename F>
struct apply<F, na, na, na, na, na>
    : apply0<F>
{
};
template <
    typename F, typename T1>
struct apply1
    : apply_wrap1<
          typename lambda<F>::type, T1>
{
};
template <
    typename F, typename T1>
struct apply<F, T1, na, na, na, na>
    : apply1<F, T1>
{
};
template <
    typename F, typename T1, typename T2>
struct apply2
    : apply_wrap2<
          typename lambda<F>::type, T1, T2>
{
};
template <
    typename F, typename T1, typename T2>
struct apply<F, T1, T2, na, na, na>
    : apply2<F, T1, T2>
{
};
template <
    typename F, typename T1, typename T2, typename T3>
struct apply3
    : apply_wrap3<
          typename lambda<F>::type, T1, T2, T3>
{
};
template <
    typename F, typename T1, typename T2, typename T3>
struct apply<F, T1, T2, T3, na, na>
    : apply3<F, T1, T2, T3>
{
};
template <
    typename F, typename T1, typename T2, typename T3, typename T4>
struct apply4
    : apply_wrap4<
          typename lambda<F>::type, T1, T2, T3, T4>
{
};
template <
    typename F, typename T1, typename T2, typename T3, typename T4>
struct apply<F, T1, T2, T3, T4, na>
    : apply4<F, T1, T2, T3, T4>
{
};
template <
    typename F, typename T1, typename T2, typename T3, typename T4, typename T5>
struct apply5
    : apply_wrap5<
          typename lambda<F>::type, T1, T2, T3, T4, T5>
{
};
template <
    typename F, typename T1, typename T2, typename T3, typename T4, typename T5>
struct apply
    : apply5<F, T1, T2, T3, T4, T5>
{
};
    }
}

namespace boost
{
    namespace iterators
    {
template <class I, class V, class TC, class R, class D>
class iterator_facade;
namespace detail
{
        struct always_bool2
        {
            template <class T, class U>
            struct apply
            {
                typedef bool type;
            };
        };
        template <typename CategoryOrTraversal, typename Required>
        struct is_traversal_at_least : public boost::is_convertible<typename iterator_category_to_traversal<CategoryOrTraversal>::type, Required>
        {
        };
        template <
            class Facade1, class Facade2, class Return>
        struct enable_if_interoperable : public boost::iterators::enable_if<
                                             is_interoperable<Facade1, Facade2>, Return>
        {
        };
        template <
            class Facade1, class Facade2, class Return>
        struct enable_if_interoperable_and_random_access_traversal : public boost::iterators::enable_if<
                                                                         mpl::and_<
                                                                             is_interoperable<Facade1, Facade2>, is_traversal_at_least<typename iterator_category<Facade1>::type, random_access_traversal_tag>, is_traversal_at_least<typename iterator_category<Facade2>::type, random_access_traversal_tag>>,
                                                                         Return>
        {
        };
        template <
            class ValueParam, class CategoryOrTraversal, class Reference, class Difference>
        struct iterator_facade_types
        {
            typedef typename facade_iterator_category<
                CategoryOrTraversal, ValueParam, Reference>::type iterator_category;
            typedef typename remove_const<ValueParam>::type value_type;
            typedef typename mpl::eval_if<
                boost::iterators::detail::iterator_writability_disabled<ValueParam, Reference>, add_pointer<const value_type>, add_pointer<value_type>>::type pointer;
        };
        template <class Iterator>
        class postfix_increment_proxy
        {
            typedef typename iterator_value<Iterator>::type value_type;

        public:
            explicit postfix_increment_proxy(Iterator const &x)
                : stored_iterator(x), stored_value(*x)
            {
            }
            value_type &operator*() const
            {
                return stored_value;
            }
            operator Iterator const &() const
            {
                return stored_iterator;
            }
            value_type *operator->() const
            {
                return boost::addressof(stored_value);
            }

        private:
            Iterator stored_iterator;
            mutable value_type stored_value;
        };
        template <class Iterator>
        class writable_postfix_increment_dereference_proxy;
        template <class T>
        struct is_not_writable_postfix_increment_dereference_proxy : public boost::true_type
        {
        };
        template <class Iterator>
        struct is_not_writable_postfix_increment_dereference_proxy<
            writable_postfix_increment_dereference_proxy<Iterator>> : public boost::false_type
        {
        };
        template <class Iterator>
        class writable_postfix_increment_proxy;
        template <class Iterator>
        class writable_postfix_increment_dereference_proxy
        {
            friend class writable_postfix_increment_proxy<Iterator>;
            typedef typename iterator_value<Iterator>::type value_type;

        public:
            explicit writable_postfix_increment_dereference_proxy(Iterator const &x)
                : stored_iterator(x), stored_value(*x)
            {
            }
            operator value_type &() const
            {
                return this->stored_value;
            }
            template <class OtherIterator>
            writable_postfix_increment_dereference_proxy const &
            operator=(writable_postfix_increment_dereference_proxy<OtherIterator> const &x) const
            {
                typedef typename iterator_value<OtherIterator>::type other_value_type;
                *this->stored_iterator = static_cast<other_value_type &>(x);
                return *this;
            }
            template <class T>
            typename iterators::enable_if<
                is_not_writable_postfix_increment_dereference_proxy<T>,
                writable_postfix_increment_dereference_proxy const &>::type
            operator=(T const &x) const
            {
                *this->stored_iterator = x;
                return *this;
            }
            template <class T>
            typename iterators::enable_if<
                is_not_writable_postfix_increment_dereference_proxy<T>,
                writable_postfix_increment_dereference_proxy const &>::type
            operator=(T &x) const
            {
                *this->stored_iterator = x;
                return *this;
            }

        private:
            Iterator stored_iterator;
            mutable value_type stored_value;
        };
        template <class Iterator>
        class writable_postfix_increment_proxy
        {
            typedef typename iterator_value<Iterator>::type value_type;

        public:
            explicit writable_postfix_increment_proxy(Iterator const &x)
                : dereference_proxy(x)
            {
            }
            writable_postfix_increment_dereference_proxy<Iterator> const &
            operator*() const
            {
                return dereference_proxy;
            }
            operator Iterator const &() const
            {
                return dereference_proxy.stored_iterator;
            }
            value_type *operator->() const
            {
                return boost::addressof(dereference_proxy.stored_value);
            }

        private:
            writable_postfix_increment_dereference_proxy<Iterator> dereference_proxy;
        };
        template <class Reference, class Value>
        struct is_non_proxy_reference
            : is_convertible<
                  typename remove_reference<Reference>::type const volatile *, Value const volatile *>
        {
        };
        template <class Iterator, class Value, class Reference, class CategoryOrTraversal>
        struct postfix_increment_result
            : mpl::eval_if<
                  mpl::and_<
                      is_convertible<
                          Reference, typename add_lvalue_reference<Value const>::type>,
                      mpl::not_<
                          is_convertible<
                              typename iterator_category_to_traversal<CategoryOrTraversal>::type, forward_traversal_tag>>>,
                  mpl::if_<
                      is_non_proxy_reference<Reference, Value>, postfix_increment_proxy<Iterator>, writable_postfix_increment_proxy<Iterator>>,
                  mpl::identity<Iterator>>
        {
        };
        template <class Reference, class Pointer>
        struct operator_arrow_dispatch
        {
            struct proxy
            {
                explicit proxy(Reference const &x) : m_ref(x) {}
                Reference *operator->() { return boost::addressof(m_ref); }
                operator Reference *() { return boost::addressof(m_ref); }
                Reference m_ref;
            };
            typedef proxy result_type;
            static result_type apply(Reference const &x)
            {
                return result_type(x);
            }
        };
        template <class T, class Pointer>
        struct operator_arrow_dispatch<T &, Pointer>
        {
            typedef Pointer result_type;
            static result_type apply(T &x)
            {
                return boost::addressof(x);
            }
        };
        template <class Iterator>
        class operator_brackets_proxy
        {
            typedef typename Iterator::reference reference;
            typedef typename Iterator::value_type value_type;

        public:
            operator_brackets_proxy(Iterator const &iter)
                : m_iter(iter)
            {
            }
            operator reference() const
            {
                return *m_iter;
            }
            operator_brackets_proxy &operator=(value_type const &val)
            {
                *m_iter = val;
                return *this;
            }

        private:
            Iterator m_iter;
        };
        template <class ValueType, class Reference>
        struct use_operator_brackets_proxy
            : mpl::not_<
                  mpl::and_<
                      boost::is_POD<ValueType>, iterator_writability_disabled<ValueType, Reference>>>
        {
        };
        template <class Iterator, class Value, class Reference>
        struct operator_brackets_result
        {
            typedef typename mpl::if_<
                use_operator_brackets_proxy<Value, Reference>, operator_brackets_proxy<Iterator>, Value>::type type;
        };
        template <class Iterator>
        operator_brackets_proxy<Iterator> make_operator_brackets_result(Iterator const &iter, mpl::true_)
        {
            return operator_brackets_proxy<Iterator>(iter);
        }
        template <class Iterator>
        typename Iterator::value_type make_operator_brackets_result(Iterator const &iter, mpl::false_)
        {
            return *iter;
        }
        struct choose_difference_type
        {
            template <class I1, class I2>
            struct apply
                : mpl::eval_if<
                      is_convertible<I2, I1>, iterator_difference<I1>, iterator_difference<I2>>
            {
            };
        };
        template <
            class Derived, class Value, class CategoryOrTraversal, class Reference, class Difference, bool IsBidirectionalTraversal, bool IsRandomAccessTraversal>
        class iterator_facade_base;
}
class iterator_core_access
{
        template <class I, class V, class TC, class R, class D>
        friend class iterator_facade;
        template <class I, class V, class TC, class R, class D, bool IsBidirectionalTraversal, bool IsRandomAccessTraversal>
        friend class detail::iterator_facade_base;
        template <class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
        friend typename boost::iterators::detail::enable_if_interoperable<Derived1, Derived2, typename mpl::apply2<boost::iterators::detail::always_bool2, Derived1, Derived2>::type>::type operator==(iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const &lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const &rhs);
        template <class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
        friend typename boost::iterators::detail::enable_if_interoperable<Derived1, Derived2, typename mpl::apply2<boost::iterators::detail::always_bool2, Derived1, Derived2>::type>::type operator!=(iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const &lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const &rhs);
        template <class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
        friend typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal<Derived1, Derived2, typename mpl::apply2<boost::iterators::detail::always_bool2, Derived1, Derived2>::type>::type operator<(iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const &lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const &rhs);
        template <class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
        friend typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal<Derived1, Derived2, typename mpl::apply2<boost::iterators::detail::always_bool2, Derived1, Derived2>::type>::type operator>(iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const &lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const &rhs);
        template <class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
        friend typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal<Derived1, Derived2, typename mpl::apply2<boost::iterators::detail::always_bool2, Derived1, Derived2>::type>::type operator<=(iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const &lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const &rhs);
        template <class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
        friend typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal<Derived1, Derived2, typename mpl::apply2<boost::iterators::detail::always_bool2, Derived1, Derived2>::type>::type operator>=(iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const &lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const &rhs);
        template <class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
        friend typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal<Derived1, Derived2, typename mpl::apply2<boost::iterators::detail::choose_difference_type, Derived1, Derived2>::type>::type operator-(iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const &lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const &rhs);
        template <class Derived, class V, class TC, class R, class D>
        friend inline typename boost::iterators::enable_if<boost::iterators::detail::is_traversal_at_least<TC, boost::iterators::random_access_traversal_tag>, Derived>::type operator+(iterator_facade<Derived, V, TC, R, D> const &, typename Derived::difference_type);
        template <class Derived, class V, class TC, class R, class D>
        friend inline typename boost::iterators::enable_if<boost::iterators::detail::is_traversal_at_least<TC, boost::iterators::random_access_traversal_tag>, Derived>::type operator+(typename Derived::difference_type, iterator_facade<Derived, V, TC, R, D> const &);
        template <class Facade>
        static typename Facade::reference dereference(Facade const &f)
        {
            return f.dereference();
        }
        template <class Facade>
        static void increment(Facade &f)
        {
            f.increment();
        }
        template <class Facade>
        static void decrement(Facade &f)
        {
            f.decrement();
        }
        template <class Facade1, class Facade2>
        static bool equal(Facade1 const &f1, Facade2 const &f2, mpl::true_)
        {
            return f1.equal(f2);
        }
        template <class Facade1, class Facade2>
        static bool equal(Facade1 const &f1, Facade2 const &f2, mpl::false_)
        {
            return f2.equal(f1);
        }
        template <class Facade>
        static void advance(Facade &f, typename Facade::difference_type n)
        {
            f.advance(n);
        }
        template <class Facade1, class Facade2>
        static typename Facade1::difference_type distance_from(
            Facade1 const &f1, Facade2 const &f2, mpl::true_)
        {
            return -f1.distance_to(f2);
        }
        template <class Facade1, class Facade2>
        static typename Facade2::difference_type distance_from(
            Facade1 const &f1, Facade2 const &f2, mpl::false_)
        {
            return f2.distance_to(f1);
        }
        template <class I, class V, class TC, class R, class D>
        static I &derived(iterator_facade<I, V, TC, R, D> &facade)
        {
            return *static_cast<I *>(&facade);
        }
        template <class I, class V, class TC, class R, class D>
        static I const &derived(iterator_facade<I, V, TC, R, D> const &facade)
        {
            return *static_cast<I const *>(&facade);
        }

    private:
        iterator_core_access();
};
namespace detail
{
        template <
            class Derived, class Value, class CategoryOrTraversal, class Reference, class Difference>
        class iterator_facade_base<Derived, Value, CategoryOrTraversal, Reference, Difference, false, false>
        {
        private:
            typedef boost::iterators::detail::iterator_facade_types<
                Value, CategoryOrTraversal, Reference, Difference>
                associated_types;
            typedef boost::iterators::detail::operator_arrow_dispatch<
                Reference, typename associated_types::pointer>
                operator_arrow_dispatch_;

        public:
            typedef typename associated_types::value_type value_type;
            typedef Reference reference;
            typedef Difference difference_type;
            typedef typename operator_arrow_dispatch_::result_type pointer;
            typedef typename associated_types::iterator_category iterator_category;

        public:
            reference operator*() const
            {
                return iterator_core_access::dereference(this->derived());
            }
            pointer operator->() const
            {
                return operator_arrow_dispatch_::apply(*this->derived());
            }
            Derived &operator++()
            {
                iterator_core_access::increment(this->derived());
                return this->derived();
            }

        protected:
            Derived &derived()
            {
                return *static_cast<Derived *>(this);
            }
            Derived const &derived() const
            {
                return *static_cast<Derived const *>(this);
            }
        };
        template <
            class Derived, class Value, class CategoryOrTraversal, class Reference, class Difference>
        class iterator_facade_base<Derived, Value, CategoryOrTraversal, Reference, Difference, true, false> : public iterator_facade_base<Derived, Value, CategoryOrTraversal, Reference, Difference, false, false>
        {
        public:
            Derived &operator--()
            {
                iterator_core_access::decrement(this->derived());
                return this->derived();
            }
            Derived operator--(int)
            {
                Derived tmp(this->derived());
                --*this;
                return tmp;
            }
        };
        template <
            class Derived, class Value, class CategoryOrTraversal, class Reference, class Difference>
        class iterator_facade_base<Derived, Value, CategoryOrTraversal, Reference, Difference, true, true> : public iterator_facade_base<Derived, Value, CategoryOrTraversal, Reference, Difference, true, false>
        {
        private:
            typedef iterator_facade_base<Derived, Value, CategoryOrTraversal, Reference, Difference, true, false> base_type;

        public:
            typedef typename base_type::reference reference;
            typedef typename base_type::difference_type difference_type;

        public:
            typename boost::iterators::detail::operator_brackets_result<Derived, Value, reference>::type
            operator[](difference_type n) const
            {
                typedef boost::iterators::detail::use_operator_brackets_proxy<Value, Reference> use_proxy;
                return boost::iterators::detail::make_operator_brackets_result<Derived>(
                    this->derived() + n, use_proxy());
            }
            Derived &operator+=(difference_type n)
            {
                iterator_core_access::advance(this->derived(), n);
                return this->derived();
            }
            Derived &operator-=(difference_type n)
            {
                iterator_core_access::advance(this->derived(), -n);
                return this->derived();
            }
            Derived operator-(difference_type x) const
            {
                Derived result(this->derived());
                return result -= x;
            }
        };
}
template <
    class Derived, class Value, class CategoryOrTraversal, class Reference = Value &, class Difference = std::ptrdiff_t>
class iterator_facade : public detail::iterator_facade_base<
                            Derived,
                            Value,
                            CategoryOrTraversal,
                            Reference,
                            Difference,
                            detail::is_traversal_at_least<CategoryOrTraversal, bidirectional_traversal_tag>::value,
                            detail::is_traversal_at_least<CategoryOrTraversal, random_access_traversal_tag>::value>
{
    protected:
        typedef iterator_facade<Derived, Value, CategoryOrTraversal, Reference, Difference> iterator_facade_;
};
template <class I, class V, class TC, class R, class D>
inline typename boost::iterators::detail::postfix_increment_result<I, V, R, TC>::type
operator++(
    iterator_facade<I, V, TC, R, D> &i, int)
{
        typename boost::iterators::detail::postfix_increment_result<I, V, R, TC>::type
            tmp(*static_cast<I *>(&i));
        ++i;
        return tmp;
}
template <class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
inline typename boost::iterators::detail::enable_if_interoperable<Derived1, Derived2, typename mpl::apply2<boost::iterators::detail::always_bool2, Derived1, Derived2>::type>::type operator==(iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const &lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const &rhs) { typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(((is_interoperable<Derived1, Derived2>::value)) != 0)>)> boost_static_assert_typedef_981; }
template <class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
inline typename boost::iterators::detail::enable_if_interoperable<Derived1, Derived2, typename mpl::apply2<boost::iterators::detail::always_bool2, Derived1, Derived2>::type>::type operator!=(iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const &lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const &rhs) { typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(((is_interoperable<Derived1, Derived2>::value)) != 0)>)> boost_static_assert_typedef_982; }
template <class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
inline typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal<Derived1, Derived2, typename mpl::apply2<boost::iterators::detail::always_bool2, Derived1, Derived2>::type>::type operator<(iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const &lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const &rhs) { typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(((is_interoperable<Derived1, Derived2>::value && boost::iterators::detail::is_traversal_at_least<typename iterator_category<Derived1>::type, random_access_traversal_tag>::value && boost::iterators::detail::is_traversal_at_least<typename iterator_category<Derived2>::type, random_access_traversal_tag>::value)) != 0)>)> boost_static_assert_typedef_1011; }
template <class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
inline typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal<Derived1, Derived2, typename mpl::apply2<boost::iterators::detail::always_bool2, Derived1, Derived2>::type>::type operator>(iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const &lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const &rhs) { typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(((is_interoperable<Derived1, Derived2>::value && boost::iterators::detail::is_traversal_at_least<typename iterator_category<Derived1>::type, random_access_traversal_tag>::value && boost::iterators::detail::is_traversal_at_least<typename iterator_category<Derived2>::type, random_access_traversal_tag>::value)) != 0)>)> boost_static_assert_typedef_1012; }
template <class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
inline typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal<Derived1, Derived2, typename mpl::apply2<boost::iterators::detail::always_bool2, Derived1, Derived2>::type>::type operator<=(iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const &lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const &rhs) { typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(((is_interoperable<Derived1, Derived2>::value && boost::iterators::detail::is_traversal_at_least<typename iterator_category<Derived1>::type, random_access_traversal_tag>::value && boost::iterators::detail::is_traversal_at_least<typename iterator_category<Derived2>::type, random_access_traversal_tag>::value)) != 0)>)> boost_static_assert_typedef_1013; }
template <class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
inline typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal<Derived1, Derived2, typename mpl::apply2<boost::iterators::detail::always_bool2, Derived1, Derived2>::type>::type operator>=(iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const &lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const &rhs) { typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(((is_interoperable<Derived1, Derived2>::value && boost::iterators::detail::is_traversal_at_least<typename iterator_category<Derived1>::type, random_access_traversal_tag>::value && boost::iterators::detail::is_traversal_at_least<typename iterator_category<Derived2>::type, random_access_traversal_tag>::value)) != 0)>)> boost_static_assert_typedef_1014; }
template <class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
inline typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal<Derived1, Derived2, typename mpl::apply2<boost::iterators::detail::choose_difference_type, Derived1, Derived2>::type>::type operator-(iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const &lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const &rhs) { typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(((is_interoperable<Derived1, Derived2>::value && boost::iterators::detail::is_traversal_at_least<typename iterator_category<Derived1>::type, random_access_traversal_tag>::value && boost::iterators::detail::is_traversal_at_least<typename iterator_category<Derived2>::type, random_access_traversal_tag>::value)) != 0)>)> boost_static_assert_typedef_1024; }
template <class Derived, class V, class TC, class R, class D>
inline typename boost::iterators::enable_if<boost::iterators::detail::is_traversal_at_least<TC, boost::iterators::random_access_traversal_tag>, Derived>::type operator+(iterator_facade<Derived, V, TC, R, D> const &i, typename Derived::difference_type n)
{
        Derived tmp(static_cast<Derived const &>(i));
        return tmp += n;
}
template <class Derived, class V, class TC, class R, class D>
inline typename boost::iterators::enable_if<boost::iterators::detail::is_traversal_at_least<TC, boost::iterators::random_access_traversal_tag>, Derived>::type operator+(typename Derived::difference_type n, iterator_facade<Derived, V, TC, R, D> const &i)
{
        Derived tmp(static_cast<Derived const &>(i));
        return tmp += n;
}
    }
    using iterators::iterator_core_access;
    using iterators::iterator_facade;
}
namespace boost
{
    namespace detail
    {
template <class T>
struct is_abstract_imp
{
        static const bool value = __is_abstract(T);
};
    }
    template <class T>
    struct is_abstract : public integral_constant<bool, ::boost::detail::is_abstract_imp<T>::value>
    {
    };
}

namespace boost
{
    template <typename C, typename Enabler>
    struct range_iterator;
    template <typename C, typename Enabler>
    struct range_mutable_iterator;
    template <typename C, typename Enabler>
    struct range_const_iterator;
    template <typename IteratorT>
    class iterator_range;
    template <typename ForwardRange>
    class sub_range;
    template <typename T>
    struct range_category;
    template <typename T>
    struct range_difference;
    template <typename T>
    struct range_pointer;
    template <typename T>
    struct range_reference;
    template <typename T>
    struct range_reverse_iterator;
    template <typename T>
    struct range_size;
    template <typename T>
    struct range_value;
    template <typename T>
    struct has_range_iterator;
    template <typename T>
    struct has_range_const_iterator;
}
namespace boost
{
    namespace range_detail
    {
template <typename T, typename fallback_ = boost::mpl::bool_<false>>
struct has_iterator
{
        struct gcc_3_2_wknd
        {
            template <typename U>
            static boost::mpl::aux::yes_tag test(boost::mpl::aux::type_wrapper<U> const volatile *, boost::mpl::aux::type_wrapper<typename U::iterator> * = 0);
            static boost::mpl::aux::no_tag test(...);
        };
        typedef boost::mpl::aux::type_wrapper<T> t_;
        static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_ *>(0))) == sizeof(boost::mpl::aux::yes_tag);
        typedef boost::mpl::bool_<value> type;
};
template <typename C, bool B = has_iterator<C>::value>
struct extract_iterator
{
};
template <typename C>
struct extract_iterator<C, true>
{
        typedef typename C::iterator type;
};
template <typename C>
struct range_mutable_iterator
    : range_detail::extract_iterator<
          typename remove_reference<C>::type>
{
};
template <typename Iterator>
struct range_mutable_iterator<std::pair<Iterator, Iterator>>
{
        typedef Iterator type;
};
template <typename T, std::size_t sz>
struct range_mutable_iterator<T[sz]>
{
        typedef T *type;
};
    }
    template <typename C, typename Enabler = void>
    struct range_mutable_iterator
        : range_detail::range_mutable_iterator<
              typename remove_reference<C>::type>
    {
    };
}
namespace boost
{
    namespace range_detail
    {
template <typename T, typename fallback_ = boost::mpl::bool_<false>>
struct has_const_iterator
{
        struct gcc_3_2_wknd
        {
            template <typename U>
            static boost::mpl::aux::yes_tag test(boost::mpl::aux::type_wrapper<U> const volatile *, boost::mpl::aux::type_wrapper<typename U::const_iterator> * = 0);
            static boost::mpl::aux::no_tag test(...);
        };
        typedef boost::mpl::aux::type_wrapper<T> t_;
        static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_ *>(0))) == sizeof(boost::mpl::aux::yes_tag);
        typedef boost::mpl::bool_<value> type;
};
template <typename C, bool B = has_const_iterator<C>::value>
struct extract_const_iterator
{
};
template <typename C>
struct extract_const_iterator<C, true>
{
        typedef typename C::const_iterator type;
};
template <typename C>
struct range_const_iterator_helper
    : extract_const_iterator<C>
{
};
template <typename Iterator>
struct range_const_iterator_helper<std::pair<Iterator, Iterator>>
{
        typedef Iterator type;
};
template <typename T, std::size_t sz>
struct range_const_iterator_helper<T[sz]>
{
        typedef const T *type;
};
    }
    template <typename C, typename Enabler = void>
    struct range_const_iterator
        : range_detail::range_const_iterator_helper<
              typename remove_reference<C>::type>
    {
    };
}
namespace boost
{
    template <typename C, typename Enabler = void>
    struct range_iterator
        : mpl::if_c<
              is_const<typename remove_reference<C>::type>::value,
              range_const_iterator<typename remove_const<typename remove_reference<C>::type>::type>,
              range_mutable_iterator<typename remove_reference<C>::type>>::type
    {
    };
}
namespace boost
{
    namespace range_detail
    {
template <typename C>
inline typename range_iterator<C>::type
range_begin(C &c)
{
        return c.begin();
}
template <typename Iterator>
inline Iterator range_begin(const std::pair<Iterator, Iterator> &p)
{
        return p.first;
}
template <typename Iterator>
inline Iterator range_begin(std::pair<Iterator, Iterator> &p)
{
        return p.first;
}
template <typename T, std::size_t sz>
inline const T *range_begin(const T (&a)[sz])
{
        return a;
}
template <typename T, std::size_t sz>
inline T *range_begin(T (&a)[sz])
{
        return a;
}
    }
    namespace range_adl_barrier
    {
template <class T>
inline typename range_iterator<T>::type begin(T &r)
{
        using namespace range_detail;
        return range_begin(r);
}
template <class T>
inline typename range_iterator<const T>::type begin(const T &r)
{
        using namespace range_detail;
        return range_begin(r);
}
    }
}
namespace boost
{
    namespace range_adl_barrier
    {
template <class T>
inline typename range_iterator<const T>::type
const_begin(const T &r)
{
        return boost::range_adl_barrier::begin(r);
}
    }
    using namespace range_adl_barrier;
}
namespace boost
{
    namespace range_detail
    {
using type_traits::no_type;
using type_traits::yes_type;
yes_type is_string_impl(const char *const);
yes_type is_string_impl(const wchar_t *const);
no_type is_string_impl(...);
template <std::size_t sz>
yes_type is_char_array_impl(char (&boost_range_array)[sz]);
template <std::size_t sz>
yes_type is_char_array_impl(const char (&boost_range_array)[sz]);
no_type is_char_array_impl(...);
template <std::size_t sz>
yes_type is_wchar_t_array_impl(wchar_t (&boost_range_array)[sz]);
template <std::size_t sz>
yes_type is_wchar_t_array_impl(const wchar_t (&boost_range_array)[sz]);
no_type is_wchar_t_array_impl(...);
yes_type is_char_ptr_impl(char *const);
no_type is_char_ptr_impl(...);
yes_type is_const_char_ptr_impl(const char *const);
no_type is_const_char_ptr_impl(...);
yes_type is_wchar_t_ptr_impl(wchar_t *const);
no_type is_wchar_t_ptr_impl(...);
yes_type is_const_wchar_t_ptr_impl(const wchar_t *const);
no_type is_const_wchar_t_ptr_impl(...);
template <typename Iterator>
yes_type is_pair_impl(const std::pair<Iterator, Iterator> *);
no_type is_pair_impl(...);
struct char_or_wchar_t_array_tag
{
};
    }
}
namespace boost
{
    namespace range_detail
    {
typedef mpl::int_<1>::type std_container_;
typedef mpl::int_<2>::type std_pair_;
typedef mpl::int_<3>::type const_std_pair_;
typedef mpl::int_<4>::type array_;
typedef mpl::int_<5>::type const_array_;
typedef mpl::int_<6>::type char_array_;
typedef mpl::int_<7>::type wchar_t_array_;
typedef mpl::int_<8>::type char_ptr_;
typedef mpl::int_<9>::type const_char_ptr_;
typedef mpl::int_<10>::type wchar_t_ptr_;
typedef mpl::int_<11>::type const_wchar_t_ptr_;
typedef mpl::int_<12>::type string_;
template <typename C>
struct range_helper
{
        static C *c;
        static C ptr;
        static const bool is_pair_ = sizeof(boost::range_detail::is_pair_impl(c)) == sizeof(yes_type);
        static const bool is_char_ptr_ = sizeof(boost::range_detail::is_char_ptr_impl(ptr)) == sizeof(yes_type);
        static const bool is_const_char_ptr_ = sizeof(boost::range_detail::is_const_char_ptr_impl(ptr)) == sizeof(yes_type);
        static const bool is_wchar_t_ptr_ = sizeof(boost::range_detail::is_wchar_t_ptr_impl(ptr)) == sizeof(yes_type);
        static const bool is_const_wchar_t_ptr_ = sizeof(boost::range_detail::is_const_wchar_t_ptr_impl(ptr)) == sizeof(yes_type);
        static const bool is_char_array_ = sizeof(boost::range_detail::is_char_array_impl(ptr)) == sizeof(yes_type);
        static const bool is_wchar_t_array_ = sizeof(boost::range_detail::is_wchar_t_array_impl(ptr)) == sizeof(yes_type);
        static const bool is_string_ = (is_const_char_ptr_ || is_const_wchar_t_ptr_);
        static const bool is_array_ = boost::is_array<C>::value;
};
template <typename C>
class range
{
        typedef typename boost::mpl::if_c<::boost::range_detail::range_helper<C>::is_pair_,
                                          boost::range_detail::std_pair_,
                                          void>::type pair_t;
        typedef typename boost::mpl::if_c<::boost::range_detail::range_helper<C>::is_array_,
                                          boost::range_detail::array_,
                                          pair_t>::type array_t;
        typedef typename boost::mpl::if_c<::boost::range_detail::range_helper<C>::is_string_,
                                          boost::range_detail::string_,
                                          array_t>::type string_t;
        typedef typename boost::mpl::if_c<::boost::range_detail::range_helper<C>::is_const_char_ptr_,
                                          boost::range_detail::const_char_ptr_,
                                          string_t>::type const_char_ptr_t;
        typedef typename boost::mpl::if_c<::boost::range_detail::range_helper<C>::is_char_ptr_,
                                          boost::range_detail::char_ptr_,
                                          const_char_ptr_t>::type char_ptr_t;
        typedef typename boost::mpl::if_c<::boost::range_detail::range_helper<C>::is_const_wchar_t_ptr_,
                                          boost::range_detail::const_wchar_t_ptr_,
                                          char_ptr_t>::type const_wchar_ptr_t;
        typedef typename boost::mpl::if_c<::boost::range_detail::range_helper<C>::is_wchar_t_ptr_,
                                          boost::range_detail::wchar_t_ptr_,
                                          const_wchar_ptr_t>::type wchar_ptr_t;
        typedef typename boost::mpl::if_c<::boost::range_detail::range_helper<C>::is_wchar_t_array_,
                                          boost::range_detail::wchar_t_array_,
                                          wchar_ptr_t>::type wchar_array_t;
        typedef typename boost::mpl::if_c<::boost::range_detail::range_helper<C>::is_char_array_,
                                          boost::range_detail::char_array_,
                                          wchar_array_t>::type char_array_t;

    public:
        typedef typename boost::mpl::if_c<::boost::is_void<char_array_t>::value,
                                          boost::range_detail::std_container_,
                                          char_array_t>::type type;
};
    }
}
namespace boost
{
    namespace range_detail
    {
template <typename T>
inline void boost_range_silence_warning(const T &) {}
inline const char *str_end(const char *s, const char *)
{
        return s + strlen(s);
}
inline const wchar_t *str_end(const wchar_t *s, const wchar_t *)
{
        return s + wcslen(s);
}
template <class Char>
inline Char *str_end(Char *s)
{
        return const_cast<Char *>(str_end(s, s));
}
template <class T, std::size_t sz>
inline T *array_end(T (&boost_range_array)[sz])
{
        return boost_range_array + sz;
}
template <class T, std::size_t sz>
inline const T *array_end(const T (&boost_range_array)[sz])
{
        return boost_range_array + sz;
}
template <class Char>
inline std::size_t str_size(const Char *const &s)
{
        return str_end(s) - s;
}
template <class T, std::size_t sz>
inline std::size_t array_size(T (&boost_range_array)[sz])
{
        boost_range_silence_warning(boost_range_array);
        return sz;
}
template <class T, std::size_t sz>
inline std::size_t array_size(const T (&boost_range_array)[sz])
{
        boost_range_silence_warning(boost_range_array);
        return sz;
}
inline bool is_same_address(const void *l, const void *r)
{
        return l == r;
}
template <class T1, class T2>
inline bool is_same_object(const T1 &l, const T2 &r)
{
        return range_detail::is_same_address(&l, &r);
}
    }
}
namespace boost
{
    namespace range_detail
    {
template <typename C>
inline typename range_iterator<C>::type
range_end(C &c)
{
        return c.end();
}
template <typename Iterator>
inline Iterator range_end(const std::pair<Iterator, Iterator> &p)
{
        return p.second;
}
template <typename Iterator>
inline Iterator range_end(std::pair<Iterator, Iterator> &p)
{
        return p.second;
}
template <typename T, std::size_t sz>
inline const T *range_end(const T (&a)[sz])
{
        return range_detail::array_end<T, sz>(a);
}
template <typename T, std::size_t sz>
inline T *range_end(T (&a)[sz])
{
        return range_detail::array_end<T, sz>(a);
}
    }
    namespace range_adl_barrier
    {
template <class T>
inline typename range_iterator<T>::type end(T &r)
{
        using namespace range_detail;
        return range_end(r);
}
template <class T>
inline typename range_iterator<const T>::type end(const T &r)
{
        using namespace range_detail;
        return range_end(r);
}
    }
}
namespace boost
{
    namespace range_adl_barrier
    {
template <class T>
inline typename range_iterator<const T>::type
const_end(const T &r)
{
        return boost::range_adl_barrier::end(r);
}
    }
    using namespace range_adl_barrier;
}
namespace boost
{
    template <typename T, typename R = void>
    struct enable_if_has_type
    {
typedef R type;
    };
    template <bool B, class T = void>
    struct enable_if_c
    {
typedef T type;
    };
    template <class T>
    struct enable_if_c<false, T>
    {
    };
    template <class Cond, class T = void>
    struct enable_if : public enable_if_c<Cond::value, T>
    {
    };
    template <bool B, class T>
    struct lazy_enable_if_c
    {
typedef typename T::type type;
    };
    template <class T>
    struct lazy_enable_if_c<false, T>
    {
    };
    template <class Cond, class T>
    struct lazy_enable_if : public lazy_enable_if_c<Cond::value, T>
    {
    };
    template <bool B, class T = void>
    struct disable_if_c
    {
typedef T type;
    };
    template <class T>
    struct disable_if_c<true, T>
    {
    };
    template <class Cond, class T = void>
    struct disable_if : public disable_if_c<Cond::value, T>
    {
    };
    template <bool B, class T>
    struct lazy_disable_if_c
    {
typedef typename T::type type;
    };
    template <class T>
    struct lazy_disable_if_c<true, T>
    {
    };
    template <class Cond, class T>
    struct lazy_disable_if : public lazy_disable_if_c<Cond::value, T>
    {
    };
}

namespace boost
{
    namespace range_detail
    {
template <typename T, typename fallback_ = boost::mpl::bool_<false>>
struct has_type
{
        struct gcc_3_2_wknd
        {
            template <typename U>
            static boost::mpl::aux::yes_tag test(boost::mpl::aux::type_wrapper<U> const volatile *, boost::mpl::aux::type_wrapper<typename U::type> * = 0);
            static boost::mpl::aux::no_tag test(...);
        };
        typedef boost::mpl::aux::type_wrapper<T> t_;
        static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_ *>(0))) == sizeof(boost::mpl::aux::yes_tag);
        typedef boost::mpl::bool_<value> type;
};
template <class T, class Enabler = void>
struct has_range_iterator_impl
    : boost::mpl::false_
{
};
template <class T>
struct has_range_iterator_impl<
    T,
    typename ::boost::enable_if<
        typename mpl::eval_if<is_const<T>,
                              has_type<boost::range_const_iterator<
                                  typename remove_const<T>::type>>,
                              has_type<boost::range_mutable_iterator<T>>>::type>::type>
    : boost::mpl::true_
{
};
template <class T, class Enabler = void>
struct has_range_const_iterator_impl
    : boost::mpl::false_
{
};
template <class T>
struct has_range_const_iterator_impl<
    T,
    typename ::boost::enable_if<
        has_type<boost::range_const_iterator<T>>>::type>
    : boost::mpl::true_
{
};
    }
    template <class T>
    struct has_range_iterator
        : range_detail::has_range_iterator_impl<
              typename remove_reference<T>::type>
    {
    };
    template <class T>
    struct has_range_const_iterator
        : range_detail::has_range_const_iterator_impl<
              typename remove_reference<T>::type>
    {
    };
}
namespace boost
{
    namespace range_detail
    {
template <class T, bool B = has_type<range_iterator<T>>::value>
struct range_difference
{
};
template <class T>
struct range_difference<T, true>
    : iterator_difference<
          typename range_iterator<T>::type>
{
};
    }
    template <class T>
    struct range_difference
        : range_detail::range_difference<typename remove_reference<T>::type>
    {
    };
}
namespace boost
{
    namespace concepts
    {
    }
}
namespace boost
{
    namespace concepts
    {
namespace detail
{
        typedef char yes;
        typedef char (&no)[2];
        template <class Model, void (Model::*)()>
        struct wrap_constraints
        {
        };
        template <class Model>
        inline yes has_constraints_(Model *, wrap_constraints<Model, &Model::constraints> * = 0);
        inline no has_constraints_(...);
}
template <class Model>
struct not_satisfied
{
        static const bool value = sizeof(detail::has_constraints_((Model *)0)) == sizeof(detail::yes);
        typedef boost::integral_constant<bool, value> type;
};
    }
}
namespace boost
{
    namespace concepts
    {
template <class ModelFn>
struct requirement_;
namespace detail
{
        template <void (*)()>
        struct instantiate
        {
        };
}
template <class Model>
struct requirement
{
        static void failed() { ((Model *)0)->~Model(); }
};
struct failed
{
};
template <class Model>
struct requirement<failed *********** * Model::************>
{
        static void failed() { ((Model *)0)->~Model(); }
};
template <class Model>
struct constraint
{
        static void failed() { ((Model *)0)->constraints(); }
};
template <class Model>
struct requirement_<void (*)(Model)>
    : boost::conditional<
          concepts::not_satisfied<Model>::value, constraint<Model>, requirement<failed *********** * Model::************>>::type
{
};
    }
}
namespace boost
{
    namespace concepts
    {
template <class Model>
struct usage_requirements
{
        ~usage_requirements() { ((Model *)0)->~Model(); }
};
    }
}
namespace boost
{
    template <class Model>
    inline void function_requires(Model * = 0)
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(Model)>::failed> boost_concept_check50;
    }
    template <class T>
    inline void ignore_unused_variable_warning(T const &) {}
    template <typename T>
    struct Integer;
    template <typename T>
    struct IntegerConcept : Integer<T>
    {
    };
    template <typename T>
    struct Integer
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<Integer>)>::failed> boost_concept_check72
{
        x.error_type_must_be_an_integer_type();
}

private:
T x;
    };
    template <>
    struct Integer<char>
    {
    };
    template <>
    struct Integer<signed char>
    {
    };
    template <>
    struct Integer<unsigned char>
    {
    };
    template <>
    struct Integer<short>
    {
    };
    template <>
    struct Integer<unsigned short>
    {
    };
    template <>
    struct Integer<int>
    {
    };
    template <>
    struct Integer<unsigned int>
    {
    };
    template <>
    struct Integer<long>
    {
    };
    template <>
    struct Integer<unsigned long>
    {
    };
    template <>
    struct Integer<::boost::long_long_type>
    {
    };
    template <>
    struct Integer<::boost::ulong_long_type>
    {
    };
    template <typename T>
    struct SignedInteger;
    template <typename T>
    struct SignedIntegerConcept : SignedInteger<T>
    {
    };
    template <typename T>
    struct SignedInteger
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<SignedInteger>)>::failed> boost_concept_check98
{
        x.error_type_must_be_a_signed_integer_type();
}

private:
T x;
    };
    template <>
    struct SignedInteger<signed char>
    {
    };
    template <>
    struct SignedInteger<short>
    {
    };
    template <>
    struct SignedInteger<int>
    {
    };
    template <>
    struct SignedInteger<long>
    {
    };
    template <>
    struct SignedInteger<::boost::long_long_type>
    {
    };
    template <typename T>
    struct UnsignedInteger;
    template <typename T>
    struct UnsignedIntegerConcept : UnsignedInteger<T>
    {
    };
    template <typename T>
    struct UnsignedInteger
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<UnsignedInteger>)>::failed> boost_concept_check115
{
        x.error_type_must_be_an_unsigned_integer_type();
}

private:
T x;
    };
    template <>
    struct UnsignedInteger<unsigned char>
    {
    };
    template <>
    struct UnsignedInteger<unsigned short>
    {
    };
    template <>
    struct UnsignedInteger<unsigned int>
    {
    };
    template <>
    struct UnsignedInteger<unsigned long>
    {
    };
    template <>
    struct UnsignedInteger<::boost::ulong_long_type>
    {
    };
    template <typename TT>
    struct DefaultConstructible;
    template <typename TT>
    struct DefaultConstructibleConcept : DefaultConstructible<TT>
    {
    };
    template <typename TT>
    struct DefaultConstructible
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<DefaultConstructible>)>::failed> boost_concept_check137
{
        TT a;
        ignore_unused_variable_warning(a);
}
    };
    template <typename TT>
    struct Assignable;
    template <typename TT>
    struct AssignableConcept : Assignable<TT>
    {
    };
    template <typename TT>
    struct Assignable
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<Assignable>)>::failed> boost_concept_check145
{
        a = b;
        const_constraints(b);
}

private:
void const_constraints(const TT &x)
{
        a = x;
}

private:
TT a;
TT b;
    };
    template <typename TT>
    struct CopyConstructible;
    template <typename TT>
    struct CopyConstructibleConcept : CopyConstructible<TT>
    {
    };
    template <typename TT>
    struct CopyConstructible
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<CopyConstructible>)>::failed> boost_concept_check167
{
        TT a(b);
        TT *ptr = &a;
        const_constraints(a);
        ignore_unused_variable_warning(ptr);
}

private:
void const_constraints(const TT &a)
{
        TT c(a);
        const TT *ptr = &a;
        ignore_unused_variable_warning(c);
        ignore_unused_variable_warning(ptr);
}
TT b;
    };
    template <typename TT>
    struct SGIAssignable;
    template <typename TT>
    struct SGIAssignableConcept : SGIAssignable<TT>
    {
    };
    template <typename TT>
    struct SGIAssignable
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<SGIAssignable>)>::failed> boost_concept_check186
{
        TT c(a);
        a = b;
        const_constraints(b);
        ignore_unused_variable_warning(c);
}

private:
void const_constraints(const TT &x)
{
        TT c(x);
        a = x;
        ignore_unused_variable_warning(c);
}
TT a;
TT b;
    };
    template <typename X, typename Y>
    struct Convertible;
    template <typename X, typename Y>
    struct ConvertibleConcept : Convertible<X, Y>
    {
    };
    template <typename X, typename Y>
    struct Convertible
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<Convertible>)>::failed> boost_concept_check208
{
        Y y = x;
        ignore_unused_variable_warning(y);
}

private:
X x;
    };
    template <class TT>
    void require_boolean_expr(const TT &t)
    {
bool x = t;
ignore_unused_variable_warning(x);
    }
    template <typename TT>
    struct EqualityComparable;
    template <typename TT>
    struct EqualityComparableConcept : EqualityComparable<TT>
    {
    };
    template <typename TT>
    struct EqualityComparable
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<EqualityComparable>)>::failed> boost_concept_check233
{
        require_boolean_expr(a == b);
        require_boolean_expr(a != b);
}

private:
TT a, b;
    };
    template <typename TT>
    struct LessThanComparable;
    template <typename TT>
    struct LessThanComparableConcept : LessThanComparable<TT>
    {
    };
    template <typename TT>
    struct LessThanComparable
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<LessThanComparable>)>::failed> boost_concept_check243
{
        require_boolean_expr(a < b);
}

private:
TT a, b;
    };
    template <typename TT>
    struct Comparable;
    template <typename TT>
    struct ComparableConcept : Comparable<TT>
    {
    };
    template <typename TT>
    struct Comparable
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<Comparable>)>::failed> boost_concept_check253
{
        require_boolean_expr(a < b);
        require_boolean_expr(a > b);
        require_boolean_expr(a <= b);
        require_boolean_expr(a >= b);
}

private:
TT a, b;
    };
    template <typename First, typename Second>
    struct EqualOp;
    template <typename First, typename Second>
    struct EqualOpConcept : EqualOp<First, Second>
    {
    };
    template <typename First, typename Second>
    struct EqualOp
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<EqualOp>)>::failed> boost_concept_check283 { return a == b; }
First a;
Second b;
    };
    template <typename First, typename Second>
    struct NotEqualOp;
    template <typename First, typename Second>
    struct NotEqualOpConcept : NotEqualOp<First, Second>
    {
    };
    template <typename First, typename Second>
    struct NotEqualOp
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<NotEqualOp>)>::failed> boost_concept_check284 { return a != b; }
First a;
Second b;
    };
    template <typename First, typename Second>
    struct LessThanOp;
    template <typename First, typename Second>
    struct LessThanOpConcept : LessThanOp<First, Second>
    {
    };
    template <typename First, typename Second>
    struct LessThanOp
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<LessThanOp>)>::failed> boost_concept_check285 { return a < b; }
First a;
Second b;
    };
    template <typename First, typename Second>
    struct LessEqualOp;
    template <typename First, typename Second>
    struct LessEqualOpConcept : LessEqualOp<First, Second>
    {
    };
    template <typename First, typename Second>
    struct LessEqualOp
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<LessEqualOp>)>::failed> boost_concept_check286 { return a <= b; }
First a;
Second b;
    };
    template <typename First, typename Second>
    struct GreaterThanOp;
    template <typename First, typename Second>
    struct GreaterThanOpConcept : GreaterThanOp<First, Second>
    {
    };
    template <typename First, typename Second>
    struct GreaterThanOp
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<GreaterThanOp>)>::failed> boost_concept_check287 { return a > b; }
First a;
Second b;
    };
    template <typename First, typename Second>
    struct GreaterEqualOp;
    template <typename First, typename Second>
    struct GreaterEqualOpConcept : GreaterEqualOp<First, Second>
    {
    };
    template <typename First, typename Second>
    struct GreaterEqualOp
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<GreaterEqualOp>)>::failed> boost_concept_check288 { return a >= b; }
First a;
Second b;
    };
    template <typename Ret, typename First, typename Second>
    struct PlusOp;
    template <typename Ret, typename First, typename Second>
    struct PlusOpConcept : PlusOp<Ret, First, Second>
    {
    };
    template <typename Ret, typename First, typename Second>
    struct PlusOp
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<PlusOp>)>::failed> boost_concept_check290 { return a + b; }
First a;
Second b;
    };
    template <typename Ret, typename First, typename Second>
    struct TimesOp;
    template <typename Ret, typename First, typename Second>
    struct TimesOpConcept : TimesOp<Ret, First, Second>
    {
    };
    template <typename Ret, typename First, typename Second>
    struct TimesOp
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<TimesOp>)>::failed> boost_concept_check291 { return a * b; }
First a;
Second b;
    };
    template <typename Ret, typename First, typename Second>
    struct DivideOp;
    template <typename Ret, typename First, typename Second>
    struct DivideOpConcept : DivideOp<Ret, First, Second>
    {
    };
    template <typename Ret, typename First, typename Second>
    struct DivideOp
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<DivideOp>)>::failed> boost_concept_check292 { return a / b; }
First a;
Second b;
    };
    template <typename Ret, typename First, typename Second>
    struct SubtractOp;
    template <typename Ret, typename First, typename Second>
    struct SubtractOpConcept : SubtractOp<Ret, First, Second>
    {
    };
    template <typename Ret, typename First, typename Second>
    struct SubtractOp
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<SubtractOp>)>::failed> boost_concept_check293 { return a - b; }
First a;
Second b;
    };
    template <typename Ret, typename First, typename Second>
    struct ModOp;
    template <typename Ret, typename First, typename Second>
    struct ModOpConcept : ModOp<Ret, First, Second>
    {
    };
    template <typename Ret, typename First, typename Second>
    struct ModOp
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<ModOp>)>::failed> boost_concept_check294 { return a % b; }
First a;
Second b;
    };
    template <typename Func, typename Return>
    struct Generator;
    template <typename Func, typename Return>
    struct GeneratorConcept : Generator<Func, Return>
    {
    };
    template <typename Func, typename Return>
    struct Generator
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<Generator>)>::failed> boost_concept_check301;
    } private : void test(boost::false_type)
    {
const Return &r = f();
ignore_unused_variable_warning(r);
    }
    void test(boost::true_type)
    {
f();
    }
    Func f;
};
template <typename Func, typename Return, typename Arg>
struct UnaryFunction;
template <typename Func, typename Return, typename Arg>
struct UnaryFunctionConcept : UnaryFunction<Func, Return, Arg>
{
};
template <typename Func, typename Return, typename Arg>
struct UnaryFunction
{
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<UnaryFunction>)>::failed> boost_concept_check321;
} private : void test(boost::false_type)
{
    f(arg);
    Return r = f(arg);
    ignore_unused_variable_warning(r);
}
void test(boost::true_type)
{
    f(arg);
}
UnaryFunction();
Func f;
Arg arg;
}
;
template <typename Func, typename Return, typename First, typename Second>
struct BinaryFunction;
template <typename Func, typename Return, typename First, typename Second>
struct BinaryFunctionConcept : BinaryFunction<Func, Return, First, Second>
{
};
template <typename Func, typename Return, typename First, typename Second>
struct BinaryFunction
{
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<BinaryFunction>)>::failed> boost_concept_check351;
} private : void test(boost::false_type)
{
    (void)f(first, second);
    Return r = f(first, second);
    (void)r;
}
void test(boost::true_type)
{
    f(first, second);
}
BinaryFunction();
Func f;
First first;
Second second;
}
;
template <typename Func, typename Arg>
struct UnaryPredicate;
template <typename Func, typename Arg>
struct UnaryPredicateConcept : UnaryPredicate<Func, Arg>
{
};
template <typename Func, typename Arg>
struct UnaryPredicate
{
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<UnaryPredicate>)>::failed> boost_concept_check381
    {
require_boolean_expr(f(arg));
    }

private:
    UnaryPredicate();
    Func f;
    Arg arg;
};
template <typename Func, typename First, typename Second>
struct BinaryPredicate;
template <typename Func, typename First, typename Second>
struct BinaryPredicateConcept : BinaryPredicate<Func, First, Second>
{
};
template <typename Func, typename First, typename Second>
struct BinaryPredicate
{
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<BinaryPredicate>)>::failed> boost_concept_check400
    {
require_boolean_expr(f(a, b));
    }

private:
    BinaryPredicate();
    Func f;
    First a;
    Second b;
};
template <typename Func, typename First, typename Second>
struct Const_BinaryPredicate;
template <typename Func, typename First, typename Second>
struct Const_BinaryPredicateConcept : Const_BinaryPredicate<Func, First, Second>
{
};
template <typename Func, typename First, typename Second>
struct Const_BinaryPredicate
    : BinaryPredicate<Func, First, Second>
{
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<Const_BinaryPredicate>)>::failed> boost_concept_check421
    {
const_constraints(f);
    }

private:
    void const_constraints(const Func &fun)
    {
require_boolean_expr(fun(a, b));
    }
    Const_BinaryPredicate();
    Func f;
    First a;
    Second b;
};
template <typename Func, typename Return>
struct AdaptableGenerator;
template <typename Func, typename Return>
struct AdaptableGeneratorConcept : AdaptableGenerator<Func, Return>
{
};
template <typename Func, typename Return>
struct AdaptableGenerator
    : Generator<Func, typename Func::result_type>
{
    typedef typename Func::result_type result_type;
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<AdaptableGenerator>)>::failed> boost_concept_check448
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(Convertible<result_type, Return>)>::failed> boost_concept_check450;
    }
};
template <typename Func, typename Return, typename Arg>
struct AdaptableUnaryFunction;
template <typename Func, typename Return, typename Arg>
struct AdaptableUnaryFunctionConcept : AdaptableUnaryFunction<Func, Return, Arg>
{
};
template <typename Func, typename Return, typename Arg>
struct AdaptableUnaryFunction
    : UnaryFunction<Func, typename Func::result_type, typename Func::argument_type>
{
    typedef typename Func::argument_type argument_type;
    typedef typename Func::result_type result_type;
    ~AdaptableUnaryFunction()
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(Convertible<result_type, Return>)>::failed> boost_concept_check462;
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(Convertible<Arg, argument_type>)>::failed> boost_concept_check463;
    }
};
template <typename Func, typename Return, typename First, typename Second>
struct AdaptableBinaryFunction;
template <typename Func, typename Return, typename First, typename Second>
struct AdaptableBinaryFunctionConcept : AdaptableBinaryFunction<Func, Return, First, Second>
{
};
template <typename Func, typename Return, typename First, typename Second>
struct AdaptableBinaryFunction
    : BinaryFunction<
          Func, typename Func::result_type, typename Func::first_argument_type, typename Func::second_argument_type>
{
    typedef typename Func::first_argument_type first_argument_type;
    typedef typename Func::second_argument_type second_argument_type;
    typedef typename Func::result_type result_type;
    ~AdaptableBinaryFunction()
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(Convertible<result_type, Return>)>::failed> boost_concept_check481;
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(Convertible<First, first_argument_type>)>::failed> boost_concept_check482;
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(Convertible<Second, second_argument_type>)>::failed> boost_concept_check483;
    }
};
template <typename Func, typename Arg>
struct AdaptablePredicate;
template <typename Func, typename Arg>
struct AdaptablePredicateConcept : AdaptablePredicate<Func, Arg>
{
};
template <typename Func, typename Arg>
struct AdaptablePredicate
    : UnaryPredicate<Func, Arg>,
      AdaptableUnaryFunction<Func, bool, Arg>
{
};
template <typename Func, typename First, typename Second>
struct AdaptableBinaryPredicate;
template <typename Func, typename First, typename Second>
struct AdaptableBinaryPredicateConcept : AdaptableBinaryPredicate<Func, First, Second>
{
};
template <typename Func, typename First, typename Second>
struct AdaptableBinaryPredicate
    : BinaryPredicate<Func, First, Second>,
      AdaptableBinaryFunction<Func, bool, First, Second>
{
};
template <typename TT>
struct InputIterator;
template <typename TT>
struct InputIteratorConcept : InputIterator<TT>
{
};
template <typename TT>
struct InputIterator
    : Assignable<TT>,
      EqualityComparable<TT>
{
    typedef typename std::iterator_traits<TT>::value_type value_type;
    typedef typename std::iterator_traits<TT>::difference_type difference_type;
    typedef typename std::iterator_traits<TT>::reference reference;
    typedef typename std::iterator_traits<TT>::pointer pointer;
    typedef typename std::iterator_traits<TT>::iterator_category iterator_category;
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<InputIterator>)>::failed> boost_concept_check512
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(SignedInteger<difference_type>)>::failed> boost_concept_check514;
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(Convertible<iterator_category, std::input_iterator_tag>)>::failed> boost_concept_check515;
TT j(i);
(void)*i;
++j;
i++;
    }

private:
    TT i;
};
template <typename TT, typename ValueT>
struct OutputIterator;
template <typename TT, typename ValueT>
struct OutputIteratorConcept : OutputIterator<TT, ValueT>
{
};
template <typename TT, typename ValueT>
struct OutputIterator
    : Assignable<TT>
{
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<OutputIterator>)>::failed> boost_concept_check529
    {
++i;
i++;
*i++ = t;
    }

private:
    TT i, j;
    ValueT t;
};
template <typename TT>
struct ForwardIterator;
template <typename TT>
struct ForwardIteratorConcept : ForwardIterator<TT>
{
};
template <typename TT>
struct ForwardIterator
    : InputIterator<TT>
{
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<ForwardIterator>)>::failed> boost_concept_check543
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(Convertible<typename ForwardIterator::iterator_category, std::forward_iterator_tag>)>::failed> boost_concept_check548;
typename InputIterator<TT>::reference r = *i;
ignore_unused_variable_warning(r);
    }

private:
    TT i;
};
template <typename TT>
struct Mutable_ForwardIterator;
template <typename TT>
struct Mutable_ForwardIteratorConcept : Mutable_ForwardIterator<TT>
{
};
template <typename TT>
struct Mutable_ForwardIterator
    : ForwardIterator<TT>
{
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<Mutable_ForwardIterator>)>::failed> boost_concept_check561
    {
*i++ = *j;
    }

private:
    TT i, j;
};
template <typename TT>
struct BidirectionalIterator;
template <typename TT>
struct BidirectionalIteratorConcept : BidirectionalIterator<TT>
{
};
template <typename TT>
struct BidirectionalIterator
    : ForwardIterator<TT>
{
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<BidirectionalIterator>)>::failed> boost_concept_check571
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(Convertible<typename BidirectionalIterator::iterator_category, std::bidirectional_iterator_tag>)>::failed> boost_concept_check576;
--i;
i--;
    }

private:
    TT i;
};
template <typename TT>
struct Mutable_BidirectionalIterator;
template <typename TT>
struct Mutable_BidirectionalIteratorConcept : Mutable_BidirectionalIterator<TT>
{
};
template <typename TT>
struct Mutable_BidirectionalIterator
    : BidirectionalIterator<TT>,
      Mutable_ForwardIterator<TT>
{
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<Mutable_BidirectionalIterator>)>::failed> boost_concept_check589
    {
*i-- = *j;
    }

private:
    TT i, j;
};
template <typename TT>
struct RandomAccessIterator;
template <typename TT>
struct RandomAccessIteratorConcept : RandomAccessIterator<TT>
{
};
template <typename TT>
struct RandomAccessIterator
    : BidirectionalIterator<TT>,
      Comparable<TT>
{
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<RandomAccessIterator>)>::failed> boost_concept_check601
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(Convertible<typename BidirectionalIterator<TT>::iterator_category, std::random_access_iterator_tag>)>::failed> boost_concept_check606;
i += n;
i = i + n;
i = n + i;
i -= n;
i = i - n;
n = i - j;
(void)i[n];
    }

private:
    TT a, b;
    TT i, j;
    typename std::iterator_traits<TT>::difference_type n;
};
template <typename TT>
struct Mutable_RandomAccessIterator;
template <typename TT>
struct Mutable_RandomAccessIteratorConcept : Mutable_RandomAccessIterator<TT>
{
};
template <typename TT>
struct Mutable_RandomAccessIterator
    : RandomAccessIterator<TT>,
      Mutable_BidirectionalIterator<TT>
{
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<Mutable_RandomAccessIterator>)>::failed> boost_concept_check626
    {
i[n] = *i;
    }

private:
    TT i;
    typename std::iterator_traits<TT>::difference_type n;
};
template <typename C>
struct Container;
template <typename C>
struct ContainerConcept : Container<C>
{
};
template <typename C>
struct Container
    : Assignable<C>
{
    typedef typename C::value_type value_type;
    typedef typename C::difference_type difference_type;
    typedef typename C::size_type size_type;
    typedef typename C::const_reference const_reference;
    typedef typename C::const_pointer const_pointer;
    typedef typename C::const_iterator const_iterator;
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<Container>)>::failed> boost_concept_check648
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(InputIterator<const_iterator>)>::failed> boost_concept_check650;
const_constraints(c);
    }

private:
    void const_constraints(const C &cc)
    {
i = cc.begin();
i = cc.end();
n = cc.size();
n = cc.max_size();
b = cc.empty();
    }
    C c;
    bool b;
    const_iterator i;
    size_type n;
};
template <typename C>
struct Mutable_Container;
template <typename C>
struct Mutable_ContainerConcept : Mutable_Container<C>
{
};
template <typename C>
struct Mutable_Container
    : Container<C>
{
    typedef typename C::reference reference;
    typedef typename C::iterator iterator;
    typedef typename C::pointer pointer;
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<Mutable_Container>)>::failed> boost_concept_check675
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(Assignable<typename Mutable_Container::value_type>)>::failed> boost_concept_check678;
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(InputIterator<iterator>)>::failed> boost_concept_check680;
i = c.begin();
i = c.end();
c.swap(c2);
    }

private:
    iterator i;
    C c, c2;
};
template <typename C>
struct ForwardContainer;
template <typename C>
struct ForwardContainerConcept : ForwardContainer<C>
{
};
template <typename C>
struct ForwardContainer
    : Container<C>
{
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<ForwardContainer>)>::failed> boost_concept_check695
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(ForwardIterator<typename ForwardContainer::const_iterator>)>::failed> boost_concept_check700;
    }
};
template <typename C>
struct Mutable_ForwardContainer;
template <typename C>
struct Mutable_ForwardContainerConcept : Mutable_ForwardContainer<C>
{
};
template <typename C>
struct Mutable_ForwardContainer
    : ForwardContainer<C>,
      Mutable_Container<C>
{
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<Mutable_ForwardContainer>)>::failed> boost_concept_check708
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(Mutable_ForwardIterator<typename Mutable_ForwardContainer::iterator>)>::failed> boost_concept_check713;
    }
};
template <typename C>
struct ReversibleContainer;
template <typename C>
struct ReversibleContainerConcept : ReversibleContainer<C>
{
};
template <typename C>
struct ReversibleContainer
    : ForwardContainer<C>
{
    typedef typename C::const_reverse_iterator
        const_reverse_iterator;
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<ReversibleContainer>)>::failed> boost_concept_check724
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(BidirectionalIterator<typename ReversibleContainer::const_iterator>)>::failed> boost_concept_check728;
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(BidirectionalIterator<const_reverse_iterator>)>::failed> boost_concept_check730;
const_constraints(c);
    }

private:
    void const_constraints(const C &cc)
    {
const_reverse_iterator _i = cc.rbegin();
_i = cc.rend();
    }
    C c;
};
template <typename C>
struct Mutable_ReversibleContainer;
template <typename C>
struct Mutable_ReversibleContainerConcept : Mutable_ReversibleContainer<C>
{
};
template <typename C>
struct Mutable_ReversibleContainer
    : Mutable_ForwardContainer<C>,
      ReversibleContainer<C>
{
    typedef typename C::reverse_iterator reverse_iterator;
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<Mutable_ReversibleContainer>)>::failed> boost_concept_check749
    {
typedef typename Mutable_ForwardContainer<C>::iterator iterator;
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(Mutable_BidirectionalIterator<iterator>)>::failed> boost_concept_check752;
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(Mutable_BidirectionalIterator<reverse_iterator>)>::failed> boost_concept_check753;
reverse_iterator i = c.rbegin();
i = c.rend();
    }

private:
    C c;
};
template <typename C>
struct RandomAccessContainer;
template <typename C>
struct RandomAccessContainerConcept : RandomAccessContainer<C>
{
};
template <typename C>
struct RandomAccessContainer
    : ReversibleContainer<C>
{
    typedef typename C::size_type size_type;
    typedef typename C::const_reference const_reference;
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<RandomAccessContainer>)>::failed> boost_concept_check768
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(RandomAccessIterator<typename RandomAccessContainer::const_iterator>)>::failed> boost_concept_check773;
const_constraints(c);
    }

private:
    void const_constraints(const C &cc)
    {
const_reference r = cc[n];
ignore_unused_variable_warning(r);
    }
    C c;
    size_type n;
};
template <typename C>
struct Mutable_RandomAccessContainer;
template <typename C>
struct Mutable_RandomAccessContainerConcept : Mutable_RandomAccessContainer<C>
{
};
template <typename C>
struct Mutable_RandomAccessContainer
    : Mutable_ReversibleContainer<C>,
      RandomAccessContainer<C>
{
private:
    typedef Mutable_RandomAccessContainer self;

public:
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<Mutable_RandomAccessContainer>)>::failed> boost_concept_check795
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(Mutable_RandomAccessIterator<typename self::iterator>)>::failed> boost_concept_check797;
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(Mutable_RandomAccessIterator<typename self::reverse_iterator>)>::failed> boost_concept_check798;
typename self::reference r = c[i];
ignore_unused_variable_warning(r);
    }

private:
    typename Mutable_ReversibleContainer<C>::size_type i;
    C c;
};
template <typename S>
struct Sequence;
template <typename S>
struct SequenceConcept : Sequence<S>
{
};
template <typename S>
struct Sequence
    : Mutable_ForwardContainer<S>,
      DefaultConstructible<S>
{
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<Sequence>)>::failed> boost_concept_check817
    {
S
    c(n, t),
    c2(first, last);
c.insert(p, t);
c.insert(p, n, t);
c.insert(p, first, last);
c.erase(p);
c.erase(p, q);
typename Sequence::reference r = c.front();
ignore_unused_variable_warning(c);
ignore_unused_variable_warning(c2);
ignore_unused_variable_warning(r);
const_constraints(c);
    }

private:
    void const_constraints(const S &c)
    {
typename Sequence::const_reference r = c.front();
ignore_unused_variable_warning(r);
    }
    typename S::value_type t;
    typename S::size_type n;
    typename S::value_type *first, *last;
    typename S::iterator p, q;
};
template <typename S>
struct FrontInsertionSequence;
template <typename S>
struct FrontInsertionSequenceConcept : FrontInsertionSequence<S>
{
};
template <typename S>
struct FrontInsertionSequence
    : Sequence<S>
{
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<FrontInsertionSequence>)>::failed> boost_concept_check852
    {
c.push_front(t);
c.pop_front();
    }

private:
    S c;
    typename S::value_type t;
};
template <typename S>
struct BackInsertionSequence;
template <typename S>
struct BackInsertionSequenceConcept : BackInsertionSequence<S>
{
};
template <typename S>
struct BackInsertionSequence
    : Sequence<S>
{
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<BackInsertionSequence>)>::failed> boost_concept_check865
    {
c.push_back(t);
c.pop_back();
typename BackInsertionSequence::reference r = c.back();
ignore_unused_variable_warning(r);
const_constraints(c);
    }

private:
    void const_constraints(const S &cc)
    {
typename BackInsertionSequence::const_reference
    r = cc.back();
ignore_unused_variable_warning(r);
    }
    S c;
    typename S::value_type t;
};
template <typename C>
struct AssociativeContainer;
template <typename C>
struct AssociativeContainerConcept : AssociativeContainer<C>
{
};
template <typename C>
struct AssociativeContainer
    : ForwardContainer<C>,
      DefaultConstructible<C>
{
    typedef typename C::key_type key_type;
    typedef typename C::key_compare key_compare;
    typedef typename C::value_compare value_compare;
    typedef typename C::iterator iterator;
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<AssociativeContainer>)>::failed> boost_concept_check892
    {
i = c.find(k);
r = c.equal_range(k);
c.erase(k);
c.erase(i);
c.erase(r.first, r.second);
const_constraints(c);
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(BinaryPredicate<key_compare, key_type, key_type>)>::failed> boost_concept_check900;
typedef typename AssociativeContainer::value_type value_type_;
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(BinaryPredicate<value_compare, value_type_, value_type_>)>::failed> boost_concept_check903;
    }
    typedef typename C::const_iterator const_iterator;

private:
    void const_constraints(const C &cc)
    {
ci = cc.find(k);
n = cc.count(k);
cr = cc.equal_range(k);
    }
    C c;
    iterator i;
    std::pair<iterator, iterator> r;
    const_iterator ci;
    std::pair<const_iterator, const_iterator> cr;
    typename C::key_type k;
    typename C::size_type n;
};
template <typename C>
struct UniqueAssociativeContainer;
template <typename C>
struct UniqueAssociativeContainerConcept : UniqueAssociativeContainer<C>
{
};
template <typename C>
struct UniqueAssociativeContainer
    : AssociativeContainer<C>
{
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<UniqueAssociativeContainer>)>::failed> boost_concept_check928
    {
C c(first, last);
pos_flag = c.insert(t);
c.insert(first, last);
ignore_unused_variable_warning(c);
    }

private:
    std::pair<typename C::iterator, bool> pos_flag;
    typename C::value_type t;
    typename C::value_type *first, *last;
};
template <typename C>
struct MultipleAssociativeContainer;
template <typename C>
struct MultipleAssociativeContainerConcept : MultipleAssociativeContainer<C>
{
};
template <typename C>
struct MultipleAssociativeContainer
    : AssociativeContainer<C>
{
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<MultipleAssociativeContainer>)>::failed> boost_concept_check946
    {
C c(first, last);
pos = c.insert(t);
c.insert(first, last);
ignore_unused_variable_warning(c);
ignore_unused_variable_warning(pos);
    }

private:
    typename C::iterator pos;
    typename C::value_type t;
    typename C::value_type *first, *last;
};
template <typename C>
struct SimpleAssociativeContainer;
template <typename C>
struct SimpleAssociativeContainerConcept : SimpleAssociativeContainer<C>
{
};
template <typename C>
struct SimpleAssociativeContainer
    : AssociativeContainer<C>
{
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<SimpleAssociativeContainer>)>::failed> boost_concept_check965
    {
typedef typename C::key_type key_type;
typedef typename C::value_type value_type;
typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(((boost::is_same<key_type, value_type>::value)) != 0)>)> boost_static_assert_typedef_969;
    }
};
template <typename C>
struct PairAssociativeContainer;
template <typename C>
struct PairAssociativeContainerConcept : PairAssociativeContainer<C>
{
};
template <typename C>
struct PairAssociativeContainer
    : AssociativeContainer<C>
{
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<PairAssociativeContainer>)>::failed> boost_concept_check976
    {
typedef typename C::key_type key_type;
typedef typename C::value_type value_type;
typedef typename C::mapped_type mapped_type;
typedef std::pair<const key_type, mapped_type> required_value_type;
typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(((boost::is_same<value_type, required_value_type>::value)) != 0)>)> boost_static_assert_typedef_982;
    }
};
template <typename C>
struct SortedAssociativeContainer;
template <typename C>
struct SortedAssociativeContainerConcept : SortedAssociativeContainer<C>
{
};
template <typename C>
struct SortedAssociativeContainer
    : AssociativeContainer<C>,
      ReversibleContainer<C>
{
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<SortedAssociativeContainer>)>::failed> boost_concept_check990
    {
C
    c(kc),
    c2(first, last),
    c3(first, last, kc);
p = c.upper_bound(k);
p = c.lower_bound(k);
r = c.equal_range(k);
c.insert(p, t);
ignore_unused_variable_warning(c);
ignore_unused_variable_warning(c2);
ignore_unused_variable_warning(c3);
const_constraints(c);
    }
    void const_constraints(const C &c)
    {
kc = c.key_comp();
vc = c.value_comp();
cp = c.upper_bound(k);
cp = c.lower_bound(k);
cr = c.equal_range(k);
    }

private:
    typename C::key_compare kc;
    typename C::value_compare vc;
    typename C::value_type t;
    typename C::key_type k;
    typedef typename C::iterator iterator;
    typedef typename C::const_iterator const_iterator;
    typedef SortedAssociativeContainer self;
    iterator p;
    const_iterator cp;
    std::pair<typename self::iterator, typename self::iterator> r;
    std::pair<typename self::const_iterator, typename self::const_iterator> cr;
    typename C::value_type *first, *last;
};
template <typename C>
struct Collection;
template <typename C>
struct CollectionConcept : Collection<C>
{
};
template <typename C>
struct Collection
{
    typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<Collection>)>::failed> boost_concept_check1039
    {
boost::function_requires<boost::InputIteratorConcept<iterator>>();
boost::function_requires<boost::InputIteratorConcept<const_iterator>>();
boost::function_requires<boost::CopyConstructibleConcept<value_type>>();
const_constraints(c);
i = c.begin();
i = c.end();
c.swap(c);
    }
    void const_constraints(const C &cc)
    {
ci = cc.begin();
ci = cc.end();
n = cc.size();
b = cc.empty();
    }

private:
    typedef typename C::value_type value_type;
    typedef typename C::iterator iterator;
    typedef typename C::const_iterator const_iterator;
    typedef typename C::reference reference;
    typedef typename C::const_reference const_reference;
    typedef typename C::difference_type difference_type;
    typedef typename C::size_type size_type;
    C c;
    bool b;
    iterator i;
    const_iterator ci;
    size_type n;
};
}

namespace boost_concepts
{
    template <typename Iterator>
    struct ReadableIterator;
    template <typename Iterator>
    struct ReadableIteratorConcept : ReadableIterator<Iterator>
    {
    };
    template <typename Iterator>
    struct ReadableIterator
        : boost::Assignable<Iterator>,
          boost::CopyConstructible<Iterator>
    {
typedef typename std::iterator_traits<Iterator>::value_type value_type;
typedef typename std::iterator_traits<Iterator>::reference reference;
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<ReadableIterator>)>::failed> boost_concept_check48
{
        value_type v = *i;
        boost::ignore_unused_variable_warning(v);
}

private:
Iterator i;
    };
    template <
        typename Iterator, typename ValueType = typename std::iterator_traits<Iterator>::value_type>
    struct WritableIterator
        : boost::CopyConstructible<Iterator>
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<WritableIterator>)>::failed> boost_concept_check65
{
        *i = v;
}

private:
ValueType v;
Iterator i;
    };
    template <
        typename Iterator, typename ValueType = typename std::iterator_traits<Iterator>::value_type>
    struct WritableIteratorConcept : WritableIterator<Iterator, ValueType>
    {
    };
    template <typename Iterator>
    struct SwappableIterator;
    template <typename Iterator>
    struct SwappableIteratorConcept : SwappableIterator<Iterator>
    {
    };
    template <typename Iterator>
    struct SwappableIterator
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<SwappableIterator>)>::failed> boost_concept_check82
{
        std::iter_swap(i1, i2);
}

private:
Iterator i1;
Iterator i2;
    };
    template <typename Iterator>
    struct LvalueIterator;
    template <typename Iterator>
    struct LvalueIteratorConcept : LvalueIterator<Iterator>
    {
    };
    template <typename Iterator>
    struct LvalueIterator
    {
typedef typename std::iterator_traits<Iterator>::value_type value_type;
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<LvalueIterator>)>::failed> boost_concept_check95
{
        value_type &r = const_cast<value_type &>(*i);
        boost::ignore_unused_variable_warning(r);
}

private:
Iterator i;
    };
    template <typename Iterator>
    struct IncrementableIterator;
    template <typename Iterator>
    struct IncrementableIteratorConcept : IncrementableIterator<Iterator>
    {
    };
    template <typename Iterator>
    struct IncrementableIterator
        : boost::Assignable<Iterator>,
          boost::CopyConstructible<Iterator>
    {
typedef typename boost::iterator_traversal<Iterator>::type traversal_category;
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::Convertible<traversal_category, boost::incrementable_traversal_tag>)>::failed> boost_concept_check118;
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<IncrementableIterator>)>::failed> boost_concept_check120
{
        ++i;
        (void)i++;
}

private:
Iterator i;
    };
    template <typename Iterator>
    struct SinglePassIterator;
    template <typename Iterator>
    struct SinglePassIteratorConcept : SinglePassIterator<Iterator>
    {
    };
    template <typename Iterator>
    struct SinglePassIterator
        : IncrementableIterator<Iterator>,
          boost::EqualityComparable<Iterator>
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::Convertible<typename SinglePassIterator::traversal_category, boost::single_pass_traversal_tag>)>::failed> boost_concept_check138;
    };
    template <typename Iterator>
    struct ForwardTraversal;
    template <typename Iterator>
    struct ForwardTraversalConcept : ForwardTraversal<Iterator>
    {
    };
    template <typename Iterator>
    struct ForwardTraversal
        : SinglePassIterator<Iterator>,
          boost::DefaultConstructible<Iterator>
    {
typedef typename std::iterator_traits<Iterator>::difference_type difference_type;
enum
{
    mpl_assertion_in_line_147 = sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_arg((void (*)(boost::is_integral<difference_type>))0, 1)))
};
enum
{
    mpl_assert_rel_value148 = (std::numeric_limits<difference_type>::is_signed == true)
};
enum
{
    mpl_assertion_in_line_148 = sizeof(boost::mpl::assertion_failed<mpl_assert_rel_value148>((boost::mpl::failed * ***********(boost::mpl::assert_relation<boost::mpl::assert_::relations(sizeof(boost::mpl::assert_::arg == boost::mpl::assert_::arg)), std::numeric_limits<difference_type>::is_signed, true>::************))0))
};
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::Convertible<typename ForwardTraversal::traversal_category, boost::forward_traversal_tag>)>::failed> boost_concept_check154;
    };
    template <typename Iterator>
    struct BidirectionalTraversal;
    template <typename Iterator>
    struct BidirectionalTraversalConcept : BidirectionalTraversal<Iterator>
    {
    };
    template <typename Iterator>
    struct BidirectionalTraversal
        : ForwardTraversal<Iterator>
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::Convertible<typename BidirectionalTraversal::traversal_category, boost::bidirectional_traversal_tag>)>::failed> boost_concept_check164;
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<BidirectionalTraversal>)>::failed> boost_concept_check166
{
        --i;
        (void)i--;
}

private:
Iterator i;
    };
    template <typename Iterator>
    struct RandomAccessTraversal;
    template <typename Iterator>
    struct RandomAccessTraversalConcept : RandomAccessTraversal<Iterator>
    {
    };
    template <typename Iterator>
    struct RandomAccessTraversal
        : BidirectionalTraversal<Iterator>
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::Convertible<typename RandomAccessTraversal::traversal_category, boost::random_access_traversal_tag>)>::failed> boost_concept_check182;
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<RandomAccessTraversal>)>::failed> boost_concept_check184
{
        i += n;
        i = i + n;
        i = n + i;
        i -= n;
        i = i - n;
        n = i - j;
}

private:
typename BidirectionalTraversal<Iterator>::difference_type n;
Iterator i, j;
    };
    namespace detail
    {
template <typename Iterator1, typename Iterator2>
void interop_single_pass_constraints(Iterator1 const &i1, Iterator2 const &i2)
{
        bool b;
        b = i1 == i2;
        b = i1 != i2;
        b = i2 == i1;
        b = i2 != i1;
        boost::ignore_unused_variable_warning(b);
}
template <typename Iterator1, typename Iterator2>
void interop_rand_access_constraints(
    Iterator1 const &i1, Iterator2 const &i2,
    boost::random_access_traversal_tag, boost::random_access_traversal_tag)
{
        bool b;
        typename std::iterator_traits<Iterator2>::difference_type n;
        b = i1 < i2;
        b = i1 <= i2;
        b = i1 > i2;
        b = i1 >= i2;
        n = i1 - i2;
        b = i2 < i1;
        b = i2 <= i1;
        b = i2 > i1;
        b = i2 >= i1;
        n = i2 - i1;
        boost::ignore_unused_variable_warning(b);
        boost::ignore_unused_variable_warning(n);
}
template <typename Iterator1, typename Iterator2>
void interop_rand_access_constraints(
    Iterator1 const &, Iterator2 const &,
    boost::single_pass_traversal_tag, boost::single_pass_traversal_tag)
{
}
    }
    template <typename Iterator, typename ConstIterator>
    struct InteroperableIterator;
    template <typename Iterator, typename ConstIterator>
    struct InteroperableIteratorConcept : InteroperableIterator<Iterator, ConstIterator>
    {
    };
    template <typename Iterator, typename ConstIterator>
    struct InteroperableIterator
    {
private:
typedef typename boost::iterators::pure_iterator_traversal<Iterator>::type traversal_category;
typedef typename boost::iterators::pure_iterator_traversal<ConstIterator>::type const_traversal_category;

public:
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(SinglePassIterator<Iterator>)>::failed> boost_concept_check253;
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(SinglePassIterator<ConstIterator>)>::failed> boost_concept_check254;
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<InteroperableIterator>)>::failed> boost_concept_check256
{
        detail::interop_single_pass_constraints(i, ci);
        detail::interop_rand_access_constraints(i, ci, traversal_category(), const_traversal_category());
        ci = i;
}

private:
Iterator i;
ConstIterator ci;
    };
}
namespace boost
{
    template <class T>
    struct range_value : iterator_value<typename range_iterator<T>::type>
    {
    };
}
namespace boost
{
    namespace range_detail
    {
template <typename T1, typename T2>
class SameTypeConcept
{
    public:
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<SameTypeConcept>)>::failed> boost_concept_check21
        {
            same_type(a, b);
        }

    private:
        template <typename T>
        void same_type(T, T) {}
        T1 a;
        T2 b;
};
    }
}
namespace boost
{
    namespace range_detail
    {
template <class Iterator>
struct IncrementableIteratorConcept : CopyConstructible<Iterator>
{
        typedef typename iterator_traversal<Iterator>::type traversal_category;
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(Convertible<traversal_category, incrementable_traversal_tag>)>::failed> boost_concept_check134;
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<IncrementableIteratorConcept>)>::failed> boost_concept_check136
        {
            ++i;
            (void)i++;
        }

    private:
        Iterator i;
};
template <class Iterator>
struct SinglePassIteratorConcept
    : IncrementableIteratorConcept<Iterator>,
      EqualityComparable<Iterator>
{
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(Convertible<typename SinglePassIteratorConcept::traversal_category, single_pass_traversal_tag>)>::failed> boost_concept_check156;
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<SinglePassIteratorConcept>)>::failed> boost_concept_check158
        {
            Iterator i2(++i);
            boost::ignore_unused_variable_warning(i2);
            (void)(i++);
            typename std::iterator_traits<Iterator>::reference r1(*i);
            boost::ignore_unused_variable_warning(r1);
            typename std::iterator_traits<Iterator>::reference r2(*(++i));
            boost::ignore_unused_variable_warning(r2);
        }

    private:
        Iterator i;
};
template <class Iterator>
struct ForwardIteratorConcept
    : SinglePassIteratorConcept<Iterator>,
      DefaultConstructible<Iterator>
{
        typedef typename std::iterator_traits<Iterator>::difference_type difference_type;
        enum
        {
            mpl_assertion_in_line_188 = sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_arg((void (*)(is_integral<difference_type>))0, 1)))
        };
        enum
        {
            mpl_assert_rel_value189 = (std::numeric_limits<difference_type>::is_signed == true)
        };
        enum
        {
            mpl_assertion_in_line_189 = sizeof(boost::mpl::assertion_failed<mpl_assert_rel_value189>((boost::mpl::failed * ***********(boost::mpl::assert_relation<boost::mpl::assert_::relations(sizeof(boost::mpl::assert_::arg == boost::mpl::assert_::arg)), std::numeric_limits<difference_type>::is_signed, true>::************))0))
        };
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(Convertible<typename ForwardIteratorConcept::traversal_category, forward_traversal_tag>)>::failed> boost_concept_check195;
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<ForwardIteratorConcept>)>::failed> boost_concept_check197
        {
            Iterator i2(i++);
            boost::ignore_unused_variable_warning(i2);
            typename std::iterator_traits<Iterator>::reference r(*(i++));
            boost::ignore_unused_variable_warning(r);
        }

    private:
        Iterator i;
};
template <class Iterator>
struct BidirectionalIteratorConcept
    : ForwardIteratorConcept<Iterator>
{
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(Convertible<typename BidirectionalIteratorConcept::traversal_category, bidirectional_traversal_tag>)>::failed> boost_concept_check222;
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<BidirectionalIteratorConcept>)>::failed> boost_concept_check224
        {
            --i;
            (void)i--;
        }

    private:
        Iterator i;
};
template <class Iterator>
struct RandomAccessIteratorConcept
    : BidirectionalIteratorConcept<Iterator>
{
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(Convertible<typename RandomAccessIteratorConcept::traversal_category, random_access_traversal_tag>)>::failed> boost_concept_check243;
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<RandomAccessIteratorConcept>)>::failed> boost_concept_check245
        {
            i += n;
            i = i + n;
            i = n + i;
            i -= n;
            i = i - n;
            n = i - j;
        }

    private:
        typename BidirectionalIteratorConcept<Iterator>::difference_type n;
        Iterator i;
        Iterator j;
};
    }
    template <class T>
    struct SinglePassRangeConcept
    {
typedef typename remove_reference<T>::type Rng;
typedef typename range_iterator<
    Rng const>::type const_iterator;
typedef typename range_iterator<Rng>::type iterator;
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(range_detail::SinglePassIteratorConcept<iterator>)>::failed> boost_concept_check279;
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(range_detail::SinglePassIteratorConcept<const_iterator>)>::failed> boost_concept_check282;
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<SinglePassRangeConcept>)>::failed> boost_concept_check284
{
        iterator i1 = boost::begin(*m_range);
        iterator i2 = boost::end(*m_range);
        boost::ignore_unused_variable_warning(i1);
        boost::ignore_unused_variable_warning(i2);
        const_constraints(*m_range);
}

private:
void const_constraints(const Rng &const_range)
{
        const_iterator ci1 = boost::begin(const_range);
        const_iterator ci2 = boost::end(const_range);
        boost::ignore_unused_variable_warning(ci1);
        boost::ignore_unused_variable_warning(ci2);
}
Rng *m_range;
    };
    template <class T>
    struct ForwardRangeConcept : SinglePassRangeConcept<T>
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(range_detail::ForwardIteratorConcept<typename ForwardRangeConcept::iterator>)>::failed> boost_concept_check321;
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(range_detail::ForwardIteratorConcept<typename ForwardRangeConcept::const_iterator>)>::failed> boost_concept_check322;
    };
    template <class T>
    struct WriteableRangeConcept
    {
typedef typename range_iterator<T>::type iterator;
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::concepts::usage_requirements<WriteableRangeConcept>)>::failed> boost_concept_check332
{
        *i = v;
}

private:
iterator i;
typename range_value<T>::type v;
    };
    template <class T>
    struct WriteableForwardRangeConcept
        : ForwardRangeConcept<T>,
          WriteableRangeConcept<T>
    {
    };
    template <class T>
    struct BidirectionalRangeConcept : ForwardRangeConcept<T>
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(range_detail::BidirectionalIteratorConcept<typename BidirectionalRangeConcept::iterator>)>::failed> boost_concept_check355;
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(range_detail::BidirectionalIteratorConcept<typename BidirectionalRangeConcept::const_iterator>)>::failed> boost_concept_check356;
    };
    template <class T>
    struct WriteableBidirectionalRangeConcept
        : BidirectionalRangeConcept<T>,
          WriteableRangeConcept<T>
    {
    };
    template <class T>
    struct RandomAccessRangeConcept : BidirectionalRangeConcept<T>
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(range_detail::RandomAccessIteratorConcept<typename RandomAccessRangeConcept::iterator>)>::failed> boost_concept_check373;
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(range_detail::RandomAccessIteratorConcept<typename RandomAccessRangeConcept::const_iterator>)>::failed> boost_concept_check374;
    };
    template <class T>
    struct WriteableRandomAccessRangeConcept
        : RandomAccessRangeConcept<T>,
          WriteableRangeConcept<T>
    {
    };
}
namespace boost
{
    namespace detail
    {
template <class T>
struct is_signed_values
{
        typedef typename remove_cv<T>::type no_cv_t;
        static const no_cv_t minus_one = (static_cast<no_cv_t>(-1));
        static const no_cv_t zero = (static_cast<no_cv_t>(0));
};
template <class T>
struct is_signed_helper
{
        typedef typename remove_cv<T>::type no_cv_t;
        static const bool value = (!(::boost::detail::is_signed_values<T>::minus_one > boost::detail::is_signed_values<T>::zero));
};
template <bool integral_type>
struct is_signed_select_helper
{
        template <class T>
        struct rebind
        {
            typedef is_signed_helper<T> type;
        };
};
template <>
struct is_signed_select_helper<false>
{
        template <class T>
        struct rebind
        {
            typedef false_type type;
        };
};
template <class T>
struct is_signed_impl
{
        typedef ::boost::detail::is_signed_select_helper<::boost::is_integral<T>::value || ::boost::is_enum<T>::value> selector;
        typedef typename selector::template rebind<T> binder;
        typedef typename binder::type type;
        static const bool value = type::value;
};
    }
    template <class T>
    struct is_signed : public integral_constant<bool, boost::detail::is_signed_impl<T>::value>
    {
    };
    template <>
    struct is_signed<signed char> : public true_type
    {
    };
    template <>
    struct is_signed<const signed char> : public true_type
    {
    };
    template <>
    struct is_signed<volatile signed char> : public true_type
    {
    };
    template <>
    struct is_signed<const volatile signed char> : public true_type
    {
    };
    template <>
    struct is_signed<short> : public true_type
    {
    };
    template <>
    struct is_signed<const short> : public true_type
    {
    };
    template <>
    struct is_signed<volatile short> : public true_type
    {
    };
    template <>
    struct is_signed<const volatile short> : public true_type
    {
    };
    template <>
    struct is_signed<int> : public true_type
    {
    };
    template <>
    struct is_signed<const int> : public true_type
    {
    };
    template <>
    struct is_signed<volatile int> : public true_type
    {
    };
    template <>
    struct is_signed<const volatile int> : public true_type
    {
    };
    template <>
    struct is_signed<long> : public true_type
    {
    };
    template <>
    struct is_signed<const long> : public true_type
    {
    };
    template <>
    struct is_signed<volatile long> : public true_type
    {
    };
    template <>
    struct is_signed<const volatile long> : public true_type
    {
    };
    template <>
    struct is_signed<unsigned char> : public false_type
    {
    };
    template <>
    struct is_signed<const unsigned char> : public false_type
    {
    };
    template <>
    struct is_signed<volatile unsigned char> : public false_type
    {
    };
    template <>
    struct is_signed<const volatile unsigned char> : public false_type
    {
    };
    template <>
    struct is_signed<unsigned short> : public false_type
    {
    };
    template <>
    struct is_signed<const unsigned short> : public false_type
    {
    };
    template <>
    struct is_signed<volatile unsigned short> : public false_type
    {
    };
    template <>
    struct is_signed<const volatile unsigned short> : public false_type
    {
    };
    template <>
    struct is_signed<unsigned int> : public false_type
    {
    };
    template <>
    struct is_signed<const unsigned int> : public false_type
    {
    };
    template <>
    struct is_signed<volatile unsigned int> : public false_type
    {
    };
    template <>
    struct is_signed<const volatile unsigned int> : public false_type
    {
    };
    template <>
    struct is_signed<unsigned long> : public false_type
    {
    };
    template <>
    struct is_signed<const unsigned long> : public false_type
    {
    };
    template <>
    struct is_signed<volatile unsigned long> : public false_type
    {
    };
    template <>
    struct is_signed<const volatile unsigned long> : public false_type
    {
    };
    template <>
    struct is_signed<::boost::long_long_type> : public true_type
    {
    };
    template <>
    struct is_signed<const ::boost::long_long_type> : public true_type
    {
    };
    template <>
    struct is_signed<volatile ::boost::long_long_type> : public true_type
    {
    };
    template <>
    struct is_signed<const volatile ::boost::long_long_type> : public true_type
    {
    };
    template <>
    struct is_signed<::boost::ulong_long_type> : public false_type
    {
    };
    template <>
    struct is_signed<const ::boost::ulong_long_type> : public false_type
    {
    };
    template <>
    struct is_signed<volatile ::boost::ulong_long_type> : public false_type
    {
    };
    template <>
    struct is_signed<const volatile ::boost::ulong_long_type> : public false_type
    {
    };
    template <>
    struct is_signed<char> : public true_type
    {
    };
    template <>
    struct is_signed<const char> : public true_type
    {
    };
    template <>
    struct is_signed<volatile char> : public true_type
    {
    };
    template <>
    struct is_signed<const volatile char> : public true_type
    {
    };
    template <>
    struct is_signed<wchar_t> : public true_type
    {
    };
    template <>
    struct is_signed<const wchar_t> : public true_type
    {
    };
    template <>
    struct is_signed<volatile wchar_t> : public true_type
    {
    };
    template <>
    struct is_signed<const volatile wchar_t> : public true_type
    {
    };
}
namespace boost
{
    namespace detail
    {
template <class T>
struct is_unsigned_values
{
        typedef typename remove_cv<T>::type no_cv_t;
        static const no_cv_t minus_one = (static_cast<no_cv_t>(-1));
        static const no_cv_t zero = (static_cast<no_cv_t>(0));
};
template <class T>
struct is_ununsigned_helper
{
        static const bool value = (::boost::detail::is_unsigned_values<T>::minus_one > ::boost::detail::is_unsigned_values<T>::zero);
};
template <bool integral_type>
struct is_unsigned_select_helper
{
        template <class T>
        struct rebind
        {
            typedef is_ununsigned_helper<T> type;
        };
};
template <>
struct is_unsigned_select_helper<false>
{
        template <class T>
        struct rebind
        {
            typedef false_type type;
        };
};
template <class T>
struct is_unsigned
{
        typedef ::boost::detail::is_unsigned_select_helper<::boost::is_integral<T>::value || ::boost::is_enum<T>::value> selector;
        typedef typename selector::template rebind<T> binder;
        typedef typename binder::type type;
        static const bool value = type::value;
};
    }
    template <class T>
    struct is_unsigned : public integral_constant<bool, boost::detail::is_unsigned<T>::value>
    {
    };
    template <>
    struct is_unsigned<unsigned char> : public true_type
    {
    };
    template <>
    struct is_unsigned<const unsigned char> : public true_type
    {
    };
    template <>
    struct is_unsigned<volatile unsigned char> : public true_type
    {
    };
    template <>
    struct is_unsigned<const volatile unsigned char> : public true_type
    {
    };
    template <>
    struct is_unsigned<unsigned short> : public true_type
    {
    };
    template <>
    struct is_unsigned<const unsigned short> : public true_type
    {
    };
    template <>
    struct is_unsigned<volatile unsigned short> : public true_type
    {
    };
    template <>
    struct is_unsigned<const volatile unsigned short> : public true_type
    {
    };
    template <>
    struct is_unsigned<unsigned int> : public true_type
    {
    };
    template <>
    struct is_unsigned<const unsigned int> : public true_type
    {
    };
    template <>
    struct is_unsigned<volatile unsigned int> : public true_type
    {
    };
    template <>
    struct is_unsigned<const volatile unsigned int> : public true_type
    {
    };
    template <>
    struct is_unsigned<unsigned long> : public true_type
    {
    };
    template <>
    struct is_unsigned<const unsigned long> : public true_type
    {
    };
    template <>
    struct is_unsigned<volatile unsigned long> : public true_type
    {
    };
    template <>
    struct is_unsigned<const volatile unsigned long> : public true_type
    {
    };
    template <>
    struct is_unsigned<signed char> : public false_type
    {
    };
    template <>
    struct is_unsigned<const signed char> : public false_type
    {
    };
    template <>
    struct is_unsigned<volatile signed char> : public false_type
    {
    };
    template <>
    struct is_unsigned<const volatile signed char> : public false_type
    {
    };
    template <>
    struct is_unsigned<short> : public false_type
    {
    };
    template <>
    struct is_unsigned<const short> : public false_type
    {
    };
    template <>
    struct is_unsigned<volatile short> : public false_type
    {
    };
    template <>
    struct is_unsigned<const volatile short> : public false_type
    {
    };
    template <>
    struct is_unsigned<int> : public false_type
    {
    };
    template <>
    struct is_unsigned<const int> : public false_type
    {
    };
    template <>
    struct is_unsigned<volatile int> : public false_type
    {
    };
    template <>
    struct is_unsigned<const volatile int> : public false_type
    {
    };
    template <>
    struct is_unsigned<long> : public false_type
    {
    };
    template <>
    struct is_unsigned<const long> : public false_type
    {
    };
    template <>
    struct is_unsigned<volatile long> : public false_type
    {
    };
    template <>
    struct is_unsigned<const volatile long> : public false_type
    {
    };
    template <>
    struct is_unsigned<::boost::ulong_long_type> : public true_type
    {
    };
    template <>
    struct is_unsigned<const ::boost::ulong_long_type> : public true_type
    {
    };
    template <>
    struct is_unsigned<volatile ::boost::ulong_long_type> : public true_type
    {
    };
    template <>
    struct is_unsigned<const volatile ::boost::ulong_long_type> : public true_type
    {
    };
    template <>
    struct is_unsigned<::boost::long_long_type> : public false_type
    {
    };
    template <>
    struct is_unsigned<const ::boost::long_long_type> : public false_type
    {
    };
    template <>
    struct is_unsigned<volatile ::boost::long_long_type> : public false_type
    {
    };
    template <>
    struct is_unsigned<const volatile ::boost::long_long_type> : public false_type
    {
    };
    template <>
    struct is_unsigned<char> : public false_type
    {
    };
    template <>
    struct is_unsigned<const char> : public false_type
    {
    };
    template <>
    struct is_unsigned<volatile char> : public false_type
    {
    };
    template <>
    struct is_unsigned<const volatile char> : public false_type
    {
    };
    template <>
    struct is_unsigned<wchar_t> : public false_type
    {
    };
    template <>
    struct is_unsigned<const wchar_t> : public false_type
    {
    };
    template <>
    struct is_unsigned<volatile wchar_t> : public false_type
    {
    };
    template <>
    struct is_unsigned<const volatile wchar_t> : public false_type
    {
    };
}
namespace boost
{
    template <class T>
    struct add_volatile
    {
typedef T volatile type;
    };
    template <class T>
    struct add_volatile<T &>
    {
typedef T &type;
    };
}
namespace boost
{
    template <class T>
    struct make_unsigned
    {
private:
typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(((::boost::is_integral<T>::value || ::boost::is_enum<T>::value)) != 0)>)> boost_static_assert_typedef_31;
typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(((!::boost::is_same<typename remove_cv<T>::type, bool>::value)) != 0)>)> boost_static_assert_typedef_32;
typedef typename remove_cv<T>::type t_no_cv;
typedef typename conditional<
    (::boost::is_unsigned<T>::value && ::boost::is_integral<T>::value && !::boost::is_same<t_no_cv, char>::value && !::boost::is_same<t_no_cv, wchar_t>::value && !::boost::is_same<t_no_cv, bool>::value),
    T,
    typename conditional<
        (::boost::is_integral<T>::value && !::boost::is_same<t_no_cv, char>::value && !::boost::is_same<t_no_cv, wchar_t>::value && !::boost::is_same<t_no_cv, bool>::value),
        typename conditional<
            is_same<t_no_cv, signed char>::value,
            unsigned char,
            typename conditional<
                is_same<t_no_cv, short>::value,
                unsigned short,
                typename conditional<
                    is_same<t_no_cv, int>::value,
                    unsigned int,
                    typename conditional<
                        is_same<t_no_cv, long>::value,
                        unsigned long,
                        typename conditional<
                            sizeof(t_no_cv) == sizeof(boost::ulong_long_type),
                            boost::ulong_long_type,
                            boost::uint128_type>::type>::type>::type>::type>::type,
        typename conditional<
            sizeof(t_no_cv) == sizeof(unsigned char),
            unsigned char,
            typename conditional<
                sizeof(t_no_cv) == sizeof(unsigned short),
                unsigned short,
                typename conditional<
                    sizeof(t_no_cv) == sizeof(unsigned int),
                    unsigned int,
                    typename conditional<
                        sizeof(t_no_cv) == sizeof(unsigned long),
                        unsigned long,
                        typename conditional<
                            sizeof(t_no_cv) == sizeof(boost::ulong_long_type),
                            boost::ulong_long_type,
                            boost::uint128_type>::type>::type>::type>::type>::type>::type>::type base_integer_type;
typedef typename conditional<
    is_const<T>::value,
    typename add_const<base_integer_type>::type,
    base_integer_type>::type const_base_integer_type;

public:
typedef typename conditional<
    is_volatile<T>::value,
    typename add_volatile<const_base_integer_type>::type,
    const_base_integer_type>::type type;
    };
}
namespace boost
{
    namespace detail
    {
template <typename T>
class has_size_type
{
        typedef char no_type;
        struct yes_type
        {
            char dummy[2];
        };
        template <typename C>
        static yes_type test(typename C::size_type x);
        template <typename C>
        static no_type test(...);

    public:
        static const bool value = sizeof(test<T>(0)) == sizeof(yes_type);
};
template <typename C, typename Enabler = void>
struct range_size_
{
        typedef typename make_unsigned<
            typename range_difference<C>::type>::type type;
};
template <typename C>
struct range_size_<
    C,
    typename ::boost::enable_if<has_size_type<C>, void>::type>
{
        typedef typename C::size_type type;
};
template <typename C, bool B = range_detail::has_type<range_iterator<C>>::value>
struct range_size
{
};
template <typename C>
struct range_size<C, true>
    : range_size_<C>
{
};
    }
    template <class T>
    struct range_size : detail::range_size<T>
    {
    };
}

namespace boost
{
    namespace range_detail
    {
template <class T>
class has_member_size_impl
{
    private:
        template <class U, U>
        class check
        {
        };
        template <class C>
        static boost::uint8_t f(check<std::size_t (C::*)(void) const, &C::size> *);
        template <class C>
        static boost::uint16_t f(...);

    public:
        static const bool value =
            (sizeof(f<T>(0)) == sizeof(boost::uint8_t));
        typedef typename mpl::if_c<
            (sizeof(f<T>(0)) == sizeof(boost::uint8_t)),
            mpl::true_,
            mpl::false_>::type type;
};
template <class T>
struct has_member_size
{
        typedef typename mpl::and_<
            typename is_class<T>::type,
            typename has_member_size_impl<const T>::type>::type type;
        static const bool value =
            is_class<T>::value && has_member_size_impl<const T>::value;
};
    }
}
extern "C"
{
    void __assert_rtn(const char *, const char *, int, const char *);
}
namespace boost
{
    namespace detail
    {
template <typename T>
struct remove_cv_ref
{
        typedef typename ::boost::remove_cv<typename ::boost::remove_reference<T>::type>::type type;
};
template <typename T, typename U>
struct is_related
    : public ::boost::is_same<
          typename ::boost::detail::remove_cv_ref<T>::type,
          typename ::boost::detail::remove_cv_ref<U>::type>
{
};
    }
    template <typename MemberType, int UniqueID = 0>
    class base_from_member
    {
protected:
MemberType member;
base_from_member()
    : member()
{
}
template <typename T0>
explicit base_from_member(T0 x0) : member(x0) {}
template <typename T0, typename T1>
base_from_member(T0 x0, T1 x1) : member(x0, x1) {}
template <typename T0, typename T1, typename T2>
base_from_member(T0 x0, T1 x1, T2 x2) : member(x0, x1, x2) {}
template <typename T0, typename T1, typename T2, typename T3>
base_from_member(T0 x0, T1 x1, T2 x2, T3 x3) : member(x0, x1, x2, x3) {}
template <typename T0, typename T1, typename T2, typename T3, typename T4>
base_from_member(T0 x0, T1 x1, T2 x2, T3 x3, T4 x4) : member(x0, x1, x2, x3, x4) {}
template <typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
base_from_member(T0 x0, T1 x1, T2 x2, T3 x3, T4 x4, T5 x5) : member(x0, x1, x2, x3, x4, x5) {}
template <typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
base_from_member(T0 x0, T1 x1, T2 x2, T3 x3, T4 x4, T5 x5, T6 x6) : member(x0, x1, x2, x3, x4, x5, x6) {}
template <typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
base_from_member(T0 x0, T1 x1, T2 x2, T3 x3, T4 x4, T5 x5, T6 x6, T7 x7) : member(x0, x1, x2, x3, x4, x5, x6, x7) {}
template <typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
base_from_member(T0 x0, T1 x1, T2 x2, T3 x3, T4 x4, T5 x5, T6 x6, T7 x7, T8 x8) : member(x0, x1, x2, x3, x4, x5, x6, x7, x8) {}
template <typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
base_from_member(T0 x0, T1 x1, T2 x2, T3 x3, T4 x4, T5 x5, T6 x6, T7 x7, T8 x8, T9 x9) : member(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9) {}
    };
    template <typename MemberType, int UniqueID>
    class base_from_member<MemberType &, UniqueID>
    {
protected:
MemberType &member;
explicit base_from_member(MemberType &x)
    : member(x)
{
}
    };
}
namespace boost
{
    namespace detail
    {
template <typename Function>
struct function_traits_helper;
template <typename R>
struct function_traits_helper<R (*)(void)>
{
        static const unsigned arity = 0;
        typedef R result_type;
};
template <typename R, typename T1>
struct function_traits_helper<R (*)(T1)>
{
        static const unsigned arity = 1;
        typedef R result_type;
        typedef T1 arg1_type;
        typedef T1 argument_type;
};
template <typename R, typename T1, typename T2>
struct function_traits_helper<R (*)(T1, T2)>
{
        static const unsigned arity = 2;
        typedef R result_type;
        typedef T1 arg1_type;
        typedef T2 arg2_type;
        typedef T1 first_argument_type;
        typedef T2 second_argument_type;
};
template <typename R, typename T1, typename T2, typename T3>
struct function_traits_helper<R (*)(T1, T2, T3)>
{
        static const unsigned arity = 3;
        typedef R result_type;
        typedef T1 arg1_type;
        typedef T2 arg2_type;
        typedef T3 arg3_type;
};
template <typename R, typename T1, typename T2, typename T3, typename T4>
struct function_traits_helper<R (*)(T1, T2, T3, T4)>
{
        static const unsigned arity = 4;
        typedef R result_type;
        typedef T1 arg1_type;
        typedef T2 arg2_type;
        typedef T3 arg3_type;
        typedef T4 arg4_type;
};
template <typename R, typename T1, typename T2, typename T3, typename T4,
          typename T5>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5)>
{
        static const unsigned arity = 5;
        typedef R result_type;
        typedef T1 arg1_type;
        typedef T2 arg2_type;
        typedef T3 arg3_type;
        typedef T4 arg4_type;
        typedef T5 arg5_type;
};
template <typename R, typename T1, typename T2, typename T3, typename T4,
          typename T5, typename T6>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6)>
{
        static const unsigned arity = 6;
        typedef R result_type;
        typedef T1 arg1_type;
        typedef T2 arg2_type;
        typedef T3 arg3_type;
        typedef T4 arg4_type;
        typedef T5 arg5_type;
        typedef T6 arg6_type;
};
template <typename R, typename T1, typename T2, typename T3, typename T4,
          typename T5, typename T6, typename T7>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7)>
{
        static const unsigned arity = 7;
        typedef R result_type;
        typedef T1 arg1_type;
        typedef T2 arg2_type;
        typedef T3 arg3_type;
        typedef T4 arg4_type;
        typedef T5 arg5_type;
        typedef T6 arg6_type;
        typedef T7 arg7_type;
};
template <typename R, typename T1, typename T2, typename T3, typename T4,
          typename T5, typename T6, typename T7, typename T8>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8)>
{
        static const unsigned arity = 8;
        typedef R result_type;
        typedef T1 arg1_type;
        typedef T2 arg2_type;
        typedef T3 arg3_type;
        typedef T4 arg4_type;
        typedef T5 arg5_type;
        typedef T6 arg6_type;
        typedef T7 arg7_type;
        typedef T8 arg8_type;
};
template <typename R, typename T1, typename T2, typename T3, typename T4,
          typename T5, typename T6, typename T7, typename T8, typename T9>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8, T9)>
{
        static const unsigned arity = 9;
        typedef R result_type;
        typedef T1 arg1_type;
        typedef T2 arg2_type;
        typedef T3 arg3_type;
        typedef T4 arg4_type;
        typedef T5 arg5_type;
        typedef T6 arg6_type;
        typedef T7 arg7_type;
        typedef T8 arg8_type;
        typedef T9 arg9_type;
};
template <typename R, typename T1, typename T2, typename T3, typename T4,
          typename T5, typename T6, typename T7, typename T8, typename T9,
          typename T10>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
{
        static const unsigned arity = 10;
        typedef R result_type;
        typedef T1 arg1_type;
        typedef T2 arg2_type;
        typedef T3 arg3_type;
        typedef T4 arg4_type;
        typedef T5 arg5_type;
        typedef T6 arg6_type;
        typedef T7 arg7_type;
        typedef T8 arg8_type;
        typedef T9 arg9_type;
        typedef T10 arg10_type;
};
    }
    template <typename Function>
    struct function_traits : public boost::detail::function_traits_helper<typename boost::add_pointer<Function>::type>
    {
    };
}
namespace boost
{
    template <class T>
    inline void checked_delete(T *x)
    {
typedef char type_must_be_complete[sizeof(T) ? 1 : -1];
(void)sizeof(type_must_be_complete);
delete x;
    }
    template <class T>
    inline void checked_array_delete(T *x)
    {
typedef char type_must_be_complete[sizeof(T) ? 1 : -1];
(void)sizeof(type_must_be_complete);
delete[] x;
    }
    template <class T>
    struct checked_deleter
    {
typedef void result_type;
typedef T *argument_type;
void operator()(T *x) const
{
        boost::checked_delete(x);
}
    };
    template <class T>
    struct checked_array_deleter
    {
typedef void result_type;
typedef T *argument_type;
void operator()(T *x) const
{
        boost::checked_array_delete(x);
}
    };
}
namespace boost
{
    namespace noncopyable_
    {
struct base_token
{
};
class noncopyable : base_token
{
    protected:
        noncopyable() {}
        ~noncopyable() {}

    private:
        noncopyable(const noncopyable &);
        noncopyable &operator=(const noncopyable &);
};
    }
    typedef noncopyable_::noncopyable noncopyable;
}

namespace boost
{
    namespace range_detail
    {
template <class SinglePassRange>
inline typename ::boost::enable_if<
    has_member_size<SinglePassRange>,
    typename range_size<const SinglePassRange>::type>::type
range_calculate_size(const SinglePassRange &rng)
{
        return rng.size();
}
template <class SinglePassRange>
inline typename disable_if<
    has_member_size<SinglePassRange>,
    typename range_size<const SinglePassRange>::type>::type
range_calculate_size(const SinglePassRange &rng)
{
        return std::distance(boost::begin(rng), boost::end(rng));
}
    }
    template <class SinglePassRange>
    inline typename range_size<const SinglePassRange>::type
    size(const SinglePassRange &rng)
    {
typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(boost::SinglePassRangeConcept<SinglePassRange>)>::failed> boost_concept_check62;
using namespace range_detail;
return range_calculate_size(rng);
    }
}
namespace boost
{
    namespace iterators
    {
namespace detail
{
        template <typename SinglePassIterator>
        inline typename iterator_difference<SinglePassIterator>::type
        distance_impl(
            SinglePassIterator first, SinglePassIterator last, single_pass_traversal_tag)
        {
            typename iterator_difference<SinglePassIterator>::type n = 0;
            while (first != last)
            {
                ++first;
                ++n;
            }
            return n;
        }
        template <typename RandomAccessIterator>
        inline typename iterator_difference<RandomAccessIterator>::type
        distance_impl(
            RandomAccessIterator first, RandomAccessIterator last, random_access_traversal_tag)
        {
            return last - first;
        }
}
namespace distance_adl_barrier
{
        template <typename SinglePassIterator>
        inline typename iterator_difference<SinglePassIterator>::type
        distance(SinglePassIterator first, SinglePassIterator last)
        {
            return detail::distance_impl(
                first, last, typename iterator_traversal<SinglePassIterator>::type());
        }
}
using namespace distance_adl_barrier;
    }
    using namespace iterators::distance_adl_barrier;
}
namespace boost
{
    namespace range_distance_adl_barrier
    {
template <class T>
inline typename range_difference<T>::type
distance(const T &r)
{
        return boost::iterators::distance(boost::begin(r), boost::end(r));
}
    }
    using namespace range_distance_adl_barrier;
}
namespace boost
{
    template <class T>
    inline bool empty(const T &r)
    {
return boost::begin(r) == boost::end(r);
    }
}
namespace boost
{
    namespace iterators
    {
using boost::use_default;
    }
    template <class To>
    struct is_convertible<use_default, To>
        : mpl::false_
    {
    };
    namespace iterators
    {
namespace detail
{
        struct enable_type;
}
template <typename From, typename To>
struct enable_if_convertible
    : iterators::enable_if<
          is_convertible<From, To>, boost::iterators::detail::enable_type>
{
};
namespace detail
{
        template <class T, class DefaultNullaryFn>
        struct ia_dflt_help
            : mpl::eval_if<
                  is_same<T, use_default>, DefaultNullaryFn, mpl::identity<T>>
        {
        };
        template <
            class Derived, class Base, class Value, class Traversal, class Reference, class Difference>
        struct iterator_adaptor_base
        {
            typedef iterator_facade<
                Derived, typename boost::iterators::detail::ia_dflt_help<Value, mpl::eval_if<is_same<Reference, use_default>, iterator_value<Base>, remove_reference<Reference>>>::type, typename boost::iterators::detail::ia_dflt_help<Traversal, iterator_traversal<Base>>::type, typename boost::iterators::detail::ia_dflt_help<Reference, mpl::eval_if<is_same<Value, use_default>, iterator_reference<Base>, add_reference<Value>>>::type, typename boost::iterators::detail::ia_dflt_help<Difference, iterator_difference<Base>>::type>
                type;
        };
        template <class Tr1, class Tr2>
        inline void iterator_adaptor_assert_traversal()
        {
            typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(((is_convertible<Tr1, Tr2>::value)) != 0)>)> boost_static_assert_typedef_212;
        }
}
template <
    class Derived, class Base, class Value = use_default, class Traversal = use_default, class Reference = use_default, class Difference = use_default>
class iterator_adaptor
    : public boost::iterators::detail::iterator_adaptor_base<
          Derived, Base, Value, Traversal, Reference, Difference>::type
{
        friend class iterator_core_access;

    protected:
        typedef typename boost::iterators::detail::iterator_adaptor_base<
            Derived, Base, Value, Traversal, Reference, Difference>::type super_t;

    public:
        iterator_adaptor() {}
        explicit iterator_adaptor(Base const &iter)
            : m_iterator(iter)
        {
        }
        typedef Base base_type;
        Base const &base() const
        {
            return m_iterator;
        }

    protected:
        typedef iterator_adaptor<Derived, Base, Value, Traversal, Reference, Difference> iterator_adaptor_;
        Base const &base_reference() const
        {
            return m_iterator;
        }
        Base &base_reference()
        {
            return m_iterator;
        }

    private:
        typename super_t::reference dereference() const
        {
            return *m_iterator;
        }
        template <
            class OtherDerived, class OtherIterator, class V, class C, class R, class D>
        bool equal(iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const &x) const
        {
            return m_iterator == x.base();
        }
        typedef typename iterator_category_to_traversal<
            typename super_t::iterator_category>::type my_traversal;
        void advance(typename super_t::difference_type n)
        {
            boost::iterators::detail::iterator_adaptor_assert_traversal<my_traversal, random_access_traversal_tag>();
            m_iterator += n;
        }
        void increment() { ++m_iterator; }
        void decrement()
        {
            boost::iterators::detail::iterator_adaptor_assert_traversal<my_traversal, bidirectional_traversal_tag>();
            --m_iterator;
        }
        template <
            class OtherDerived, class OtherIterator, class V, class C, class R, class D>
        typename super_t::difference_type distance_to(
            iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const &y) const
        {
            boost::iterators::detail::iterator_adaptor_assert_traversal<my_traversal, random_access_traversal_tag>();
            return y.base() - m_iterator;
        }

    private:
        Base m_iterator;
};
    }
    using iterators::enable_if_convertible;
    using iterators::iterator_adaptor;
}

namespace boost
{
    namespace iterators
    {
template <class Iterator>
class reverse_iterator
    : public iterator_adaptor<reverse_iterator<Iterator>, Iterator>
{
        typedef iterator_adaptor<reverse_iterator<Iterator>, Iterator> super_t;
        friend class iterator_core_access;

    public:
        reverse_iterator() {}
        explicit reverse_iterator(Iterator x)
            : super_t(x) {}
        template <class OtherIterator>
        reverse_iterator(
            reverse_iterator<OtherIterator> const &r, typename enable_if_convertible<OtherIterator, Iterator>::type * = 0)
            : super_t(r.base())
        {
        }

    private:
        typename super_t::reference dereference() const
        {
            Iterator it = this->base_reference();
            --it;
            return *it;
        }
        void increment() { --this->base_reference(); }
        void decrement() { ++this->base_reference(); }
        void advance(typename super_t::difference_type n)
        {
            this->base_reference() -= n;
        }
        template <class OtherIterator>
        typename super_t::difference_type
        distance_to(reverse_iterator<OtherIterator> const &y) const
        {
            return this->base_reference() - y.base();
        }
};
template <class BidirectionalIterator>
inline reverse_iterator<BidirectionalIterator> make_reverse_iterator(BidirectionalIterator x)
{
        return reverse_iterator<BidirectionalIterator>(x);
}
    }
    using iterators::make_reverse_iterator;
    using iterators::reverse_iterator;
}
namespace boost
{
    template <typename T>
    struct range_reverse_iterator
    {
typedef reverse_iterator<
    typename range_iterator<
        typename remove_reference<T>::type>::type>
    type;
    };
}

namespace boost
{
    template <class C>
    inline typename range_reverse_iterator<C>::type
    rbegin(C &c)
    {
typedef typename range_reverse_iterator<C>::type
    iter_type;
return iter_type(boost::end(c));
    }
    template <class C>
    inline typename range_reverse_iterator<const C>::type
    rbegin(const C &c)
    {
typedef typename range_reverse_iterator<const C>::type
    iter_type;
return iter_type(boost::end(c));
    }
    template <class T>
    inline typename range_reverse_iterator<const T>::type
    const_rbegin(const T &r)
    {
return boost::rbegin(r);
    }
}
namespace boost
{
    template <class C>
    inline typename range_reverse_iterator<C>::type
    rend(C &c)
    {
typedef typename range_reverse_iterator<C>::type
    iter_type;
return iter_type(boost::begin(c));
    }
    template <class C>
    inline typename range_reverse_iterator<const C>::type
    rend(const C &c)
    {
typedef typename range_reverse_iterator<const C>::type
    iter_type;
return iter_type(boost::begin(c));
    }
    template <class T>
    inline typename range_reverse_iterator<const T>::type
    const_rend(const T &r)
    {
return boost::rend(r);
    }
}
namespace boost
{
    namespace range_detail
    {
template <class SinglePassTraversalReadableIterator1,
          class SinglePassTraversalReadableIterator2,
          class IteratorCategoryTag1,
          class IteratorCategoryTag2>
inline bool equal_impl(SinglePassTraversalReadableIterator1 first1,
                       SinglePassTraversalReadableIterator1 last1,
                       SinglePassTraversalReadableIterator2 first2,
                       SinglePassTraversalReadableIterator2 last2,
                       IteratorCategoryTag1,
                       IteratorCategoryTag2)
{
        for (;;)
        {
            if (first1 == last1)
                return first2 == last2;
            if (first2 == last2)
                return false;
            if (*first1 != *first2)
                break;
            ++first1;
            ++first2;
        }
        return false;
}
template <class SinglePassTraversalReadableIterator1,
          class SinglePassTraversalReadableIterator2,
          class IteratorCategoryTag1,
          class IteratorCategoryTag2,
          class BinaryPredicate>
inline bool equal_impl(SinglePassTraversalReadableIterator1 first1,
                       SinglePassTraversalReadableIterator1 last1,
                       SinglePassTraversalReadableIterator2 first2,
                       SinglePassTraversalReadableIterator2 last2,
                       BinaryPredicate pred,
                       IteratorCategoryTag1,
                       IteratorCategoryTag2)
{
        for (;;)
        {
            if (first1 == last1)
                return first2 == last2;
            if (first2 == last2)
                return false;
            if (!pred(*first1, *first2))
                break;
            ++first1;
            ++first2;
        }
        return false;
}
template <class RandomAccessTraversalReadableIterator1,
          class RandomAccessTraversalReadableIterator2>
inline bool equal_impl(RandomAccessTraversalReadableIterator1 first1,
                       RandomAccessTraversalReadableIterator1 last1,
                       RandomAccessTraversalReadableIterator2 first2,
                       RandomAccessTraversalReadableIterator2 last2,
                       std::random_access_iterator_tag,
                       std::random_access_iterator_tag)
{
        return ((last1 - first1) == (last2 - first2)) && std::equal(first1, last1, first2);
}
template <class RandomAccessTraversalReadableIterator1,
          class RandomAccessTraversalReadableIterator2,
          class BinaryPredicate>
inline bool equal_impl(RandomAccessTraversalReadableIterator1 first1,
                       RandomAccessTraversalReadableIterator1 last1,
                       RandomAccessTraversalReadableIterator2 first2,
                       RandomAccessTraversalReadableIterator2 last2,
                       BinaryPredicate pred,
                       std::random_access_iterator_tag,
                       std::random_access_iterator_tag)
{
        return ((last1 - first1) == (last2 - first2)) && std::equal(first1, last1, first2, pred);
}
template <class SinglePassTraversalReadableIterator1,
          class SinglePassTraversalReadableIterator2>
inline bool equal(SinglePassTraversalReadableIterator1 first1,
                  SinglePassTraversalReadableIterator1 last1,
                  SinglePassTraversalReadableIterator2 first2,
                  SinglePassTraversalReadableIterator2 last2)
{
        typename std::iterator_traits<SinglePassTraversalReadableIterator1>::iterator_category tag1;
        typename std::iterator_traits<SinglePassTraversalReadableIterator2>::iterator_category tag2;
        return equal_impl(first1, last1, first2, last2, tag1, tag2);
}
template <class SinglePassTraversalReadableIterator1,
          class SinglePassTraversalReadableIterator2,
          class BinaryPredicate>
inline bool equal(SinglePassTraversalReadableIterator1 first1,
                  SinglePassTraversalReadableIterator1 last1,
                  SinglePassTraversalReadableIterator2 first2,
                  SinglePassTraversalReadableIterator2 last2,
                  BinaryPredicate pred)
{
        typename std::iterator_traits<SinglePassTraversalReadableIterator1>::iterator_category tag1;
        typename std::iterator_traits<SinglePassTraversalReadableIterator2>::iterator_category tag2;
        return equal_impl(first1, last1, first2, last2, pred, tag1, tag2);
}
    }
    namespace range
    {
template <class SinglePassRange1, class SinglePassRange2>
inline bool equal(const SinglePassRange1 &rng1, const SinglePassRange2 &rng2)
{
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(SinglePassRangeConcept<const SinglePassRange1>)>::failed> boost_concept_check174;
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(SinglePassRangeConcept<const SinglePassRange2>)>::failed> boost_concept_check175;
        return ::boost::range_detail::equal(
            ::boost::begin(rng1), ::boost::end(rng1),
            ::boost::begin(rng2), ::boost::end(rng2));
}
template <class SinglePassRange1, class SinglePassRange2, class BinaryPredicate>
inline bool equal(const SinglePassRange1 &rng1, const SinglePassRange2 &rng2,
                  BinaryPredicate pred)
{
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(SinglePassRangeConcept<const SinglePassRange1>)>::failed> boost_concept_check187;
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(SinglePassRangeConcept<const SinglePassRange2>)>::failed> boost_concept_check188;
        return ::boost::range_detail::equal(
            ::boost::begin(rng1), ::boost::end(rng1),
            ::boost::begin(rng2), ::boost::end(rng2),
            pred);
}
    }
    using ::boost::range::equal;
}
namespace boost
{
    namespace range_detail
    {
template <class DataMemberPtr>
class safe_bool
{
    public:
        typedef safe_bool this_type;
        typedef DataMemberPtr unspecified_bool_type;
        static unspecified_bool_type to_unspecified_bool(const bool x, DataMemberPtr p)
        {
            return x ? p : 0;
        }

    private:
        safe_bool();
        safe_bool(const safe_bool &);
        void operator=(const safe_bool &);
        ~safe_bool();
};
    }
}

namespace boost
{
    template <class T>
    struct is_fundamental : public integral_constant<bool, ::boost::is_arithmetic<T>::value || ::boost::is_void<T>::value>
    {
    };
}
namespace boost
{
    namespace type_traits_detail
    {
template <typename T>
struct is_likely_stateless_lambda : public boost::integral_constant<bool, false>
{
};
    }
}

namespace boost
{
    namespace detail
    {
namespace has_plus_impl
{
        template <typename T>
        T &make();
        struct no_operator
        {
        };
        struct any
        {
            template <class T>
            any(T const &);
        };
        no_operator operator+(const any &, const any &);
        struct returns_void_t
        {
        };
        template <typename T>
        int operator,(const T &, returns_void_t);
        template <typename T>
        int operator,(const volatile T &, returns_void_t);
        template <typename Lhs, typename Rhs>
        struct operator_returns_void
        {
            static ::boost::type_traits::yes_type returns_void(returns_void_t);
            static ::boost::type_traits::no_type returns_void(int);
            static const bool value = (sizeof(::boost::type_traits::yes_type) == sizeof(returns_void((make<Lhs>() + make<Rhs>(), returns_void_t()))));
        };
        struct dont_care
        {
        };
        template <typename Lhs, typename Rhs, typename Ret, bool Returns_void>
        struct operator_returns_Ret;
        template <typename Lhs, typename Rhs>
        struct operator_returns_Ret<Lhs, Rhs, dont_care, true>
        {
            static const bool value = true;
        };
        template <typename Lhs, typename Rhs>
        struct operator_returns_Ret<Lhs, Rhs, dont_care, false>
        {
            static const bool value = true;
        };
        template <typename Lhs, typename Rhs>
        struct operator_returns_Ret<Lhs, Rhs, void, true>
        {
            static const bool value = true;
        };
        template <typename Lhs, typename Rhs>
        struct operator_returns_Ret<Lhs, Rhs, void, false>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Rhs, typename Ret>
        struct operator_returns_Ret<Lhs, Rhs, Ret, true>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Rhs, typename Ret>
        struct operator_returns_Ret<Lhs, Rhs, Ret, false>
        {
            static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
            static ::boost::type_traits::no_type is_convertible_to_Ret(...);
            static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() + make<Rhs>())) == sizeof(::boost::type_traits::yes_type));
        };
        struct has_operator
        {
        };
        no_operator operator,(no_operator, has_operator);
        template <typename Lhs, typename Rhs>
        struct operator_exists
        {
            static ::boost::type_traits::yes_type s_check(has_operator);
            static ::boost::type_traits::no_type s_check(no_operator);
            static const bool value = (sizeof(s_check(((make<Lhs>() + make<Rhs>()), make<has_operator>()))) == sizeof(::boost::type_traits::yes_type));
        };
        template <typename Lhs, typename Rhs, typename Ret, bool Forbidden_if>
        struct trait_impl1;
        template <typename Lhs, typename Rhs, typename Ret>
        struct trait_impl1<Lhs, Rhs, Ret, true>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Rhs, typename Ret>
        struct trait_impl1<Lhs, Rhs, Ret, false>
        {
            static const bool value = (operator_exists<Lhs, Rhs>::value && operator_returns_Ret<Lhs, Rhs, Ret, operator_returns_void<Lhs, Rhs>::value>::value);
        };
        template <typename Rhs, typename Ret>
        struct trait_impl1<void, Rhs, Ret, false>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Ret>
        struct trait_impl1<Lhs, void, Ret, false>
        {
            static const bool value = false;
        };
        template <typename Ret>
        struct trait_impl1<void, void, Ret, false>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Rhs, typename Ret>
        struct trait_impl
        {
            typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
            typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
            typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
            typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
            typedef typename ::boost::remove_cv<typename ::boost::remove_reference<typename ::boost::remove_pointer<Lhs_noref>::type>::type>::type Lhs_noptr;
            typedef typename ::boost::remove_cv<typename ::boost::remove_reference<typename ::boost::remove_pointer<Rhs_noref>::type>::type>::type Rhs_noptr;
            static const bool value = (trait_impl1<Lhs_noref, Rhs_noref, Ret, ((::boost::is_pointer<Lhs_noref>::value && ::boost::is_pointer<Rhs_noref>::value) || (::boost::is_pointer<Lhs_noref>::value && ::boost::is_void<Lhs_noptr>::value && ::boost::is_fundamental<Rhs_nocv>::value) || (::boost::is_pointer<Rhs_noref>::value && ::boost::is_void<Rhs_noptr>::value && ::boost::is_fundamental<Lhs_nocv>::value) || (::boost::is_pointer<Lhs_noref>::value && ::boost::is_fundamental<Rhs_nocv>::value && (!::boost::is_integral<Rhs_noref>::value)) || (::boost::is_pointer<Rhs_noref>::value && ::boost::is_fundamental<Lhs_nocv>::value && (!::boost::is_integral<Lhs_noref>::value)))>::value);
        };
}
    }
    template <class Lhs, class Rhs = Lhs, class Ret = ::boost::detail::has_plus_impl::dont_care>
    struct has_plus : public integral_constant<bool, (::boost::detail::has_plus_impl::trait_impl<Lhs, Rhs, Ret>::value)>
    {
    };
}
namespace boost
{
    namespace detail
    {
namespace has_plus_assign_impl
{
        template <typename T>
        T &make();
        struct no_operator
        {
        };
        struct any
        {
            template <class T>
            any(T const &);
        };
        no_operator operator+=(const any &, const any &);
        struct returns_void_t
        {
        };
        template <typename T>
        int operator,(const T &, returns_void_t);
        template <typename T>
        int operator,(const volatile T &, returns_void_t);
        template <typename Lhs, typename Rhs>
        struct operator_returns_void
        {
            static ::boost::type_traits::yes_type returns_void(returns_void_t);
            static ::boost::type_traits::no_type returns_void(int);
            static const bool value = (sizeof(::boost::type_traits::yes_type) == sizeof(returns_void((make<Lhs>() += make<Rhs>(), returns_void_t()))));
        };
        struct dont_care
        {
        };
        template <typename Lhs, typename Rhs, typename Ret, bool Returns_void>
        struct operator_returns_Ret;
        template <typename Lhs, typename Rhs>
        struct operator_returns_Ret<Lhs, Rhs, dont_care, true>
        {
            static const bool value = true;
        };
        template <typename Lhs, typename Rhs>
        struct operator_returns_Ret<Lhs, Rhs, dont_care, false>
        {
            static const bool value = true;
        };
        template <typename Lhs, typename Rhs>
        struct operator_returns_Ret<Lhs, Rhs, void, true>
        {
            static const bool value = true;
        };
        template <typename Lhs, typename Rhs>
        struct operator_returns_Ret<Lhs, Rhs, void, false>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Rhs, typename Ret>
        struct operator_returns_Ret<Lhs, Rhs, Ret, true>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Rhs, typename Ret>
        struct operator_returns_Ret<Lhs, Rhs, Ret, false>
        {
            static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
            static ::boost::type_traits::no_type is_convertible_to_Ret(...);
            static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() += make<Rhs>())) == sizeof(::boost::type_traits::yes_type));
        };
        struct has_operator
        {
        };
        no_operator operator,(no_operator, has_operator);
        template <typename Lhs, typename Rhs>
        struct operator_exists
        {
            static ::boost::type_traits::yes_type s_check(has_operator);
            static ::boost::type_traits::no_type s_check(no_operator);
            static const bool value = (sizeof(s_check(((make<Lhs>() += make<Rhs>()), make<has_operator>()))) == sizeof(::boost::type_traits::yes_type));
        };
        template <typename Lhs, typename Rhs, typename Ret, bool Forbidden_if>
        struct trait_impl1;
        template <typename Lhs, typename Rhs, typename Ret>
        struct trait_impl1<Lhs, Rhs, Ret, true>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Rhs, typename Ret>
        struct trait_impl1<Lhs, Rhs, Ret, false>
        {
            static const bool value = (operator_exists<Lhs, Rhs>::value && operator_returns_Ret<Lhs, Rhs, Ret, operator_returns_void<Lhs, Rhs>::value>::value);
        };
        template <typename Rhs, typename Ret>
        struct trait_impl1<void, Rhs, Ret, false>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Ret>
        struct trait_impl1<Lhs, void, Ret, false>
        {
            static const bool value = false;
        };
        template <typename Ret>
        struct trait_impl1<void, void, Ret, false>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Rhs, typename Ret>
        struct trait_impl
        {
            typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
            typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
            typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
            typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
            typedef typename ::boost::remove_cv<typename ::boost::remove_reference<typename ::boost::remove_pointer<Lhs_noref>::type>::type>::type Lhs_noptr;
            typedef typename ::boost::remove_cv<typename ::boost::remove_reference<typename ::boost::remove_pointer<Rhs_noref>::type>::type>::type Rhs_noptr;
            static const bool value = (trait_impl1<Lhs_noref, Rhs_noref, Ret, ((::boost::is_pointer<Lhs_noref>::value && ::boost::is_pointer<Rhs_noref>::value) || (::boost::is_pointer<Lhs_noref>::value && ::boost::is_void<Lhs_noptr>::value && ::boost::is_fundamental<Rhs_nocv>::value) || (::boost::is_pointer<Rhs_noref>::value && ::boost::is_void<Rhs_noptr>::value && ::boost::is_fundamental<Lhs_nocv>::value) || (::boost::is_pointer<Lhs_noref>::value && ::boost::is_fundamental<Rhs_nocv>::value && (!::boost::is_integral<Rhs_noref>::value)) || (::boost::is_pointer<Rhs_noref>::value && ::boost::is_fundamental<Lhs_nocv>::value && (!::boost::is_same<Lhs_nocv, bool>::value)) || ((::boost::is_fundamental<Lhs_nocv>::value || ::boost::is_pointer<Lhs_noref>::value) && (::boost::is_fundamental<Rhs_nocv>::value || ::boost::is_pointer<Rhs_noref>::value) && ::boost::is_const<Lhs_noref>::value))>::value);
        };
}
    }
    template <class Lhs, class Rhs = Lhs, class Ret = ::boost::detail::has_plus_assign_impl::dont_care>
    struct has_plus_assign : public integral_constant<bool, (::boost::detail::has_plus_assign_impl::trait_impl<Lhs, Rhs, Ret>::value)>
    {
    };
}
namespace boost
{
    namespace detail
    {
namespace has_minus_impl
{
        template <typename T>
        T &make();
        struct no_operator
        {
        };
        struct any
        {
            template <class T>
            any(T const &);
        };
        no_operator operator-(const any &, const any &);
        struct returns_void_t
        {
        };
        template <typename T>
        int operator,(const T &, returns_void_t);
        template <typename T>
        int operator,(const volatile T &, returns_void_t);
        template <typename Lhs, typename Rhs>
        struct operator_returns_void
        {
            static ::boost::type_traits::yes_type returns_void(returns_void_t);
            static ::boost::type_traits::no_type returns_void(int);
            static const bool value = (sizeof(::boost::type_traits::yes_type) == sizeof(returns_void((make<Lhs>() - make<Rhs>(), returns_void_t()))));
        };
        struct dont_care
        {
        };
        template <typename Lhs, typename Rhs, typename Ret, bool Returns_void>
        struct operator_returns_Ret;
        template <typename Lhs, typename Rhs>
        struct operator_returns_Ret<Lhs, Rhs, dont_care, true>
        {
            static const bool value = true;
        };
        template <typename Lhs, typename Rhs>
        struct operator_returns_Ret<Lhs, Rhs, dont_care, false>
        {
            static const bool value = true;
        };
        template <typename Lhs, typename Rhs>
        struct operator_returns_Ret<Lhs, Rhs, void, true>
        {
            static const bool value = true;
        };
        template <typename Lhs, typename Rhs>
        struct operator_returns_Ret<Lhs, Rhs, void, false>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Rhs, typename Ret>
        struct operator_returns_Ret<Lhs, Rhs, Ret, true>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Rhs, typename Ret>
        struct operator_returns_Ret<Lhs, Rhs, Ret, false>
        {
            static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
            static ::boost::type_traits::no_type is_convertible_to_Ret(...);
            static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() - make<Rhs>())) == sizeof(::boost::type_traits::yes_type));
        };
        struct has_operator
        {
        };
        no_operator operator,(no_operator, has_operator);
        template <typename Lhs, typename Rhs>
        struct operator_exists
        {
            static ::boost::type_traits::yes_type s_check(has_operator);
            static ::boost::type_traits::no_type s_check(no_operator);
            static const bool value = (sizeof(s_check(((make<Lhs>() - make<Rhs>()), make<has_operator>()))) == sizeof(::boost::type_traits::yes_type));
        };
        template <typename Lhs, typename Rhs, typename Ret, bool Forbidden_if>
        struct trait_impl1;
        template <typename Lhs, typename Rhs, typename Ret>
        struct trait_impl1<Lhs, Rhs, Ret, true>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Rhs, typename Ret>
        struct trait_impl1<Lhs, Rhs, Ret, false>
        {
            static const bool value = (operator_exists<Lhs, Rhs>::value && operator_returns_Ret<Lhs, Rhs, Ret, operator_returns_void<Lhs, Rhs>::value>::value);
        };
        template <typename Rhs, typename Ret>
        struct trait_impl1<void, Rhs, Ret, false>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Ret>
        struct trait_impl1<Lhs, void, Ret, false>
        {
            static const bool value = false;
        };
        template <typename Ret>
        struct trait_impl1<void, void, Ret, false>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Rhs, typename Ret>
        struct trait_impl
        {
            typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
            typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
            typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
            typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
            typedef typename ::boost::remove_cv<typename ::boost::remove_reference<typename ::boost::remove_pointer<Lhs_noref>::type>::type>::type Lhs_noptr;
            typedef typename ::boost::remove_cv<typename ::boost::remove_reference<typename ::boost::remove_pointer<Rhs_noref>::type>::type>::type Rhs_noptr;
            static const bool value = (trait_impl1<Lhs_noref, Rhs_noref, Ret, ((::boost::is_pointer<Lhs_noref>::value && ::boost::is_fundamental<Rhs_nocv>::value && (!::boost::is_integral<Rhs_noref>::value)) || (::boost::is_pointer<Lhs_noref>::value && ::boost::is_void<Lhs_noptr>::value && (::boost::is_fundamental<Rhs_nocv>::value || ::boost::is_pointer<Rhs_noref>::value)) || (::boost::is_pointer<Rhs_noref>::value && ::boost::is_void<Rhs_noptr>::value && (::boost::is_fundamental<Lhs_nocv>::value || ::boost::is_pointer<Lhs_noref>::value)) || (::boost::is_fundamental<Lhs_nocv>::value && ::boost::is_pointer<Rhs_noref>::value) || (::boost::is_pointer<Lhs_noref>::value && ::boost::is_pointer<Rhs_noref>::value && (!::boost::is_same<Lhs_nocv, Rhs_nocv>::value)))>::value);
        };
}
    }
    template <class Lhs, class Rhs = Lhs, class Ret = ::boost::detail::has_minus_impl::dont_care>
    struct has_minus : public integral_constant<bool, (::boost::detail::has_minus_impl::trait_impl<Lhs, Rhs, Ret>::value)>
    {
    };
}
namespace boost
{
    namespace detail
    {
namespace has_minus_assign_impl
{
        template <typename T>
        T &make();
        struct no_operator
        {
        };
        struct any
        {
            template <class T>
            any(T const &);
        };
        no_operator operator-=(const any &, const any &);
        struct returns_void_t
        {
        };
        template <typename T>
        int operator,(const T &, returns_void_t);
        template <typename T>
        int operator,(const volatile T &, returns_void_t);
        template <typename Lhs, typename Rhs>
        struct operator_returns_void
        {
            static ::boost::type_traits::yes_type returns_void(returns_void_t);
            static ::boost::type_traits::no_type returns_void(int);
            static const bool value = (sizeof(::boost::type_traits::yes_type) == sizeof(returns_void((make<Lhs>() -= make<Rhs>(), returns_void_t()))));
        };
        struct dont_care
        {
        };
        template <typename Lhs, typename Rhs, typename Ret, bool Returns_void>
        struct operator_returns_Ret;
        template <typename Lhs, typename Rhs>
        struct operator_returns_Ret<Lhs, Rhs, dont_care, true>
        {
            static const bool value = true;
        };
        template <typename Lhs, typename Rhs>
        struct operator_returns_Ret<Lhs, Rhs, dont_care, false>
        {
            static const bool value = true;
        };
        template <typename Lhs, typename Rhs>
        struct operator_returns_Ret<Lhs, Rhs, void, true>
        {
            static const bool value = true;
        };
        template <typename Lhs, typename Rhs>
        struct operator_returns_Ret<Lhs, Rhs, void, false>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Rhs, typename Ret>
        struct operator_returns_Ret<Lhs, Rhs, Ret, true>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Rhs, typename Ret>
        struct operator_returns_Ret<Lhs, Rhs, Ret, false>
        {
            static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
            static ::boost::type_traits::no_type is_convertible_to_Ret(...);
            static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() -= make<Rhs>())) == sizeof(::boost::type_traits::yes_type));
        };
        struct has_operator
        {
        };
        no_operator operator,(no_operator, has_operator);
        template <typename Lhs, typename Rhs>
        struct operator_exists
        {
            static ::boost::type_traits::yes_type s_check(has_operator);
            static ::boost::type_traits::no_type s_check(no_operator);
            static const bool value = (sizeof(s_check(((make<Lhs>() -= make<Rhs>()), make<has_operator>()))) == sizeof(::boost::type_traits::yes_type));
        };
        template <typename Lhs, typename Rhs, typename Ret, bool Forbidden_if>
        struct trait_impl1;
        template <typename Lhs, typename Rhs, typename Ret>
        struct trait_impl1<Lhs, Rhs, Ret, true>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Rhs, typename Ret>
        struct trait_impl1<Lhs, Rhs, Ret, false>
        {
            static const bool value = (operator_exists<Lhs, Rhs>::value && operator_returns_Ret<Lhs, Rhs, Ret, operator_returns_void<Lhs, Rhs>::value>::value);
        };
        template <typename Rhs, typename Ret>
        struct trait_impl1<void, Rhs, Ret, false>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Ret>
        struct trait_impl1<Lhs, void, Ret, false>
        {
            static const bool value = false;
        };
        template <typename Ret>
        struct trait_impl1<void, void, Ret, false>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Rhs, typename Ret>
        struct trait_impl
        {
            typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
            typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
            typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
            typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
            typedef typename ::boost::remove_cv<typename ::boost::remove_reference<typename ::boost::remove_pointer<Lhs_noref>::type>::type>::type Lhs_noptr;
            typedef typename ::boost::remove_cv<typename ::boost::remove_reference<typename ::boost::remove_pointer<Rhs_noref>::type>::type>::type Rhs_noptr;
            static const bool value = (trait_impl1<Lhs_noref, Rhs_noref, Ret, ((::boost::is_pointer<Lhs_noref>::value && ::boost::is_fundamental<Rhs_nocv>::value && (!::boost::is_integral<Rhs_noref>::value)) || (::boost::is_pointer<Lhs_noref>::value && ::boost::is_void<Lhs_noptr>::value && ::boost::is_fundamental<Rhs_nocv>::value) || (::boost::is_pointer<Rhs_noref>::value && ::boost::is_void<Rhs_noptr>::value && ::boost::is_fundamental<Lhs_nocv>::value) || (::boost::is_fundamental<Lhs_nocv>::value && ::boost::is_pointer<Rhs_noref>::value) || (::boost::is_pointer<Lhs_noref>::value && ::boost::is_pointer<Rhs_noref>::value) || ((::boost::is_fundamental<Lhs_nocv>::value || ::boost::is_pointer<Lhs_noref>::value) && (::boost::is_fundamental<Rhs_nocv>::value || ::boost::is_pointer<Rhs_noref>::value) && ::boost::is_const<Lhs_noref>::value))>::value);
        };
}
    }
    template <class Lhs, class Rhs = Lhs, class Ret = ::boost::detail::has_minus_assign_impl::dont_care>
    struct has_minus_assign : public integral_constant<bool, (::boost::detail::has_minus_assign_impl::trait_impl<Lhs, Rhs, Ret>::value)>
    {
    };
}
namespace boost
{
    namespace iterators
    {
namespace detail
{
        template <typename InputIterator, typename Distance>
        inline void
        advance_impl(
            InputIterator &it, Distance n, incrementable_traversal_tag)
        {
            while (n > 0)
            {
                ++it;
                --n;
            }
        }
        template <typename BidirectionalIterator, typename Distance>
        inline void
        advance_impl(
            BidirectionalIterator &it, Distance n, bidirectional_traversal_tag)
        {
            if (n >= 0)
            {
                while (n > 0)
                {
                    ++it;
                    --n;
                }
            }
            else
            {
                while (n < 0)
                {
                    --it;
                    ++n;
                }
            }
        }
        template <typename RandomAccessIterator, typename Distance>
        inline void
        advance_impl(
            RandomAccessIterator &it, Distance n, random_access_traversal_tag)
        {
            it += n;
        }
}
namespace advance_adl_barrier
{
        template <typename InputIterator, typename Distance>
        inline void
        advance(InputIterator &it, Distance n)
        {
            detail::advance_impl(
                it, n, typename iterator_traversal<InputIterator>::type());
        }
}
using namespace advance_adl_barrier;
    }
    using namespace iterators::advance_adl_barrier;
}
namespace boost
{
    namespace next_prior_detail
    {
template <typename T, typename Void = void>
struct is_iterator_class
{
        static const bool value = false;
};
template <typename T>
struct is_iterator_class<
    T,
    typename enable_if_has_type<
        typename std::iterator_traits<T>::iterator_category>::type>
{
        static const bool value = true;
};
template <typename T>
struct is_iterator : public is_iterator_class<T>
{
};
template <typename T>
struct is_iterator<T *>
{
        static const bool value = true;
};
template <typename T, typename Distance, bool HasPlus = has_plus<T, Distance>::value>
struct next_plus_impl;
template <typename T, typename Distance>
struct next_plus_impl<T, Distance, true>
{
        static T call(T x, Distance n)
        {
            return x + n;
        }
};
template <typename T, typename Distance, bool HasPlusAssign = has_plus_assign<T, Distance>::value>
struct next_plus_assign_impl : public next_plus_impl<T, Distance>
{
};
template <typename T, typename Distance>
struct next_plus_assign_impl<T, Distance, true>
{
        static T call(T x, Distance n)
        {
            x += n;
            return x;
        }
};
template <typename T, typename Distance, bool IsIterator = is_iterator<T>::value>
struct next_advance_impl : public next_plus_assign_impl<T, Distance>
{
};
template <typename T, typename Distance>
struct next_advance_impl<T, Distance, true>
{
        static T call(T x, Distance n)
        {
            boost::iterators::advance(x, n);
            return x;
        }
};
template <typename T, typename Distance, bool HasMinus = has_minus<T, Distance>::value>
struct prior_minus_impl;
template <typename T, typename Distance>
struct prior_minus_impl<T, Distance, true>
{
        static T call(T x, Distance n)
        {
            return x - n;
        }
};
template <typename T, typename Distance, bool HasMinusAssign = has_minus_assign<T, Distance>::value>
struct prior_minus_assign_impl : public prior_minus_impl<T, Distance>
{
};
template <typename T, typename Distance>
struct prior_minus_assign_impl<T, Distance, true>
{
        static T call(T x, Distance n)
        {
            x -= n;
            return x;
        }
};
template <typename T, typename Distance, bool IsIterator = is_iterator<T>::value>
struct prior_advance_impl : public prior_minus_assign_impl<T, Distance>
{
};
template <typename T, typename Distance>
struct prior_advance_impl<T, Distance, true>
{
        static T call(T x, Distance n)
        {
            boost::iterators::reverse_iterator<T> rx(x);
            boost::iterators::advance(rx, n);
            return rx.base();
        }
};
    }
    template <class T>
    inline T next(T x) { return ++x; }
    template <class T, class Distance>
    inline T next(T x, Distance n)
    {
return next_prior_detail::next_advance_impl<T, Distance>::call(x, n);
    }
    template <class T>
    inline T prior(T x) { return --x; }
    template <class T, class Distance>
    inline T prior(T x, Distance n)
    {
return next_prior_detail::prior_advance_impl<T, Distance>::call(x, n);
    }
}
namespace boost
{
    namespace iterator_range_detail
    {
template <class IteratorT>
struct iterator_range_impl
{
        template <class ForwardRange>
        static IteratorT adl_begin(ForwardRange &r)
        {
            return IteratorT(boost::begin(r));
        }
        template <class ForwardRange>
        static IteratorT adl_end(ForwardRange &r)
        {
            return IteratorT(boost::end(r));
        }
};
template <class Left, class Right>
inline bool less_than(const Left &l, const Right &r)
{
        return std::lexicographical_compare(boost::begin(l),
                                            boost::end(l),
                                            boost::begin(r),
                                            boost::end(r));
}
template <class Left, class Right>
inline bool greater_than(const Left &l, const Right &r)
{
        return iterator_range_detail::less_than(r, l);
}
template <class Left, class Right>
inline bool less_or_equal_than(const Left &l, const Right &r)
{
        return !iterator_range_detail::less_than(r, l);
}
template <class Left, class Right>
inline bool greater_or_equal_than(const Left &l, const Right &r)
{
        return !iterator_range_detail::less_than(l, r);
}
template <class Left, class Right>
inline bool equal(const Left &l, const Right &r)
{
        return boost::equal(l, r);
}
struct range_tag
{
};
struct const_range_tag
{
};
struct iterator_range_tag
{
};
typedef char (&incrementable_t)[1];
typedef char (&bidirectional_t)[2];
typedef char (&random_access_t)[3];
incrementable_t test_traversal_tag(boost::incrementable_traversal_tag);
bidirectional_t test_traversal_tag(boost::bidirectional_traversal_tag);
random_access_t test_traversal_tag(boost::random_access_traversal_tag);
template <std::size_t S>
struct pure_iterator_traversal_impl
{
        typedef boost::incrementable_traversal_tag type;
};
template <>
struct pure_iterator_traversal_impl<sizeof(bidirectional_t)>
{
        typedef boost::bidirectional_traversal_tag type;
};
template <>
struct pure_iterator_traversal_impl<sizeof(random_access_t)>
{
        typedef boost::random_access_traversal_tag type;
};
template <typename IteratorT>
struct pure_iterator_traversal
{
        typedef
            typename iterator_traversal<IteratorT>::type
                traversal_t;
        static const std::size_t traversal_i = sizeof(iterator_range_detail::test_traversal_tag((traversal_t())));
        typedef
            typename pure_iterator_traversal_impl<traversal_i>::type
                type;
};
template <class IteratorT, class TraversalTag>
class iterator_range_base
    : public iterator_range_tag
{
        typedef range_detail::safe_bool<
            IteratorT iterator_range_base<IteratorT, TraversalTag>::*>
            safe_bool_t;
        typedef iterator_range_base<IteratorT, TraversalTag> type;

    protected:
        typedef iterator_range_impl<IteratorT> impl;

    public:
        typedef typename safe_bool_t::unspecified_bool_type unspecified_bool_type;
        typedef typename iterator_value<IteratorT>::type value_type;
        typedef typename iterator_difference<IteratorT>::type difference_type;
        typedef std::size_t size_type;
        typedef typename iterator_reference<IteratorT>::type reference;
        typedef IteratorT const_iterator;
        typedef IteratorT iterator;

    protected:
        iterator_range_base()
            : m_Begin(), m_End()
        {
        }
        template <class Iterator>
        iterator_range_base(Iterator Begin, Iterator End)
            : m_Begin(Begin), m_End(End)
        {
        }

    public:
        IteratorT begin() const
        {
            return m_Begin;
        }
        IteratorT end() const
        {
            return m_End;
        }
        bool empty() const
        {
            return m_Begin == m_End;
        }
        operator unspecified_bool_type() const
        {
            return safe_bool_t::to_unspecified_bool(
                m_Begin != m_End, &iterator_range_base::m_Begin);
        }
        bool operator!() const
        {
            return empty();
        }
        bool equal(const iterator_range_base &r) const
        {
            return m_Begin == r.m_Begin && m_End == r.m_End;
        }
        reference front() const
        {
            (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "iterator_range_core.hpp", 255, "!empty()") : (void)0);
            return *m_Begin;
        }
        void drop_front()
        {
            (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "iterator_range_core.hpp", 261, "!empty()") : (void)0);
            ++m_Begin;
        }
        void drop_front(difference_type n)
        {
            (__builtin_expect(!(n >= difference_type()), 0) ? __assert_rtn(__func__, "iterator_range_core.hpp", 267, "n >= difference_type()") : (void)0);
            std::advance(this->m_Begin, n);
        }
        void pop_front() { drop_front(); }

    protected:
        template <class Iterator>
        void assign(Iterator first, Iterator last)
        {
            m_Begin = first;
            m_End = last;
        }
        template <class SinglePassRange>
        void assign(const SinglePassRange &r)
        {
            m_Begin = impl::adl_begin(r);
            m_End = impl::adl_end(r);
        }
        template <class SinglePassRange>
        void assign(SinglePassRange &r)
        {
            m_Begin = impl::adl_begin(r);
            m_End = impl::adl_end(r);
        }
        IteratorT m_Begin;
        IteratorT m_End;
};
template <class IteratorT>
class iterator_range_base<IteratorT, bidirectional_traversal_tag>
    : public iterator_range_base<IteratorT, incrementable_traversal_tag>
{
        typedef iterator_range_base<IteratorT, incrementable_traversal_tag> base_type;

    protected:
        iterator_range_base()
        {
        }
        template <class Iterator>
        iterator_range_base(Iterator first, Iterator last)
            : base_type(first, last)
        {
        }

    public:
        typedef typename base_type::difference_type difference_type;
        typedef typename base_type::reference reference;
        reference back() const
        {
            (__builtin_expect(!(!this->empty()), 0) ? __assert_rtn(__func__, "iterator_range_core.hpp", 323, "!this->empty()") : (void)0);
            return *boost::prior(this->m_End);
        }
        void drop_back()
        {
            (__builtin_expect(!(!this->empty()), 0) ? __assert_rtn(__func__, "iterator_range_core.hpp", 329, "!this->empty()") : (void)0);
            --this->m_End;
        }
        void drop_back(difference_type n)
        {
            (__builtin_expect(!(n >= difference_type()), 0) ? __assert_rtn(__func__, "iterator_range_core.hpp", 335, "n >= difference_type()") : (void)0);
            std::advance(this->m_End, -n);
        }
        void pop_back() { drop_back(); }
};
template <class IteratorT>
class iterator_range_base<IteratorT, random_access_traversal_tag>
    : public iterator_range_base<IteratorT, bidirectional_traversal_tag>
{
        typedef iterator_range_base<
            IteratorT, bidirectional_traversal_tag>
            base_type;

    public:
        typedef typename boost::mpl::if_<
            boost::mpl::or_<
                boost::is_abstract<
                    typename base_type::value_type>,
                boost::is_array<
                    typename base_type::value_type>,
                boost::is_function<
                    typename base_type::value_type>>,
            typename base_type::reference,
            typename base_type::value_type>::type abstract_value_type;
        typedef typename base_type::difference_type difference_type;
        typedef typename base_type::size_type size_type;
        typedef typename base_type::reference reference;

    protected:
        iterator_range_base()
        {
        }
        template <class Iterator>
        iterator_range_base(Iterator first, Iterator last)
            : base_type(first, last)
        {
        }

    public:
        reference operator[](difference_type at) const
        {
            (__builtin_expect(!(at >= 0), 0) ? __assert_rtn(__func__, "iterator_range_core.hpp", 389, "at >= 0") : (void)0);
            (__builtin_expect(!(static_cast<typename base_type::size_type>(at) < size()), 0) ? __assert_rtn(__func__, "iterator_range_core.hpp", 390, "static_cast<typename base_type::size_type>(at) < size()") : (void)0);
            return this->m_Begin[at];
        }
        abstract_value_type operator()(difference_type at) const
        {
            (__builtin_expect(!(at >= 0), 0) ? __assert_rtn(__func__, "iterator_range_core.hpp", 401, "at >= 0") : (void)0);
            (__builtin_expect(!(static_cast<typename base_type::size_type>(at) < size()), 0) ? __assert_rtn(__func__, "iterator_range_core.hpp", 402, "static_cast<typename base_type::size_type>(at) < size()") : (void)0);
            return this->m_Begin[at];
        }
        typename base_type::size_type size() const
        {
            return this->m_End - this->m_Begin;
        }
};
    }
    template <class IteratorT>
    class iterator_range
        : public iterator_range_detail::iterator_range_base<
              IteratorT,
              typename iterator_range_detail::pure_iterator_traversal<IteratorT>::type>
    {
typedef iterator_range_detail::iterator_range_base<
    IteratorT,
    typename iterator_range_detail::pure_iterator_traversal<IteratorT>::type>
    base_type;
template <class Source>
struct is_compatible_range_
    : is_convertible<
          typename mpl::eval_if<
              has_range_iterator<Source>,
              range_iterator<Source>,
              mpl::identity<void>>::type,
          typename base_type::iterator>
{
};
template <class Source>
struct is_compatible_range
    : mpl::and_<
          mpl::not_<
              is_convertible<
                  Source,
                  typename base_type::iterator>>,
          is_compatible_range_<Source>>
{
};

protected:
typedef iterator_range_detail::iterator_range_impl<IteratorT> impl;

public:
typedef iterator_range<IteratorT> type;
iterator_range()
{
}
template <class Iterator>
iterator_range(Iterator first, Iterator last)
    : base_type(first, last)
{
}
template <class SinglePassRange>
iterator_range(
    const SinglePassRange &r,
    typename ::boost::enable_if<
        is_compatible_range<const SinglePassRange>>::type * = 0)
    : base_type(impl::adl_begin(r), impl::adl_end(r))
{
}
template <class SinglePassRange>
iterator_range(
    SinglePassRange &r,
    typename ::boost::enable_if<
        is_compatible_range<SinglePassRange>>::type * = 0)
    : base_type(impl::adl_begin(r), impl::adl_end(r))
{
}
template <class SinglePassRange>
iterator_range(const SinglePassRange &r,
               iterator_range_detail::const_range_tag)
    : base_type(impl::adl_begin(r), impl::adl_end(r))
{
}
template <class SinglePassRange>
iterator_range(SinglePassRange &r,
               iterator_range_detail::range_tag)
    : base_type(impl::adl_begin(r), impl::adl_end(r))
{
}
template <class Iterator>
iterator_range &operator=(const iterator_range<Iterator> &other)
{
        this->assign(other.begin(), other.end());
        return *this;
}
template <class Iterator>
iterator_range &operator=(iterator_range<Iterator> &other)
{
        this->assign(other.begin(), other.end());
        return *this;
}
template <class SinglePassRange>
iterator_range &operator=(SinglePassRange &r)
{
        this->assign(r);
        return *this;
}
template <class SinglePassRange>
iterator_range &operator=(const SinglePassRange &r)
{
        this->assign(r);
        return *this;
}
iterator_range &advance_begin(
    typename base_type::difference_type n)
{
        std::advance(this->m_Begin, n);
        return *this;
}
iterator_range &advance_end(
    typename base_type::difference_type n)
{
        std::advance(this->m_End, n);
        return *this;
}

protected:
typedef iterator_range iterator_range_;
    };
    template <class IteratorT, class ForwardRange>
    inline typename boost::enable_if<
        mpl::not_<is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange>>,
        bool>::type
    operator==(const ForwardRange &l, const iterator_range<IteratorT> &r)
    {
return boost::equal(l, r);
    }
    template <class IteratorT, class ForwardRange>
    inline typename boost::enable_if<
        mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange>>,
        bool>::type
    operator!=(const ForwardRange &l, const iterator_range<IteratorT> &r)
    {
return !boost::equal(l, r);
    }
    template <class IteratorT, class ForwardRange>
    inline typename boost::enable_if<
        mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange>>,
        bool>::type
    operator<(const ForwardRange &l, const iterator_range<IteratorT> &r)
    {
return iterator_range_detail::less_than(l, r);
    }
    template <class IteratorT, class ForwardRange>
    inline typename boost::enable_if<
        mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange>>,
        bool>::type
    operator<=(const ForwardRange &l, const iterator_range<IteratorT> &r)
    {
return iterator_range_detail::less_or_equal_than(l, r);
    }
    template <class IteratorT, class ForwardRange>
    inline typename boost::enable_if<
        mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange>>,
        bool>::type
    operator>(const ForwardRange &l, const iterator_range<IteratorT> &r)
    {
return iterator_range_detail::greater_than(l, r);
    }
    template <class IteratorT, class ForwardRange>
    inline typename boost::enable_if<
        mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange>>,
        bool>::type
    operator>=(const ForwardRange &l, const iterator_range<IteratorT> &r)
    {
return iterator_range_detail::greater_or_equal_than(l, r);
    }
    template <class Iterator1T, class Iterator2T>
    inline bool
    operator==(const iterator_range<Iterator1T> &l, const iterator_range<Iterator2T> &r)
    {
return boost::equal(l, r);
    }
    template <class IteratorT, class ForwardRange>
    inline typename boost::enable_if<
        mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange>>,
        bool>::type
    operator==(const iterator_range<IteratorT> &l, const ForwardRange &r)
    {
return boost::equal(l, r);
    }
    template <class Iterator1T, class Iterator2T>
    inline bool
    operator!=(const iterator_range<Iterator1T> &l, const iterator_range<Iterator2T> &r)
    {
return !boost::equal(l, r);
    }
    template <class IteratorT, class ForwardRange>
    inline typename boost::enable_if<
        mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange>>,
        bool>::type
    operator!=(const iterator_range<IteratorT> &l, const ForwardRange &r)
    {
return !boost::equal(l, r);
    }
    template <class Iterator1T, class Iterator2T>
    inline bool
    operator<(const iterator_range<Iterator1T> &l, const iterator_range<Iterator2T> &r)
    {
return iterator_range_detail::less_than(l, r);
    }
    template <class IteratorT, class ForwardRange>
    inline typename boost::enable_if<
        mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange>>,
        bool>::type
    operator<(const iterator_range<IteratorT> &l, const ForwardRange &r)
    {
return iterator_range_detail::less_than(l, r);
    }
    template <class Iterator1T, class Iterator2T>
    inline bool
    operator<=(const iterator_range<Iterator1T> &l, const iterator_range<Iterator2T> &r)
    {
return iterator_range_detail::less_or_equal_than(l, r);
    }
    template <class IteratorT, class ForwardRange>
    inline typename boost::enable_if<
        mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange>>,
        bool>::type
    operator<=(const iterator_range<IteratorT> &l, const ForwardRange &r)
    {
return iterator_range_detail::less_or_equal_than(l, r);
    }
    template <class Iterator1T, class Iterator2T>
    inline bool
    operator>(const iterator_range<Iterator1T> &l, const iterator_range<Iterator2T> &r)
    {
return iterator_range_detail::greater_than(l, r);
    }
    template <class IteratorT, class ForwardRange>
    inline typename boost::enable_if<
        mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange>>,
        bool>::type
    operator>(const iterator_range<IteratorT> &l, const ForwardRange &r)
    {
return iterator_range_detail::greater_than(l, r);
    }
    template <class Iterator1T, class Iterator2T>
    inline bool
    operator>=(const iterator_range<Iterator1T> &l, const iterator_range<Iterator2T> &r)
    {
return iterator_range_detail::greater_or_equal_than(l, r);
    }
    template <class IteratorT, class ForwardRange>
    inline typename boost::enable_if<
        mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange>>,
        bool>::type
    operator>=(const iterator_range<IteratorT> &l, const ForwardRange &r)
    {
return iterator_range_detail::greater_or_equal_than(l, r);
    }
    template <typename IteratorT>
    inline iterator_range<IteratorT>
    make_iterator_range(IteratorT Begin, IteratorT End)
    {
return iterator_range<IteratorT>(Begin, End);
    }
    template <typename IteratorT, typename IntegerT>
    inline iterator_range<IteratorT>
    make_iterator_range_n(IteratorT first, IntegerT n)
    {
return iterator_range<IteratorT>(first, boost::next(first, n));
    }
    template <class ForwardRange>
    inline iterator_range<typename range_iterator<ForwardRange>::type>
    make_iterator_range(ForwardRange &r)
    {
return iterator_range<typename range_iterator<ForwardRange>::type>(r, iterator_range_detail::range_tag());
    }
    template <class ForwardRange>
    inline iterator_range<typename range_iterator<const ForwardRange>::type>
    make_iterator_range(const ForwardRange &r)
    {
return iterator_range<typename range_iterator<const ForwardRange>::type>(r, iterator_range_detail::const_range_tag());
    }
    namespace iterator_range_detail
    {
template <class Range>
inline iterator_range<typename range_iterator<Range>::type>
make_range_impl(Range &r,
                typename range_difference<Range>::type advance_begin,
                typename range_difference<Range>::type advance_end)
{
        typename range_iterator<Range>::type
            new_begin = boost::begin(r),
            new_end = boost::end(r);
        std::advance(new_begin, advance_begin);
        std::advance(new_end, advance_end);
        return make_iterator_range(new_begin, new_end);
}
    }
    template <class Range>
    inline iterator_range<typename range_iterator<Range>::type>
    make_iterator_range(Range &r,
                        typename range_difference<Range>::type advance_begin,
                        typename range_difference<Range>::type advance_end)
    {
return iterator_range_detail::make_range_impl(r, advance_begin, advance_end);
    }
    template <class Range>
    inline iterator_range<typename range_iterator<const Range>::type>
    make_iterator_range(const Range &r,
                        typename range_difference<Range>::type advance_begin,
                        typename range_difference<Range>::type advance_end)
    {
return iterator_range_detail::make_range_impl(r, advance_begin, advance_end);
    }
    template <typename SeqT, typename Range>
    inline SeqT copy_range(const Range &r)
    {
return SeqT(boost::begin(r), boost::end(r));
    }
}
namespace std
{
    inline namespace __1
    {
template <class _Tp, class _Allocator>
class __deque_base;
template <class _Tp, class _Allocator = allocator<_Tp>>
class deque;
template <class _ValueType, class _Pointer, class _Reference, class _MapPointer,
          class _DiffType, _DiffType _BlockSize>
class __deque_iterator;
template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy(_RAIter __f,
     _RAIter __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
     typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type * = 0);
template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     _OutputIterator __r);
template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy_backward(_RAIter __f,
              _RAIter __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
              typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type * = 0);
template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              _OutputIterator __r);
template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move(_RAIter __f,
     _RAIter __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
     typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type * = 0);
template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     _OutputIterator __r);
template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move_backward(_RAIter __f,
              _RAIter __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
              typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type * = 0);
template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              _OutputIterator __r);
template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
template <class _ValueType, class _DiffType>
struct __deque_block_size
{
        static const _DiffType value = sizeof(_ValueType) < 256 ? 4096 / sizeof(_ValueType) : 16;
};
template <class _ValueType, class _Pointer, class _Reference, class _MapPointer,
          class _DiffType, _DiffType _BS = __deque_block_size<_ValueType, _DiffType>::value>
class __deque_iterator
{
        typedef _MapPointer __map_iterator;

    public:
        typedef _Pointer pointer;
        typedef _DiffType difference_type;

    private:
        __map_iterator __m_iter_;
        pointer __ptr_;
        static const difference_type __block_size;

    public:
        typedef _ValueType value_type;
        typedef random_access_iterator_tag iterator_category;
        typedef _Reference reference;

        {
        }
        template <class _Pp, class _Rp, class _MP>

        __deque_iterator(const __deque_iterator<value_type, _Pp, _Rp, _MP, difference_type, _BS> &__it,
                         typename enable_if<is_convertible<_Pp, pointer>::value>::type * = 0) throw()
            : __m_iter_(__it.__m_iter_), __ptr_(__it.__ptr_)
        {
        }
        const { return *__ptr_; }
        const { return __ptr_; }

        {
            if (++__ptr_ - *__m_iter_ == __block_size)
            {
                ++__m_iter_;
                __ptr_ = *__m_iter_;
            }
            return *this;
        }

        {
            __deque_iterator __tmp = *this;
            ++(*this);
            return __tmp;
        }

        {
            if (__ptr_ == *__m_iter_)
            {
                --__m_iter_;
                __ptr_ = *__m_iter_ + __block_size;
            }
            --__ptr_;
            return *this;
        }

        {
            __deque_iterator __tmp = *this;
            --(*this);
            return __tmp;
        }

        {
            if (__n != 0)
            {
                __n += __ptr_ - *__m_iter_;
                if (__n > 0)
                {
                    __m_iter_ += __n / __block_size;
                    __ptr_ = *__m_iter_ + __n % __block_size;
                }
                else
                {
                    difference_type __z = __block_size - 1 - __n;
                    __m_iter_ -= __z / __block_size;
                    __ptr_ = *__m_iter_ + (__block_size - 1 - __z % __block_size);
                }
            }
            return *this;
        }

        {
            return *this += -__n;
        }
        const
        {
            __deque_iterator __t(*this);
            __t += __n;
            return __t;
        }
        const
        {
            __deque_iterator __t(*this);
            __t -= __n;
            return __t;
        }

        friend __deque_iterator operator+(difference_type __n, const __deque_iterator &__it)
        {
            return __it + __n;
        }

        friend difference_type operator-(const __deque_iterator &__x, const __deque_iterator &__y)
        {
            if (__x != __y)
                return (__x.__m_iter_ - __y.__m_iter_) * __block_size + (__x.__ptr_ - *__x.__m_iter_) - (__y.__ptr_ - *__y.__m_iter_);
            return 0;
        }
        const
        {
            return *(*this + __n);
        }
        friend bool operator==(const __deque_iterator &__x, const __deque_iterator &__y)
        {
            return __x.__ptr_ == __y.__ptr_;
        }
        friend bool operator!=(const __deque_iterator &__x, const __deque_iterator &__y)
        {
            return !(__x == __y);
        }
        friend bool operator<(const __deque_iterator &__x, const __deque_iterator &__y)
        {
            return __x.__m_iter_ < __y.__m_iter_ ||
                   (__x.__m_iter_ == __y.__m_iter_ && __x.__ptr_ < __y.__ptr_);
        }
        friend bool operator>(const __deque_iterator &__x, const __deque_iterator &__y)
        {
            return __y < __x;
        }
        friend bool operator<=(const __deque_iterator &__x, const __deque_iterator &__y)
        {
            return !(__y < __x);
        }
        friend bool operator>=(const __deque_iterator &__x, const __deque_iterator &__y)
        {
            return !(__x < __y);
        }

    private:
        : __m_iter_(__m), __ptr_(__p) {}
        template <class _Tp, class _Ap>
        friend class __deque_base;
        template <class _Tp, class _Ap>
        friend class deque;
        template <class _Vp, class _Pp, class _Rp, class _MP, class _Dp, _Dp>
        friend class __deque_iterator;
        template <class _RAIter,
                  class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
        friend __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
        copy(_RAIter __f,
             _RAIter __l,
             __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
             typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type *);
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
                  class _OutputIterator>
        friend _OutputIterator
        copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
             __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
             _OutputIterator __r);
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
                  class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
        friend __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
        copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
             __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
             __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
        template <class _RAIter,
                  class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
        friend __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
        copy_backward(_RAIter __f,
                      _RAIter __l,
                      __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
                      typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type *);
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
                  class _OutputIterator>
        friend _OutputIterator
        copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                      __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                      _OutputIterator __r);
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
                  class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
        friend __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
        copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                      __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                      __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
        template <class _RAIter,
                  class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
        friend __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
        move(_RAIter __f,
             _RAIter __l,
             __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
             typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type *);
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
                  class _OutputIterator>
        friend _OutputIterator
        move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
             __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
             _OutputIterator __r);
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
                  class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
        friend __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
        move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
             __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
             __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
        template <class _RAIter,
                  class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
        friend __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
        move_backward(_RAIter __f,
                      _RAIter __l,
                      __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
                      typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type *);
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
                  class _OutputIterator>
        friend _OutputIterator
        move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                      __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                      _OutputIterator __r);
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
                  class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
        friend __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
        move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                      __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                      __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
};
template <class _ValueType, class _Pointer, class _Reference, class _MapPointer,
          class _DiffType, _DiffType _BlockSize>
const _DiffType __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer,
                                 _DiffType, _BlockSize>::__block_size =
    __deque_block_size<_ValueType, _DiffType>::value;
template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy(_RAIter __f,
     _RAIter __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
     typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type *)
{
        typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;
        typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;
        const difference_type __block_size = __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::__block_size;
        while (__f != __l)
        {
            pointer __rb = __r.__ptr_;
            pointer __re = *__r.__m_iter_ + __block_size;
            difference_type __bs = __re - __rb;
            difference_type __n = __l - __f;
            _RAIter __m = __l;
            if (__n > __bs)
            {
                __n = __bs;
                __m = __f + __n;
            }
            std::copy(__f, __m, __rb);
            __f = __m;
            __r += __n;
        }
        return __r;
}
template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     _OutputIterator __r)
{
        typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
        typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
        const difference_type __block_size = __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::__block_size;
        difference_type __n = __l - __f;
        while (__n > 0)
        {
            pointer __fb = __f.__ptr_;
            pointer __fe = *__f.__m_iter_ + __block_size;
            difference_type __bs = __fe - __fb;
            if (__bs > __n)
            {
                __bs = __n;
                __fe = __fb + __bs;
            }
            __r = std::copy(__fb, __fe, __r);
            __n -= __bs;
            __f += __bs;
        }
        return __r;
}
template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)
{
        typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
        typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
        const difference_type __block_size = __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::__block_size;
        difference_type __n = __l - __f;
        while (__n > 0)
        {
            pointer __fb = __f.__ptr_;
            pointer __fe = *__f.__m_iter_ + __block_size;
            difference_type __bs = __fe - __fb;
            if (__bs > __n)
            {
                __bs = __n;
                __fe = __fb + __bs;
            }
            __r = std::copy(__fb, __fe, __r);
            __n -= __bs;
            __f += __bs;
        }
        return __r;
}
template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy_backward(_RAIter __f,
              _RAIter __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
              typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type *)
{
        typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;
        typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;
        while (__f != __l)
        {
            __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __rp = std::prev(__r);
            pointer __rb = *__rp.__m_iter_;
            pointer __re = __rp.__ptr_ + 1;
            difference_type __bs = __re - __rb;
            difference_type __n = __l - __f;
            _RAIter __m = __f;
            if (__n > __bs)
            {
                __n = __bs;
                __m = __l - __n;
            }
            std::copy_backward(__m, __l, __re);
            __l = __m;
            __r -= __n;
        }
        return __r;
}
template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              _OutputIterator __r)
{
        typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
        typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
        difference_type __n = __l - __f;
        while (__n > 0)
        {
            --__l;
            pointer __lb = *__l.__m_iter_;
            pointer __le = __l.__ptr_ + 1;
            difference_type __bs = __le - __lb;
            if (__bs > __n)
            {
                __bs = __n;
                __lb = __le - __bs;
            }
            __r = std::copy_backward(__lb, __le, __r);
            __n -= __bs;
            __l -= __bs - 1;
        }
        return __r;
}
template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)
{
        typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
        typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
        difference_type __n = __l - __f;
        while (__n > 0)
        {
            --__l;
            pointer __lb = *__l.__m_iter_;
            pointer __le = __l.__ptr_ + 1;
            difference_type __bs = __le - __lb;
            if (__bs > __n)
            {
                __bs = __n;
                __lb = __le - __bs;
            }
            __r = std::copy_backward(__lb, __le, __r);
            __n -= __bs;
            __l -= __bs - 1;
        }
        return __r;
}
template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move(_RAIter __f,
     _RAIter __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
     typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type *)
{
        typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;
        typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;
        const difference_type __block_size = __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::__block_size;
        while (__f != __l)
        {
            pointer __rb = __r.__ptr_;
            pointer __re = *__r.__m_iter_ + __block_size;
            difference_type __bs = __re - __rb;
            difference_type __n = __l - __f;
            _RAIter __m = __l;
            if (__n > __bs)
            {
                __n = __bs;
                __m = __f + __n;
            }
            std::move(__f, __m, __rb);
            __f = __m;
            __r += __n;
        }
        return __r;
}
template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     _OutputIterator __r)
{
        typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
        typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
        const difference_type __block_size = __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::__block_size;
        difference_type __n = __l - __f;
        while (__n > 0)
        {
            pointer __fb = __f.__ptr_;
            pointer __fe = *__f.__m_iter_ + __block_size;
            difference_type __bs = __fe - __fb;
            if (__bs > __n)
            {
                __bs = __n;
                __fe = __fb + __bs;
            }
            __r = std::move(__fb, __fe, __r);
            __n -= __bs;
            __f += __bs;
        }
        return __r;
}
template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)
{
        typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
        typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
        const difference_type __block_size = __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::__block_size;
        difference_type __n = __l - __f;
        while (__n > 0)
        {
            pointer __fb = __f.__ptr_;
            pointer __fe = *__f.__m_iter_ + __block_size;
            difference_type __bs = __fe - __fb;
            if (__bs > __n)
            {
                __bs = __n;
                __fe = __fb + __bs;
            }
            __r = std::move(__fb, __fe, __r);
            __n -= __bs;
            __f += __bs;
        }
        return __r;
}
template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move_backward(_RAIter __f,
              _RAIter __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
              typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type *)
{
        typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;
        typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;
        while (__f != __l)
        {
            __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __rp = std::prev(__r);
            pointer __rb = *__rp.__m_iter_;
            pointer __re = __rp.__ptr_ + 1;
            difference_type __bs = __re - __rb;
            difference_type __n = __l - __f;
            _RAIter __m = __f;
            if (__n > __bs)
            {
                __n = __bs;
                __m = __l - __n;
            }
            std::move_backward(__m, __l, __re);
            __l = __m;
            __r -= __n;
        }
        return __r;
}
template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              _OutputIterator __r)
{
        typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
        typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
        difference_type __n = __l - __f;
        while (__n > 0)
        {
            --__l;
            pointer __lb = *__l.__m_iter_;
            pointer __le = __l.__ptr_ + 1;
            difference_type __bs = __le - __lb;
            if (__bs > __n)
            {
                __bs = __n;
                __lb = __le - __bs;
            }
            __r = std::move_backward(__lb, __le, __r);
            __n -= __bs;
            __l -= __bs - 1;
        }
        return __r;
}
template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)
{
        typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
        typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
        difference_type __n = __l - __f;
        while (__n > 0)
        {
            --__l;
            pointer __lb = *__l.__m_iter_;
            pointer __le = __l.__ptr_ + 1;
            difference_type __bs = __le - __lb;
            if (__bs > __n)
            {
                __bs = __n;
                __lb = __le - __bs;
            }
            __r = std::move_backward(__lb, __le, __r);
            __n -= __bs;
            __l -= __bs - 1;
        }
        return __r;
}
template <class _Tp, class _Allocator>
class __deque_base
{
        __deque_base(const __deque_base &__c);
        __deque_base &operator=(const __deque_base &__c);

    public:
        typedef _Allocator allocator_type;
        typedef allocator_traits<allocator_type> __alloc_traits;
        typedef typename __alloc_traits::size_type size_type;
        typedef _Tp value_type;
        typedef value_type &reference;
        typedef const value_type &const_reference;
        typedef typename __alloc_traits::difference_type difference_type;
        typedef typename __alloc_traits::pointer pointer;
        typedef typename __alloc_traits::const_pointer const_pointer;
        static const difference_type __block_size;
        typedef typename __rebind_alloc_helper<__alloc_traits, pointer>::type __pointer_allocator;
        typedef allocator_traits<__pointer_allocator> __map_traits;
        typedef typename __map_traits::pointer __map_pointer;
        typedef typename __rebind_alloc_helper<__alloc_traits, const_pointer>::type __const_pointer_allocator;
        typedef typename allocator_traits<__const_pointer_allocator>::const_pointer __map_const_pointer;
        typedef __split_buffer<pointer, __pointer_allocator> __map;
        typedef __deque_iterator<value_type, pointer, reference, __map_pointer,
                                 difference_type>
            iterator;
        typedef __deque_iterator<value_type, const_pointer, const_reference, __map_const_pointer,
                                 difference_type>
            const_iterator;
        struct __deque_block_range
        {
            explicit __deque_block_range(pointer __b, pointer __e) throw() : __begin_(__b), __end_(__e) {}
            const pointer __begin_;
            const pointer __end_;
        };
        struct __deque_range
        {
            iterator __pos_;
            const iterator __end_;
            __deque_range(iterator __pos, iterator __e) throw()
                : __pos_(__pos), __end_(__e) {}
            explicit operator bool() const throw()
            {
                return __pos_ != __end_;
            }
            __deque_range begin() const
            {
                return *this;
            }
            __deque_range end() const
            {
                return __deque_range(__end_, __end_);
            }
            __deque_block_range operator*() const throw()
            {
                if (__pos_.__m_iter_ == __end_.__m_iter_)
                {
                    return __deque_block_range(__pos_.__ptr_, __end_.__ptr_);
                }
                return __deque_block_range(__pos_.__ptr_, *__pos_.__m_iter_ + __block_size);
            }
            __deque_range &operator++() throw()
            {
                if (__pos_.__m_iter_ == __end_.__m_iter_)
                {
                    __pos_ = __end_;
                }
                else
                {
                    ++__pos_.__m_iter_;
                    __pos_.__ptr_ = *__pos_.__m_iter_;
                }
                return *this;
            }
            friend bool operator==(__deque_range const &__lhs, __deque_range const &__rhs)
            {
                return __lhs.__pos_ == __rhs.__pos_;
            }
            friend bool operator!=(__deque_range const &__lhs, __deque_range const &__rhs)
            {
                return !(__lhs == __rhs);
            }
        };
        struct _ConstructTransaction
        {
            _ConstructTransaction(__deque_base *__db, __deque_block_range &__r)
                : __pos_(__r.__begin_), __end_(__r.__end_), __begin_(__r.__begin_), __base_(__db) {}
            ~_ConstructTransaction()
            {
                __base_->size() += (__pos_ - __begin_);
            }
            pointer __pos_;
            const pointer __end_;

        private:
            const pointer __begin_;
            __deque_base *const __base_;
        };

    protected:
        __map __map_;
        size_type __start_;
        __compressed_pair<size_type, allocator_type> __size_;
        iterator begin() throw();
        const_iterator begin() const throw();
        iterator end() throw();
        const_iterator end() const throw();
        ;
}

const size_type &
size() const throw()
{
        return __size_.first();
};
    }

    const allocator_type &__alloc() const throw() { return __size_.second(); }

    __deque_base();

    explicit __deque_base(const allocator_type &__a);

public:
    ~__deque_base();
    void swap(__deque_base &__c);

protected:
    void clear() throw();
    bool __invariants() const;

    void __move_assign(__deque_base &__c)
    {
__map_ = std::move(__c.__map_);
__start_ = __c.__start_;
size() = __c.size();
__move_assign_alloc(__c);
__c.__start_ = __c.size() = 0;
    }

    void __move_assign_alloc(__deque_base &__c)
    {
__move_assign_alloc(__c, integral_constant<bool,
                                           __alloc_traits::propagate_on_container_move_assignment::value>());
    }

private:
    void __move_assign_alloc(__deque_base &__c, true_type)
    {
__alloc() = std::move(__c.__alloc());
    }

    void __move_assign_alloc(__deque_base &, false_type) throw()
    {
    }
};
template <class _Tp, class _Allocator>
const typename __deque_base<_Tp, _Allocator>::difference_type
    __deque_base<_Tp, _Allocator>::__block_size =
        __deque_block_size<value_type, difference_type>::value;
template <class _Tp, class _Allocator>
bool __deque_base<_Tp, _Allocator>::__invariants() const
{
    if (!__map_.__invariants())
return false;
    if (__map_.size() >= size_type(-1) / __block_size)
return false;
    for (typename __map::const_iterator __i = __map_.begin(), __e = __map_.end();
         __i != __e; ++__i)
if (*__i == __nullptr)
        return false;
    if (__map_.size() != 0)
    {
if (size() >= __map_.size() * __block_size)
        return false;
if (__start_ >= __map_.size() * __block_size - size())
        return false;
    }
    else
    {
if (size() != 0)
        return false;
if (__start_ != 0)
        return false;
    }
    return true;
}
template <class _Tp, class _Allocator>
typename __deque_base<_Tp, _Allocator>::iterator
__deque_base<_Tp, _Allocator>::begin() throw()
{
    __map_pointer __mp = __map_.begin() + __start_ / __block_size;
    return iterator(__mp, __map_.empty() ? 0 : *__mp + __start_ % __block_size);
}
template <class _Tp, class _Allocator>
typename __deque_base<_Tp, _Allocator>::const_iterator
__deque_base<_Tp, _Allocator>::begin() const throw()
{
    __map_const_pointer __mp = static_cast<__map_const_pointer>(__map_.begin() + __start_ / __block_size);
    return const_iterator(__mp, __map_.empty() ? 0 : *__mp + __start_ % __block_size);
}
template <class _Tp, class _Allocator>
typename __deque_base<_Tp, _Allocator>::iterator
__deque_base<_Tp, _Allocator>::end() throw()
{
    size_type __p = size() + __start_;
    __map_pointer __mp = __map_.begin() + __p / __block_size;
    return iterator(__mp, __map_.empty() ? 0 : *__mp + __p % __block_size);
}
template <class _Tp, class _Allocator>
typename __deque_base<_Tp, _Allocator>::const_iterator
__deque_base<_Tp, _Allocator>::end() const throw()
{
    size_type __p = size() + __start_;
    __map_const_pointer __mp = static_cast<__map_const_pointer>(__map_.begin() + __p / __block_size);
    return const_iterator(__mp, __map_.empty() ? 0 : *__mp + __p % __block_size);
}
template <class _Tp, class _Allocator>
inline __deque_base<_Tp, _Allocator>::__deque_base()
    : __start_(0), __size_(0, __default_init_tag()) {}
template <class _Tp, class _Allocator>
inline __deque_base<_Tp, _Allocator>::__deque_base(const allocator_type &__a)
    : __map_(__pointer_allocator(__a)), __start_(0), __size_(0, __a) {}
template <class _Tp, class _Allocator>
__deque_base<_Tp, _Allocator>::~__deque_base()
{
    clear();
    typename __map::iterator __i = __map_.begin();
    typename __map::iterator __e = __map_.end();
    for (; __i != __e; ++__i)
__alloc_traits::deallocate(__alloc(), *__i, __block_size);
}
template <class _Tp, class _Allocator>
void __deque_base<_Tp, _Allocator>::swap(__deque_base &__c)
{
    __map_.swap(__c.__map_);
    std::swap(__start_, __c.__start_);
    std::swap(size(), __c.size());
    std::__swap_allocator(__alloc(), __c.__alloc());
}
template <class _Tp, class _Allocator>
void __deque_base<_Tp, _Allocator>::clear() throw()
{
    allocator_type &__a = __alloc();
    for (iterator __i = begin(), __e = end(); __i != __e; ++__i)
__alloc_traits::destroy(__a, std::addressof(*__i));
    size() = 0;
    while (__map_.size() > 2)
    {
__alloc_traits::deallocate(__a, __map_.front(), __block_size);
__map_.pop_front();
    }
    switch (__map_.size())
    {
    case 1:
__start_ = __block_size / 2;
break;
    case 2:
__start_ = __block_size;
break;
    }
}
template <class _Tp, class _Allocator>
class deque
    : private __deque_base<_Tp, _Allocator>
{
public:
    typedef _Tp value_type;
    typedef _Allocator allocator_type;
    _Static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");
    typedef __deque_base<value_type, allocator_type> __base;
    typedef typename __base::__alloc_traits __alloc_traits;
    typedef typename __base::reference reference;
    typedef typename __base::const_reference const_reference;
    typedef typename __base::iterator iterator;
    typedef typename __base::const_iterator const_iterator;
    typedef typename __base::size_type size_type;
    typedef typename __base::difference_type difference_type;
    typedef typename __base::pointer pointer;
    typedef typename __base::const_pointer const_pointer;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    using typename __base::__deque_block_range;
    using typename __base::__deque_range;
    using typename __base::_ConstructTransaction;

    deque(){}
    {
    }
    explicit deque(size_type __n);
    deque(size_type __n, const value_type &__v);
    template <class = __enable_if_t<__is_allocator<_Allocator>::value>>
    deque(size_type __n, const value_type &__v, const allocator_type &__a) : __base(__a)
    {
if (__n > 0)
        __append(__n, __v);
    }
    template <class _InputIter>
    deque(_InputIter __f, _InputIter __l,
          typename enable_if<__is_cpp17_input_iterator<_InputIter>::value>::type * = 0);
    template <class _InputIter>
    deque(_InputIter __f, _InputIter __l, const allocator_type &__a,
          typename enable_if<__is_cpp17_input_iterator<_InputIter>::value>::type * = 0);
    deque(const deque &__c);
    deque(const deque &__c, const __type_identity_t<allocator_type> &__a);
    deque &operator=(const deque &__c);
    template <class _InputIter>
    void assign(_InputIter __f, _InputIter __l,
                typename enable_if<__is_cpp17_input_iterator<_InputIter>::value &&
                                   !__is_cpp17_random_access_iterator<_InputIter>::value>::type * = 0);
    template <class _RAIter>
    void assign(_RAIter __f, _RAIter __l,
                typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type * = 0);
    void assign(size_type __n, const value_type &__v);

    allocator_type get_allocator() const throw();

    iterator begin() throw() { return __base::begin(); }

    const_iterator begin() const throw() { return __base::begin(); }

    iterator end() throw() { return __base::end(); }

    const_iterator end() const throw() { return __base::end(); }

    reverse_iterator rbegin() throw()
    {
return reverse_iterator(__base::end());
    }

    const_reverse_iterator rbegin() const throw()
    {
return const_reverse_iterator(__base::end());
    }

    reverse_iterator rend() throw()
    {
return reverse_iterator(__base::begin());
    }

    const_reverse_iterator rend() const throw()
    {
return const_reverse_iterator(__base::begin());
    }

    const_iterator cbegin() const throw()
    {
return __base::begin();
    }

    const_iterator cend() const throw()
    {
return __base::end();
    }

    const_reverse_iterator crbegin() const throw()
    {
return const_reverse_iterator(__base::end());
    }

    const_reverse_iterator crend() const throw()
    {
return const_reverse_iterator(__base::begin());
    }

    size_type size() const throw() { return __base::size(); }

    size_type max_size() const throw()
    {
return std::min<size_type>(
    __alloc_traits::max_size(__base::__alloc()),
    numeric_limits<difference_type>::max());
    }
    void resize(size_type __n);
    void resize(size_type __n, const value_type &__v);
    void shrink_to_fit() throw();

    bool empty() const throw() { return __base::size() == 0; }

    reference operator[](size_type __i) throw();

    const_reference operator[](size_type __i) const throw();

    reference at(size_type __i);

    const_reference at(size_type __i) const;

    reference front() throw();

    const_reference front() const throw();

    reference back() throw();

    const_reference back() const throw();
    void push_front(const value_type &__v);
    void push_back(const value_type &__v);
    iterator insert(const_iterator __p, const value_type &__v);
    iterator insert(const_iterator __p, size_type __n, const value_type &__v);
    template <class _InputIter>
    iterator insert(const_iterator __p, _InputIter __f, _InputIter __l,
                    typename enable_if<__is_exactly_cpp17_input_iterator<_InputIter>::value>::type * = 0);
    template <class _ForwardIterator>
    iterator insert(const_iterator __p, _ForwardIterator __f, _ForwardIterator __l,
                    typename enable_if<__is_exactly_cpp17_forward_iterator<_ForwardIterator>::value>::type * = 0);
    template <class _BiIter>
    iterator insert(const_iterator __p, _BiIter __f, _BiIter __l,
                    typename enable_if<__is_cpp17_bidirectional_iterator<_BiIter>::value>::type * = 0);
    void pop_front();
    void pop_back();
    iterator erase(const_iterator __p);
    iterator erase(const_iterator __f, const_iterator __l);

    void swap(deque &__c);

    void clear() throw();

    bool __invariants() const { return __base::__invariants(); }
    typedef typename __base::__map_const_pointer __map_const_pointer;

    static size_type __recommend_blocks(size_type __n)
    {
return __n / __base::__block_size + (__n % __base::__block_size != 0);
    }

    size_type __capacity() const
    {
return __base::__map_.size() == 0 ? 0 : __base::__map_.size() * __base::__block_size - 1;
    }

    size_type __block_count() const
    {
return __base::__map_.size();
    }

    size_type __front_spare() const
    {
return __base::__start_;
    }

    size_type __front_spare_blocks() const
    {
return __front_spare() / __base::__block_size;
    }

    size_type __back_spare() const
    {
return __capacity() - (__base::__start_ + __base::size());
    }

    size_type __back_spare_blocks() const
    {
return __back_spare() / __base::__block_size;
    }

private:
    bool __maybe_remove_front_spare(bool __keep_one = true)
    {
if (__front_spare_blocks() >= 2 || (!__keep_one && __front_spare_blocks()))
{
        __alloc_traits::deallocate(__base::__alloc(), __base::__map_.front(),
                                   __base::__block_size);
        __base::__map_.pop_front();
        __base::__start_ -= __base::__block_size;
        return true;
}
return false;
    }

    bool __maybe_remove_back_spare(bool __keep_one = true)
    {
if (__back_spare_blocks() >= 2 || (!__keep_one && __back_spare_blocks()))
{
        __alloc_traits::deallocate(__base::__alloc(), __base::__map_.back(),
                                   __base::__block_size);
        __base::__map_.pop_back();
        return true;
}
return false;
    }
    template <class _InpIter>
    void __append(_InpIter __f, _InpIter __l,
                  typename enable_if<__is_exactly_cpp17_input_iterator<_InpIter>::value>::type * = 0);
    template <class _ForIter>
    void __append(_ForIter __f, _ForIter __l,
                  typename enable_if<__is_cpp17_forward_iterator<_ForIter>::value>::type * = 0);
    void __append(size_type __n);
    void __append(size_type __n, const value_type &__v);
    void __erase_to_end(const_iterator __f);
    void __add_front_capacity();
    void __add_front_capacity(size_type __n);
    void __add_back_capacity();
    void __add_back_capacity(size_type __n);
    iterator __move_and_check(iterator __f, iterator __l, iterator __r,
                              const_pointer &__vt);
    iterator __move_backward_and_check(iterator __f, iterator __l, iterator __r,
                                       const_pointer &__vt);
    void __move_construct_and_check(iterator __f, iterator __l,
                                    iterator __r, const_pointer &__vt);
    void __move_construct_backward_and_check(iterator __f, iterator __l,
                                             iterator __r, const_pointer &__vt);

    void __copy_assign_alloc(const deque &__c)
    {
__copy_assign_alloc(__c, integral_constant<bool,
                                           __alloc_traits::propagate_on_container_copy_assignment::value>());
    }

    void __copy_assign_alloc(const deque &__c, true_type)
    {
if (__base::__alloc() != __c.__alloc())
{
        clear();
        shrink_to_fit();
}
__base::__alloc() = __c.__alloc();
__base::__map_.__alloc() = __c.__map_.__alloc();
    }

    void __copy_assign_alloc(const deque &, false_type)
    {
    }
    void __move_assign(deque &__c, true_type);
    void __move_assign(deque &__c, false_type);
};
template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(size_type __n)
{
    if (__n > 0)
__append(__n);
}
template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(size_type __n, const value_type &__v)
{
    if (__n > 0)
__append(__n, __v);
}
template <class _Tp, class _Allocator>
template <class _InputIter>
deque<_Tp, _Allocator>::deque(_InputIter __f, _InputIter __l,
                              typename enable_if<__is_cpp17_input_iterator<_InputIter>::value>::type *)
{
    __append(__f, __l);
}
template <class _Tp, class _Allocator>
template <class _InputIter>
deque<_Tp, _Allocator>::deque(_InputIter __f, _InputIter __l, const allocator_type &__a,
                              typename enable_if<__is_cpp17_input_iterator<_InputIter>::value>::type *)
    : __base(__a)
{
    __append(__f, __l);
}
template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(const deque &__c)
    : __base(__alloc_traits::select_on_container_copy_construction(__c.__alloc()))
{
    __append(__c.begin(), __c.end());
}
template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(const deque &__c, const __type_identity_t<allocator_type> &__a)
    : __base(__a)
{
    __append(__c.begin(), __c.end());
}
template <class _Tp, class _Allocator>
deque<_Tp, _Allocator> &
deque<_Tp, _Allocator>::operator=(const deque &__c)
{
    if (this != std::addressof(__c))
    {
__copy_assign_alloc(__c);
assign(__c.begin(), __c.end());
    }
    return *this;
}
template <class _Tp, class _Allocator>
template <class _InputIter>
void deque<_Tp, _Allocator>::assign(_InputIter __f, _InputIter __l,
                                    typename enable_if<__is_cpp17_input_iterator<_InputIter>::value &&
                                                       !__is_cpp17_random_access_iterator<_InputIter>::value>::type *)
{
    iterator __i = __base::begin();
    iterator __e = __base::end();
    for (; __f != __l && __i != __e; ++__f, (void)++__i)
*__i = *__f;
    if (__f != __l)
__append(__f, __l);
    else
__erase_to_end(__i);
}
template <class _Tp, class _Allocator>
template <class _RAIter>
void deque<_Tp, _Allocator>::assign(_RAIter __f, _RAIter __l,
                                    typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type *)
{
    if (static_cast<size_type>(__l - __f) > __base::size())
    {
_RAIter __m = __f + __base::size();
std::copy(__f, __m, __base::begin());
__append(__m, __l);
    }
    else
__erase_to_end(std::copy(__f, __l, __base::begin()));
}
template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::assign(size_type __n, const value_type &__v)
{
    if (__n > __base::size())
    {
std::fill_n(__base::begin(), __base::size(), __v);
__n -= __base::size();
__append(__n, __v);
    }
    else
__erase_to_end(std::fill_n(__base::begin(), __n, __v));
}
template <class _Tp, class _Allocator>
inline _Allocator
deque<_Tp, _Allocator>::get_allocator() const throw()
{
    return __base::__alloc();
}
template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::resize(size_type __n)
{
    if (__n > __base::size())
__append(__n - __base::size());
    else if (__n < __base::size())
__erase_to_end(__base::begin() + __n);
}
template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::resize(size_type __n, const value_type &__v)
{
    if (__n > __base::size())
__append(__n - __base::size(), __v);
    else if (__n < __base::size())
__erase_to_end(__base::begin() + __n);
}
template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::shrink_to_fit() throw()
{
    allocator_type &__a = __base::__alloc();
    if (empty())
    {
while (__base::__map_.size() > 0)
{
        __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);
        __base::__map_.pop_back();
}
__base::__start_ = 0;
    }
    else
    {
__maybe_remove_front_spare(false);
__maybe_remove_back_spare(false);
    }
    __base::__map_.shrink_to_fit();
}
template <class _Tp, class _Allocator>
inline
    typename deque<_Tp, _Allocator>::reference
    deque<_Tp, _Allocator>::operator[](size_type __i) throw()
{
    size_type __p = __base::__start_ + __i;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}
template <class _Tp, class _Allocator>
inline
    typename deque<_Tp, _Allocator>::const_reference
    deque<_Tp, _Allocator>::operator[](size_type __i) const throw()
{
    size_type __p = __base::__start_ + __i;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}
template <class _Tp, class _Allocator>
inline
    typename deque<_Tp, _Allocator>::reference
    deque<_Tp, _Allocator>::at(size_type __i)
{
    if (__i >= __base::size())
std::__throw_out_of_range("deque");
    size_type __p = __base::__start_ + __i;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}
template <class _Tp, class _Allocator>
inline
    typename deque<_Tp, _Allocator>::const_reference
    deque<_Tp, _Allocator>::at(size_type __i) const
{
    if (__i >= __base::size())
std::__throw_out_of_range("deque");
    size_type __p = __base::__start_ + __i;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}
template <class _Tp, class _Allocator>
inline
    typename deque<_Tp, _Allocator>::reference
    deque<_Tp, _Allocator>::front() throw()
{
    return *(*(__base::__map_.begin() + __base::__start_ / __base::__block_size) + __base::__start_ % __base::__block_size);
}
template <class _Tp, class _Allocator>
inline
    typename deque<_Tp, _Allocator>::const_reference
    deque<_Tp, _Allocator>::front() const throw()
{
    return *(*(__base::__map_.begin() + __base::__start_ / __base::__block_size) + __base::__start_ % __base::__block_size);
}
template <class _Tp, class _Allocator>
inline
    typename deque<_Tp, _Allocator>::reference
    deque<_Tp, _Allocator>::back() throw()
{
    size_type __p = __base::size() + __base::__start_ - 1;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}
template <class _Tp, class _Allocator>
inline
    typename deque<_Tp, _Allocator>::const_reference
    deque<_Tp, _Allocator>::back() const throw()
{
    size_type __p = __base::size() + __base::__start_ - 1;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}
template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::push_back(const value_type &__v)
{
    allocator_type &__a = __base::__alloc();
    if (__back_spare() == 0)
__add_back_capacity();
    __alloc_traits::construct(__a, std::addressof(*__base::end()), __v);
    ++__base::size();
}
template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::push_front(const value_type &__v)
{
    allocator_type &__a = __base::__alloc();
    if (__front_spare() == 0)
__add_front_capacity();
    __alloc_traits::construct(__a, std::addressof(*--__base::begin()), __v);
    --__base::__start_;
    ++__base::size();
}
template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, const value_type &__v)
{
    size_type __pos = __p - __base::begin();
    size_type __to_end = __base::size() - __pos;
    allocator_type &__a = __base::__alloc();
    if (__pos < __to_end)
    {
if (__front_spare() == 0)
        __add_front_capacity();
if (__pos == 0)
{
        __alloc_traits::construct(__a, std::addressof(*--__base::begin()), __v);
        --__base::__start_;
        ++__base::size();
}
else
{
        const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
        iterator __b = __base::begin();
        iterator __bm1 = std::prev(__b);
        if (__vt == pointer_traits<const_pointer>::pointer_to(*__b))
            __vt = pointer_traits<const_pointer>::pointer_to(*__bm1);
        __alloc_traits::construct(__a, std::addressof(*__bm1), std::move(*__b));
        --__base::__start_;
        ++__base::size();
        if (__pos > 1)
            __b = __move_and_check(std::next(__b), __b + __pos, __b, __vt);
        *__b = *__vt;
}
    }
    else
    {
if (__back_spare() == 0)
        __add_back_capacity();
size_type __de = __base::size() - __pos;
if (__de == 0)
{
        __alloc_traits::construct(__a, std::addressof(*__base::end()), __v);
        ++__base::size();
}
else
{
        const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
        iterator __e = __base::end();
        iterator __em1 = std::prev(__e);
        if (__vt == pointer_traits<const_pointer>::pointer_to(*__em1))
            __vt = pointer_traits<const_pointer>::pointer_to(*__e);
        __alloc_traits::construct(__a, std::addressof(*__e), std::move(*__em1));
        ++__base::size();
        if (__de > 1)
            __e = __move_backward_and_check(__e - __de, __em1, __e, __vt);
        *--__e = *__vt;
}
    }
    return __base::begin() + __pos;
}
template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, size_type __n, const value_type &__v)
{
    size_type __pos = __p - __base::begin();
    size_type __to_end = __base::size() - __pos;
    allocator_type &__a = __base::__alloc();
    if (__pos < __to_end)
    {
if (__n > __front_spare())
        __add_front_capacity(__n - __front_spare());
iterator __old_begin = __base::begin();
iterator __i = __old_begin;
if (__n > __pos)
{
        for (size_type __m = __n - __pos; __m; --__m, --__base::__start_, ++__base::size())
            __alloc_traits::construct(__a, std::addressof(*--__i), __v);
        __n = __pos;
}
if (__n > 0)
{
        const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
        iterator __obn = __old_begin + __n;
        __move_construct_backward_and_check(__old_begin, __obn, __i, __vt);
        if (__n < __pos)
            __old_begin = __move_and_check(__obn, __old_begin + __pos, __old_begin, __vt);
        std::fill_n(__old_begin, __n, *__vt);
}
    }
    else
    {
size_type __back_capacity = __back_spare();
if (__n > __back_capacity)
        __add_back_capacity(__n - __back_capacity);
iterator __old_end = __base::end();
iterator __i = __old_end;
size_type __de = __base::size() - __pos;
if (__n > __de)
{
        for (size_type __m = __n - __de; __m; --__m, (void)++__i, ++__base::size())
            __alloc_traits::construct(__a, std::addressof(*__i), __v);
        __n = __de;
}
if (__n > 0)
{
        const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
        iterator __oen = __old_end - __n;
        __move_construct_and_check(__oen, __old_end, __i, __vt);
        if (__n < __de)
            __old_end = __move_backward_and_check(__old_end - __de, __oen, __old_end, __vt);
        std::fill_n(__old_end - __n, __n, *__vt);
}
    }
    return __base::begin() + __pos;
}
template <class _Tp, class _Allocator>
template <class _InputIter>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, _InputIter __f, _InputIter __l,
                               typename enable_if<__is_exactly_cpp17_input_iterator<_InputIter>::value>::type *)
{
    __split_buffer<value_type, allocator_type &> __buf(__base::__alloc());
    __buf.__construct_at_end(__f, __l);
    typedef typename __split_buffer<value_type, allocator_type &>::iterator __bi;
    return insert(__p, move_iterator<__bi>(__buf.begin()), move_iterator<__bi>(__buf.end()));
}
template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, _ForwardIterator __f, _ForwardIterator __l,
                               typename enable_if<__is_exactly_cpp17_forward_iterator<_ForwardIterator>::value>::type *)
{
    size_type __n = std::distance(__f, __l);
    __split_buffer<value_type, allocator_type &> __buf(__n, 0, __base::__alloc());
    __buf.__construct_at_end(__f, __l);
    typedef typename __split_buffer<value_type, allocator_type &>::iterator __fwd;
    return insert(__p, move_iterator<__fwd>(__buf.begin()), move_iterator<__fwd>(__buf.end()));
}
template <class _Tp, class _Allocator>
template <class _BiIter>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, _BiIter __f, _BiIter __l,
                               typename enable_if<__is_cpp17_bidirectional_iterator<_BiIter>::value>::type *)
{
    size_type __n = std::distance(__f, __l);
    size_type __pos = __p - __base::begin();
    size_type __to_end = __base::size() - __pos;
    allocator_type &__a = __base::__alloc();
    if (__pos < __to_end)
    {
if (__n > __front_spare())
        __add_front_capacity(__n - __front_spare());
iterator __old_begin = __base::begin();
iterator __i = __old_begin;
_BiIter __m = __f;
if (__n > __pos)
{
        __m = __pos < __n / 2 ? std::prev(__l, __pos) : std::next(__f, __n - __pos);
        for (_BiIter __j = __m; __j != __f; --__base::__start_, ++__base::size())
            __alloc_traits::construct(__a, std::addressof(*--__i), *--__j);
        __n = __pos;
}
if (__n > 0)
{
        iterator __obn = __old_begin + __n;
        for (iterator __j = __obn; __j != __old_begin;)
        {
            __alloc_traits::construct(__a, std::addressof(*--__i), std::move(*--__j));
            --__base::__start_;
            ++__base::size();
        }
        if (__n < __pos)
            __old_begin = std::move(__obn, __old_begin + __pos, __old_begin);
        std::copy(__m, __l, __old_begin);
}
    }
    else
    {
size_type __back_capacity = __back_spare();
if (__n > __back_capacity)
        __add_back_capacity(__n - __back_capacity);
iterator __old_end = __base::end();
iterator __i = __old_end;
_BiIter __m = __l;
size_type __de = __base::size() - __pos;
if (__n > __de)
{
        __m = __de < __n / 2 ? std::next(__f, __de) : std::prev(__l, __n - __de);
        for (_BiIter __j = __m; __j != __l; ++__i, (void)++__j, ++__base::size())
            __alloc_traits::construct(__a, std::addressof(*__i), *__j);
        __n = __de;
}
if (__n > 0)
{
        iterator __oen = __old_end - __n;
        for (iterator __j = __oen; __j != __old_end; ++__i, (void)++__j, ++__base::size())
            __alloc_traits::construct(__a, std::addressof(*__i), std::move(*__j));
        if (__n < __de)
            __old_end = std::move_backward(__old_end - __de, __oen, __old_end);
        std::copy_backward(__f, __m, __old_end);
}
    }
    return __base::begin() + __pos;
}
template <class _Tp, class _Allocator>
template <class _InpIter>
void deque<_Tp, _Allocator>::__append(_InpIter __f, _InpIter __l,
                                      typename enable_if<__is_exactly_cpp17_input_iterator<_InpIter>::value>::type *)
{
    for (; __f != __l; ++__f)
push_back(*__f);
}
template <class _Tp, class _Allocator>
template <class _ForIter>
void deque<_Tp, _Allocator>::__append(_ForIter __f, _ForIter __l,
                                      typename enable_if<__is_cpp17_forward_iterator<_ForIter>::value>::type *)
{
    size_type __n = std::distance(__f, __l);
    allocator_type &__a = __base::__alloc();
    size_type __back_capacity = __back_spare();
    if (__n > __back_capacity)
__add_back_capacity(__n - __back_capacity);
    for (__deque_block_range __br : __deque_range(__base::end(), __base::end() + __n))
    {
_ConstructTransaction __tx(this, __br);
for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_, (void)++__f)
{
        __alloc_traits::construct(__a, std::__to_address(__tx.__pos_), *__f);
}
    }
}
template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__append(size_type __n)
{
    allocator_type &__a = __base::__alloc();
    size_type __back_capacity = __back_spare();
    if (__n > __back_capacity)
__add_back_capacity(__n - __back_capacity);
    for (__deque_block_range __br : __deque_range(__base::end(), __base::end() + __n))
    {
_ConstructTransaction __tx(this, __br);
for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_)
{
        __alloc_traits::construct(__a, std::__to_address(__tx.__pos_));
}
    }
}
template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__append(size_type __n, const value_type &__v)
{
    allocator_type &__a = __base::__alloc();
    size_type __back_capacity = __back_spare();
    if (__n > __back_capacity)
__add_back_capacity(__n - __back_capacity);
    for (__deque_block_range __br : __deque_range(__base::end(), __base::end() + __n))
    {
_ConstructTransaction __tx(this, __br);
for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_)
{
        __alloc_traits::construct(__a, std::__to_address(__tx.__pos_), __v);
}
    }
}
template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__add_front_capacity()
{
    allocator_type &__a = __base::__alloc();
    if (__back_spare() >= __base::__block_size)
    {
__base::__start_ += __base::__block_size;
pointer __pt = __base::__map_.back();
__base::__map_.pop_back();
__base::__map_.push_front(__pt);
    }
    else if (__base::__map_.size() < __base::__map_.capacity())
    {
if (__base::__map_.__front_spare() > 0)
        __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));
else
{
        __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));
        pointer __pt = __base::__map_.back();
        __base::__map_.pop_back();
        __base::__map_.push_front(__pt);
}
__base::__start_ = __base::__map_.size() == 1 ? __base::__block_size / 2 : __base::__start_ + __base::__block_size;
    }
    else
    {
__split_buffer<pointer, typename __base::__pointer_allocator &>
    __buf(max<size_type>(2 * __base::__map_.capacity(), 1),
          0, __base::__map_.__alloc());
typedef __allocator_destructor<_Allocator> _Dp;
unique_ptr<pointer, _Dp> __hold(
    __alloc_traits::allocate(__a, __base::__block_size),
    _Dp(__a, __base::__block_size));
__buf.push_back(__hold.get());
__hold.release();
for (typename __base::__map_pointer __i = __base::__map_.begin();
     __i != __base::__map_.end(); ++__i)
        __buf.push_back(*__i);
std::swap(__base::__map_.__first_, __buf.__first_);
std::swap(__base::__map_.__begin_, __buf.__begin_);
std::swap(__base::__map_.__end_, __buf.__end_);
std::swap(__base::__map_.__end_cap(), __buf.__end_cap());
__base::__start_ = __base::__map_.size() == 1 ? __base::__block_size / 2 : __base::__start_ + __base::__block_size;
    }
}
template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__add_front_capacity(size_type __n)
{
    allocator_type &__a = __base::__alloc();
    size_type __nb = __recommend_blocks(__n + __base::__map_.empty());
    size_type __back_capacity = __back_spare() / __base::__block_size;
    __back_capacity = std::min(__back_capacity, __nb);
    __nb -= __back_capacity;
    if (__nb == 0)
    {
__base::__start_ += __base::__block_size * __back_capacity;
for (; __back_capacity > 0; --__back_capacity)
{
        pointer __pt = __base::__map_.back();
        __base::__map_.pop_back();
        __base::__map_.push_front(__pt);
}
    }
    else if (__nb <= __base::__map_.capacity() - __base::__map_.size())
    {
for (; __nb > 0; --__nb, __base::__start_ += __base::__block_size - (__base::__map_.size() == 1))
{
        if (__base::__map_.__front_spare() == 0)
            break;
        __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));
}
for (; __nb > 0; --__nb, ++__back_capacity)
        __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));
__base::__start_ += __back_capacity * __base::__block_size;
for (; __back_capacity > 0; --__back_capacity)
{
        pointer __pt = __base::__map_.back();
        __base::__map_.pop_back();
        __base::__map_.push_front(__pt);
}
    }
    else
    {
size_type __ds = (__nb + __back_capacity) * __base::__block_size - __base::__map_.empty();
__split_buffer<pointer, typename __base::__pointer_allocator &>
    __buf(max<size_type>(2 * __base::__map_.capacity(),
                         __nb + __base::__map_.size()),
          0, __base::__map_.__alloc());
try
{
        for (; __nb > 0; --__nb)
            __buf.push_back(__alloc_traits::allocate(__a, __base::__block_size));
}
catch (...)
{
        for (typename __base::__map_pointer __i = __buf.begin();
             __i != __buf.end(); ++__i)
            __alloc_traits::deallocate(__a, *__i, __base::__block_size);
        throw;
}
for (; __back_capacity > 0; --__back_capacity)
{
        __buf.push_back(__base::__map_.back());
        __base::__map_.pop_back();
}
for (typename __base::__map_pointer __i = __base::__map_.begin();
     __i != __base::__map_.end(); ++__i)
        __buf.push_back(*__i);
std::swap(__base::__map_.__first_, __buf.__first_);
std::swap(__base::__map_.__begin_, __buf.__begin_);
std::swap(__base::__map_.__end_, __buf.__end_);
std::swap(__base::__map_.__end_cap(), __buf.__end_cap());
__base::__start_ += __ds;
    }
}
template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__add_back_capacity()
{
    allocator_type &__a = __base::__alloc();
    if (__front_spare() >= __base::__block_size)
    {
__base::__start_ -= __base::__block_size;
pointer __pt = __base::__map_.front();
__base::__map_.pop_front();
__base::__map_.push_back(__pt);
    }
    else if (__base::__map_.size() < __base::__map_.capacity())
    {
if (__base::__map_.__back_spare() != 0)
        __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));
else
{
        __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));
        pointer __pt = __base::__map_.front();
        __base::__map_.pop_front();
        __base::__map_.push_back(__pt);
}
    }
    else
    {
__split_buffer<pointer, typename __base::__pointer_allocator &>
    __buf(max<size_type>(2 * __base::__map_.capacity(), 1),
          __base::__map_.size(),
          __base::__map_.__alloc());
typedef __allocator_destructor<_Allocator> _Dp;
unique_ptr<pointer, _Dp> __hold(
    __alloc_traits::allocate(__a, __base::__block_size),
    _Dp(__a, __base::__block_size));
__buf.push_back(__hold.get());
__hold.release();
for (typename __base::__map_pointer __i = __base::__map_.end();
     __i != __base::__map_.begin();)
        __buf.push_front(*--__i);
std::swap(__base::__map_.__first_, __buf.__first_);
std::swap(__base::__map_.__begin_, __buf.__begin_);
std::swap(__base::__map_.__end_, __buf.__end_);
std::swap(__base::__map_.__end_cap(), __buf.__end_cap());
    }
}
template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__add_back_capacity(size_type __n)
{
    allocator_type &__a = __base::__alloc();
    size_type __nb = __recommend_blocks(__n + __base::__map_.empty());
    size_type __front_capacity = __front_spare() / __base::__block_size;
    __front_capacity = std::min(__front_capacity, __nb);
    __nb -= __front_capacity;
    if (__nb == 0)
    {
__base::__start_ -= __base::__block_size * __front_capacity;
for (; __front_capacity > 0; --__front_capacity)
{
        pointer __pt = __base::__map_.front();
        __base::__map_.pop_front();
        __base::__map_.push_back(__pt);
}
    }
    else if (__nb <= __base::__map_.capacity() - __base::__map_.size())
    {
for (; __nb > 0; --__nb)
{
        if (__base::__map_.__back_spare() == 0)
            break;
        __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));
}
for (; __nb > 0; --__nb, ++__front_capacity, __base::__start_ += __base::__block_size - (__base::__map_.size() == 1))
        __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));
__base::__start_ -= __base::__block_size * __front_capacity;
for (; __front_capacity > 0; --__front_capacity)
{
        pointer __pt = __base::__map_.front();
        __base::__map_.pop_front();
        __base::__map_.push_back(__pt);
}
    }
    else
    {
size_type __ds = __front_capacity * __base::__block_size;
__split_buffer<pointer, typename __base::__pointer_allocator &>
    __buf(max<size_type>(2 * __base::__map_.capacity(),
                         __nb + __base::__map_.size()),
          __base::__map_.size() - __front_capacity,
          __base::__map_.__alloc());
try
{
        for (; __nb > 0; --__nb)
            __buf.push_back(__alloc_traits::allocate(__a, __base::__block_size));
}
catch (...)
{
        for (typename __base::__map_pointer __i = __buf.begin();
             __i != __buf.end(); ++__i)
            __alloc_traits::deallocate(__a, *__i, __base::__block_size);
        throw;
}
for (; __front_capacity > 0; --__front_capacity)
{
        __buf.push_back(__base::__map_.front());
        __base::__map_.pop_front();
}
for (typename __base::__map_pointer __i = __base::__map_.end();
     __i != __base::__map_.begin();)
        __buf.push_front(*--__i);
std::swap(__base::__map_.__first_, __buf.__first_);
std::swap(__base::__map_.__begin_, __buf.__begin_);
std::swap(__base::__map_.__end_, __buf.__end_);
std::swap(__base::__map_.__end_cap(), __buf.__end_cap());
__base::__start_ -= __ds;
    }
}
template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::pop_front()
{
    allocator_type &__a = __base::__alloc();
    __alloc_traits::destroy(__a, std::__to_address(*(__base::__map_.begin() +
                                                     __base::__start_ / __base::__block_size) +
                                                   __base::__start_ % __base::__block_size));
    --__base::size();
    ++__base::__start_;
    __maybe_remove_front_spare();
}
template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::pop_back()
{
    ((void)0);
    allocator_type &__a = __base::__alloc();
    size_type __p = __base::size() + __base::__start_ - 1;
    __alloc_traits::destroy(__a, std::__to_address(*(__base::__map_.begin() +
                                                     __p / __base::__block_size) +
                                                   __p % __base::__block_size));
    --__base::size();
    __maybe_remove_back_spare();
}
template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::__move_and_check(iterator __f, iterator __l, iterator __r,
                                         const_pointer &__vt)
{
    difference_type __n = __l - __f;
    while (__n > 0)
    {
pointer __fb = __f.__ptr_;
pointer __fe = *__f.__m_iter_ + __base::__block_size;
difference_type __bs = __fe - __fb;
if (__bs > __n)
{
        __bs = __n;
        __fe = __fb + __bs;
}
if (__fb <= __vt && __vt < __fe)
        __vt = (const_iterator(static_cast<__map_const_pointer>(__f.__m_iter_), __vt) -= __f - __r).__ptr_;
__r = std::move(__fb, __fe, __r);
__n -= __bs;
__f += __bs;
    }
    return __r;
}
template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::__move_backward_and_check(iterator __f, iterator __l, iterator __r,
                                                  const_pointer &__vt)
{
    difference_type __n = __l - __f;
    while (__n > 0)
    {
--__l;
pointer __lb = *__l.__m_iter_;
pointer __le = __l.__ptr_ + 1;
difference_type __bs = __le - __lb;
if (__bs > __n)
{
        __bs = __n;
        __lb = __le - __bs;
}
if (__lb <= __vt && __vt < __le)
        __vt = (const_iterator(static_cast<__map_const_pointer>(__l.__m_iter_), __vt) += __r - __l - 1).__ptr_;
__r = std::move_backward(__lb, __le, __r);
__n -= __bs;
__l -= __bs - 1;
    }
    return __r;
}
template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__move_construct_and_check(iterator __f, iterator __l,
                                                        iterator __r, const_pointer &__vt)
{
    allocator_type &__a = __base::__alloc();
    difference_type __n = __l - __f;
    while (__n > 0)
    {
pointer __fb = __f.__ptr_;
pointer __fe = *__f.__m_iter_ + __base::__block_size;
difference_type __bs = __fe - __fb;
if (__bs > __n)
{
        __bs = __n;
        __fe = __fb + __bs;
}
if (__fb <= __vt && __vt < __fe)
        __vt = (const_iterator(static_cast<__map_const_pointer>(__f.__m_iter_), __vt) += __r - __f).__ptr_;
for (; __fb != __fe; ++__fb, ++__r, ++__base::size())
        __alloc_traits::construct(__a, std::addressof(*__r), std::move(*__fb));
__n -= __bs;
__f += __bs;
    }
}
template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__move_construct_backward_and_check(iterator __f, iterator __l,
                                                                 iterator __r, const_pointer &__vt)
{
    allocator_type &__a = __base::__alloc();
    difference_type __n = __l - __f;
    while (__n > 0)
    {
--__l;
pointer __lb = *__l.__m_iter_;
pointer __le = __l.__ptr_ + 1;
difference_type __bs = __le - __lb;
if (__bs > __n)
{
        __bs = __n;
        __lb = __le - __bs;
}
if (__lb <= __vt && __vt < __le)
        __vt = (const_iterator(static_cast<__map_const_pointer>(__l.__m_iter_), __vt) -= __l - __r + 1).__ptr_;
while (__le != __lb)
{
        __alloc_traits::construct(__a, std::addressof(*--__r), std::move(*--__le));
        --__base::__start_;
        ++__base::size();
}
__n -= __bs;
__l -= __bs - 1;
    }
}
template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::erase(const_iterator __f)
{
    iterator __b = __base::begin();
    difference_type __pos = __f - __b;
    iterator __p = __b + __pos;
    allocator_type &__a = __base::__alloc();
    if (static_cast<size_t>(__pos) <= (__base::size() - 1) / 2)
    {
std::move_backward(__b, __p, std::next(__p));
__alloc_traits::destroy(__a, std::addressof(*__b));
--__base::size();
++__base::__start_;
__maybe_remove_front_spare();
    }
    else
    {
iterator __i = std::move(std::next(__p), __base::end(), __p);
__alloc_traits::destroy(__a, std::addressof(*__i));
--__base::size();
__maybe_remove_back_spare();
    }
    return __base::begin() + __pos;
}
template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::erase(const_iterator __f, const_iterator __l)
{
    difference_type __n = __l - __f;
    iterator __b = __base::begin();
    difference_type __pos = __f - __b;
    iterator __p = __b + __pos;
    if (__n > 0)
    {
allocator_type &__a = __base::__alloc();
if (static_cast<size_t>(__pos) <= (__base::size() - __n) / 2)
{
        iterator __i = std::move_backward(__b, __p, __p + __n);
        for (; __b != __i; ++__b)
            __alloc_traits::destroy(__a, std::addressof(*__b));
        __base::size() -= __n;
        __base::__start_ += __n;
        while (__maybe_remove_front_spare())
        {
        }
}
else
{
        iterator __i = std::move(__p + __n, __base::end(), __p);
        for (iterator __e = __base::end(); __i != __e; ++__i)
            __alloc_traits::destroy(__a, std::addressof(*__i));
        __base::size() -= __n;
        while (__maybe_remove_back_spare())
        {
        }
}
    }
    return __base::begin() + __pos;
}
template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__erase_to_end(const_iterator __f)
{
    iterator __e = __base::end();
    difference_type __n = __e - __f;
    if (__n > 0)
    {
allocator_type &__a = __base::__alloc();
iterator __b = __base::begin();
difference_type __pos = __f - __b;
for (iterator __p = __b + __pos; __p != __e; ++__p)
        __alloc_traits::destroy(__a, std::addressof(*__p));
__base::size() -= __n;
while (__maybe_remove_back_spare())
{
}
    }
}
template <class _Tp, class _Allocator>
inline void
deque<_Tp, _Allocator>::swap(deque &__c)
{
    __base::swap(__c);
}
template <class _Tp, class _Allocator>
inline void
deque<_Tp, _Allocator>::clear() throw()
{
    __base::clear();
}
template <class _Tp, class _Allocator>
inline bool
operator==(const deque<_Tp, _Allocator> &__x, const deque<_Tp, _Allocator> &__y)
{
    const typename deque<_Tp, _Allocator>::size_type __sz = __x.size();
    return __sz == __y.size() && std::equal(__x.begin(), __x.end(), __y.begin());
}
template <class _Tp, class _Allocator>
inline bool
operator!=(const deque<_Tp, _Allocator> &__x, const deque<_Tp, _Allocator> &__y)
{
    return !(__x == __y);
}
template <class _Tp, class _Allocator>
inline bool
operator<(const deque<_Tp, _Allocator> &__x, const deque<_Tp, _Allocator> &__y)
{
    return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}
template <class _Tp, class _Allocator>
inline bool
operator>(const deque<_Tp, _Allocator> &__x, const deque<_Tp, _Allocator> &__y)
{
    return __y < __x;
}
template <class _Tp, class _Allocator>
inline bool
operator>=(const deque<_Tp, _Allocator> &__x, const deque<_Tp, _Allocator> &__y)
{
    return !(__x < __y);
}
template <class _Tp, class _Allocator>
inline bool
operator<=(const deque<_Tp, _Allocator> &__x, const deque<_Tp, _Allocator> &__y)
{
    return !(__y < __x);
}
template <class _Tp, class _Allocator>
inline void
swap(deque<_Tp, _Allocator> &__x, deque<_Tp, _Allocator> &__y)
{
    __x.swap(__y);
}
}
}
namespace boost
{
    template <typename IteratorT, typename Elem, typename Traits>
    inline std::basic_ostream<Elem, Traits> &operator<<(
        std::basic_ostream<Elem, Traits> &Os,
        const iterator_range<IteratorT> &r)
    {
std::copy(r.begin(), r.end(),
          std::ostream_iterator<typename iterator_value<IteratorT>::type,
                                Elem, Traits>(Os));
return Os;
    }
}
namespace boost
{
    template <class T>
    struct range_mutable_iterator<T *>
    {
typedef T *type;
    };
    template <class T>
    struct range_const_iterator<T *>
    {
typedef const T *type;
    };
    template <class T>
    struct range_size<T *>
    {
typedef std::size_t type;
    };
}
namespace boost
{
    namespace range_detail
    {
inline std::size_t length(const char *s)
{
        return strlen(s);
}
inline std::size_t length(const wchar_t *s)
{
        return wcslen(s);
}
inline bool is_char_ptr(char *)
{
        return true;
}
inline bool is_char_ptr(const char *)
{
        return true;
}
inline bool is_char_ptr(wchar_t *)
{
        return true;
}
inline bool is_char_ptr(const wchar_t *)
{
        return true;
}
template <class T>
inline long is_char_ptr(const T &)
{
        return 0L;
}
template <class T>
inline iterator_range<T *>
make_range(T *const r, bool)
{
        return iterator_range<T *>(r, r + length(r));
}
template <class T>
inline iterator_range<typename range_iterator<T>::type>
make_range(T &r, long)
{
        return boost::make_iterator_range(r);
}
    }
    template <class Range>
    inline iterator_range<typename range_iterator<Range>::type>
    as_literal(Range &r)
    {
return range_detail::make_range(r, range_detail::is_char_ptr(r));
    }
    template <class Range>
    inline iterator_range<typename range_iterator<const Range>::type>
    as_literal(const Range &r)
    {
return range_detail::make_range(r, range_detail::is_char_ptr(r));
    }
    template <class Char, std::size_t sz>
    inline iterator_range<Char *> as_literal(Char (&arr)[sz])
    {
return range_detail::make_range(arr, range_detail::is_char_ptr(arr));
    }
    template <class Char, std::size_t sz>
    inline iterator_range<const Char *> as_literal(const Char (&arr)[sz])
    {
return range_detail::make_range(arr, range_detail::is_char_ptr(arr));
    }
}

namespace boost
{
    namespace algorithm
    {
template <typename FinderT, typename IteratorT>
struct FinderConcept
{
    private:
        typedef iterator_range<IteratorT> range;

    public:
        void constraints()
        {
            r = (*pF)(i, i);
        }

    private:
        range r;
        IteratorT i;
        FinderT *pF;
};
template <typename FormatterT, typename FinderT, typename IteratorT>
struct FormatterConcept
{
    public:
        void constraints()
        {
            ::boost::begin((*pFo)((*pF)(i, i)));
            ::boost::end((*pFo)((*pF)(i, i)));
        }

    private:
        IteratorT i;
        FinderT *pF;
        FormatterT *pFo;
};
    }
}
namespace boost
{
    namespace algorithm
    {
namespace detail
{
        template <
            typename ForwardIteratorT,
            typename FormatterT,
            typename FormatResultT>
        class find_format_store : public iterator_range<ForwardIteratorT>
        {
        public:
            typedef iterator_range<ForwardIteratorT> base_type;
            typedef FormatterT formatter_type;
            typedef FormatResultT format_result_type;

        public:
            find_format_store(
                const base_type &FindResult,
                const format_result_type &FormatResult,
                const formatter_type &Formatter) : base_type(FindResult),
                                                   m_FormatResult(FormatResult),
                                                   m_Formatter(Formatter) {}
            template <typename FindResultT>
            find_format_store &operator=(FindResultT FindResult)
            {
                iterator_range<ForwardIteratorT>::operator=(FindResult);
                if (!this->empty())
                {
                    m_FormatResult = m_Formatter(FindResult);
                }
                return *this;
            }
            const format_result_type &format_result()
            {
                return m_FormatResult;
            }

        private:
            format_result_type m_FormatResult;
            const formatter_type &m_Formatter;
        };
        template <typename InputT, typename FindResultT>
        bool check_find_result(InputT &, FindResultT &FindResult)
        {
            typedef typename range_const_iterator<InputT>::type input_iterator_type;
            iterator_range<input_iterator_type> ResultRange(FindResult);
            return !ResultRange.empty();
        }
}
    }
}
namespace boost
{
    namespace algorithm
    {
template <int I>
struct size_descriptor
{
        typedef char (&type)[I];
};
typedef size_descriptor<1>::type yes_type;
typedef size_descriptor<2>::type no_type;
    }
}
namespace boost
{
    namespace algorithm
    {
template <typename T>
class has_native_replace
{
    public:
        static const bool value = false;
        typedef mpl::bool_<has_native_replace<T>::value> type;
};
template <typename T>
class has_stable_iterators
{
    public:
        static const bool value = false;
        typedef mpl::bool_<has_stable_iterators<T>::value> type;
};
template <typename T>
class has_const_time_insert
{
    public:
        static const bool value = false;
        typedef mpl::bool_<has_const_time_insert<T>::value> type;
};
template <typename T>
class has_const_time_erase
{
    public:
        static const bool value = false;
        typedef mpl::bool_<has_const_time_erase<T>::value> type;
};
    }
}
namespace boost
{
    namespace algorithm
    {
namespace detail
{
        template <typename InputT, typename ForwardIteratorT>
        inline void insert(
            InputT &Input,
            typename InputT::iterator At,
            ForwardIteratorT Begin,
            ForwardIteratorT End)
        {
            Input.insert(At, Begin, End);
        }
        template <typename InputT, typename InsertT>
        inline void insert(
            InputT &Input,
            typename InputT::iterator At,
            const InsertT &Insert)
        {
            ::boost::algorithm::detail::insert(Input, At, ::boost::begin(Insert), ::boost::end(Insert));
        }
        template <typename InputT>
        inline typename InputT::iterator erase(
            InputT &Input,
            typename InputT::iterator From,
            typename InputT::iterator To)
        {
            return Input.erase(From, To);
        }
        template <bool HasConstTimeOperations>
        struct replace_const_time_helper
        {
            template <typename InputT, typename ForwardIteratorT>
            void operator()(
                InputT &Input,
                typename InputT::iterator From,
                typename InputT::iterator To,
                ForwardIteratorT Begin,
                ForwardIteratorT End)
            {
                ForwardIteratorT InsertIt = Begin;
                typename InputT::iterator InputIt = From;
                for (; InsertIt != End && InputIt != To; InsertIt++, InputIt++)
                {
                    *InputIt = *InsertIt;
                }
                if (InsertIt != End)
                {
                    Input.insert(InputIt, InsertIt, End);
                }
                else
                {
                    if (InputIt != To)
                    {
                        Input.erase(InputIt, To);
                    }
                }
            }
        };
        template <>
        struct replace_const_time_helper<true>
        {
            template <typename InputT, typename ForwardIteratorT>
            void operator()(
                InputT &Input,
                typename InputT::iterator From,
                typename InputT::iterator To,
                ForwardIteratorT Begin,
                ForwardIteratorT End)
            {
                typename InputT::iterator At = Input.erase(From, To);
                if (Begin != End)
                {
                    if (!Input.empty())
                    {
                        Input.insert(At, Begin, End);
                    }
                    else
                    {
                        Input.insert(Input.begin(), Begin, End);
                    }
                }
            }
        };
        template <bool HasNative>
        struct replace_native_helper
        {
            template <typename InputT, typename ForwardIteratorT>
            void operator()(
                InputT &Input,
                typename InputT::iterator From,
                typename InputT::iterator To,
                ForwardIteratorT Begin,
                ForwardIteratorT End)
            {
                replace_const_time_helper<
                    boost::mpl::and_<
                        has_const_time_insert<InputT>,
                        has_const_time_erase<InputT>>::value>()(
                    Input, From, To, Begin, End);
            }
        };
        template <>
        struct replace_native_helper<true>
        {
            template <typename InputT, typename ForwardIteratorT>
            void operator()(
                InputT &Input,
                typename InputT::iterator From,
                typename InputT::iterator To,
                ForwardIteratorT Begin,
                ForwardIteratorT End)
            {
                Input.replace(From, To, Begin, End);
            }
        };
        template <typename InputT, typename ForwardIteratorT>
        inline void replace(
            InputT &Input,
            typename InputT::iterator From,
            typename InputT::iterator To,
            ForwardIteratorT Begin,
            ForwardIteratorT End)
        {
            replace_native_helper<has_native_replace<InputT>::value>()(
                Input, From, To, Begin, End);
        }
        template <typename InputT, typename InsertT>
        inline void replace(
            InputT &Input,
            typename InputT::iterator From,
            typename InputT::iterator To,
            const InsertT &Insert)
        {
            if (From != To)
            {
                ::boost::algorithm::detail::replace(Input, From, To, ::boost::begin(Insert), ::boost::end(Insert));
            }
            else
            {
                ::boost::algorithm::detail::insert(Input, From, ::boost::begin(Insert), ::boost::end(Insert));
            }
        }
}
    }
}

namespace boost
{
    namespace algorithm
    {
namespace detail
{
        template <typename StorageT, typename OutputIteratorT>
        inline OutputIteratorT move_from_storage(
            StorageT &Storage,
            OutputIteratorT DestBegin,
            OutputIteratorT DestEnd)
        {
            OutputIteratorT OutputIt = DestBegin;
            while (!Storage.empty() && OutputIt != DestEnd)
            {
                *OutputIt = Storage.front();
                Storage.pop_front();
                ++OutputIt;
            }
            return OutputIt;
        }
        template <typename StorageT, typename WhatT>
        inline void copy_to_storage(
            StorageT &Storage,
            const WhatT &What)
        {
            Storage.insert(Storage.end(), ::boost::begin(What), ::boost::end(What));
        }
        template <bool HasStableIterators>
        struct process_segment_helper
        {
            template <
                typename StorageT,
                typename InputT,
                typename ForwardIteratorT>
            ForwardIteratorT operator()(
                StorageT &Storage,
                InputT &,
                ForwardIteratorT InsertIt,
                ForwardIteratorT SegmentBegin,
                ForwardIteratorT SegmentEnd)
            {
                ForwardIteratorT It = ::boost::algorithm::detail::move_from_storage(Storage, InsertIt, SegmentBegin);
                if (Storage.empty())
                {
                    if (It == SegmentBegin)
                    {
                        return SegmentEnd;
                    }
                    else
                    {
                        return std::copy(SegmentBegin, SegmentEnd, It);
                    }
                }
                else
                {
                    while (It != SegmentEnd)
                    {
                        Storage.push_back(*It);
                        *It = Storage.front();
                        Storage.pop_front();
                        ++It;
                    }
                    return It;
                }
            }
        };
        template <>
        struct process_segment_helper<true>
        {
            template <
                typename StorageT,
                typename InputT,
                typename ForwardIteratorT>
            ForwardIteratorT operator()(
                StorageT &Storage,
                InputT &Input,
                ForwardIteratorT InsertIt,
                ForwardIteratorT SegmentBegin,
                ForwardIteratorT SegmentEnd)
            {
                ::boost::algorithm::detail::replace(Input, InsertIt, SegmentBegin, Storage);
                Storage.clear();
                return SegmentEnd;
            }
        };
        template <
            typename StorageT,
            typename InputT,
            typename ForwardIteratorT>
        inline ForwardIteratorT process_segment(
            StorageT &Storage,
            InputT &Input,
            ForwardIteratorT InsertIt,
            ForwardIteratorT SegmentBegin,
            ForwardIteratorT SegmentEnd)
        {
            return process_segment_helper<
                has_stable_iterators<InputT>::value>()(
                Storage, Input, InsertIt, SegmentBegin, SegmentEnd);
        }
}
    }
}

namespace boost
{
    namespace algorithm
    {
namespace detail
{
        template <
            typename OutputIteratorT,
            typename InputT,
            typename FormatterT,
            typename FindResultT,
            typename FormatResultT>
        inline OutputIteratorT find_format_copy_impl2(
            OutputIteratorT Output,
            const InputT &Input,
            FormatterT Formatter,
            const FindResultT &FindResult,
            const FormatResultT &FormatResult)
        {
            typedef find_format_store<
                typename range_const_iterator<InputT>::type,
                FormatterT,
                FormatResultT>
                store_type;
            store_type M(FindResult, FormatResult, Formatter);
            if (!M)
            {
                Output = std::copy(::boost::begin(Input), ::boost::end(Input), Output);
                return Output;
            }
            Output = std::copy(::boost::begin(Input), ::boost::begin(M), Output);
            Output = std::copy(::boost::begin(M.format_result()), ::boost::end(M.format_result()), Output);
            Output = std::copy(M.end(), ::boost::end(Input), Output);
            return Output;
        }
        template <
            typename OutputIteratorT,
            typename InputT,
            typename FormatterT,
            typename FindResultT>
        inline OutputIteratorT find_format_copy_impl(
            OutputIteratorT Output,
            const InputT &Input,
            FormatterT Formatter,
            const FindResultT &FindResult)
        {
            if (::boost::algorithm::detail::check_find_result(Input, FindResult))
            {
                return ::boost::algorithm::detail::find_format_copy_impl2(
                    Output,
                    Input,
                    Formatter,
                    FindResult,
                    Formatter(FindResult));
            }
            else
            {
                return std::copy(::boost::begin(Input), ::boost::end(Input), Output);
            }
        }
        template <
            typename InputT,
            typename FormatterT,
            typename FindResultT,
            typename FormatResultT>
        inline InputT find_format_copy_impl2(
            const InputT &Input,
            FormatterT Formatter,
            const FindResultT &FindResult,
            const FormatResultT &FormatResult)
        {
            typedef find_format_store<
                typename range_const_iterator<InputT>::type,
                FormatterT,
                FormatResultT>
                store_type;
            store_type M(FindResult, FormatResult, Formatter);
            if (!M)
            {
                return InputT(Input);
            }
            InputT Output;
            boost::algorithm::detail::insert(Output, ::boost::end(Output), ::boost::begin(Input), M.begin());
            boost::algorithm::detail::insert(Output, ::boost::end(Output), M.format_result());
            boost::algorithm::detail::insert(Output, ::boost::end(Output), M.end(), ::boost::end(Input));
            return Output;
        }
        template <
            typename InputT,
            typename FormatterT,
            typename FindResultT>
        inline InputT find_format_copy_impl(
            const InputT &Input,
            FormatterT Formatter,
            const FindResultT &FindResult)
        {
            if (::boost::algorithm::detail::check_find_result(Input, FindResult))
            {
                return ::boost::algorithm::detail::find_format_copy_impl2(
                    Input,
                    Formatter,
                    FindResult,
                    Formatter(FindResult));
            }
            else
            {
                return Input;
            }
        }
        template <
            typename InputT,
            typename FormatterT,
            typename FindResultT,
            typename FormatResultT>
        inline void find_format_impl2(
            InputT &Input,
            FormatterT Formatter,
            const FindResultT &FindResult,
            const FormatResultT &FormatResult)
        {
            typedef find_format_store<
                typename range_iterator<InputT>::type,
                FormatterT,
                FormatResultT>
                store_type;
            store_type M(FindResult, FormatResult, Formatter);
            if (!M)
            {
                return;
            }
            ::boost::algorithm::detail::replace(Input, M.begin(), M.end(), M.format_result());
        }
        template <
            typename InputT,
            typename FormatterT,
            typename FindResultT>
        inline void find_format_impl(
            InputT &Input,
            FormatterT Formatter,
            const FindResultT &FindResult)
        {
            if (::boost::algorithm::detail::check_find_result(Input, FindResult))
            {
                ::boost::algorithm::detail::find_format_impl2(
                    Input,
                    Formatter,
                    FindResult,
                    Formatter(FindResult));
            }
        }
}
    }
}
namespace boost
{
    namespace algorithm
    {
namespace detail
{
        template <
            typename OutputIteratorT,
            typename InputT,
            typename FinderT,
            typename FormatterT,
            typename FindResultT,
            typename FormatResultT>
        inline OutputIteratorT find_format_all_copy_impl2(
            OutputIteratorT Output,
            const InputT &Input,
            FinderT Finder,
            FormatterT Formatter,
            const FindResultT &FindResult,
            const FormatResultT &FormatResult)
        {
            typedef typename range_const_iterator<InputT>::type input_iterator_type;
            typedef find_format_store<
                input_iterator_type,
                FormatterT,
                FormatResultT>
                store_type;
            store_type M(FindResult, FormatResult, Formatter);
            input_iterator_type LastMatch = ::boost::begin(Input);
            while (M)
            {
                Output = std::copy(LastMatch, M.begin(), Output);
                Output = std::copy(::boost::begin(M.format_result()), ::boost::end(M.format_result()), Output);
                LastMatch = M.end();
                M = Finder(LastMatch, ::boost::end(Input));
            }
            Output = std::copy(LastMatch, ::boost::end(Input), Output);
            return Output;
        }
        template <
            typename OutputIteratorT,
            typename InputT,
            typename FinderT,
            typename FormatterT,
            typename FindResultT>
        inline OutputIteratorT find_format_all_copy_impl(
            OutputIteratorT Output,
            const InputT &Input,
            FinderT Finder,
            FormatterT Formatter,
            const FindResultT &FindResult)
        {
            if (::boost::algorithm::detail::check_find_result(Input, FindResult))
            {
                return ::boost::algorithm::detail::find_format_all_copy_impl2(
                    Output,
                    Input,
                    Finder,
                    Formatter,
                    FindResult,
                    Formatter(FindResult));
            }
            else
            {
                return std::copy(::boost::begin(Input), ::boost::end(Input), Output);
            }
        }
        template <
            typename InputT,
            typename FinderT,
            typename FormatterT,
            typename FindResultT,
            typename FormatResultT>
        inline InputT find_format_all_copy_impl2(
            const InputT &Input,
            FinderT Finder,
            FormatterT Formatter,
            const FindResultT &FindResult,
            const FormatResultT &FormatResult)
        {
            typedef typename range_const_iterator<InputT>::type input_iterator_type;
            typedef find_format_store<
                input_iterator_type,
                FormatterT,
                FormatResultT>
                store_type;
            store_type M(FindResult, FormatResult, Formatter);
            input_iterator_type LastMatch = ::boost::begin(Input);
            InputT Output;
            while (M)
            {
                boost::algorithm::detail::insert(Output, ::boost::end(Output), LastMatch, M.begin());
                boost::algorithm::detail::insert(Output, ::boost::end(Output), M.format_result());
                LastMatch = M.end();
                M = Finder(LastMatch, ::boost::end(Input));
            }
            ::boost::algorithm::detail::insert(Output, ::boost::end(Output), LastMatch, ::boost::end(Input));
            return Output;
        }
        template <
            typename InputT,
            typename FinderT,
            typename FormatterT,
            typename FindResultT>
        inline InputT find_format_all_copy_impl(
            const InputT &Input,
            FinderT Finder,
            FormatterT Formatter,
            const FindResultT &FindResult)
        {
            if (::boost::algorithm::detail::check_find_result(Input, FindResult))
            {
                return ::boost::algorithm::detail::find_format_all_copy_impl2(
                    Input,
                    Finder,
                    Formatter,
                    FindResult,
                    Formatter(FindResult));
            }
            else
            {
                return Input;
            }
        }
        template <
            typename InputT,
            typename FinderT,
            typename FormatterT,
            typename FindResultT,
            typename FormatResultT>
        inline void find_format_all_impl2(
            InputT &Input,
            FinderT Finder,
            FormatterT Formatter,
            FindResultT FindResult,
            FormatResultT FormatResult)
        {
            typedef typename range_iterator<InputT>::type input_iterator_type;
            typedef find_format_store<
                input_iterator_type,
                FormatterT,
                FormatResultT>
                store_type;
            store_type M(FindResult, FormatResult, Formatter);
            std::deque<
                typename range_value<InputT>::type>
                Storage;
            input_iterator_type InsertIt = ::boost::begin(Input);
            input_iterator_type SearchIt = ::boost::begin(Input);
            while (M)
            {
                InsertIt = process_segment(
                    Storage,
                    Input,
                    InsertIt,
                    SearchIt,
                    M.begin());
                SearchIt = M.end();
                ::boost::algorithm::detail::copy_to_storage(Storage, M.format_result());
                M = Finder(SearchIt, ::boost::end(Input));
            }
            InsertIt = ::boost::algorithm::detail::process_segment(
                Storage,
                Input,
                InsertIt,
                SearchIt,
                ::boost::end(Input));
            if (Storage.empty())
            {
                ::boost::algorithm::detail::erase(Input, InsertIt, ::boost::end(Input));
            }
            else
            {
                ::boost::algorithm::detail::insert(Input, ::boost::end(Input), Storage.begin(), Storage.end());
            }
        }
        template <
            typename InputT,
            typename FinderT,
            typename FormatterT,
            typename FindResultT>
        inline void find_format_all_impl(
            InputT &Input,
            FinderT Finder,
            FormatterT Formatter,
            FindResultT FindResult)
        {
            if (::boost::algorithm::detail::check_find_result(Input, FindResult))
            {
                ::boost::algorithm::detail::find_format_all_impl2(
                    Input,
                    Finder,
                    Formatter,
                    FindResult,
                    Formatter(FindResult));
            }
        }
}
    }
}
namespace boost
{
    namespace algorithm
    {
template <
    typename OutputIteratorT,
    typename RangeT,
    typename FinderT,
    typename FormatterT>
inline OutputIteratorT find_format_copy(
    OutputIteratorT Output,
    const RangeT &Input,
    FinderT Finder,
    FormatterT Formatter)
{
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(FinderConcept<FinderT, typename range_const_iterator<RangeT>::type>)>::failed> boost_concept_check68;
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(FormatterConcept<FormatterT, FinderT, typename range_const_iterator<RangeT>::type>)>::failed> boost_concept_check73;
        iterator_range<typename range_const_iterator<RangeT>::type> lit_input(::boost::as_literal(Input));
        return detail::find_format_copy_impl(
            Output,
            lit_input,
            Formatter,
            Finder(::boost::begin(lit_input), ::boost::end(lit_input)));
}
template <
    typename SequenceT,
    typename FinderT,
    typename FormatterT>
inline SequenceT find_format_copy(
    const SequenceT &Input,
    FinderT Finder,
    FormatterT Formatter)
{
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(FinderConcept<FinderT, typename range_const_iterator<SequenceT>::type>)>::failed> boost_concept_check102;
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(FormatterConcept<FormatterT, FinderT, typename range_const_iterator<SequenceT>::type>)>::failed> boost_concept_check107;
        return detail::find_format_copy_impl(
            Input,
            Formatter,
            Finder(::boost::begin(Input), ::boost::end(Input)));
}
template <
    typename SequenceT,
    typename FinderT,
    typename FormatterT>
inline void find_format(
    SequenceT &Input,
    FinderT Finder,
    FormatterT Formatter)
{
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(FinderConcept<FinderT, typename range_const_iterator<SequenceT>::type>)>::failed> boost_concept_check138;
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(FormatterConcept<FormatterT, FinderT, typename range_const_iterator<SequenceT>::type>)>::failed> boost_concept_check143;
        detail::find_format_impl(
            Input,
            Formatter,
            Finder(::boost::begin(Input), ::boost::end(Input)));
}
template <
    typename OutputIteratorT,
    typename RangeT,
    typename FinderT,
    typename FormatterT>
inline OutputIteratorT find_format_all_copy(
    OutputIteratorT Output,
    const RangeT &Input,
    FinderT Finder,
    FormatterT Formatter)
{
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(FinderConcept<FinderT, typename range_const_iterator<RangeT>::type>)>::failed> boost_concept_check187;
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(FormatterConcept<FormatterT, FinderT, typename range_const_iterator<RangeT>::type>)>::failed> boost_concept_check192;
        iterator_range<typename range_const_iterator<RangeT>::type> lit_input(::boost::as_literal(Input));
        return detail::find_format_all_copy_impl(
            Output,
            lit_input,
            Finder,
            Formatter,
            Finder(::boost::begin(lit_input), ::boost::end(lit_input)));
}
template <
    typename SequenceT,
    typename FinderT,
    typename FormatterT>
inline SequenceT find_format_all_copy(
    const SequenceT &Input,
    FinderT Finder,
    FormatterT Formatter)
{
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(FinderConcept<FinderT, typename range_const_iterator<SequenceT>::type>)>::failed> boost_concept_check222;
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(FormatterConcept<FormatterT, FinderT, typename range_const_iterator<SequenceT>::type>)>::failed> boost_concept_check227;
        return detail::find_format_all_copy_impl(
            Input,
            Finder,
            Formatter,
            Finder(::boost::begin(Input), ::boost::end(Input)));
}
template <
    typename SequenceT,
    typename FinderT,
    typename FormatterT>
inline void find_format_all(
    SequenceT &Input,
    FinderT Finder,
    FormatterT Formatter)
{
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(FinderConcept<FinderT, typename range_const_iterator<SequenceT>::type>)>::failed> boost_concept_check260;
        typedef ::boost::concepts::detail::instantiate<&::boost::concepts::requirement_<void (*)(FormatterConcept<FormatterT, FinderT, typename range_const_iterator<SequenceT>::type>)>::failed> boost_concept_check265;
        detail::find_format_all_impl(
            Input,
            Finder,
            Formatter,
            Finder(::boost::begin(Input), ::boost::end(Input)));
}
    }
    using algorithm::find_format;
    using algorithm::find_format_all;
    using algorithm::find_format_all_copy;
    using algorithm::find_format_copy;
}
namespace boost
{
    namespace algorithm
    {
enum token_compress_mode_type
{
    token_compress_on,
    token_compress_off
};
    }
    using algorithm::token_compress_off;
    using algorithm::token_compress_on;
}
namespace boost
{
    namespace algorithm
    {
namespace detail
{
        template <typename SearchIteratorT, typename PredicateT>
        struct first_finderF
        {
            typedef SearchIteratorT search_iterator_type;
            template <typename SearchT>
            first_finderF(const SearchT &Search, PredicateT Comp) : m_Search(::boost::begin(Search), ::boost::end(Search)), m_Comp(Comp) {}
            first_finderF(
                search_iterator_type SearchBegin,
                search_iterator_type SearchEnd,
                PredicateT Comp) : m_Search(SearchBegin, SearchEnd), m_Comp(Comp) {}
            template <typename ForwardIteratorT>
            iterator_range<ForwardIteratorT>
            operator()(
                ForwardIteratorT Begin,
                ForwardIteratorT End) const
            {
                typedef iterator_range<ForwardIteratorT> result_type;
                typedef ForwardIteratorT input_iterator_type;
                for (input_iterator_type OuterIt = Begin;
                     OuterIt != End;
                     ++OuterIt)
                {
                    if (boost::empty(m_Search))
                        return result_type(End, End);
                    input_iterator_type InnerIt = OuterIt;
                    search_iterator_type SubstrIt = m_Search.begin();
                    for (;
                         InnerIt != End && SubstrIt != m_Search.end();
                         ++InnerIt, ++SubstrIt)
                    {
                        if (!(m_Comp(*InnerIt, *SubstrIt)))
                            break;
                    }
                    if (SubstrIt == m_Search.end())
                        return result_type(OuterIt, InnerIt);
                }
                return result_type(End, End);
            }

        private:
            iterator_range<search_iterator_type> m_Search;
            PredicateT m_Comp;
        };
        template <typename SearchIteratorT, typename PredicateT>
        struct last_finderF
        {
            typedef SearchIteratorT search_iterator_type;
            typedef first_finderF<
                search_iterator_type,
                PredicateT>
                first_finder_type;
            template <typename SearchT>
            last_finderF(const SearchT &Search, PredicateT Comp) : m_Search(::boost::begin(Search), ::boost::end(Search)), m_Comp(Comp) {}
            last_finderF(
                search_iterator_type SearchBegin,
                search_iterator_type SearchEnd,
                PredicateT Comp) : m_Search(SearchBegin, SearchEnd), m_Comp(Comp) {}
            template <typename ForwardIteratorT>
            iterator_range<ForwardIteratorT>
            operator()(
                ForwardIteratorT Begin,
                ForwardIteratorT End) const
            {
                typedef iterator_range<ForwardIteratorT> result_type;
                if (boost::empty(m_Search))
                    return result_type(End, End);
                typedef typename std::iterator_traits<ForwardIteratorT>::iterator_category category;
                return findit(Begin, End, category());
            }

        private:
            template <typename ForwardIteratorT>
            iterator_range<ForwardIteratorT>
            findit(
                ForwardIteratorT Begin,
                ForwardIteratorT End,
                std::forward_iterator_tag) const
            {
                typedef iterator_range<ForwardIteratorT> result_type;
                first_finder_type first_finder(
                    m_Search.begin(), m_Search.end(), m_Comp);
                result_type M = first_finder(Begin, End);
                result_type Last = M;
                while (M)
                {
                    Last = M;
                    M = first_finder(::boost::end(M), End);
                }
                return Last;
            }
            template <typename ForwardIteratorT>
            iterator_range<ForwardIteratorT>
            findit(
                ForwardIteratorT Begin,
                ForwardIteratorT End,
                std::bidirectional_iterator_tag) const
            {
                typedef iterator_range<ForwardIteratorT> result_type;
                typedef ForwardIteratorT input_iterator_type;
                for (input_iterator_type OuterIt = End;
                     OuterIt != Begin;)
                {
                    input_iterator_type OuterIt2 = --OuterIt;
                    input_iterator_type InnerIt = OuterIt2;
                    search_iterator_type SubstrIt = m_Search.begin();
                    for (;
                         InnerIt != End && SubstrIt != m_Search.end();
                         ++InnerIt, ++SubstrIt)
                    {
                        if (!(m_Comp(*InnerIt, *SubstrIt)))
                            break;
                    }
                    if (SubstrIt == m_Search.end())
                        return result_type(OuterIt2, InnerIt);
                }
                return result_type(End, End);
            }

        private:
            iterator_range<search_iterator_type> m_Search;
            PredicateT m_Comp;
        };
        template <typename SearchIteratorT, typename PredicateT>
        struct nth_finderF
        {
            typedef SearchIteratorT search_iterator_type;
            typedef first_finderF<
                search_iterator_type,
                PredicateT>
                first_finder_type;
            typedef last_finderF<
                search_iterator_type,
                PredicateT>
                last_finder_type;
            template <typename SearchT>
            nth_finderF(
                const SearchT &Search,
                int Nth,
                PredicateT Comp) : m_Search(::boost::begin(Search), ::boost::end(Search)),
                                   m_Nth(Nth),
                                   m_Comp(Comp) {}
            nth_finderF(
                search_iterator_type SearchBegin,
                search_iterator_type SearchEnd,
                int Nth,
                PredicateT Comp) : m_Search(SearchBegin, SearchEnd),
                                   m_Nth(Nth),
                                   m_Comp(Comp) {}
            template <typename ForwardIteratorT>
            iterator_range<ForwardIteratorT>
            operator()(
                ForwardIteratorT Begin,
                ForwardIteratorT End) const
            {
                if (m_Nth >= 0)
                {
                    return find_forward(Begin, End, m_Nth);
                }
                else
                {
                    return find_backward(Begin, End, -m_Nth);
                }
            }

        private:
            template <typename ForwardIteratorT>
            iterator_range<ForwardIteratorT>
            find_forward(
                ForwardIteratorT Begin,
                ForwardIteratorT End,
                unsigned int N) const
            {
                typedef iterator_range<ForwardIteratorT> result_type;
                if (boost::empty(m_Search))
                    return result_type(End, End);
                first_finder_type first_finder(
                    m_Search.begin(), m_Search.end(), m_Comp);
                result_type M(Begin, Begin);
                for (unsigned int n = 0; n <= N; ++n)
                {
                    M = first_finder(::boost::end(M), End);
                    if (!M)
                    {
                        return M;
                    }
                }
                return M;
            }
            template <typename ForwardIteratorT>
            iterator_range<ForwardIteratorT>
            find_backward(
                ForwardIteratorT Begin,
                ForwardIteratorT End,
                unsigned int N) const
            {
                typedef iterator_range<ForwardIteratorT> result_type;
                if (boost::empty(m_Search))
                    return result_type(End, End);
                last_finder_type last_finder(
                    m_Search.begin(), m_Search.end(), m_Comp);
                result_type M(End, End);
                for (unsigned int n = 1; n <= N; ++n)
                {
                    M = last_finder(Begin, ::boost::begin(M));
                    if (!M)
                    {
                        return M;
                    }
                }
                return M;
            }

        private:
            iterator_range<search_iterator_type> m_Search;
            int m_Nth;
            PredicateT m_Comp;
        };
        template <typename ForwardIteratorT>
        iterator_range<ForwardIteratorT>
        find_head_impl(
            ForwardIteratorT Begin,
            ForwardIteratorT End,
            unsigned int N,
            std::forward_iterator_tag)
        {
            typedef ForwardIteratorT input_iterator_type;
            typedef iterator_range<ForwardIteratorT> result_type;
            input_iterator_type It = Begin;
            for (unsigned int Index = 0; Index < N && It != End; ++Index, ++It)
                ;
            return result_type(Begin, It);
        }
        template <typename ForwardIteratorT>
        iterator_range<ForwardIteratorT>
        find_head_impl(
            ForwardIteratorT Begin,
            ForwardIteratorT End,
            unsigned int N,
            std::random_access_iterator_tag)
        {
            typedef iterator_range<ForwardIteratorT> result_type;
            if ((End <= Begin) || (static_cast<unsigned int>(End - Begin) < N))
                return result_type(Begin, End);
            return result_type(Begin, Begin + N);
        }
        template <typename ForwardIteratorT>
        iterator_range<ForwardIteratorT>
        find_head_impl(
            ForwardIteratorT Begin,
            ForwardIteratorT End,
            unsigned int N)
        {
            typedef typename std::iterator_traits<ForwardIteratorT>::iterator_category category;
            return ::boost::algorithm::detail::find_head_impl(Begin, End, N, category());
        }
        template <typename ForwardIteratorT>
        iterator_range<ForwardIteratorT>
        find_tail_impl(
            ForwardIteratorT Begin,
            ForwardIteratorT End,
            unsigned int N,
            std::forward_iterator_tag)
        {
            typedef ForwardIteratorT input_iterator_type;
            typedef iterator_range<ForwardIteratorT> result_type;
            unsigned int Index = 0;
            input_iterator_type It = Begin;
            input_iterator_type It2 = Begin;
            for (Index = 0; Index < N && It2 != End; ++Index, ++It2)
                ;
            for (; It2 != End; ++It, ++It2)
                ;
            return result_type(It, It2);
        }
        template <typename ForwardIteratorT>
        iterator_range<ForwardIteratorT>
        find_tail_impl(
            ForwardIteratorT Begin,
            ForwardIteratorT End,
            unsigned int N,
            std::bidirectional_iterator_tag)
        {
            typedef ForwardIteratorT input_iterator_type;
            typedef iterator_range<ForwardIteratorT> result_type;
            input_iterator_type It = End;
            for (unsigned int Index = 0; Index < N && It != Begin; ++Index, --It)
                ;
            return result_type(It, End);
        }
        template <typename ForwardIteratorT>
        iterator_range<ForwardIteratorT>
        find_tail_impl(
            ForwardIteratorT Begin,
            ForwardIteratorT End,
            unsigned int N,
            std::random_access_iterator_tag)
        {
            typedef iterator_range<ForwardIteratorT> result_type;
            if ((End <= Begin) || (static_cast<unsigned int>(End - Begin) < N))
                return result_type(Begin, End);
            return result_type(End - N, End);
        }
        template <typename ForwardIteratorT>
        iterator_range<ForwardIteratorT>
        find_tail_impl(
            ForwardIteratorT Begin,
            ForwardIteratorT End,
            unsigned int N)
        {
            typedef typename std::iterator_traits<ForwardIteratorT>::iterator_category category;
            return ::boost::algorithm::detail::find_tail_impl(Begin, End, N, category());
        }
        struct head_finderF
        {
            head_finderF(int N) : m_N(N) {}
            template <typename ForwardIteratorT>
            iterator_range<ForwardIteratorT>
            operator()(
                ForwardIteratorT Begin,
                ForwardIteratorT End) const
            {
                if (m_N >= 0)
                {
                    return ::boost::algorithm::detail::find_head_impl(Begin, End, m_N);
                }
                else
                {
                    iterator_range<ForwardIteratorT> Res =
                        ::boost::algorithm::detail::find_tail_impl(Begin, End, -m_N);
                    return ::boost::make_iterator_range(Begin, Res.begin());
                }
            }

        private:
            int m_N;
        };
        struct tail_finderF
        {
            tail_finderF(int N) : m_N(N) {}
            template <typename ForwardIteratorT>
            iterator_range<ForwardIteratorT>
            operator()(
                ForwardIteratorT Begin,
                ForwardIteratorT End) const
            {
                if (m_N >= 0)
                {
                    return ::boost::algorithm::detail::find_tail_impl(Begin, End, m_N);
                }
                else
                {
                    iterator_range<ForwardIteratorT> Res =
                        ::boost::algorithm::detail::find_head_impl(Begin, End, -m_N);
                    return ::boost::make_iterator_range(Res.end(), End);
                }
            }

        private:
            int m_N;
        };
        template <typename PredicateT>
        struct token_finderF
        {
            token_finderF(
                PredicateT Pred,
                token_compress_mode_type eCompress = token_compress_off) : m_Pred(Pred), m_eCompress(eCompress) {}
            template <typename ForwardIteratorT>
            iterator_range<ForwardIteratorT>
            operator()(
                ForwardIteratorT Begin,
                ForwardIteratorT End) const
            {
                typedef iterator_range<ForwardIteratorT> result_type;
                ForwardIteratorT It = std::find_if(Begin, End, m_Pred);
                if (It == End)
                {
                    return result_type(End, End);
                }
                else
                {
                    ForwardIteratorT It2 = It;
                    if (m_eCompress == token_compress_on)
                    {
                        while (It2 != End && m_Pred(*It2))
                            ++It2;
                    }
                    else
                    {
                        ++It2;
                    }
                    return result_type(It, It2);
                }
            }

        private:
            PredicateT m_Pred;
            token_compress_mode_type m_eCompress;
        };
        template <typename ForwardIterator1T>
        struct range_finderF
        {
            typedef ForwardIterator1T input_iterator_type;
            typedef iterator_range<input_iterator_type> result_type;
            range_finderF(
                input_iterator_type Begin,
                input_iterator_type End) : m_Range(Begin, End) {}
            range_finderF(const iterator_range<input_iterator_type> &Range) : m_Range(Range) {}
            template <typename ForwardIterator2T>
            iterator_range<ForwardIterator2T>
            operator()(
                ForwardIterator2T,
                ForwardIterator2T) const
            {
                return m_Range;
            }

        private:
            iterator_range<input_iterator_type> m_Range;
        };
}
    }
}
namespace boost
{
    namespace algorithm
    {
struct is_equal
{
        template <typename T1, typename T2>
        bool operator()(const T1 &Arg1, const T2 &Arg2) const
        {
            return Arg1 == Arg2;
        }
};
struct is_iequal
{
        is_iequal(const std::locale &Loc = std::locale()) : m_Loc(Loc) {}
        template <typename T1, typename T2>
        bool operator()(const T1 &Arg1, const T2 &Arg2) const
        {
            return std::toupper<T1>(Arg1, m_Loc) == std::toupper<T2>(Arg2, m_Loc);
        }

    private:
        std::locale m_Loc;
};
struct is_less
{
        template <typename T1, typename T2>
        bool operator()(const T1 &Arg1, const T2 &Arg2) const
        {
            return Arg1 < Arg2;
        }
};
struct is_iless
{
        is_iless(const std::locale &Loc = std::locale()) : m_Loc(Loc) {}
        template <typename T1, typename T2>
        bool operator()(const T1 &Arg1, const T2 &Arg2) const
        {
            return std::toupper<T1>(Arg1, m_Loc) < std::toupper<T2>(Arg2, m_Loc);
        }

    private:
        std::locale m_Loc;
};
struct is_not_greater
{
        template <typename T1, typename T2>
        bool operator()(const T1 &Arg1, const T2 &Arg2) const
        {
            return Arg1 <= Arg2;
        }
};
struct is_not_igreater
{
        is_not_igreater(const std::locale &Loc = std::locale()) : m_Loc(Loc) {}
        template <typename T1, typename T2>
        bool operator()(const T1 &Arg1, const T2 &Arg2) const
        {
            return std::toupper<T1>(Arg1, m_Loc) <= std::toupper<T2>(Arg2, m_Loc);
        }

    private:
        std::locale m_Loc;
};
    }
    using algorithm::is_equal;
    using algorithm::is_iequal;
    using algorithm::is_iless;
    using algorithm::is_less;
    using algorithm::is_not_greater;
    using algorithm::is_not_igreater;
}
namespace boost
{
    namespace algorithm
    {
template <typename RangeT>
inline detail::first_finderF<
    typename range_const_iterator<RangeT>::type,
    is_equal>
first_finder(const RangeT &Search)
{
        return detail::first_finderF<
            typename range_const_iterator<RangeT>::type,
            is_equal>(::boost::as_literal(Search), is_equal());
}
template <typename RangeT, typename PredicateT>
inline detail::first_finderF<
    typename range_const_iterator<RangeT>::type,
    PredicateT>
first_finder(
    const RangeT &Search, PredicateT Comp)
{
        return detail::first_finderF<
            typename range_const_iterator<RangeT>::type,
            PredicateT>(::boost::as_literal(Search), Comp);
}
template <typename RangeT>
inline detail::last_finderF<
    typename range_const_iterator<RangeT>::type,
    is_equal>
last_finder(const RangeT &Search)
{
        return detail::last_finderF<
            typename range_const_iterator<RangeT>::type,
            is_equal>(::boost::as_literal(Search), is_equal());
}
template <typename RangeT, typename PredicateT>
inline detail::last_finderF<
    typename range_const_iterator<RangeT>::type,
    PredicateT>
last_finder(const RangeT &Search, PredicateT Comp)
{
        return detail::last_finderF<
            typename range_const_iterator<RangeT>::type,
            PredicateT>(::boost::as_literal(Search), Comp);
}
template <typename RangeT>
inline detail::nth_finderF<
    typename range_const_iterator<RangeT>::type,
    is_equal>
nth_finder(
    const RangeT &Search,
    int Nth)
{
        return detail::nth_finderF<
            typename range_const_iterator<RangeT>::type,
            is_equal>(::boost::as_literal(Search), Nth, is_equal());
}
template <typename RangeT, typename PredicateT>
inline detail::nth_finderF<
    typename range_const_iterator<RangeT>::type,
    PredicateT>
nth_finder(
    const RangeT &Search,
    int Nth,
    PredicateT Comp)
{
        return detail::nth_finderF<
            typename range_const_iterator<RangeT>::type,
            PredicateT>(::boost::as_literal(Search), Nth, Comp);
}
inline detail::head_finderF
head_finder(int N)
{
        return detail::head_finderF(N);
}
inline detail::tail_finderF
tail_finder(int N)
{
        return detail::tail_finderF(N);
}
template <typename PredicateT>
inline detail::token_finderF<PredicateT>
token_finder(
    PredicateT Pred,
    token_compress_mode_type eCompress = token_compress_off)
{
        return detail::token_finderF<PredicateT>(Pred, eCompress);
}
template <typename ForwardIteratorT>
inline detail::range_finderF<ForwardIteratorT>
range_finder(
    ForwardIteratorT Begin,
    ForwardIteratorT End)
{
        return detail::range_finderF<ForwardIteratorT>(Begin, End);
}
template <typename ForwardIteratorT>
inline detail::range_finderF<ForwardIteratorT>
range_finder(iterator_range<ForwardIteratorT> Range)
{
        return detail::range_finderF<ForwardIteratorT>(Range);
}
    }
    using algorithm::first_finder;
    using algorithm::head_finder;
    using algorithm::last_finder;
    using algorithm::nth_finder;
    using algorithm::range_finder;
    using algorithm::tail_finder;
    using algorithm::token_finder;
}
namespace boost
{
    namespace algorithm
    {
namespace detail
{
        template <typename CharT>
        struct empty_container
        {
            typedef empty_container<CharT> type;
            typedef CharT value_type;
            typedef std::size_t size_type;
            typedef std::ptrdiff_t difference_type;
            typedef const value_type &reference;
            typedef const value_type &const_reference;
            typedef const value_type *iterator;
            typedef const value_type *const_iterator;
            const_iterator begin() const
            {
                return reinterpret_cast<const_iterator>(0);
            }
            const_iterator end() const
            {
                return reinterpret_cast<const_iterator>(0);
            }
            bool empty() const
            {
                return false;
            }
            size_type size() const
            {
                return 0;
            }
        };
        template <typename InputIteratorT, typename OutputIteratorT>
        inline OutputIteratorT bounded_copy(
            InputIteratorT First,
            InputIteratorT Last,
            OutputIteratorT DestFirst,
            OutputIteratorT DestLast)
        {
            InputIteratorT InputIt = First;
            OutputIteratorT OutputIt = DestFirst;
            for (; InputIt != Last && OutputIt != DestLast; InputIt++, OutputIt++)
            {
                *OutputIt = *InputIt;
            }
            return OutputIt;
        }
        template <
            typename SeqT,
            typename IteratorT = typename SeqT::const_iterator>
        struct copy_iterator_rangeF
        {
            typedef iterator_range<IteratorT> argument_type;
            typedef SeqT result_type;
            SeqT operator()(const iterator_range<IteratorT> &Range) const
            {
                return copy_range<SeqT>(Range);
            }
        };
}
    }
}
namespace boost
{
    namespace algorithm
    {
namespace detail
{
        template <typename RangeT>
        struct const_formatF
        {
        private:
            typedef typename range_const_iterator<RangeT>::type format_iterator;
            typedef iterator_range<format_iterator> result_type;

        public:
            const_formatF(const RangeT &Format) : m_Format(::boost::begin(Format), ::boost::end(Format)) {}
            template <typename Range2T>
            const result_type &operator()(const Range2T &) const
            {
                return m_Format;
            }

        private:
            result_type m_Format;
        };
        template <typename RangeT>
        struct identity_formatF
        {
            template <typename Range2T>
            const RangeT &operator()(const Range2T &Replace) const
            {
                return RangeT(::boost::begin(Replace), ::boost::end(Replace));
            }
        };
        template <typename CharT>
        struct empty_formatF
        {
            template <typename ReplaceT>
            empty_container<CharT> operator()(const ReplaceT &) const
            {
                return empty_container<CharT>();
            }
        };
        template <typename FinderT>
        struct dissect_formatF
        {
        public:
            dissect_formatF(FinderT Finder) : m_Finder(Finder) {}
            template <typename RangeT>
            inline iterator_range<
                typename range_const_iterator<RangeT>::type>
            operator()(const RangeT &Replace) const
            {
                return m_Finder(::boost::begin(Replace), ::boost::end(Replace));
            }

        private:
            FinderT m_Finder;
        };
}
    }
}
namespace boost
{
    namespace algorithm
    {
template <typename RangeT>
inline detail::const_formatF<
    iterator_range<
        typename range_const_iterator<RangeT>::type>>
const_formatter(const RangeT &Format)
{
        return detail::const_formatF<
            iterator_range<
                typename range_const_iterator<RangeT>::type>>(::boost::as_literal(Format));
}
template <typename RangeT>
inline detail::identity_formatF<
    iterator_range<
        typename range_const_iterator<RangeT>::type>>
identity_formatter()
{
        return detail::identity_formatF<
            iterator_range<
                typename range_const_iterator<RangeT>::type>>();
}
template <typename RangeT>
inline detail::empty_formatF<
    typename range_value<RangeT>::type>
empty_formatter(const RangeT &)
{
        return detail::empty_formatF<
            typename range_value<RangeT>::type>();
}
template <typename FinderT>
inline detail::dissect_formatF<FinderT>
dissect_formatter(const FinderT &Finder)
{
        return detail::dissect_formatF<FinderT>(Finder);
}
    }
    using algorithm::const_formatter;
    using algorithm::dissect_formatter;
    using algorithm::empty_formatter;
    using algorithm::identity_formatter;
}
namespace boost
{
    namespace algorithm
    {
template <
    typename OutputIteratorT,
    typename Range1T,
    typename Range2T>
inline OutputIteratorT replace_range_copy(
    OutputIteratorT Output,
    const Range1T &Input,
    const iterator_range<
        typename range_const_iterator<Range1T>::type> &SearchRange,
    const Range2T &Format)
{
        return ::boost::algorithm::find_format_copy(
            Output,
            Input,
            ::boost::algorithm::range_finder(SearchRange),
            ::boost::algorithm::const_formatter(Format));
}
template <typename SequenceT, typename RangeT>
inline SequenceT replace_range_copy(
    const SequenceT &Input,
    const iterator_range<
        typename range_const_iterator<SequenceT>::type> &SearchRange,
    const RangeT &Format)
{
        return ::boost::algorithm::find_format_copy(
            Input,
            ::boost::algorithm::range_finder(SearchRange),
            ::boost::algorithm::const_formatter(Format));
}
template <typename SequenceT, typename RangeT>
inline void replace_range(
    SequenceT &Input,
    const iterator_range<
        typename range_iterator<SequenceT>::type> &SearchRange,
    const RangeT &Format)
{
        ::boost::algorithm::find_format(
            Input,
            ::boost::algorithm::range_finder(SearchRange),
            ::boost::algorithm::const_formatter(Format));
}
template <
    typename OutputIteratorT,
    typename Range1T,
    typename Range2T,
    typename Range3T>
inline OutputIteratorT replace_first_copy(
    OutputIteratorT Output,
    const Range1T &Input,
    const Range2T &Search,
    const Range3T &Format)
{
        return ::boost::algorithm::find_format_copy(
            Output,
            Input,
            ::boost::algorithm::first_finder(Search),
            ::boost::algorithm::const_formatter(Format));
}
template <typename SequenceT, typename Range1T, typename Range2T>
inline SequenceT replace_first_copy(
    const SequenceT &Input,
    const Range1T &Search,
    const Range2T &Format)
{
        return ::boost::algorithm::find_format_copy(
            Input,
            ::boost::algorithm::first_finder(Search),
            ::boost::algorithm::const_formatter(Format));
}
template <typename SequenceT, typename Range1T, typename Range2T>
inline void replace_first(
    SequenceT &Input,
    const Range1T &Search,
    const Range2T &Format)
{
        ::boost::algorithm::find_format(
            Input,
            ::boost::algorithm::first_finder(Search),
            ::boost::algorithm::const_formatter(Format));
}
template <
    typename OutputIteratorT,
    typename Range1T,
    typename Range2T,
    typename Range3T>
inline OutputIteratorT ireplace_first_copy(
    OutputIteratorT Output,
    const Range1T &Input,
    const Range2T &Search,
    const Range3T &Format,
    const std::locale &Loc = std::locale())
{
        return ::boost::algorithm::find_format_copy(
            Output,
            Input,
            ::boost::algorithm::first_finder(Search, is_iequal(Loc)),
            ::boost::algorithm::const_formatter(Format));
}
template <typename SequenceT, typename Range2T, typename Range1T>
inline SequenceT ireplace_first_copy(
    const SequenceT &Input,
    const Range2T &Search,
    const Range1T &Format,
    const std::locale &Loc = std::locale())
{
        return ::boost::algorithm::find_format_copy(
            Input,
            ::boost::algorithm::first_finder(Search, is_iequal(Loc)),
            ::boost::algorithm::const_formatter(Format));
}
template <typename SequenceT, typename Range1T, typename Range2T>
inline void ireplace_first(
    SequenceT &Input,
    const Range1T &Search,
    const Range2T &Format,
    const std::locale &Loc = std::locale())
{
        ::boost::algorithm::find_format(
            Input,
            ::boost::algorithm::first_finder(Search, is_iequal(Loc)),
            ::boost::algorithm::const_formatter(Format));
}
template <
    typename OutputIteratorT,
    typename Range1T,
    typename Range2T,
    typename Range3T>
inline OutputIteratorT replace_last_copy(
    OutputIteratorT Output,
    const Range1T &Input,
    const Range2T &Search,
    const Range3T &Format)
{
        return ::boost::algorithm::find_format_copy(
            Output,
            Input,
            ::boost::algorithm::last_finder(Search),
            ::boost::algorithm::const_formatter(Format));
}
template <typename SequenceT, typename Range1T, typename Range2T>
inline SequenceT replace_last_copy(
    const SequenceT &Input,
    const Range1T &Search,
    const Range2T &Format)
{
        return ::boost::algorithm::find_format_copy(
            Input,
            ::boost::algorithm::last_finder(Search),
            ::boost::algorithm::const_formatter(Format));
}
template <typename SequenceT, typename Range1T, typename Range2T>
inline void replace_last(
    SequenceT &Input,
    const Range1T &Search,
    const Range2T &Format)
{
        ::boost::algorithm::find_format(
            Input,
            ::boost::algorithm::last_finder(Search),
            ::boost::algorithm::const_formatter(Format));
}
template <
    typename OutputIteratorT,
    typename Range1T,
    typename Range2T,
    typename Range3T>
inline OutputIteratorT ireplace_last_copy(
    OutputIteratorT Output,
    const Range1T &Input,
    const Range2T &Search,
    const Range3T &Format,
    const std::locale &Loc = std::locale())
{
        return ::boost::algorithm::find_format_copy(
            Output,
            Input,
            ::boost::algorithm::last_finder(Search, is_iequal(Loc)),
            ::boost::algorithm::const_formatter(Format));
}
template <typename SequenceT, typename Range1T, typename Range2T>
inline SequenceT ireplace_last_copy(
    const SequenceT &Input,
    const Range1T &Search,
    const Range2T &Format,
    const std::locale &Loc = std::locale())
{
        return ::boost::algorithm::find_format_copy(
            Input,
            ::boost::algorithm::last_finder(Search, is_iequal(Loc)),
            ::boost::algorithm::const_formatter(Format));
}
template <typename SequenceT, typename Range1T, typename Range2T>
inline void ireplace_last(
    SequenceT &Input,
    const Range1T &Search,
    const Range2T &Format,
    const std::locale &Loc = std::locale())
{
        ::boost::algorithm::find_format(
            Input,
            ::boost::algorithm::last_finder(Search, is_iequal(Loc)),
            ::boost::algorithm::const_formatter(Format));
}
template <
    typename OutputIteratorT,
    typename Range1T,
    typename Range2T,
    typename Range3T>
inline OutputIteratorT replace_nth_copy(
    OutputIteratorT Output,
    const Range1T &Input,
    const Range2T &Search,
    int Nth,
    const Range3T &Format)
{
        return ::boost::algorithm::find_format_copy(
            Output,
            Input,
            ::boost::algorithm::nth_finder(Search, Nth),
            ::boost::algorithm::const_formatter(Format));
}
template <typename SequenceT, typename Range1T, typename Range2T>
inline SequenceT replace_nth_copy(
    const SequenceT &Input,
    const Range1T &Search,
    int Nth,
    const Range2T &Format)
{
        return ::boost::algorithm::find_format_copy(
            Input,
            ::boost::algorithm::nth_finder(Search, Nth),
            ::boost::algorithm::const_formatter(Format));
}
template <typename SequenceT, typename Range1T, typename Range2T>
inline void replace_nth(
    SequenceT &Input,
    const Range1T &Search,
    int Nth,
    const Range2T &Format)
{
        ::boost::algorithm::find_format(
            Input,
            ::boost::algorithm::nth_finder(Search, Nth),
            ::boost::algorithm::const_formatter(Format));
}
template <
    typename OutputIteratorT,
    typename Range1T,
    typename Range2T,
    typename Range3T>
inline OutputIteratorT ireplace_nth_copy(
    OutputIteratorT Output,
    const Range1T &Input,
    const Range2T &Search,
    int Nth,
    const Range3T &Format,
    const std::locale &Loc = std::locale())
{
        return ::boost::algorithm::find_format_copy(
            Output,
            Input,
            ::boost::algorithm::nth_finder(Search, Nth, is_iequal(Loc)),
            ::boost::algorithm::const_formatter(Format));
}
template <typename SequenceT, typename Range1T, typename Range2T>
inline SequenceT ireplace_nth_copy(
    const SequenceT &Input,
    const Range1T &Search,
    int Nth,
    const Range2T &Format,
    const std::locale &Loc = std::locale())
{
        return ::boost::algorithm::find_format_copy(
            Input,
            ::boost::algorithm::nth_finder(Search, Nth, is_iequal(Loc)),
            ::boost::algorithm::const_formatter(Format));
}
template <typename SequenceT, typename Range1T, typename Range2T>
inline void ireplace_nth(
    SequenceT &Input,
    const Range1T &Search,
    int Nth,
    const Range2T &Format,
    const std::locale &Loc = std::locale())
{
        ::boost::algorithm::find_format(
            Input,
            ::boost::algorithm::nth_finder(Search, Nth, is_iequal(Loc)),
            ::boost::algorithm::const_formatter(Format));
}
template <
    typename OutputIteratorT,
    typename Range1T,
    typename Range2T,
    typename Range3T>
inline OutputIteratorT replace_all_copy(
    OutputIteratorT Output,
    const Range1T &Input,
    const Range2T &Search,
    const Range3T &Format)
{
        return ::boost::algorithm::find_format_all_copy(
            Output,
            Input,
            ::boost::algorithm::first_finder(Search),
            ::boost::algorithm::const_formatter(Format));
}
template <typename SequenceT, typename Range1T, typename Range2T>
inline SequenceT replace_all_copy(
    const SequenceT &Input,
    const Range1T &Search,
    const Range2T &Format)
{
        return ::boost::algorithm::find_format_all_copy(
            Input,
            ::boost::algorithm::first_finder(Search),
            ::boost::algorithm::const_formatter(Format));
}
template <typename SequenceT, typename Range1T, typename Range2T>
inline void replace_all(
    SequenceT &Input,
    const Range1T &Search,
    const Range2T &Format)
{
        ::boost::algorithm::find_format_all(
            Input,
            ::boost::algorithm::first_finder(Search),
            ::boost::algorithm::const_formatter(Format));
}
template <
    typename OutputIteratorT,
    typename Range1T,
    typename Range2T,
    typename Range3T>
inline OutputIteratorT ireplace_all_copy(
    OutputIteratorT Output,
    const Range1T &Input,
    const Range2T &Search,
    const Range3T &Format,
    const std::locale &Loc = std::locale())
{
        return ::boost::algorithm::find_format_all_copy(
            Output,
            Input,
            ::boost::algorithm::first_finder(Search, is_iequal(Loc)),
            ::boost::algorithm::const_formatter(Format));
}
template <typename SequenceT, typename Range1T, typename Range2T>
inline SequenceT ireplace_all_copy(
    const SequenceT &Input,
    const Range1T &Search,
    const Range2T &Format,
    const std::locale &Loc = std::locale())
{
        return ::boost::algorithm::find_format_all_copy(
            Input,
            ::boost::algorithm::first_finder(Search, is_iequal(Loc)),
            ::boost::algorithm::const_formatter(Format));
}
template <typename SequenceT, typename Range1T, typename Range2T>
inline void ireplace_all(
    SequenceT &Input,
    const Range1T &Search,
    const Range2T &Format,
    const std::locale &Loc = std::locale())
{
        ::boost::algorithm::find_format_all(
            Input,
            ::boost::algorithm::first_finder(Search, is_iequal(Loc)),
            ::boost::algorithm::const_formatter(Format));
}
template <
    typename OutputIteratorT,
    typename Range1T,
    typename Range2T>
inline OutputIteratorT replace_head_copy(
    OutputIteratorT Output,
    const Range1T &Input,
    int N,
    const Range2T &Format)
{
        return ::boost::algorithm::find_format_copy(
            Output,
            Input,
            ::boost::algorithm::head_finder(N),
            ::boost::algorithm::const_formatter(Format));
}
template <typename SequenceT, typename RangeT>
inline SequenceT replace_head_copy(
    const SequenceT &Input,
    int N,
    const RangeT &Format)
{
        return ::boost::algorithm::find_format_copy(
            Input,
            ::boost::algorithm::head_finder(N),
            ::boost::algorithm::const_formatter(Format));
}
template <typename SequenceT, typename RangeT>
inline void replace_head(
    SequenceT &Input,
    int N,
    const RangeT &Format)
{
        ::boost::algorithm::find_format(
            Input,
            ::boost::algorithm::head_finder(N),
            ::boost::algorithm::const_formatter(Format));
}
template <
    typename OutputIteratorT,
    typename Range1T,
    typename Range2T>
inline OutputIteratorT replace_tail_copy(
    OutputIteratorT Output,
    const Range1T &Input,
    int N,
    const Range2T &Format)
{
        return ::boost::algorithm::find_format_copy(
            Output,
            Input,
            ::boost::algorithm::tail_finder(N),
            ::boost::algorithm::const_formatter(Format));
}
template <typename SequenceT, typename RangeT>
inline SequenceT replace_tail_copy(
    const SequenceT &Input,
    int N,
    const RangeT &Format)
{
        return ::boost::algorithm::find_format_copy(
            Input,
            ::boost::algorithm::tail_finder(N),
            ::boost::algorithm::const_formatter(Format));
}
template <typename SequenceT, typename RangeT>
inline void replace_tail(
    SequenceT &Input,
    int N,
    const RangeT &Format)
{
        ::boost::algorithm::find_format(
            Input,
            ::boost::algorithm::tail_finder(N),
            ::boost::algorithm::const_formatter(Format));
}
    }
    using algorithm::ireplace_all;
    using algorithm::ireplace_all_copy;
    using algorithm::ireplace_first;
    using algorithm::ireplace_first_copy;
    using algorithm::ireplace_last;
    using algorithm::ireplace_last_copy;
    using algorithm::ireplace_nth;
    using algorithm::ireplace_nth_copy;
    using algorithm::replace_all;
    using algorithm::replace_all_copy;
    using algorithm::replace_first;
    using algorithm::replace_first_copy;
    using algorithm::replace_head;
    using algorithm::replace_head_copy;
    using algorithm::replace_last;
    using algorithm::replace_last_copy;
    using algorithm::replace_nth;
    using algorithm::replace_nth_copy;
    using algorithm::replace_range;
    using algorithm::replace_range_copy;
    using algorithm::replace_tail;
    using algorithm::replace_tail_copy;
}
namespace boost
{
    namespace date_time
    {
template <class CharT, class OutItrT = std::ostreambuf_iterator<CharT, std::char_traits<CharT>>>
class special_values_formatter
{
    public:
        typedef std::basic_string<CharT> string_type;
        typedef CharT char_type;
        typedef std::vector<string_type> collection_type;
        static const char_type default_special_value_names[3][17];
        special_values_formatter()
        {
            std::copy(&default_special_value_names[0],
                      &default_special_value_names[3],
                      std::back_inserter(m_special_value_names));
        }
        special_values_formatter(const char_type *const *begin, const char_type *const *end)
        {
            std::copy(begin, end, std::back_inserter(m_special_value_names));
        }
        special_values_formatter(typename collection_type::iterator beg, typename collection_type::iterator end)
        {
            std::copy(beg, end, std::back_inserter(m_special_value_names));
        }
        OutItrT put_special(OutItrT next,
                            const boost::date_time::special_values &value) const
        {
            unsigned int index = value;
            if (index < m_special_value_names.size())
            {
                std::copy(m_special_value_names[index].begin(),
                          m_special_value_names[index].end(),
                          next);
            }
            return next;
        }

    protected:
        collection_type m_special_value_names;
};
template <class CharT, class OutItrT>
const typename special_values_formatter<CharT, OutItrT>::char_type special_values_formatter<CharT, OutItrT>::default_special_value_names[3][17] = {
    {'n', 'o', 't', '-', 'a', '-', 'd', 'a', 't', 'e', '-', 't', 'i', 'm', 'e'},
    {'-', 'i', 'n', 'f', 'i', 'n', 'i', 't', 'y'},
    {'+', 'i', 'n', 'f', 'i', 'n', 'i', 't', 'y'}};
    }
}
namespace boost
{
    namespace date_time
    {
template <class CharT, class OutItrT = std::ostreambuf_iterator<CharT, std::char_traits<CharT>>>
class period_formatter
{
    public:
        typedef std::basic_string<CharT> string_type;
        typedef CharT char_type;
        typedef typename std::basic_string<char_type>::const_iterator const_itr_type;
        typedef std::vector<std::basic_string<CharT>> collection_type;
        static const char_type default_period_separator[2];
        static const char_type default_period_start_delimeter[2];
        static const char_type default_period_open_range_end_delimeter[2];
        static const char_type default_period_closed_range_end_delimeter[2];
        enum range_display_options
        {
            AS_OPEN_RANGE,
            AS_CLOSED_RANGE
        };
        period_formatter(range_display_options range_option_in = AS_CLOSED_RANGE,
                         const char_type *const period_separator = default_period_separator,
                         const char_type *const period_start_delimeter = default_period_start_delimeter,
                         const char_type *const period_open_range_end_delimeter = default_period_open_range_end_delimeter,
                         const char_type *const period_closed_range_end_delimeter = default_period_closed_range_end_delimeter) : m_range_option(range_option_in),
                                                                                                                                 m_period_separator(period_separator),
                                                                                                                                 m_period_start_delimeter(period_start_delimeter),
                                                                                                                                 m_open_range_end_delimeter(period_open_range_end_delimeter),
                                                                                                                                 m_closed_range_end_delimeter(period_closed_range_end_delimeter)
        {
        }
        OutItrT put_period_separator(OutItrT &oitr) const
        {
            const_itr_type ci = m_period_separator.begin();
            while (ci != m_period_separator.end())
            {
                *oitr = *ci;
                ci++;
            }
            return oitr;
        }
        OutItrT put_period_start_delimeter(OutItrT &oitr) const
        {
            const_itr_type ci = m_period_start_delimeter.begin();
            while (ci != m_period_start_delimeter.end())
            {
                *oitr = *ci;
                ci++;
            }
            return oitr;
        }
        OutItrT put_period_end_delimeter(OutItrT &oitr) const
        {
            const_itr_type ci, end;
            if (m_range_option == AS_OPEN_RANGE)
            {
                ci = m_open_range_end_delimeter.begin();
                end = m_open_range_end_delimeter.end();
            }
            else
            {
                ci = m_closed_range_end_delimeter.begin();
                end = m_closed_range_end_delimeter.end();
            }
            while (ci != end)
            {
                *oitr = *ci;
                ci++;
            }
            return oitr;
        }
        range_display_options range_option() const
        {
            return m_range_option;
        }
        void
        range_option(range_display_options option) const
        {
            m_range_option = option;
        }
        void delimiter_strings(const string_type &separator,
                               const string_type &start_delim,
                               const string_type &open_end_delim,
                               const string_type &closed_end_delim)
        {
            m_period_separator = separator;
            m_period_start_delimeter = start_delim;
            m_open_range_end_delimeter = open_end_delim;
            m_closed_range_end_delimeter = closed_end_delim;
        }
        template <class period_type, class facet_type>
        OutItrT put_period(OutItrT next,
                           std::ios_base &a_ios,
                           char_type a_fill,
                           const period_type &p,
                           const facet_type &facet) const
        {
            put_period_start_delimeter(next);
            next = facet.put(next, a_ios, a_fill, p.begin());
            put_period_separator(next);
            if (m_range_option == AS_CLOSED_RANGE)
            {
                facet.put(next, a_ios, a_fill, p.last());
            }
            else
            {
                facet.put(next, a_ios, a_fill, p.end());
            }
            put_period_end_delimeter(next);
            return next;
        }

    private:
        range_display_options m_range_option;
        string_type m_period_separator;
        string_type m_period_start_delimeter;
        string_type m_open_range_end_delimeter;
        string_type m_closed_range_end_delimeter;
};
template <class CharT, class OutItrT>
const typename period_formatter<CharT, OutItrT>::char_type
    period_formatter<CharT, OutItrT>::default_period_separator[2] = {'/'};
template <class CharT, class OutItrT>
const typename period_formatter<CharT, OutItrT>::char_type
    period_formatter<CharT, OutItrT>::default_period_start_delimeter[2] = {'['};
template <class CharT, class OutItrT>
const typename period_formatter<CharT, OutItrT>::char_type
    period_formatter<CharT, OutItrT>::default_period_open_range_end_delimeter[2] = {')'};
template <class CharT, class OutItrT>
const typename period_formatter<CharT, OutItrT>::char_type
    period_formatter<CharT, OutItrT>::default_period_closed_range_end_delimeter[2] = {']'};
    }
}
namespace boost
{
    template <class T>
    struct type_identity
    {
typedef T type;
    };
}
namespace boost
{
    template <typename F>
    struct result_of;
    template <typename F>
    struct tr1_result_of;
    namespace detail
    {
typedef char result_of_yes_type;
typedef char (&result_of_no_type)[2];
template <class T>
struct result_of_has_type
{
};
template <class T>
struct result_of_has_result_type_impl
{
        template <class U>
        static result_of_yes_type f(result_of_has_type<typename U::result_type> *);
        template <class U>
        static result_of_no_type f(...);
        typedef boost::integral_constant<bool, sizeof(f<T>(0)) == sizeof(result_of_yes_type)> type;
};
template <class T>
struct result_of_has_result_type : result_of_has_result_type_impl<T>::type
{
};
template <typename F, typename FArgs, bool HasResultType>
struct tr1_result_of_impl;
template <typename F>
struct cpp0x_result_of;
template <typename T>
struct result_of_always_void
{
        typedef void type;
};
template <typename F, typename Enable = void>
struct cpp0x_result_of_impl
{
};
template <typename F>
struct result_of_void_impl
{
        typedef void type;
};
template <typename R>
struct result_of_void_impl<R (*)(void)>
{
        typedef R type;
};
template <typename R>
struct result_of_void_impl<R (&)(void)>
{
        typedef R type;
};
template <typename F, typename FArgs>
struct result_of_pointer
    : tr1_result_of_impl<typename remove_cv<F>::type, FArgs, false>
{
};
template <typename F, typename FArgs>
struct tr1_result_of_impl<F, FArgs, true>
{
        typedef typename F::result_type type;
};
template <typename FArgs>
struct is_function_with_no_args : false_type
{
};
template <typename F>
struct is_function_with_no_args<F(void)> : true_type
{
};
template <typename F, typename FArgs>
struct result_of_nested_result : F::template result<FArgs>
{
};
template <typename F, typename FArgs>
struct tr1_result_of_impl<F, FArgs, false>
    : conditional<is_function_with_no_args<FArgs>::value,
                  result_of_void_impl<F>,
                  result_of_nested_result<F, FArgs>>::type
{
};
    }

    template <typename F>
    struct tr1_result_of<F()>
        : conditional<
              is_pointer<F>::value || is_member_function_pointer<F>::value, boost::detail::tr1_result_of_impl<typename remove_cv<F>::type, typename remove_cv<F>::type(), (boost::detail::result_of_has_result_type<F>::value)>, boost::detail::tr1_result_of_impl<F, F(), (boost::detail::result_of_has_result_type<F>::value)>>::type
    {
    };
    template <typename F>
    struct result_of<F()>
        : tr1_result_of<F()>
    {
    };
    template <typename F, typename T0>
    struct tr1_result_of<F(T0)>
        : conditional<
              is_pointer<F>::value || is_member_function_pointer<F>::value, boost::detail::tr1_result_of_impl<typename remove_cv<F>::type, typename remove_cv<F>::type(T0), (boost::detail::result_of_has_result_type<F>::value)>, boost::detail::tr1_result_of_impl<F, F(T0), (boost::detail::result_of_has_result_type<F>::value)>>::type
    {
    };
    template <typename F, typename T0>
    struct result_of<F(T0)>
        : tr1_result_of<F(T0)>
    {
    };
    namespace detail
    {
template <typename R, typename FArgs, typename T0>
struct tr1_result_of_impl<R (*)(T0), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0>
struct tr1_result_of_impl<R (&)(T0), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0>
struct tr1_result_of_impl<R (T0::*)(),
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0>
struct tr1_result_of_impl<R (T0::*)()
                              const,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0>
struct tr1_result_of_impl<R (T0::*)() volatile,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0>
struct tr1_result_of_impl<R (T0::*)()
                              const volatile,
                          FArgs, false>
{
        typedef R type;
};
    }
    template <typename F, typename T0, typename T1>
    struct tr1_result_of<F(T0, T1)>
        : conditional<
              is_pointer<F>::value || is_member_function_pointer<F>::value, boost::detail::tr1_result_of_impl<typename remove_cv<F>::type, typename remove_cv<F>::type(T0, T1), (boost::detail::result_of_has_result_type<F>::value)>, boost::detail::tr1_result_of_impl<F, F(T0, T1), (boost::detail::result_of_has_result_type<F>::value)>>::type
    {
    };
    template <typename F, typename T0, typename T1>
    struct result_of<F(T0, T1)>
        : tr1_result_of<F(T0, T1)>
    {
    };
    namespace detail
    {
template <typename R, typename FArgs, typename T0, typename T1>
struct tr1_result_of_impl<R (*)(T0, T1), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1>
struct tr1_result_of_impl<R (&)(T0, T1), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1>
struct tr1_result_of_impl<R (T0::*)(T1),
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1>
struct tr1_result_of_impl<R (T0::*)(T1)
                              const,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1>
struct tr1_result_of_impl<R (T0::*)(T1) volatile,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1>
struct tr1_result_of_impl<R (T0::*)(T1)
                              const volatile,
                          FArgs, false>
{
        typedef R type;
};
    }
    template <typename F, typename T0, typename T1, typename T2>
    struct tr1_result_of<F(T0, T1, T2)>
        : conditional<
              is_pointer<F>::value || is_member_function_pointer<F>::value, boost::detail::tr1_result_of_impl<typename remove_cv<F>::type, typename remove_cv<F>::type(T0, T1, T2), (boost::detail::result_of_has_result_type<F>::value)>, boost::detail::tr1_result_of_impl<F, F(T0, T1, T2), (boost::detail::result_of_has_result_type<F>::value)>>::type
    {
    };
    template <typename F, typename T0, typename T1, typename T2>
    struct result_of<F(T0, T1, T2)>
        : tr1_result_of<F(T0, T1, T2)>
    {
    };
    namespace detail
    {
template <typename R, typename FArgs, typename T0, typename T1, typename T2>
struct tr1_result_of_impl<R (*)(T0, T1, T2), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2>
struct tr1_result_of_impl<R (&)(T0, T1, T2), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2>
struct tr1_result_of_impl<R (T0::*)(T1, T2),
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2>
struct tr1_result_of_impl<R (T0::*)(T1, T2)
                              const,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2>
struct tr1_result_of_impl<R (T0::*)(T1, T2) volatile,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2>
struct tr1_result_of_impl<R (T0::*)(T1, T2)
                              const volatile,
                          FArgs, false>
{
        typedef R type;
};
    }
    template <typename F, typename T0, typename T1, typename T2, typename T3>
    struct tr1_result_of<F(T0, T1, T2, T3)>
        : conditional<
              is_pointer<F>::value || is_member_function_pointer<F>::value, boost::detail::tr1_result_of_impl<typename remove_cv<F>::type, typename remove_cv<F>::type(T0, T1, T2, T3), (boost::detail::result_of_has_result_type<F>::value)>, boost::detail::tr1_result_of_impl<F, F(T0, T1, T2, T3), (boost::detail::result_of_has_result_type<F>::value)>>::type
    {
    };
    template <typename F, typename T0, typename T1, typename T2, typename T3>
    struct result_of<F(T0, T1, T2, T3)>
        : tr1_result_of<F(T0, T1, T2, T3)>
    {
    };
    namespace detail
    {
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3>
struct tr1_result_of_impl<R (*)(T0, T1, T2, T3), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3>
struct tr1_result_of_impl<R (&)(T0, T1, T2, T3), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3),
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3)
                              const,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3) volatile,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3)
                              const volatile,
                          FArgs, false>
{
        typedef R type;
};
    }
    template <typename F, typename T0, typename T1, typename T2, typename T3, typename T4>
    struct tr1_result_of<F(T0, T1, T2, T3, T4)>
        : conditional<
              is_pointer<F>::value || is_member_function_pointer<F>::value, boost::detail::tr1_result_of_impl<typename remove_cv<F>::type, typename remove_cv<F>::type(T0, T1, T2, T3, T4), (boost::detail::result_of_has_result_type<F>::value)>, boost::detail::tr1_result_of_impl<F, F(T0, T1, T2, T3, T4), (boost::detail::result_of_has_result_type<F>::value)>>::type
    {
    };
    template <typename F, typename T0, typename T1, typename T2, typename T3, typename T4>
    struct result_of<F(T0, T1, T2, T3, T4)>
        : tr1_result_of<F(T0, T1, T2, T3, T4)>
    {
    };
    namespace detail
    {
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4>
struct tr1_result_of_impl<R (*)(T0, T1, T2, T3, T4), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4>
struct tr1_result_of_impl<R (&)(T0, T1, T2, T3, T4), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4),
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4)
                              const,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4) volatile,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4)
                              const volatile,
                          FArgs, false>
{
        typedef R type;
};
    }
    template <typename F, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
    struct tr1_result_of<F(T0, T1, T2, T3, T4, T5)>
        : conditional<
              is_pointer<F>::value || is_member_function_pointer<F>::value, boost::detail::tr1_result_of_impl<typename remove_cv<F>::type, typename remove_cv<F>::type(T0, T1, T2, T3, T4, T5), (boost::detail::result_of_has_result_type<F>::value)>, boost::detail::tr1_result_of_impl<F, F(T0, T1, T2, T3, T4, T5), (boost::detail::result_of_has_result_type<F>::value)>>::type
    {
    };
    template <typename F, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
    struct result_of<F(T0, T1, T2, T3, T4, T5)>
        : tr1_result_of<F(T0, T1, T2, T3, T4, T5)>
    {
    };
    namespace detail
    {
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
struct tr1_result_of_impl<R (*)(T0, T1, T2, T3, T4, T5), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
struct tr1_result_of_impl<R (&)(T0, T1, T2, T3, T4, T5), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5),
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5)
                              const,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5) volatile,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5)
                              const volatile,
                          FArgs, false>
{
        typedef R type;
};
    }
    template <typename F, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
    struct tr1_result_of<F(T0, T1, T2, T3, T4, T5, T6)>
        : conditional<
              is_pointer<F>::value || is_member_function_pointer<F>::value, boost::detail::tr1_result_of_impl<typename remove_cv<F>::type, typename remove_cv<F>::type(T0, T1, T2, T3, T4, T5, T6), (boost::detail::result_of_has_result_type<F>::value)>, boost::detail::tr1_result_of_impl<F, F(T0, T1, T2, T3, T4, T5, T6), (boost::detail::result_of_has_result_type<F>::value)>>::type
    {
    };
    template <typename F, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
    struct result_of<F(T0, T1, T2, T3, T4, T5, T6)>
        : tr1_result_of<F(T0, T1, T2, T3, T4, T5, T6)>
    {
    };
    namespace detail
    {
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
struct tr1_result_of_impl<R (*)(T0, T1, T2, T3, T4, T5, T6), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
struct tr1_result_of_impl<R (&)(T0, T1, T2, T3, T4, T5, T6), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6),
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6)
                              const,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6) volatile,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6)
                              const volatile,
                          FArgs, false>
{
        typedef R type;
};
    }
    template <typename F, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
    struct tr1_result_of<F(T0, T1, T2, T3, T4, T5, T6, T7)>
        : conditional<
              is_pointer<F>::value || is_member_function_pointer<F>::value, boost::detail::tr1_result_of_impl<typename remove_cv<F>::type, typename remove_cv<F>::type(T0, T1, T2, T3, T4, T5, T6, T7), (boost::detail::result_of_has_result_type<F>::value)>, boost::detail::tr1_result_of_impl<F, F(T0, T1, T2, T3, T4, T5, T6, T7), (boost::detail::result_of_has_result_type<F>::value)>>::type
    {
    };
    template <typename F, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
    struct result_of<F(T0, T1, T2, T3, T4, T5, T6, T7)>
        : tr1_result_of<F(T0, T1, T2, T3, T4, T5, T6, T7)>
    {
    };
    namespace detail
    {
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
struct tr1_result_of_impl<R (*)(T0, T1, T2, T3, T4, T5, T6, T7), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
struct tr1_result_of_impl<R (&)(T0, T1, T2, T3, T4, T5, T6, T7), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7),
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7)
                              const,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7) volatile,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7)
                              const volatile,
                          FArgs, false>
{
        typedef R type;
};
    }
    template <typename F, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
    struct tr1_result_of<F(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
        : conditional<
              is_pointer<F>::value || is_member_function_pointer<F>::value, boost::detail::tr1_result_of_impl<typename remove_cv<F>::type, typename remove_cv<F>::type(T0, T1, T2, T3, T4, T5, T6, T7, T8), (boost::detail::result_of_has_result_type<F>::value)>, boost::detail::tr1_result_of_impl<F, F(T0, T1, T2, T3, T4, T5, T6, T7, T8), (boost::detail::result_of_has_result_type<F>::value)>>::type
    {
    };
    template <typename F, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
    struct result_of<F(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
        : tr1_result_of<F(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
    {
    };
    namespace detail
    {
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
struct tr1_result_of_impl<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
struct tr1_result_of_impl<R (&)(T0, T1, T2, T3, T4, T5, T6, T7, T8), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8),
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8)
                              const,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8) volatile,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8)
                              const volatile,
                          FArgs, false>
{
        typedef R type;
};
    }
    template <typename F, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
    struct tr1_result_of<F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
        : conditional<
              is_pointer<F>::value || is_member_function_pointer<F>::value, boost::detail::tr1_result_of_impl<typename remove_cv<F>::type, typename remove_cv<F>::type(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9), (boost::detail::result_of_has_result_type<F>::value)>, boost::detail::tr1_result_of_impl<F, F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9), (boost::detail::result_of_has_result_type<F>::value)>>::type
    {
    };
    template <typename F, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
    struct result_of<F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
        : tr1_result_of<F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
    {
    };
    namespace detail
    {
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
struct tr1_result_of_impl<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
struct tr1_result_of_impl<R (&)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9),
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9)
                              const,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9) volatile,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9)
                              const volatile,
                          FArgs, false>
{
        typedef R type;
};
    }
    template <typename F, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10>
    struct tr1_result_of<F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
        : conditional<
              is_pointer<F>::value || is_member_function_pointer<F>::value, boost::detail::tr1_result_of_impl<typename remove_cv<F>::type, typename remove_cv<F>::type(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10), (boost::detail::result_of_has_result_type<F>::value)>, boost::detail::tr1_result_of_impl<F, F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10), (boost::detail::result_of_has_result_type<F>::value)>>::type
    {
    };
    template <typename F, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10>
    struct result_of<F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
        : tr1_result_of<F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
    {
    };
    namespace detail
    {
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10>
struct tr1_result_of_impl<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10>
struct tr1_result_of_impl<R (&)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10),
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)
                              const,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) volatile,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)
                              const volatile,
                          FArgs, false>
{
        typedef R type;
};
    }
    template <typename F, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11>
    struct tr1_result_of<F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
        : conditional<
              is_pointer<F>::value || is_member_function_pointer<F>::value, boost::detail::tr1_result_of_impl<typename remove_cv<F>::type, typename remove_cv<F>::type(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11), (boost::detail::result_of_has_result_type<F>::value)>, boost::detail::tr1_result_of_impl<F, F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11), (boost::detail::result_of_has_result_type<F>::value)>>::type
    {
    };
    template <typename F, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11>
    struct result_of<F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
        : tr1_result_of<F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
    {
    };
    namespace detail
    {
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11>
struct tr1_result_of_impl<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11>
struct tr1_result_of_impl<R (&)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11),
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)
                              const,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) volatile,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)
                              const volatile,
                          FArgs, false>
{
        typedef R type;
};
    }
    template <typename F, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12>
    struct tr1_result_of<F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
        : conditional<
              is_pointer<F>::value || is_member_function_pointer<F>::value, boost::detail::tr1_result_of_impl<typename remove_cv<F>::type, typename remove_cv<F>::type(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12), (boost::detail::result_of_has_result_type<F>::value)>, boost::detail::tr1_result_of_impl<F, F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12), (boost::detail::result_of_has_result_type<F>::value)>>::type
    {
    };
    template <typename F, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12>
    struct result_of<F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
        : tr1_result_of<F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
    {
    };
    namespace detail
    {
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12>
struct tr1_result_of_impl<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12>
struct tr1_result_of_impl<R (&)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12),
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)
                              const,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) volatile,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)
                              const volatile,
                          FArgs, false>
{
        typedef R type;
};
    }
    template <typename F, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13>
    struct tr1_result_of<F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
        : conditional<
              is_pointer<F>::value || is_member_function_pointer<F>::value, boost::detail::tr1_result_of_impl<typename remove_cv<F>::type, typename remove_cv<F>::type(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13), (boost::detail::result_of_has_result_type<F>::value)>, boost::detail::tr1_result_of_impl<F, F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13), (boost::detail::result_of_has_result_type<F>::value)>>::type
    {
    };
    template <typename F, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13>
    struct result_of<F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
        : tr1_result_of<F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
    {
    };
    namespace detail
    {
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13>
struct tr1_result_of_impl<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13>
struct tr1_result_of_impl<R (&)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13),
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)
                              const,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) volatile,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)
                              const volatile,
                          FArgs, false>
{
        typedef R type;
};
    }
    template <typename F, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14>
    struct tr1_result_of<F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)>
        : conditional<
              is_pointer<F>::value || is_member_function_pointer<F>::value, boost::detail::tr1_result_of_impl<typename remove_cv<F>::type, typename remove_cv<F>::type(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14), (boost::detail::result_of_has_result_type<F>::value)>, boost::detail::tr1_result_of_impl<F, F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14), (boost::detail::result_of_has_result_type<F>::value)>>::type
    {
    };
    template <typename F, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14>
    struct result_of<F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)>
        : tr1_result_of<F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)>
    {
    };
    namespace detail
    {
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14>
struct tr1_result_of_impl<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14>
struct tr1_result_of_impl<R (&)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14),
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)
                              const,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) volatile,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)
                              const volatile,
                          FArgs, false>
{
        typedef R type;
};
    }
    template <typename F, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15>
    struct tr1_result_of<F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)>
        : conditional<
              is_pointer<F>::value || is_member_function_pointer<F>::value, boost::detail::tr1_result_of_impl<typename remove_cv<F>::type, typename remove_cv<F>::type(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15), (boost::detail::result_of_has_result_type<F>::value)>, boost::detail::tr1_result_of_impl<F, F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15), (boost::detail::result_of_has_result_type<F>::value)>>::type
    {
    };
    template <typename F, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15>
    struct result_of<F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)>
        : tr1_result_of<F(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)>
    {
    };
    namespace detail
    {
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15>
struct tr1_result_of_impl<R (*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15>
struct tr1_result_of_impl<R (&)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15), FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15),
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)
                              const,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) volatile,
                          FArgs, false>
{
        typedef R type;
};
template <typename R, typename FArgs, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15>
struct tr1_result_of_impl<R (T0::*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)
                              const volatile,
                          FArgs, false>
{
        typedef R type;
};
    }
}
namespace boost
{
    namespace iterators
    {
template <class UnaryFunction, class Iterator, class Reference = use_default, class Value = use_default>
class transform_iterator;
namespace detail
{
        template <class UnaryFunc, class Iterator, class Reference, class Value>
        struct transform_iterator_base
        {
        private:
            typedef typename ia_dflt_help<
                Reference, result_of<const UnaryFunc(typename std::iterator_traits<Iterator>::reference)>>::type reference;
            typedef typename ia_dflt_help<
                Value, remove_reference<reference>>::type cv_value_type;

        public:
            typedef iterator_adaptor<
                transform_iterator<UnaryFunc, Iterator, Reference, Value>, Iterator, cv_value_type, use_default, reference>
                type;
        };
}
template <class UnaryFunc, class Iterator, class Reference, class Value>
class transform_iterator
    : public boost::iterators::detail::transform_iterator_base<UnaryFunc, Iterator, Reference, Value>::type
{
        typedef typename boost::iterators::detail::transform_iterator_base<UnaryFunc, Iterator, Reference, Value>::type
            super_t;
        friend class iterator_core_access;

    public:
        transform_iterator() {}
        transform_iterator(Iterator const &x, UnaryFunc f)
            : super_t(x), m_f(f) {}
        explicit transform_iterator(Iterator const &x)
            : super_t(x)
        {
            typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<((is_class<UnaryFunc>::value) != 0)>)> boost_static_assert_typedef_106;
        }
        template <
            class OtherUnaryFunction, class OtherIterator, class OtherReference, class OtherValue>
        transform_iterator(
            transform_iterator<OtherUnaryFunction, OtherIterator, OtherReference, OtherValue> const &t, typename enable_if_convertible<OtherIterator, Iterator>::type * = 0, typename enable_if_convertible<OtherUnaryFunction, UnaryFunc>::type * = 0)
            : super_t(t.base()), m_f(t.functor())
        {
        }
        UnaryFunc functor() const
        {
            return m_f;
        }

    private:
        typename super_t::reference dereference() const
        {
            return m_f(*this->base());
        }
        UnaryFunc m_f;
};
template <class UnaryFunc, class Iterator>
inline transform_iterator<UnaryFunc, Iterator>
make_transform_iterator(Iterator it, UnaryFunc fun)
{
        return transform_iterator<UnaryFunc, Iterator>(it, fun);
}
template <class UnaryFunc, class Iterator>
inline typename iterators::enable_if<
    is_class<UnaryFunc>, transform_iterator<UnaryFunc, Iterator>>::type
make_transform_iterator(Iterator it)
{
        return transform_iterator<UnaryFunc, Iterator>(it, UnaryFunc());
}
    }
    using iterators::make_transform_iterator;
    using iterators::transform_iterator;
}
namespace boost
{
    namespace algorithm
    {
namespace detail
{
        template <typename CharT>
        struct to_lowerF
        {
            typedef CharT argument_type;
            typedef CharT result_type;
            to_lowerF(const std::locale &Loc) : m_Loc(&Loc) {}
            CharT operator()(CharT Ch) const
            {
                return std::tolower<CharT>(Ch, *m_Loc);
            }

        private:
            const std::locale *m_Loc;
        };
        template <typename CharT>
        struct to_upperF
        {
            typedef CharT argument_type;
            typedef CharT result_type;
            to_upperF(const std::locale &Loc) : m_Loc(&Loc) {}
            CharT operator()(CharT Ch) const
            {
                return std::toupper<CharT>(Ch, *m_Loc);
            }

        private:
            const std::locale *m_Loc;
        };
        template <typename OutputIteratorT, typename RangeT, typename FunctorT>
        OutputIteratorT transform_range_copy(
            OutputIteratorT Output,
            const RangeT &Input,
            FunctorT Functor)
        {
            return std::transform(
                ::boost::begin(Input),
                ::boost::end(Input),
                Output,
                Functor);
        }
        template <typename RangeT, typename FunctorT>
        void transform_range(
            const RangeT &Input,
            FunctorT Functor)
        {
            std::transform(
                ::boost::begin(Input),
                ::boost::end(Input),
                ::boost::begin(Input),
                Functor);
        }
        template <typename SequenceT, typename RangeT, typename FunctorT>
        inline SequenceT transform_range_copy(
            const RangeT &Input,
            FunctorT Functor)
        {
            return SequenceT(
                ::boost::make_transform_iterator(
                    ::boost::begin(Input),
                    Functor),
                ::boost::make_transform_iterator(
                    ::boost::end(Input),
                    Functor));
        }
}
    }
}
namespace boost
{
    namespace algorithm
    {
template <typename OutputIteratorT, typename RangeT>
inline OutputIteratorT
to_lower_copy(
    OutputIteratorT Output,
    const RangeT &Input,
    const std::locale &Loc = std::locale())
{
        return ::boost::algorithm::detail::transform_range_copy(
            Output,
            ::boost::as_literal(Input),
            ::boost::algorithm::detail::to_lowerF<
                typename range_value<RangeT>::type>(Loc));
}
template <typename SequenceT>
inline SequenceT to_lower_copy(
    const SequenceT &Input,
    const std::locale &Loc = std::locale())
{
        return ::boost::algorithm::detail::transform_range_copy<SequenceT>(
            Input,
            ::boost::algorithm::detail::to_lowerF<
                typename range_value<SequenceT>::type>(Loc));
}
template <typename WritableRangeT>
inline void to_lower(
    WritableRangeT &Input,
    const std::locale &Loc = std::locale())
{
        ::boost::algorithm::detail::transform_range(
            ::boost::as_literal(Input),
            ::boost::algorithm::detail::to_lowerF<
                typename range_value<WritableRangeT>::type>(Loc));
}
template <typename OutputIteratorT, typename RangeT>
inline OutputIteratorT
to_upper_copy(
    OutputIteratorT Output,
    const RangeT &Input,
    const std::locale &Loc = std::locale())
{
        return ::boost::algorithm::detail::transform_range_copy(
            Output,
            ::boost::as_literal(Input),
            ::boost::algorithm::detail::to_upperF<
                typename range_value<RangeT>::type>(Loc));
}
template <typename SequenceT>
inline SequenceT to_upper_copy(
    const SequenceT &Input,
    const std::locale &Loc = std::locale())
{
        return ::boost::algorithm::detail::transform_range_copy<SequenceT>(
            Input,
            ::boost::algorithm::detail::to_upperF<
                typename range_value<SequenceT>::type>(Loc));
}
template <typename WritableRangeT>
inline void to_upper(
    WritableRangeT &Input,
    const std::locale &Loc = std::locale())
{
        ::boost::algorithm::detail::transform_range(
            ::boost::as_literal(Input),
            ::boost::algorithm::detail::to_upperF<
                typename range_value<WritableRangeT>::type>(Loc));
}
    }
    using algorithm::to_lower;
    using algorithm::to_lower_copy;
    using algorithm::to_upper;
    using algorithm::to_upper_copy;
}

extern "C"
{
    void __assert_rtn(const char *, const char *, int, const char *);
}
namespace std
{
    inline namespace __1
    {
template <class, class, class, class>
class map;
template <class, class, class, class>
class multimap;
template <class, class, class>
class set;
template <class, class, class>
class multiset;
template <class _Tp, class _Compare, class _Allocator>
class __tree;
template <class _Tp, class _NodePtr, class _DiffType>
class __tree_iterator;
template <class _Tp, class _ConstNodePtr, class _DiffType>
class __tree_const_iterator;
template <class _Pointer>
class __tree_end_node;
template <class _VoidPtr>
class __tree_node_base;
template <class _Tp, class _VoidPtr>
class __tree_node;
template <class _Key, class _Value>
struct __value_type;
template <class _Allocator>
class __map_node_destructor;
template <class _TreeIterator>
class __map_iterator;
template <class _TreeIterator>
class __map_const_iterator;
template <class _NodePtr>
inline bool
__tree_is_left_child(_NodePtr __x) throw()
{
        return __x == __x->__parent_->__left_;
}
template <class _NodePtr>
unsigned
__tree_sub_invariant(_NodePtr __x)
{
        if (__x == __nullptr)
            return 1;
        if (__x->__left_ != __nullptr && __x->__left_->__parent_ != __x)
            return 0;
        if (__x->__right_ != __nullptr && __x->__right_->__parent_ != __x)
            return 0;
        if (__x->__left_ == __x->__right_ && __x->__left_ != __nullptr)
            return 0;
        if (!__x->__is_black_)
        {
            if (__x->__left_ && !__x->__left_->__is_black_)
                return 0;
            if (__x->__right_ && !__x->__right_->__is_black_)
                return 0;
        }
        unsigned __h = std::__tree_sub_invariant(__x->__left_);
        if (__h == 0)
            return 0;
        if (__h != std::__tree_sub_invariant(__x->__right_))
            return 0;
        return __h + __x->__is_black_;
}
template <class _NodePtr>
bool __tree_invariant(_NodePtr __root)
{
        if (__root == __nullptr)
            return true;
        if (__root->__parent_ == __nullptr)
            return false;
        if (!std::__tree_is_left_child(__root))
            return false;
        if (!__root->__is_black_)
            return false;
        return std::__tree_sub_invariant(__root) != 0;
}
template <class _NodePtr>
inline _NodePtr
__tree_min(_NodePtr __x) throw()
{
        ((void)0);
        while (__x->__left_ != __nullptr)
            __x = __x->__left_;
        return __x;
}
template <class _NodePtr>
inline _NodePtr
__tree_max(_NodePtr __x) throw()
{
        ((void)0);
        while (__x->__right_ != __nullptr)
            __x = __x->__right_;
        return __x;
}
template <class _NodePtr>
_NodePtr
__tree_next(_NodePtr __x) throw()
{
        ((void)0);
        if (__x->__right_ != __nullptr)
            return std::__tree_min(__x->__right_);
        while (!std::__tree_is_left_child(__x))
            __x = __x->__parent_unsafe();
        return __x->__parent_unsafe();
}
template <class _EndNodePtr, class _NodePtr>
inline _EndNodePtr
__tree_next_iter(_NodePtr __x) throw()
{
        ((void)0);
        if (__x->__right_ != __nullptr)
            return static_cast<_EndNodePtr>(std::__tree_min(__x->__right_));
        while (!std::__tree_is_left_child(__x))
            __x = __x->__parent_unsafe();
        return static_cast<_EndNodePtr>(__x->__parent_);
}
template <class _NodePtr, class _EndNodePtr>
inline _NodePtr
__tree_prev_iter(_EndNodePtr __x) throw()
{
        ((void)0);
        if (__x->__left_ != __nullptr)
            return std::__tree_max(__x->__left_);
        _NodePtr __xx = static_cast<_NodePtr>(__x);
        while (std::__tree_is_left_child(__xx))
            __xx = __xx->__parent_unsafe();
        return __xx->__parent_unsafe();
}
template <class _NodePtr>
_NodePtr
__tree_leaf(_NodePtr __x) throw()
{
        ((void)0);
        while (true)
        {
            if (__x->__left_ != __nullptr)
            {
                __x = __x->__left_;
                continue;
            }
            if (__x->__right_ != __nullptr)
            {
                __x = __x->__right_;
                continue;
            }
            break;
        }
        return __x;
}
template <class _NodePtr>
void __tree_left_rotate(_NodePtr __x) throw()
{
        ((void)0);
        ((void)0);
        _NodePtr __y = __x->__right_;
        __x->__right_ = __y->__left_;
        if (__x->__right_ != __nullptr)
            __x->__right_->__set_parent(__x);
        __y->__parent_ = __x->__parent_;
        if (std::__tree_is_left_child(__x))
            __x->__parent_->__left_ = __y;
        else
            __x->__parent_unsafe()->__right_ = __y;
        __y->__left_ = __x;
        __x->__set_parent(__y);
}
template <class _NodePtr>
void __tree_right_rotate(_NodePtr __x) throw()
{
        ((void)0);
        ((void)0);
        _NodePtr __y = __x->__left_;
        __x->__left_ = __y->__right_;
        if (__x->__left_ != __nullptr)
            __x->__left_->__set_parent(__x);
        __y->__parent_ = __x->__parent_;
        if (std::__tree_is_left_child(__x))
            __x->__parent_->__left_ = __y;
        else
            __x->__parent_unsafe()->__right_ = __y;
        __y->__right_ = __x;
        __x->__set_parent(__y);
}
template <class _NodePtr>
void __tree_balance_after_insert(_NodePtr __root, _NodePtr __x) throw()
{
        ((void)0);
        ((void)0);
        __x->__is_black_ = __x == __root;
        while (__x != __root && !__x->__parent_unsafe()->__is_black_)
        {
            if (std::__tree_is_left_child(__x->__parent_unsafe()))
            {
                _NodePtr __y = __x->__parent_unsafe()->__parent_unsafe()->__right_;
                if (__y != __nullptr && !__y->__is_black_)
                {
                    __x = __x->__parent_unsafe();
                    __x->__is_black_ = true;
                    __x = __x->__parent_unsafe();
                    __x->__is_black_ = __x == __root;
                    __y->__is_black_ = true;
                }
                else
                {
                    if (!std::__tree_is_left_child(__x))
                    {
                        __x = __x->__parent_unsafe();
                        std::__tree_left_rotate(__x);
                    }
                    __x = __x->__parent_unsafe();
                    __x->__is_black_ = true;
                    __x = __x->__parent_unsafe();
                    __x->__is_black_ = false;
                    std::__tree_right_rotate(__x);
                    break;
                }
            }
            else
            {
                _NodePtr __y = __x->__parent_unsafe()->__parent_->__left_;
                if (__y != __nullptr && !__y->__is_black_)
                {
                    __x = __x->__parent_unsafe();
                    __x->__is_black_ = true;
                    __x = __x->__parent_unsafe();
                    __x->__is_black_ = __x == __root;
                    __y->__is_black_ = true;
                }
                else
                {
                    if (std::__tree_is_left_child(__x))
                    {
                        __x = __x->__parent_unsafe();
                        std::__tree_right_rotate(__x);
                    }
                    __x = __x->__parent_unsafe();
                    __x->__is_black_ = true;
                    __x = __x->__parent_unsafe();
                    __x->__is_black_ = false;
                    std::__tree_left_rotate(__x);
                    break;
                }
            }
        }
}
template <class _NodePtr>
void __tree_remove(_NodePtr __root, _NodePtr __z) throw()
{
        ((void)0);
        ((void)0);
        ((void)0);
        _NodePtr __y = (__z->__left_ == __nullptr || __z->__right_ == __nullptr) ? __z : std::__tree_next(__z);
        _NodePtr __x = __y->__left_ != __nullptr ? __y->__left_ : __y->__right_;
        _NodePtr __w = __nullptr;
        if (__x != __nullptr)
            __x->__parent_ = __y->__parent_;
        if (std::__tree_is_left_child(__y))
        {
            __y->__parent_->__left_ = __x;
            if (__y != __root)
                __w = __y->__parent_unsafe()->__right_;
            else
                __root = __x;
        }
        else
        {
            __y->__parent_unsafe()->__right_ = __x;
            __w = __y->__parent_->__left_;
        }
        bool __removed_black = __y->__is_black_;
        if (__y != __z)
        {
            __y->__parent_ = __z->__parent_;
            if (std::__tree_is_left_child(__z))
                __y->__parent_->__left_ = __y;
            else
                __y->__parent_unsafe()->__right_ = __y;
            __y->__left_ = __z->__left_;
            __y->__left_->__set_parent(__y);
            __y->__right_ = __z->__right_;
            if (__y->__right_ != __nullptr)
                __y->__right_->__set_parent(__y);
            __y->__is_black_ = __z->__is_black_;
            if (__root == __z)
                __root = __y;
        }
        if (__removed_black && __root != __nullptr)
        {
            if (__x != __nullptr)
                __x->__is_black_ = true;
            else
            {
                while (true)
                {
                    if (!std::__tree_is_left_child(__w))
                    {
                        if (!__w->__is_black_)
                        {
                            __w->__is_black_ = true;
                            __w->__parent_unsafe()->__is_black_ = false;
                            std::__tree_left_rotate(__w->__parent_unsafe());
                            if (__root == __w->__left_)
                                __root = __w;
                            __w = __w->__left_->__right_;
                        }
                        if ((__w->__left_ == __nullptr || __w->__left_->__is_black_) &&
                            (__w->__right_ == __nullptr || __w->__right_->__is_black_))
                        {
                            __w->__is_black_ = false;
                            __x = __w->__parent_unsafe();
                            if (__x == __root || !__x->__is_black_)
                            {
                                __x->__is_black_ = true;
                                break;
                            }
                            __w = std::__tree_is_left_child(__x) ? __x->__parent_unsafe()->__right_ : __x->__parent_->__left_;
                        }
                        else
                        {
                            if (__w->__right_ == __nullptr || __w->__right_->__is_black_)
                            {
                                __w->__left_->__is_black_ = true;
                                __w->__is_black_ = false;
                                std::__tree_right_rotate(__w);
                                __w = __w->__parent_unsafe();
                            }
                            __w->__is_black_ = __w->__parent_unsafe()->__is_black_;
                            __w->__parent_unsafe()->__is_black_ = true;
                            __w->__right_->__is_black_ = true;
                            std::__tree_left_rotate(__w->__parent_unsafe());
                            break;
                        }
                    }
                    else
                    {
                        if (!__w->__is_black_)
                        {
                            __w->__is_black_ = true;
                            __w->__parent_unsafe()->__is_black_ = false;
                            std::__tree_right_rotate(__w->__parent_unsafe());
                            if (__root == __w->__right_)
                                __root = __w;
                            __w = __w->__right_->__left_;
                        }
                        if ((__w->__left_ == __nullptr || __w->__left_->__is_black_) &&
                            (__w->__right_ == __nullptr || __w->__right_->__is_black_))
                        {
                            __w->__is_black_ = false;
                            __x = __w->__parent_unsafe();
                            if (!__x->__is_black_ || __x == __root)
                            {
                                __x->__is_black_ = true;
                                break;
                            }
                            __w = std::__tree_is_left_child(__x) ? __x->__parent_unsafe()->__right_ : __x->__parent_->__left_;
                        }
                        else
                        {
                            if (__w->__left_ == __nullptr || __w->__left_->__is_black_)
                            {
                                __w->__right_->__is_black_ = true;
                                __w->__is_black_ = false;
                                std::__tree_left_rotate(__w);
                                __w = __w->__parent_unsafe();
                            }
                            __w->__is_black_ = __w->__parent_unsafe()->__is_black_;
                            __w->__parent_unsafe()->__is_black_ = true;
                            __w->__left_->__is_black_ = true;
                            std::__tree_right_rotate(__w->__parent_unsafe());
                            break;
                        }
                    }
                }
            }
        }
}
template <class _Tp>
struct __is_tree_value_type_imp : false_type
{
};
template <class _Key, class _Value>
struct __is_tree_value_type_imp<__value_type<_Key, _Value>> : true_type
{
};
template <class... _Args>
struct __is_tree_value_type : false_type
{
};
template <class _One>
struct __is_tree_value_type<_One> : __is_tree_value_type_imp<__uncvref_t<_One>>
{
};
template <class _Tp>
struct __tree_key_value_types
{
        typedef _Tp key_type;
        typedef _Tp __node_value_type;
        typedef _Tp __container_value_type;
        static const bool __is_map = false;

        static key_type const &__get_key(_Tp const &__v)
        {
            return __v;
        }

        static __container_value_type const &__get_value(__node_value_type const &__v)
        {
            return __v;
        }

        static __container_value_type *__get_ptr(__node_value_type &__n)
        {
            return std::addressof(__n);
        }

        static __container_value_type &&__move(__node_value_type &__v)
        {
            return std::move(__v);
        }
};
template <class _Key, class _Tp>
struct __tree_key_value_types<__value_type<_Key, _Tp>>
{
        typedef _Key key_type;
        typedef _Tp mapped_type;
        typedef __value_type<_Key, _Tp> __node_value_type;
        typedef pair<const _Key, _Tp> __container_value_type;
        typedef __container_value_type __map_value_type;
        static const bool __is_map = true;

        static key_type const &
        __get_key(__node_value_type const &__t)
        {
            return __t.__get_value().first;
        }
        template <class _Up>

        static __enable_if_t<__is_same_uncvref<_Up, __container_value_type>::value, key_type const &>
        __get_key(_Up &__t)
        {
            return __t.first;
        }

        static __container_value_type const &
        __get_value(__node_value_type const &__t)
        {
            return __t.__get_value();
        }
        template <class _Up>

        static __enable_if_t<__is_same_uncvref<_Up, __container_value_type>::value, __container_value_type const &>
        __get_value(_Up &__t)
        {
            return __t;
        }

        static __container_value_type *__get_ptr(__node_value_type &__n)
        {
            return std::addressof(__n.__get_value());
        }

        static pair<key_type &&, mapped_type &&> __move(__node_value_type &__v)
        {
            return __v.__move();
        }
};
template <class _VoidPtr>
struct __tree_node_base_types
{
        typedef _VoidPtr __void_pointer;
        typedef __tree_node_base<__void_pointer> __node_base_type;
        typedef typename __rebind_pointer<_VoidPtr, __node_base_type>::type
            __node_base_pointer;
        typedef __tree_end_node<__node_base_pointer> __end_node_type;
        typedef typename __rebind_pointer<_VoidPtr, __end_node_type>::type
            __end_node_pointer;
        typedef typename conditional<
            is_pointer<__end_node_pointer>::value,
            __end_node_pointer,
            __node_base_pointer>::type __parent_pointer;

    private:
        _Static_assert((is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value), "_VoidPtr does not point to unqualified void type");
};
template <class _Tp, class _AllocPtr, class _KVTypes = __tree_key_value_types<_Tp>,
          bool = _KVTypes::__is_map>
struct __tree_map_pointer_types
{
};
template <class _Tp, class _AllocPtr, class _KVTypes>
struct __tree_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true>
{
        typedef typename _KVTypes::__map_value_type _Mv;
        typedef typename __rebind_pointer<_AllocPtr, _Mv>::type
            __map_value_type_pointer;
        typedef typename __rebind_pointer<_AllocPtr, const _Mv>::type
            __const_map_value_type_pointer;
};
template <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type>
struct __tree_node_types;
template <class _NodePtr, class _Tp, class _VoidPtr>
struct __tree_node_types<_NodePtr, __tree_node<_Tp, _VoidPtr>>
    : public __tree_node_base_types<_VoidPtr>,
      __tree_key_value_types<_Tp>,
      __tree_map_pointer_types<_Tp, _VoidPtr>
{
        typedef __tree_node_base_types<_VoidPtr> __base;
        typedef __tree_key_value_types<_Tp> __key_base;
        typedef __tree_map_pointer_types<_Tp, _VoidPtr> __map_pointer_base;

    public:
        typedef typename pointer_traits<_NodePtr>::element_type __node_type;
        typedef _NodePtr __node_pointer;
        typedef _Tp __node_value_type;
        typedef typename __rebind_pointer<_VoidPtr, __node_value_type>::type
            __node_value_type_pointer;
        typedef typename __rebind_pointer<_VoidPtr, const __node_value_type>::type
            __const_node_value_type_pointer;
        typedef typename conditional<
            is_pointer<__node_pointer>::value,
            typename __base::__end_node_pointer,
            __node_pointer>::type __iter_pointer;

    private:
        _Static_assert(!is_const<__node_type>::value, "_NodePtr should never be a pointer to const");
        _Static_assert((is_same<typename __rebind_pointer<_VoidPtr, __node_type>::type, _NodePtr>::value), "_VoidPtr does not rebind to _NodePtr.");
};
template <class _ValueTp, class _VoidPtr>
struct __make_tree_node_types
{
        typedef typename __rebind_pointer<_VoidPtr, __tree_node<_ValueTp, _VoidPtr>>::type
            _NodePtr;
        typedef __tree_node_types<_NodePtr> type;
};
template <class _Pointer>
class __tree_end_node
{
    public:
        typedef _Pointer pointer;
        pointer __left_;

        __tree_end_node() throw() : __left_() {}
};
template <class _VoidPtr>
class __tree_node_base
    : public __tree_node_base_types<_VoidPtr>::__end_node_type
{
        typedef __tree_node_base_types<_VoidPtr> _NodeBaseTypes;

    public:
        typedef typename _NodeBaseTypes::__node_base_pointer pointer;
        typedef typename _NodeBaseTypes::__parent_pointer __parent_pointer;
        pointer __right_;
        __parent_pointer __parent_;
        bool __is_black_;

        pointer __parent_unsafe() const { return static_cast<pointer>(__parent_); }

        void __set_parent(pointer __p)
        {
            __parent_ = static_cast<__parent_pointer>(__p);
        }

    private:
        ~__tree_node_base() = delete;
        __tree_node_base(__tree_node_base const &) = delete;
        __tree_node_base &operator=(__tree_node_base const &) = delete;
};
template <class _Tp, class _VoidPtr>
class __tree_node
    : public __tree_node_base<_VoidPtr>
{
    public:
        typedef _Tp __node_value_type;
        __node_value_type __value_;

    private:
        ~__tree_node() = delete;
        __tree_node(__tree_node const &) = delete;
        __tree_node &operator=(__tree_node const &) = delete;
};
template <class _Allocator>
class __tree_node_destructor
{
        typedef _Allocator allocator_type;
        typedef allocator_traits<allocator_type> __alloc_traits;

    public:
        typedef typename __alloc_traits::pointer pointer;

    private:
        typedef __tree_node_types<pointer> _NodeTypes;
        allocator_type &__na_;

    public:
        bool __value_constructed;
        __tree_node_destructor(const __tree_node_destructor &) = default;
        __tree_node_destructor &operator=(const __tree_node_destructor &) = delete;

        explicit __tree_node_destructor(allocator_type &__na, bool __val = false) throw()
            : __na_(__na),
              __value_constructed(__val)
        {
        }

        void operator()(pointer __p) throw()
        {
            if (__value_constructed)
                __alloc_traits::destroy(__na_, _NodeTypes::__get_ptr(__p->__value_));
            if (__p)
                __alloc_traits::deallocate(__na_, __p, 1);
        }
        template <class>
        friend class __map_node_destructor;
};
template <class _Tp, class _NodePtr, class _DiffType>
class __tree_iterator
{
        typedef __tree_node_types<_NodePtr> _NodeTypes;
        typedef _NodePtr __node_pointer;
        typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
        typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;
        typedef typename _NodeTypes::__iter_pointer __iter_pointer;
        typedef pointer_traits<__node_pointer> __pointer_traits;
        __iter_pointer __ptr_;

    public:
        typedef bidirectional_iterator_tag iterator_category;
        typedef _Tp value_type;
        typedef _DiffType difference_type;
        typedef value_type &reference;
        typedef typename _NodeTypes::__node_value_type_pointer pointer;

        {
        }
        const
        {
            return __get_np()->__value_;
        }
        const
        {
            return pointer_traits<pointer>::pointer_to(__get_np()->__value_);
        }

        __tree_iterator &operator++()
        {
            __ptr_ = static_cast<__iter_pointer>(
                std::__tree_next_iter<__end_node_pointer>(static_cast<__node_base_pointer>(__ptr_)));
            return *this;
        }

        __tree_iterator operator++(int)
        {
            __tree_iterator __t(*this);
            ++(*this);
            return __t;
        }

        __tree_iterator &operator--()
        {
            __ptr_ = static_cast<__iter_pointer>(std::__tree_prev_iter<__node_base_pointer>(
                static_cast<__end_node_pointer>(__ptr_)));
            return *this;
        }

        __tree_iterator operator--(int)
        {
            __tree_iterator __t(*this);
            --(*this);
            return __t;
        }
        friend bool operator==(const __tree_iterator &__x, const __tree_iterator &__y)
        {
            return __x.__ptr_ == __y.__ptr_;
        }
        friend bool operator!=(const __tree_iterator &__x, const __tree_iterator &__y)
        {
            return !(__x == __y);
        }

    private:
        explicit __tree_iterator(__node_pointer __p) throw() : __ptr_(__p) {}

        explicit __tree_iterator(__end_node_pointer __p) throw() : __ptr_(__p) {}

        __node_pointer __get_np() const { return static_cast<__node_pointer>(__ptr_); }
        template <class, class, class>
        friend class __tree;
        template <class, class, class>
        friend class __tree_const_iterator;
        template <class>
        friend class __map_iterator;
        template <class, class, class, class>
        friend class map;
        template <class, class, class, class>
        friend class multimap;
        template <class, class, class>
        friend class set;
        template <class, class, class>
        friend class multiset;
};
template <class _Tp, class _NodePtr, class _DiffType>
class __tree_const_iterator
{
        typedef __tree_node_types<_NodePtr> _NodeTypes;
        typedef typename _NodeTypes::__node_pointer __node_pointer;
        typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
        typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;
        typedef typename _NodeTypes::__iter_pointer __iter_pointer;
        typedef pointer_traits<__node_pointer> __pointer_traits;
        __iter_pointer __ptr_;

    public:
        typedef bidirectional_iterator_tag iterator_category;
        typedef _Tp value_type;
        typedef _DiffType difference_type;
        typedef const value_type &reference;
        typedef typename _NodeTypes::__const_node_value_type_pointer pointer;

        {
        }

    private:
        typedef __tree_iterator<value_type, __node_pointer, difference_type>
            __non_const_iterator;

    public:
        __tree_const_iterator(__non_const_iterator __p) throw()
            : __ptr_(__p.__ptr_) {}
        const
        {
            return __get_np()->__value_;
        }
        const
        {
            return pointer_traits<pointer>::pointer_to(__get_np()->__value_);
        }

        __tree_const_iterator &operator++()
        {
            __ptr_ = static_cast<__iter_pointer>(
                std::__tree_next_iter<__end_node_pointer>(static_cast<__node_base_pointer>(__ptr_)));
            return *this;
        }

        __tree_const_iterator operator++(int)
        {
            __tree_const_iterator __t(*this);
            ++(*this);
            return __t;
        }

        __tree_const_iterator &operator--()
        {
            __ptr_ = static_cast<__iter_pointer>(std::__tree_prev_iter<__node_base_pointer>(
                static_cast<__end_node_pointer>(__ptr_)));
            return *this;
        }

        __tree_const_iterator operator--(int)
        {
            __tree_const_iterator __t(*this);
            --(*this);
            return __t;
        }
        friend bool operator==(const __tree_const_iterator &__x, const __tree_const_iterator &__y)
        {
            return __x.__ptr_ == __y.__ptr_;
        }
        friend bool operator!=(const __tree_const_iterator &__x, const __tree_const_iterator &__y)
        {
            return !(__x == __y);
        }

    private:
        explicit __tree_const_iterator(__node_pointer __p) throw()
            : __ptr_(__p) {}

        explicit __tree_const_iterator(__end_node_pointer __p) throw()
            : __ptr_(__p) {}

        __node_pointer __get_np() const { return static_cast<__node_pointer>(__ptr_); }
        template <class, class, class>
        friend class __tree;
        template <class, class, class, class>
        friend class map;
        template <class, class, class, class>
        friend class multimap;
        template <class, class, class>
        friend class set;
        template <class, class, class>
        friend class multiset;
        template <class>
        friend class __map_const_iterator;
};
template <class _Tp, class _Compare>
int __diagnose_non_const_comparator();
template <class _Tp, class _Compare, class _Allocator>
class __tree
{
    public:
        typedef _Tp value_type;
        typedef _Compare value_compare;
        typedef _Allocator allocator_type;

    private:
        typedef allocator_traits<allocator_type> __alloc_traits;
        typedef typename __make_tree_node_types<value_type,
                                                typename __alloc_traits::void_pointer>::type
            _NodeTypes;
        typedef typename _NodeTypes::key_type key_type;

    public:
        typedef typename _NodeTypes::__node_value_type __node_value_type;
        typedef typename _NodeTypes::__container_value_type __container_value_type;
        typedef typename __alloc_traits::pointer pointer;
        typedef typename __alloc_traits::const_pointer const_pointer;
        typedef typename __alloc_traits::size_type size_type;
        typedef typename __alloc_traits::difference_type difference_type;

    public:
        typedef typename _NodeTypes::__void_pointer __void_pointer;
        typedef typename _NodeTypes::__node_type __node;
        typedef typename _NodeTypes::__node_pointer __node_pointer;
        typedef typename _NodeTypes::__node_base_type __node_base;
        typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
        typedef typename _NodeTypes::__end_node_type __end_node_t;
        typedef typename _NodeTypes::__end_node_pointer __end_node_ptr;
        typedef typename _NodeTypes::__parent_pointer __parent_pointer;
        typedef typename _NodeTypes::__iter_pointer __iter_pointer;
        typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;
        typedef allocator_traits<__node_allocator> __node_traits;

    private:
        _Static_assert((is_same<__node_pointer, typename __node_traits::pointer>::value), "Allocator does not rebind pointers in a sane manner.");
        typedef typename __rebind_alloc_helper<__node_traits, __node_base>::type
            __node_base_allocator;
        typedef allocator_traits<__node_base_allocator> __node_base_traits;
        _Static_assert((is_same<__node_base_pointer, typename __node_base_traits::pointer>::value), "Allocator does not rebind pointers in a sane manner.");

    private:
        __iter_pointer __begin_node_;
        __compressed_pair<__end_node_t, __node_allocator> __pair1_;
        __compressed_pair<size_type, value_compare> __pair3_;

    public:
        __iter_pointer __end_node() throw()
        {
            return static_cast<__iter_pointer>(
                pointer_traits<__end_node_ptr>::pointer_to(__pair1_.first()));
        }

        __iter_pointer __end_node() const throw()
        {
            return static_cast<__iter_pointer>(
                pointer_traits<__end_node_ptr>::pointer_to(
                    const_cast<__end_node_t &>(__pair1_.first())));
        }

        __node_allocator &__node_alloc() throw() { return __pair1_.second(); }

    private:
        const __node_allocator &__node_alloc() const throw()
        {
            return __pair1_.second();
        }

        __iter_pointer &__begin_node() throw() { return __begin_node_; }

        const __iter_pointer &__begin_node() const throw() { return __begin_node_; }

    public:
        allocator_type __alloc() const throw()
        {
            return allocator_type(__node_alloc());
        }

    private:
        size_type &size() throw() { return __pair3_.first(); }

    public:
        const size_type &size() const throw() { return __pair3_.first(); }

        value_compare &value_comp() throw() { return __pair3_.second(); }

        const value_compare &value_comp() const throw()
        {
            return __pair3_.second();
        }

    public:
        __node_pointer __root() const throw()
        {
            return static_cast<__node_pointer>(__end_node()->__left_);
        }
        __node_base_pointer *__root_ptr() const throw()
        {
            return std::addressof(__end_node()->__left_);
        }
        typedef __tree_iterator<value_type, __node_pointer, difference_type> iterator;
        typedef __tree_const_iterator<value_type, __node_pointer, difference_type> const_iterator;
        explicit __tree(const value_compare &__comp);
        explicit __tree(const allocator_type &__a);
        __tree(const value_compare &__comp, const allocator_type &__a);
        __tree(const __tree &__t);
        __tree &operator=(const __tree &__t);
        template <class _ForwardIterator>
        void __assign_unique(_ForwardIterator __first, _ForwardIterator __last);
        template <class _InputIterator>
        void __assign_multi(_InputIterator __first, _InputIterator __last);
        __tree(__tree &&__t);
        __tree(__tree &&__t, const allocator_type &__a);
        __tree &operator=(__tree &&__t);
        ~__tree();

        iterator begin() throw() { return iterator(__begin_node()); }

        const_iterator begin() const throw() { return const_iterator(__begin_node()); }

        iterator end() throw() { return iterator(__end_node()); }

        const_iterator end() const throw() { return const_iterator(__end_node()); }

        size_type max_size() const throw()
        {
            return std::min<size_type>(
                __node_traits::max_size(__node_alloc()),
                numeric_limits<difference_type>::max());
        }
        void clear() throw();
        void swap(__tree &__t);
        template <class _Key, class... _Args>
        pair<iterator, bool>
        __emplace_unique_key_args(_Key const &, _Args &&...__args);
        template <class _Key, class... _Args>
        pair<iterator, bool>
        __emplace_hint_unique_key_args(const_iterator, _Key const &, _Args &&...);
        template <class... _Args>
        pair<iterator, bool> __emplace_unique_impl(_Args &&...__args);
        template <class... _Args>
        iterator __emplace_hint_unique_impl(const_iterator __p, _Args &&...__args);
        template <class... _Args>
        iterator __emplace_multi(_Args &&...__args);
        template <class... _Args>
        iterator __emplace_hint_multi(const_iterator __p, _Args &&...__args);
        template <class _Pp>

        pair<iterator, bool> __emplace_unique(_Pp &&__x)
        {
            return __emplace_unique_extract_key(std::forward<_Pp>(__x),
                                                __can_extract_key<_Pp, key_type>());
        }
        template <class _First, class _Second>

        __enable_if_t<__can_extract_map_key<_First, key_type, __container_value_type>::value, pair<iterator, bool>>
        __emplace_unique(_First &&__f, _Second &&__s)
        {
            return __emplace_unique_key_args(__f, std::forward<_First>(__f),
                                             std::forward<_Second>(__s));
        }
        template <class... _Args>

        pair<iterator, bool> __emplace_unique(_Args &&...__args)
        {
            return __emplace_unique_impl(std::forward<_Args>(__args)...);
        }
        template <class _Pp>

        pair<iterator, bool>
        __emplace_unique_extract_key(_Pp &&__x, __extract_key_fail_tag)
        {
            return __emplace_unique_impl(std::forward<_Pp>(__x));
        }
        template <class _Pp>

        pair<iterator, bool>
        __emplace_unique_extract_key(_Pp &&__x, __extract_key_self_tag)
        {
            return __emplace_unique_key_args(__x, std::forward<_Pp>(__x));
        }
        template <class _Pp>

        pair<iterator, bool>
        __emplace_unique_extract_key(_Pp &&__x, __extract_key_first_tag)
        {
            return __emplace_unique_key_args(__x.first, std::forward<_Pp>(__x));
        }
        template <class _Pp>

        iterator __emplace_hint_unique(const_iterator __p, _Pp &&__x)
        {
            return __emplace_hint_unique_extract_key(__p, std::forward<_Pp>(__x),
                                                     __can_extract_key<_Pp, key_type>());
        }
        template <class _First, class _Second>

        __enable_if_t<__can_extract_map_key<_First, key_type, __container_value_type>::value, iterator>
        __emplace_hint_unique(const_iterator __p, _First &&__f, _Second &&__s)
        {
            return __emplace_hint_unique_key_args(__p, __f,
                                                  std::forward<_First>(__f),
                                                  std::forward<_Second>(__s))
                .first;
        }
        template <class... _Args>

        iterator __emplace_hint_unique(const_iterator __p, _Args &&...__args)
        {
            return __emplace_hint_unique_impl(__p, std::forward<_Args>(__args)...);
        }
        template <class _Pp>

        iterator
        __emplace_hint_unique_extract_key(const_iterator __p, _Pp &&__x, __extract_key_fail_tag)
        {
            return __emplace_hint_unique_impl(__p, std::forward<_Pp>(__x));
        }
        template <class _Pp>

        iterator
        __emplace_hint_unique_extract_key(const_iterator __p, _Pp &&__x, __extract_key_self_tag)
        {
            return __emplace_hint_unique_key_args(__p, __x, std::forward<_Pp>(__x)).first;
        }
        template <class _Pp>

        iterator
        __emplace_hint_unique_extract_key(const_iterator __p, _Pp &&__x, __extract_key_first_tag)
        {
            return __emplace_hint_unique_key_args(__p, __x.first, std::forward<_Pp>(__x)).first;
        }

        pair<iterator, bool> __insert_unique(const __container_value_type &__v)
        {
            return __emplace_unique_key_args(_NodeTypes::__get_key(__v), __v);
        }

        iterator __insert_unique(const_iterator __p, const __container_value_type &__v)
        {
            return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), __v).first;
        }

        pair<iterator, bool> __insert_unique(__container_value_type &&__v)
        {
            return __emplace_unique_key_args(_NodeTypes::__get_key(__v), std::move(__v));
        }

        iterator __insert_unique(const_iterator __p, __container_value_type &&__v)
        {
            return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), std::move(__v)).first;
        }
        template <class _Vp,
                  class = __enable_if_t<!is_same<typename __unconstref<_Vp>::type, __container_value_type>::value>>

        pair<iterator, bool> __insert_unique(_Vp &&__v)
        {
            return __emplace_unique(std::forward<_Vp>(__v));
        }
        template <class _Vp,
                  class = __enable_if_t<!is_same<typename __unconstref<_Vp>::type, __container_value_type>::value>>

        iterator __insert_unique(const_iterator __p, _Vp &&__v)
        {
            return __emplace_hint_unique(__p, std::forward<_Vp>(__v));
        }

        iterator __insert_multi(__container_value_type &&__v)
        {
            return __emplace_multi(std::move(__v));
        }

        iterator __insert_multi(const_iterator __p, __container_value_type &&__v)
        {
            return __emplace_hint_multi(__p, std::move(__v));
        }
        template <class _Vp>

        iterator __insert_multi(_Vp &&__v)
        {
            return __emplace_multi(std::forward<_Vp>(__v));
        }
        template <class _Vp>

        iterator __insert_multi(const_iterator __p, _Vp &&__v)
        {
            return __emplace_hint_multi(__p, std::forward<_Vp>(__v));
        }

        pair<iterator, bool> __node_assign_unique(const __container_value_type &__v, __node_pointer __dest);

        iterator __node_insert_multi(__node_pointer __nd);

        iterator __node_insert_multi(const_iterator __p, __node_pointer __nd);
        iterator
            __remove_node_pointer(__node_pointer) throw();
        iterator erase(const_iterator __p);
        iterator erase(const_iterator __f, const_iterator __l);
        template <class _Key>
        size_type __erase_unique(const _Key &__k);
        template <class _Key>
        size_type __erase_multi(const _Key &__k);
        void __insert_node_at(__parent_pointer __parent,
                              __node_base_pointer &__child,
                              __node_base_pointer __new_node) throw();
        template <class _Key>
        iterator find(const _Key &__v);
        template <class _Key>
        const_iterator find(const _Key &__v) const;
        template <class _Key>
        size_type __count_unique(const _Key &__k) const;
        template <class _Key>
        size_type __count_multi(const _Key &__k) const;
        template <class _Key>

        iterator lower_bound(const _Key &__v)
        {
            return __lower_bound(__v, __root(), __end_node());
        }
        template <class _Key>
        iterator __lower_bound(const _Key &__v,
                               __node_pointer __root,
                               __iter_pointer __result);
        template <class _Key>

        const_iterator lower_bound(const _Key &__v) const
        {
            return __lower_bound(__v, __root(), __end_node());
        }
        template <class _Key>
        const_iterator __lower_bound(const _Key &__v,
                                     __node_pointer __root,
                                     __iter_pointer __result) const;
        template <class _Key>

        iterator upper_bound(const _Key &__v)
        {
            return __upper_bound(__v, __root(), __end_node());
        }
        template <class _Key>
        iterator __upper_bound(const _Key &__v,
                               __node_pointer __root,
                               __iter_pointer __result);
        template <class _Key>

        const_iterator upper_bound(const _Key &__v) const
        {
            return __upper_bound(__v, __root(), __end_node());
        }
        template <class _Key>
        const_iterator __upper_bound(const _Key &__v,
                                     __node_pointer __root,
                                     __iter_pointer __result) const;
        template <class _Key>
        pair<iterator, iterator>
        __equal_range_unique(const _Key &__k);
        template <class _Key>
        pair<const_iterator, const_iterator>
        __equal_range_unique(const _Key &__k) const;
        template <class _Key>
        pair<iterator, iterator>
        __equal_range_multi(const _Key &__k);
        template <class _Key>
        pair<const_iterator, const_iterator>
        __equal_range_multi(const _Key &__k) const;
        typedef __tree_node_destructor<__node_allocator> _Dp;
        typedef unique_ptr<__node, _Dp> __node_holder;
        __node_holder remove(const_iterator __p) throw();

    private:
        __node_base_pointer &
        __find_leaf_low(__parent_pointer &__parent, const key_type &__v);
        __node_base_pointer &
        __find_leaf_high(__parent_pointer &__parent, const key_type &__v);
        __node_base_pointer &
        __find_leaf(const_iterator __hint,
                    __parent_pointer &__parent, const key_type &__v);
        template <class _Key>
        __node_base_pointer &
        __find_equal(__parent_pointer &__parent, const _Key &__v);
        template <class _Key>
        __node_base_pointer &
        __find_equal(__parent_pointer &__parent, const _Key &__v) const
        {
            return const_cast<__tree *>(this)->__find_equal(__parent, __v);
        }
        template <class _Key>
        __node_base_pointer &
        __find_equal(const_iterator __hint, __parent_pointer &__parent,
                     __node_base_pointer &__dummy,
                     const _Key &__v);
        template <class... _Args>
        __node_holder __construct_node(_Args &&...__args);
        void destroy(__node_pointer __nd) throw();

        void __copy_assign_alloc(const __tree &__t)
        {
            __copy_assign_alloc(__t, integral_constant<bool,
                                                       __node_traits::propagate_on_container_copy_assignment::value>());
        }

        void __copy_assign_alloc(const __tree &__t, true_type)
        {
            if (__node_alloc() != __t.__node_alloc())
                clear();
            __node_alloc() = __t.__node_alloc();
        }

        void __copy_assign_alloc(const __tree &, false_type) {}
        void __move_assign(__tree &__t, false_type);
        void __move_assign(__tree &__t, true_type);

        void __move_assign_alloc(__tree &__t)
        {
            __move_assign_alloc(__t, integral_constant<bool,
                                                       __node_traits::propagate_on_container_move_assignment::value>());
        }

        void __move_assign_alloc(__tree &__t, true_type)
        {
            __node_alloc() = std::move(__t.__node_alloc());
        }

        void __move_assign_alloc(__tree &, false_type) throw() {}
        struct _DetachedTreeCache
        {

            explicit _DetachedTreeCache(__tree *__t) throw() : __t_(__t),
                                                               __cache_root_(__detach_from_tree(__t))
            {
                __advance();
            }

            __node_pointer __get() const throw()
            {
                return __cache_elem_;
            }

            void __advance() throw()
            {
                __cache_elem_ = __cache_root_;
                if (__cache_root_)
                {
                    __cache_root_ = __detach_next(__cache_root_);
                }
            }

            ~_DetachedTreeCache()
            {
                __t_->destroy(__cache_elem_);
                if (__cache_root_)
                {
                    while (__cache_root_->__parent_ != __nullptr)
                        __cache_root_ = static_cast<__node_pointer>(__cache_root_->__parent_);
                    __t_->destroy(__cache_root_);
                }
            }
            _DetachedTreeCache(_DetachedTreeCache const &) = delete;
            _DetachedTreeCache &operator=(_DetachedTreeCache const &) = delete;

        private:
            static __node_pointer __detach_from_tree(__tree *__t) throw();

            static __node_pointer __detach_next(__node_pointer) throw();
            __tree *__t_;
            __node_pointer __cache_root_;
            __node_pointer __cache_elem_;
        };
        template <class, class, class, class>
        friend class map;
        template <class, class, class, class>
        friend class multimap;
};
template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare &__comp)
    : __pair3_(0, __comp)
{
        __begin_node() = __end_node();
}
template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const allocator_type &__a)
    : __begin_node_(__iter_pointer()),
      __pair1_(__default_init_tag(), __node_allocator(__a)),
      __pair3_(0, __default_init_tag())
{
        __begin_node() = __end_node();
}
template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare &__comp,
                                          const allocator_type &__a)
    : __begin_node_(__iter_pointer()),
      __pair1_(__default_init_tag(), __node_allocator(__a)),
      __pair3_(0, __comp)
{
        __begin_node() = __end_node();
}
template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_pointer
__tree<_Tp, _Compare, _Allocator>::_DetachedTreeCache::__detach_from_tree(__tree *__t) throw()
{
        __node_pointer __cache = static_cast<__node_pointer>(__t->__begin_node());
        __t->__begin_node() = __t->__end_node();
        __t->__end_node()->__left_->__parent_ = __nullptr;
        __t->__end_node()->__left_ = __nullptr;
        __t->size() = 0;
        if (__cache->__right_ != __nullptr)
            __cache = static_cast<__node_pointer>(__cache->__right_);
        return __cache;
}
template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_pointer
__tree<_Tp, _Compare, _Allocator>::_DetachedTreeCache::__detach_next(__node_pointer __cache) throw()
{
        if (__cache->__parent_ == __nullptr)
            return __nullptr;
        if (std::__tree_is_left_child(static_cast<__node_base_pointer>(__cache)))
        {
            __cache->__parent_->__left_ = __nullptr;
            __cache = static_cast<__node_pointer>(__cache->__parent_);
            if (__cache->__right_ == __nullptr)
                return __cache;
            return static_cast<__node_pointer>(std::__tree_leaf(__cache->__right_));
        }
        __cache->__parent_unsafe()->__right_ = __nullptr;
        __cache = static_cast<__node_pointer>(__cache->__parent_);
        if (__cache->__left_ == __nullptr)
            return __cache;
        return static_cast<__node_pointer>(std::__tree_leaf(__cache->__left_));
}
template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator> &
__tree<_Tp, _Compare, _Allocator>::operator=(const __tree &__t)
{
        if (this != std::addressof(__t))
        {
            value_comp() = __t.value_comp();
            __copy_assign_alloc(__t);
            __assign_multi(__t.begin(), __t.end());
        }
        return *this;
}
template <class _Tp, class _Compare, class _Allocator>
template <class _ForwardIterator>
void __tree<_Tp, _Compare, _Allocator>::__assign_unique(_ForwardIterator __first, _ForwardIterator __last)
{
        typedef iterator_traits<_ForwardIterator> _ITraits;
        typedef typename _ITraits::value_type _ItValueType;
        _Static_assert((is_same<_ItValueType, __container_value_type>::value), "__assign_unique may only be called with the containers value type");
        _Static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value, "__assign_unique requires a forward iterator");
        if (size() != 0)
        {
            _DetachedTreeCache __cache(this);
            for (; __cache.__get() != __nullptr && __first != __last; ++__first)
            {
                if (__node_assign_unique(*__first, __cache.__get()).second)
                    __cache.__advance();
            }
        }
        for (; __first != __last; ++__first)
            __insert_unique(*__first);
}
template <class _Tp, class _Compare, class _Allocator>
template <class _InputIterator>
void __tree<_Tp, _Compare, _Allocator>::__assign_multi(_InputIterator __first, _InputIterator __last)
{
        typedef iterator_traits<_InputIterator> _ITraits;
        typedef typename _ITraits::value_type _ItValueType;
        _Static_assert((is_same<_ItValueType, __container_value_type>::value || is_same<_ItValueType, __node_value_type>::value), "__assign_multi may only be called with the containers value type"
                                                                                                                                  " or the nodes value type");
        if (size() != 0)
        {
            _DetachedTreeCache __cache(this);
            for (; __cache.__get() && __first != __last; ++__first)
            {
                __cache.__get()->__value_ = *__first;
                __node_insert_multi(__cache.__get());
                __cache.__advance();
            }
        }
        for (; __first != __last; ++__first)
            __insert_multi(_NodeTypes::__get_value(*__first));
}
template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const __tree &__t)
    : __begin_node_(__iter_pointer()),
      __pair1_(__default_init_tag(), __node_traits::select_on_container_copy_construction(__t.__node_alloc())),
      __pair3_(0, __t.value_comp())
{
        __begin_node() = __end_node();
}
template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(__tree &&__t)
    : __begin_node_(std::move(__t.__begin_node_)),
      __pair1_(std::move(__t.__pair1_)),
      __pair3_(std::move(__t.__pair3_))
{
        if (size() == 0)
            __begin_node() = __end_node();
        else
        {
            __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
            __t.__begin_node() = __t.__end_node();
            __t.__end_node()->__left_ = __nullptr;
            __t.size() = 0;
        }
}
template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(__tree &&__t, const allocator_type &__a)
    : __pair1_(__default_init_tag(), __node_allocator(__a)),
      __pair3_(0, std::move(__t.value_comp()))
{
        if (__a == __t.__alloc())
        {
            if (__t.size() == 0)
                __begin_node() = __end_node();
            else
            {
                __begin_node() = __t.__begin_node();
                __end_node()->__left_ = __t.__end_node()->__left_;
                __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
                size() = __t.size();
                __t.__begin_node() = __t.__end_node();
                __t.__end_node()->__left_ = __nullptr;
                __t.size() = 0;
            }
        }
        else
        {
            __begin_node() = __end_node();
        }
}
template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::__move_assign(__tree &__t, true_type)
{
        destroy(static_cast<__node_pointer>(__end_node()->__left_));
        __begin_node_ = __t.__begin_node_;
        __pair1_.first() = __t.__pair1_.first();
        __move_assign_alloc(__t);
        __pair3_ = std::move(__t.__pair3_);
        if (size() == 0)
            __begin_node() = __end_node();
        else
        {
            __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
            __t.__begin_node() = __t.__end_node();
            __t.__end_node()->__left_ = __nullptr;
            __t.size() = 0;
        }
}
template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::__move_assign(__tree &__t, false_type)
{
        if (__node_alloc() == __t.__node_alloc())
            __move_assign(__t, true_type());
        else
        {
            value_comp() = std::move(__t.value_comp());
            const_iterator __e = end();
            if (size() != 0)
            {
                _DetachedTreeCache __cache(this);
                while (__cache.__get() != __nullptr && __t.size() != 0)
                {
                    __cache.__get()->__value_ = std::move(__t.remove(__t.begin())->__value_);
                    __node_insert_multi(__cache.__get());
                    __cache.__advance();
                }
            }
            while (__t.size() != 0)
                __insert_multi(__e, _NodeTypes::__move(__t.remove(__t.begin())->__value_));
        }
}
template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator> &
__tree<_Tp, _Compare, _Allocator>::operator=(__tree &&__t)
{
        __move_assign(__t, integral_constant<bool,
                                             __node_traits::propagate_on_container_move_assignment::value>());
        return *this;
}
template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::~__tree()
{
        _Static_assert((is_copy_constructible<value_compare>::value), "Comparator must be copy-constructible.");
        destroy(__root());
}
template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::destroy(__node_pointer __nd) throw()
{
        if (__nd != __nullptr)
        {
            destroy(static_cast<__node_pointer>(__nd->__left_));
            destroy(static_cast<__node_pointer>(__nd->__right_));
            __node_allocator &__na = __node_alloc();
            __node_traits::destroy(__na, _NodeTypes::__get_ptr(__nd->__value_));
            __node_traits::deallocate(__na, __nd, 1);
        }
}
template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::swap(__tree &__t)
{
        using std::swap;
        swap(__begin_node_, __t.__begin_node_);
        swap(__pair1_.first(), __t.__pair1_.first());
        std::__swap_allocator(__node_alloc(), __t.__node_alloc());
        __pair3_.swap(__t.__pair3_);
        if (size() == 0)
            __begin_node() = __end_node();
        else
            __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
        if (__t.size() == 0)
            __t.__begin_node() = __t.__end_node();
        else
            __t.__end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__t.__end_node());
}
template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::clear() throw()
{
        destroy(__root());
        size() = 0;
        __begin_node() = __end_node();
        __end_node()->__left_ = __nullptr;
}
template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer &
__tree<_Tp, _Compare, _Allocator>::__find_leaf_low(__parent_pointer &__parent,
                                                   const key_type &__v)
{
        __node_pointer __nd = __root();
        if (__nd != __nullptr)
        {
            while (true)
            {
                if (value_comp()(__nd->__value_, __v))
                {
                    if (__nd->__right_ != __nullptr)
                        __nd = static_cast<__node_pointer>(__nd->__right_);
                    else
                    {
                        __parent = static_cast<__parent_pointer>(__nd);
                        return __nd->__right_;
                    }
                }
                else
                {
                    if (__nd->__left_ != __nullptr)
                        __nd = static_cast<__node_pointer>(__nd->__left_);
                    else
                    {
                        __parent = static_cast<__parent_pointer>(__nd);
                        return __parent->__left_;
                    }
                }
            }
        }
        __parent = static_cast<__parent_pointer>(__end_node());
        return __parent->__left_;
}
template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer &
__tree<_Tp, _Compare, _Allocator>::__find_leaf_high(__parent_pointer &__parent,
                                                    const key_type &__v)
{
        __node_pointer __nd = __root();
        if (__nd != __nullptr)
        {
            while (true)
            {
                if (value_comp()(__v, __nd->__value_))
                {
                    if (__nd->__left_ != __nullptr)
                        __nd = static_cast<__node_pointer>(__nd->__left_);
                    else
                    {
                        __parent = static_cast<__parent_pointer>(__nd);
                        return __parent->__left_;
                    }
                }
                else
                {
                    if (__nd->__right_ != __nullptr)
                        __nd = static_cast<__node_pointer>(__nd->__right_);
                    else
                    {
                        __parent = static_cast<__parent_pointer>(__nd);
                        return __nd->__right_;
                    }
                }
            }
        }
        __parent = static_cast<__parent_pointer>(__end_node());
        return __parent->__left_;
}
template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer &
__tree<_Tp, _Compare, _Allocator>::__find_leaf(const_iterator __hint,
                                               __parent_pointer &__parent,
                                               const key_type &__v)
{
        if (__hint == end() || !value_comp()(*__hint, __v))
        {
            const_iterator __prior = __hint;
            if (__prior == begin() || !value_comp()(__v, *--__prior))
            {
                if (__hint.__ptr_->__left_ == __nullptr)
                {
                    __parent = static_cast<__parent_pointer>(__hint.__ptr_);
                    return __parent->__left_;
                }
                else
                {
                    __parent = static_cast<__parent_pointer>(__prior.__ptr_);
                    return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;
                }
            }
            return __find_leaf_high(__parent, __v);
        }
        return __find_leaf_low(__parent, __v);
}
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer &
__tree<_Tp, _Compare, _Allocator>::__find_equal(__parent_pointer &__parent,
                                                const _Key &__v)
{
        __node_pointer __nd = __root();
        __node_base_pointer *__nd_ptr = __root_ptr();
        if (__nd != __nullptr)
        {
            while (true)
            {
                if (value_comp()(__v, __nd->__value_))
                {
                    if (__nd->__left_ != __nullptr)
                    {
                        __nd_ptr = std::addressof(__nd->__left_);
                        __nd = static_cast<__node_pointer>(__nd->__left_);
                    }
                    else
                    {
                        __parent = static_cast<__parent_pointer>(__nd);
                        return __parent->__left_;
                    }
                }
                else if (value_comp()(__nd->__value_, __v))
                {
                    if (__nd->__right_ != __nullptr)
                    {
                        __nd_ptr = std::addressof(__nd->__right_);
                        __nd = static_cast<__node_pointer>(__nd->__right_);
                    }
                    else
                    {
                        __parent = static_cast<__parent_pointer>(__nd);
                        return __nd->__right_;
                    }
                }
                else
                {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return *__nd_ptr;
                }
            }
        }
        __parent = static_cast<__parent_pointer>(__end_node());
        return __parent->__left_;
}
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer &
__tree<_Tp, _Compare, _Allocator>::__find_equal(const_iterator __hint,
                                                __parent_pointer &__parent,
                                                __node_base_pointer &__dummy,
                                                const _Key &__v)
{
        if (__hint == end() || value_comp()(__v, *__hint))
        {
            const_iterator __prior = __hint;
            if (__prior == begin() || value_comp()(*--__prior, __v))
            {
                if (__hint.__ptr_->__left_ == __nullptr)
                {
                    __parent = static_cast<__parent_pointer>(__hint.__ptr_);
                    return __parent->__left_;
                }
                else
                {
                    __parent = static_cast<__parent_pointer>(__prior.__ptr_);
                    return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;
                }
            }
            return __find_equal(__parent, __v);
        }
        else if (value_comp()(*__hint, __v))
        {
            const_iterator __next = std::next(__hint);
            if (__next == end() || value_comp()(__v, *__next))
            {
                if (__hint.__get_np()->__right_ == __nullptr)
                {
                    __parent = static_cast<__parent_pointer>(__hint.__ptr_);
                    return static_cast<__node_base_pointer>(__hint.__ptr_)->__right_;
                }
                else
                {
                    __parent = static_cast<__parent_pointer>(__next.__ptr_);
                    return __parent->__left_;
                }
            }
            return __find_equal(__parent, __v);
        }
        __parent = static_cast<__parent_pointer>(__hint.__ptr_);
        __dummy = static_cast<__node_base_pointer>(__hint.__ptr_);
        return __dummy;
}
template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::__insert_node_at(
    __parent_pointer __parent, __node_base_pointer &__child,
    __node_base_pointer __new_node) throw()
{
        __new_node->__left_ = __nullptr;
        __new_node->__right_ = __nullptr;
        __new_node->__parent_ = __parent;
        __child = __new_node;
        if (__begin_node()->__left_ != __nullptr)
            __begin_node() = static_cast<__iter_pointer>(__begin_node()->__left_);
        std::__tree_balance_after_insert(__end_node()->__left_, __child);
        ++size();
}
template <class _Tp, class _Compare, class _Allocator>
template <class _Key, class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_unique_key_args(_Key const &__k, _Args &&...__args)
{
        __parent_pointer __parent;
        __node_base_pointer &__child = __find_equal(__parent, __k);
        __node_pointer __r = static_cast<__node_pointer>(__child);
        bool __inserted = false;
        if (__child == __nullptr)
        {
            __node_holder __h = __construct_node(std::forward<_Args>(__args)...);
            __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
            __r = __h.release();
            __inserted = true;
        }
        return pair<iterator, bool>(iterator(__r), __inserted);
}
template <class _Tp, class _Compare, class _Allocator>
template <class _Key, class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_key_args(
    const_iterator __p, _Key const &__k, _Args &&...__args)
{
        __parent_pointer __parent;
        __node_base_pointer __dummy;
        __node_base_pointer &__child = __find_equal(__p, __parent, __dummy, __k);
        __node_pointer __r = static_cast<__node_pointer>(__child);
        bool __inserted = false;
        if (__child == __nullptr)
        {
            __node_holder __h = __construct_node(std::forward<_Args>(__args)...);
            __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
            __r = __h.release();
            __inserted = true;
        }
        return pair<iterator, bool>(iterator(__r), __inserted);
}
template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::__node_holder
__tree<_Tp, _Compare, _Allocator>::__construct_node(_Args &&...__args)
{
        _Static_assert(!__is_tree_value_type<_Args...>::value, "Cannot construct from __value_type");
        __node_allocator &__na = __node_alloc();
        __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
        __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), std::forward<_Args>(__args)...);
        __h.get_deleter().__value_constructed = true;
        return __h;
}
template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_unique_impl(_Args &&...__args)
{
        __node_holder __h = __construct_node(std::forward<_Args>(__args)...);
        __parent_pointer __parent;
        __node_base_pointer &__child = __find_equal(__parent, __h->__value_);
        __node_pointer __r = static_cast<__node_pointer>(__child);
        bool __inserted = false;
        if (__child == __nullptr)
        {
            __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
            __r = __h.release();
            __inserted = true;
        }
        return pair<iterator, bool>(iterator(__r), __inserted);
}
template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_impl(const_iterator __p, _Args &&...__args)
{
        __node_holder __h = __construct_node(std::forward<_Args>(__args)...);
        __parent_pointer __parent;
        __node_base_pointer __dummy;
        __node_base_pointer &__child = __find_equal(__p, __parent, __dummy, __h->__value_);
        __node_pointer __r = static_cast<__node_pointer>(__child);
        if (__child == __nullptr)
        {
            __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
            __r = __h.release();
        }
        return iterator(__r);
}
template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_multi(_Args &&...__args)
{
        __node_holder __h = __construct_node(std::forward<_Args>(__args)...);
        __parent_pointer __parent;
        __node_base_pointer &__child = __find_leaf_high(__parent, _NodeTypes::__get_key(__h->__value_));
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
        return iterator(static_cast<__node_pointer>(__h.release()));
}
template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_multi(const_iterator __p,
                                                        _Args &&...__args)
{
        __node_holder __h = __construct_node(std::forward<_Args>(__args)...);
        __parent_pointer __parent;
        __node_base_pointer &__child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__h->__value_));
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
        return iterator(static_cast<__node_pointer>(__h.release()));
}
template <class _Tp, class _Compare, class _Allocator>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__node_assign_unique(const __container_value_type &__v, __node_pointer __nd)
{
        __parent_pointer __parent;
        __node_base_pointer &__child = __find_equal(__parent, _NodeTypes::__get_key(__v));
        __node_pointer __r = static_cast<__node_pointer>(__child);
        bool __inserted = false;
        if (__child == __nullptr)
        {
            __nd->__value_ = __v;
            __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
            __r = __nd;
            __inserted = true;
        }
        return pair<iterator, bool>(iterator(__r), __inserted);
}
template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(__node_pointer __nd)
{
        __parent_pointer __parent;
        __node_base_pointer &__child = __find_leaf_high(__parent, _NodeTypes::__get_key(__nd->__value_));
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
        return iterator(__nd);
}
template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(const_iterator __p,
                                                       __node_pointer __nd)
{
        __parent_pointer __parent;
        __node_base_pointer &__child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__nd->__value_));
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
        return iterator(__nd);
}
template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__remove_node_pointer(__node_pointer __ptr) throw()
{
        iterator __r(__ptr);
        ++__r;
        if (__begin_node() == __ptr)
            __begin_node() = __r.__ptr_;
        --size();
        std::__tree_remove(__end_node()->__left_,
                           static_cast<__node_base_pointer>(__ptr));
        return __r;
}
template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __p)
{
        __node_pointer __np = __p.__get_np();
        iterator __r = __remove_node_pointer(__np);
        __node_allocator &__na = __node_alloc();
        __node_traits::destroy(__na, _NodeTypes::__get_ptr(
                                         const_cast<__node_value_type &>(*__p)));
        __node_traits::deallocate(__na, __np, 1);
        return __r;
}
template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __f, const_iterator __l)
{
        while (__f != __l)
            __f = erase(__f);
        return iterator(__l.__ptr_);
}
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__erase_unique(const _Key &__k)
{
        iterator __i = find(__k);
        if (__i == end())
            return 0;
        erase(__i);
        return 1;
}
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__erase_multi(const _Key &__k)
{
        pair<iterator, iterator> __p = __equal_range_multi(__k);
        size_type __r = 0;
        for (; __p.first != __p.second; ++__r)
            __p.first = erase(__p.first);
        return __r;
}
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::find(const _Key &__v)
{
        iterator __p = __lower_bound(__v, __root(), __end_node());
        if (__p != end() && !value_comp()(__v, *__p))
            return __p;
        return end();
}
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::find(const _Key &__v) const
{
        const_iterator __p = __lower_bound(__v, __root(), __end_node());
        if (__p != end() && !value_comp()(__v, *__p))
            return __p;
        return end();
}
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__count_unique(const _Key &__k) const
{
        __node_pointer __rt = __root();
        while (__rt != __nullptr)
        {
            if (value_comp()(__k, __rt->__value_))
            {
                __rt = static_cast<__node_pointer>(__rt->__left_);
            }
            else if (value_comp()(__rt->__value_, __k))
                __rt = static_cast<__node_pointer>(__rt->__right_);
            else
                return 1;
        }
        return 0;
}
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__count_multi(const _Key &__k) const
{
        __iter_pointer __result = __end_node();
        __node_pointer __rt = __root();
        while (__rt != __nullptr)
        {
            if (value_comp()(__k, __rt->__value_))
            {
                __result = static_cast<__iter_pointer>(__rt);
                __rt = static_cast<__node_pointer>(__rt->__left_);
            }
            else if (value_comp()(__rt->__value_, __k))
                __rt = static_cast<__node_pointer>(__rt->__right_);
            else
                return std::distance(
                    __lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),
                    __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));
        }
        return 0;
}
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key &__v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result)
{
        while (__root != __nullptr)
        {
            if (!value_comp()(__root->__value_, __v))
            {
                __result = static_cast<__iter_pointer>(__root);
                __root = static_cast<__node_pointer>(__root->__left_);
            }
            else
                __root = static_cast<__node_pointer>(__root->__right_);
        }
        return iterator(__result);
}
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key &__v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result) const
{
        while (__root != __nullptr)
        {
            if (!value_comp()(__root->__value_, __v))
            {
                __result = static_cast<__iter_pointer>(__root);
                __root = static_cast<__node_pointer>(__root->__left_);
            }
            else
                __root = static_cast<__node_pointer>(__root->__right_);
        }
        return const_iterator(__result);
}
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key &__v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result)
{
        while (__root != __nullptr)
        {
            if (value_comp()(__v, __root->__value_))
            {
                __result = static_cast<__iter_pointer>(__root);
                __root = static_cast<__node_pointer>(__root->__left_);
            }
            else
                __root = static_cast<__node_pointer>(__root->__right_);
        }
        return iterator(__result);
}
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key &__v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result) const
{
        while (__root != __nullptr)
        {
            if (value_comp()(__v, __root->__value_))
            {
                __result = static_cast<__iter_pointer>(__root);
                __root = static_cast<__node_pointer>(__root->__left_);
            }
            else
                __root = static_cast<__node_pointer>(__root->__right_);
        }
        return const_iterator(__result);
}
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator,
     typename __tree<_Tp, _Compare, _Allocator>::iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key &__k)
{
        typedef pair<iterator, iterator> _Pp;
        __iter_pointer __result = __end_node();
        __node_pointer __rt = __root();
        while (__rt != __nullptr)
        {
            if (value_comp()(__k, __rt->__value_))
            {
                __result = static_cast<__iter_pointer>(__rt);
                __rt = static_cast<__node_pointer>(__rt->__left_);
            }
            else if (value_comp()(__rt->__value_, __k))
                __rt = static_cast<__node_pointer>(__rt->__right_);
            else
                return _Pp(iterator(__rt),
                           iterator(
                               __rt->__right_ != __nullptr ? static_cast<__iter_pointer>(std::__tree_min(__rt->__right_))
                                                           : __result));
        }
        return _Pp(iterator(__result), iterator(__result));
}
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,
     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key &__k) const
{
        typedef pair<const_iterator, const_iterator> _Pp;
        __iter_pointer __result = __end_node();
        __node_pointer __rt = __root();
        while (__rt != __nullptr)
        {
            if (value_comp()(__k, __rt->__value_))
            {
                __result = static_cast<__iter_pointer>(__rt);
                __rt = static_cast<__node_pointer>(__rt->__left_);
            }
            else if (value_comp()(__rt->__value_, __k))
                __rt = static_cast<__node_pointer>(__rt->__right_);
            else
                return _Pp(const_iterator(__rt),
                           const_iterator(
                               __rt->__right_ != __nullptr ? static_cast<__iter_pointer>(std::__tree_min(__rt->__right_))
                                                           : __result));
        }
        return _Pp(const_iterator(__result), const_iterator(__result));
}
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator,
     typename __tree<_Tp, _Compare, _Allocator>::iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key &__k)
{
        typedef pair<iterator, iterator> _Pp;
        __iter_pointer __result = __end_node();
        __node_pointer __rt = __root();
        while (__rt != __nullptr)
        {
            if (value_comp()(__k, __rt->__value_))
            {
                __result = static_cast<__iter_pointer>(__rt);
                __rt = static_cast<__node_pointer>(__rt->__left_);
            }
            else if (value_comp()(__rt->__value_, __k))
                __rt = static_cast<__node_pointer>(__rt->__right_);
            else
                return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),
                           __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));
        }
        return _Pp(iterator(__result), iterator(__result));
}
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,
     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key &__k) const
{
        typedef pair<const_iterator, const_iterator> _Pp;
        __iter_pointer __result = __end_node();
        __node_pointer __rt = __root();
        while (__rt != __nullptr)
        {
            if (value_comp()(__k, __rt->__value_))
            {
                __result = static_cast<__iter_pointer>(__rt);
                __rt = static_cast<__node_pointer>(__rt->__left_);
            }
            else if (value_comp()(__rt->__value_, __k))
                __rt = static_cast<__node_pointer>(__rt->__right_);
            else
                return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),
                           __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));
        }
        return _Pp(const_iterator(__result), const_iterator(__result));
}
template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_holder
__tree<_Tp, _Compare, _Allocator>::remove(const_iterator __p) throw()
{
        __node_pointer __np = __p.__get_np();
        if (__begin_node() == __p.__ptr_)
        {
            if (__np->__right_ != __nullptr)
                __begin_node() = static_cast<__iter_pointer>(__np->__right_);
            else
                __begin_node() = static_cast<__iter_pointer>(__np->__parent_);
        }
        --size();
        std::__tree_remove(__end_node()->__left_,
                           static_cast<__node_base_pointer>(__np));
        return __node_holder(__np, _Dp(__node_alloc(), true));
}
template <class _Tp, class _Compare, class _Allocator>
inline void
swap(__tree<_Tp, _Compare, _Allocator> &__x,
     __tree<_Tp, _Compare, _Allocator> &__y)
{
        __x.swap(__y);
}
    }
}
extern "C"
{
    void __assert_rtn(const char *, const char *, int, const char *);
}
namespace std
{
    inline namespace __1
    {
template <class _Key, class _CP, class _Compare,
          bool = is_empty<_Compare>::value && !__libcpp_is_final<_Compare>::value>
class __map_value_compare
    : private _Compare
{
    public:
        __map_value_compare()
            : _Compare() {}

        __map_value_compare(_Compare __c)
            : _Compare(__c) {}

        const _Compare &key_comp() const throw() { return *this; }

        bool operator()(const _CP &__x, const _CP &__y) const
        {
            return static_cast<const _Compare &>(*this)(__x.__get_value().first, __y.__get_value().first);
        }

        bool operator()(const _CP &__x, const _Key &__y) const
        {
            return static_cast<const _Compare &>(*this)(__x.__get_value().first, __y);
        }

        bool operator()(const _Key &__x, const _CP &__y) const
        {
            return static_cast<const _Compare &>(*this)(__x, __y.__get_value().first);
        }
        void swap(__map_value_compare &__y)
        {
            using std::swap;
            swap(static_cast<_Compare &>(*this), static_cast<_Compare &>(__y));
        }
};
template <class _Key, class _CP, class _Compare>
class __map_value_compare<_Key, _CP, _Compare, false>
{
        _Compare comp;

    public:
        __map_value_compare()
            : comp() {}

        __map_value_compare(_Compare __c)
            : comp(__c) {}

        const _Compare &key_comp() const throw() { return comp; }

        bool operator()(const _CP &__x, const _CP &__y) const
        {
            return comp(__x.__get_value().first, __y.__get_value().first);
        }

        bool operator()(const _CP &__x, const _Key &__y) const
        {
            return comp(__x.__get_value().first, __y);
        }

        bool operator()(const _Key &__x, const _CP &__y) const
        {
            return comp(__x, __y.__get_value().first);
        }
        void swap(__map_value_compare &__y)
        {
            using std::swap;
            swap(comp, __y.comp);
        }
};
template <class _Key, class _CP, class _Compare, bool __b>
inline void
swap(__map_value_compare<_Key, _CP, _Compare, __b> &__x,
     __map_value_compare<_Key, _CP, _Compare, __b> &__y)
{
        __x.swap(__y);
}
template <class _Allocator>
class __map_node_destructor
{
        typedef _Allocator allocator_type;
        typedef allocator_traits<allocator_type> __alloc_traits;

    public:
        typedef typename __alloc_traits::pointer pointer;

    private:
        allocator_type &__na_;
        __map_node_destructor &operator=(const __map_node_destructor &);

    public:
        bool __first_constructed;
        bool __second_constructed;

        explicit __map_node_destructor(allocator_type &__na) throw()
            : __na_(__na),
              __first_constructed(false),
              __second_constructed(false)
        {
        }

        void operator()(pointer __p) throw()
        {
            if (__second_constructed)
                __alloc_traits::destroy(__na_, std::addressof(__p->__value_.__get_value().second));
            if (__first_constructed)
                __alloc_traits::destroy(__na_, std::addressof(__p->__value_.__get_value().first));
            if (__p)
                __alloc_traits::deallocate(__na_, __p, 1);
        }
};
template <class _Key, class _Tp, class _Compare, class _Allocator>
class map;
template <class _Key, class _Tp, class _Compare, class _Allocator>
class multimap;
template <class _TreeIterator>
class __map_const_iterator;
template <class _Key, class _Tp>
struct __value_type
{
        typedef _Key key_type;
        typedef _Tp mapped_type;
        typedef pair<const key_type, mapped_type> value_type;

    private:
        value_type __cc;

    public:
        value_type &__get_value() { return __cc; }

        const value_type &__get_value() const { return __cc; }

    private:
        __value_type();
        __value_type(__value_type const &);
        __value_type &operator=(__value_type const &);
        ~__value_type();
};
template <class _Tp>
struct __extract_key_value_types;
template <class _Key, class _Tp>
struct __extract_key_value_types<__value_type<_Key, _Tp>>
{
        typedef _Key const __key_type;
        typedef _Tp __mapped_type;
};
template <class _TreeIterator>
class __map_iterator
{
        typedef typename _TreeIterator::_NodeTypes _NodeTypes;
        typedef typename _TreeIterator::__pointer_traits __pointer_traits;
        _TreeIterator __i_;

    public:
        typedef bidirectional_iterator_tag iterator_category;
        typedef typename _NodeTypes::__map_value_type value_type;
        typedef typename _TreeIterator::difference_type difference_type;
        typedef value_type &reference;
        typedef typename _NodeTypes::__map_value_type_pointer pointer;

        __map_iterator() throw() {}

        __map_iterator(_TreeIterator __i) throw() : __i_(__i) {}

        reference operator*() const { return __i_->__get_value(); }

        pointer operator->() const { return pointer_traits<pointer>::pointer_to(__i_->__get_value()); }

        __map_iterator &operator++()
        {
            ++__i_;
            return *this;
        }

        __map_iterator operator++(int)
        {
            __map_iterator __t(*this);
            ++(*this);
            return __t;
        }

        __map_iterator &operator--()
        {
            --__i_;
            return *this;
        }

        __map_iterator operator--(int)
        {
            __map_iterator __t(*this);
            --(*this);
            return __t;
        }
        friend bool operator==(const __map_iterator &__x, const __map_iterator &__y)
        {
            return __x.__i_ == __y.__i_;
        }
        friend

            bool
            operator!=(const __map_iterator &__x, const __map_iterator &__y)
        {
            return __x.__i_ != __y.__i_;
        }
        template <class, class, class, class>
        friend class map;
        template <class, class, class, class>
        friend class multimap;
        template <class>
        friend class __map_const_iterator;
};
template <class _TreeIterator>
class __map_const_iterator
{
        typedef typename _TreeIterator::_NodeTypes _NodeTypes;
        typedef typename _TreeIterator::__pointer_traits __pointer_traits;
        _TreeIterator __i_;

    public:
        typedef bidirectional_iterator_tag iterator_category;
        typedef typename _NodeTypes::__map_value_type value_type;
        typedef typename _TreeIterator::difference_type difference_type;
        typedef const value_type &reference;
        typedef typename _NodeTypes::__const_map_value_type_pointer pointer;

        __map_const_iterator() throw() {}

        __map_const_iterator(_TreeIterator __i) throw() : __i_(__i) {}

        __map_const_iterator(__map_iterator<
                             typename _TreeIterator::__non_const_iterator>
                                 __i) throw()
            : __i_(__i.__i_) {}

        reference operator*() const { return __i_->__get_value(); }

        pointer operator->() const { return pointer_traits<pointer>::pointer_to(__i_->__get_value()); }

        __map_const_iterator &operator++()
        {
            ++__i_;
            return *this;
        }

        __map_const_iterator operator++(int)
        {
            __map_const_iterator __t(*this);
            ++(*this);
            return __t;
        }

        __map_const_iterator &operator--()
        {
            --__i_;
            return *this;
        }

        __map_const_iterator operator--(int)
        {
            __map_const_iterator __t(*this);
            --(*this);
            return __t;
        }
        friend bool operator==(const __map_const_iterator &__x, const __map_const_iterator &__y)
        {
            return __x.__i_ == __y.__i_;
        }
        friend bool operator!=(const __map_const_iterator &__x, const __map_const_iterator &__y)
        {
            return __x.__i_ != __y.__i_;
        }
        template <class, class, class, class>
        friend class map;
        template <class, class, class, class>
        friend class multimap;
        template <class, class, class>
        friend class __tree_const_iterator;
};
template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Allocator = allocator<pair<const _Key, _Tp>>>
class map
{
    public:
        typedef _Key key_type;
        typedef _Tp mapped_type;
        typedef pair<const key_type, mapped_type> value_type;
        typedef __type_identity_t<_Compare> key_compare;
        typedef __type_identity_t<_Allocator> allocator_type;
        typedef value_type &reference;
        typedef const value_type &const_reference;
        _Static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");
        class value_compare
            : public __binary_function<value_type, value_type, bool>
        {
            friend class map;

        protected:
            key_compare comp;
            {
            }

        public:
            bool operator()(const value_type &__x, const value_type &__y) const
            {
                return comp(__x.first, __y.first);
            }
        };

    private:
        typedef std::__value_type<key_type, mapped_type> __value_type;
        typedef __map_value_compare<key_type, __value_type, key_compare> __vc;
        typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                               __value_type>::type __allocator_type;
        typedef __tree<__value_type, __vc, __allocator_type> __base;
        typedef typename __base::__node_traits __node_traits;
        typedef allocator_traits<allocator_type> __alloc_traits;
        __base __tree_;

    public:
        typedef typename __alloc_traits::pointer pointer;
        typedef typename __alloc_traits::const_pointer const_pointer;
        typedef typename __alloc_traits::size_type size_type;
        typedef typename __alloc_traits::difference_type difference_type;
        typedef __map_iterator<typename __base::iterator> iterator;
        typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
        typedef std::reverse_iterator<iterator> reverse_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
        template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
        friend class map;
        template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
        friend class multimap;

        map()
            : __tree_(__vc(key_compare())) {}

        explicit map(const key_compare &__comp)
            : __tree_(__vc(__comp)) {}

        explicit map(const key_compare &__comp, const allocator_type &__a)
            : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {}
        template <class _InputIterator>

        map(_InputIterator __f, _InputIterator __l,
            const key_compare &__comp = key_compare())
            : __tree_(__vc(__comp))
        {
            insert(__f, __l);
        }
        template <class _InputIterator>

        map(_InputIterator __f, _InputIterator __l,
            const key_compare &__comp, const allocator_type &__a)
            : __tree_(__vc(__comp), typename __base::allocator_type(__a))
        {
            insert(__f, __l);
        }

        map(const map &__m)
            : __tree_(__m.__tree_)
        {
            insert(__m.begin(), __m.end());
        }

        map &operator=(const map &__m)
        {
            if (this != std::addressof(__m))
            {
                __tree_.clear();
                __tree_.value_comp() = __m.__tree_.value_comp();
                __tree_.__copy_assign_alloc(__m.__tree_);
                insert(__m.begin(), __m.end());
            }
            return *this;
        }

        explicit map(const allocator_type &__a)
            : __tree_(typename __base::allocator_type(__a))
        {
        }

        map(const map &__m, const allocator_type &__a)
            : __tree_(__m.__tree_.value_comp(), typename __base::allocator_type(__a))
        {
            insert(__m.begin(), __m.end());
        }

        ~map()
        {
            _Static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), "");
        }

        iterator begin() throw() { return __tree_.begin(); }

        const_iterator begin() const throw() { return __tree_.begin(); }

        iterator end() throw() { return __tree_.end(); }

        const_iterator end() const throw() { return __tree_.end(); }

        reverse_iterator rbegin() throw() { return reverse_iterator(end()); }

        const_reverse_iterator rbegin() const throw()
        {
            return const_reverse_iterator(end());
        }

        reverse_iterator rend() throw()
        {
            return reverse_iterator(begin());
        }

        const_reverse_iterator rend() const throw()
        {
            return const_reverse_iterator(begin());
        }

        const_iterator cbegin() const throw() { return begin(); }

        const_iterator cend() const throw() { return end(); }

        const_reverse_iterator crbegin() const throw() { return rbegin(); }

        const_reverse_iterator crend() const throw() { return rend(); }

        bool empty() const throw() { return __tree_.size() == 0; }

        size_type size() const throw() { return __tree_.size(); }

        size_type max_size() const throw() { return __tree_.max_size(); }
        mapped_type &operator[](const key_type &__k);
        mapped_type &at(const key_type &__k);
        const mapped_type &at(const key_type &__k) const;

        allocator_type get_allocator() const throw() { return allocator_type(__tree_.__alloc()); }

        key_compare key_comp() const { return __tree_.value_comp().key_comp(); }

        value_compare value_comp() const { return value_compare(__tree_.value_comp().key_comp()); }

        pair<iterator, bool>
        insert(const value_type &__v) { return __tree_.__insert_unique(__v); }

        iterator
        insert(const_iterator __p, const value_type &__v)
        {
            return __tree_.__insert_unique(__p.__i_, __v);
        }
        template <class _InputIterator>

        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                insert(__e.__i_, *__f);
        }

        iterator erase(const_iterator __p) { return __tree_.erase(__p.__i_); }

        iterator erase(iterator __p) { return __tree_.erase(__p.__i_); }

        size_type erase(const key_type &__k)
        {
            return __tree_.__erase_unique(__k);
        }

        iterator erase(const_iterator __f, const_iterator __l)
        {
            return __tree_.erase(__f.__i_, __l.__i_);
        }

        void clear() throw() { __tree_.clear(); }

        void swap(map &__m)
        {
            __tree_.swap(__m.__tree_);
        }

        iterator find(const key_type &__k) { return __tree_.find(__k); }

        const_iterator find(const key_type &__k) const { return __tree_.find(__k); }

        size_type count(const key_type &__k) const
        {
            return __tree_.__count_unique(__k);
        }

        iterator lower_bound(const key_type &__k)
        {
            return __tree_.lower_bound(__k);
        }

        const_iterator lower_bound(const key_type &__k) const
        {
            return __tree_.lower_bound(__k);
        }

        iterator upper_bound(const key_type &__k)
        {
            return __tree_.upper_bound(__k);
        }

        const_iterator upper_bound(const key_type &__k) const
        {
            return __tree_.upper_bound(__k);
        }

        pair<iterator, iterator> equal_range(const key_type &__k)
        {
            return __tree_.__equal_range_unique(__k);
        }

        pair<const_iterator, const_iterator> equal_range(const key_type &__k) const
        {
            return __tree_.__equal_range_unique(__k);
        }

    private:
        typedef typename __base::__node __node;
        typedef typename __base::__node_allocator __node_allocator;
        typedef typename __base::__node_pointer __node_pointer;
        typedef typename __base::__node_base_pointer __node_base_pointer;
        typedef typename __base::__parent_pointer __parent_pointer;
        typedef __map_node_destructor<__node_allocator> _Dp;
        typedef unique_ptr<__node, _Dp> __node_holder;
        __node_holder __construct_node_with_key(const key_type &__k);
};
template <class _Key, class _Tp, class _Compare, class _Allocator>
typename map<_Key, _Tp, _Compare, _Allocator>::__node_holder
map<_Key, _Tp, _Compare, _Allocator>::__construct_node_with_key(const key_type &__k)
{
        __node_allocator &__na = __tree_.__node_alloc();
        __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
        __node_traits::construct(__na, std::addressof(__h->__value_.__get_value().first), __k);
        __h.get_deleter().__first_constructed = true;
        __node_traits::construct(__na, std::addressof(__h->__value_.__get_value().second));
        __h.get_deleter().__second_constructed = true;
        return __h;
}
template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp &map<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type &__k)
{
        __parent_pointer __parent;
        __node_base_pointer &__child = __tree_.__find_equal(__parent, __k);
        __node_pointer __r = static_cast<__node_pointer>(__child);
        if (__child == __nullptr)
        {
            __node_holder __h = __construct_node_with_key(__k);
            __tree_.__insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
            __r = __h.release();
        }
        return __r->__value_.__get_value().second;
}
template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp &map<_Key, _Tp, _Compare, _Allocator>::at(const key_type &__k)
{
        __parent_pointer __parent;
        __node_base_pointer &__child = __tree_.__find_equal(__parent, __k);
        if (__child == __nullptr)
            __throw_out_of_range("map::at:  key not found");
        return static_cast<__node_pointer>(__child)->__value_.__get_value().second;
}
template <class _Key, class _Tp, class _Compare, class _Allocator>
const _Tp &
map<_Key, _Tp, _Compare, _Allocator>::at(const key_type &__k) const
{
        __parent_pointer __parent;
        __node_base_pointer __child = __tree_.__find_equal(__parent, __k);
        if (__child == __nullptr)
            __throw_out_of_range("map::at:  key not found");
        return static_cast<__node_pointer>(__child)->__value_.__get_value().second;
}
template <class _Key, class _Tp, class _Compare, class _Allocator>
inline bool
operator==(const map<_Key, _Tp, _Compare, _Allocator> &__x,
           const map<_Key, _Tp, _Compare, _Allocator> &__y)
{
        return __x.size() == __y.size() && std::equal(__x.begin(), __x.end(), __y.begin());
}
template <class _Key, class _Tp, class _Compare, class _Allocator>
inline bool
operator<(const map<_Key, _Tp, _Compare, _Allocator> &__x,
          const map<_Key, _Tp, _Compare, _Allocator> &__y)
{
        return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}
template <class _Key, class _Tp, class _Compare, class _Allocator>
inline bool
operator!=(const map<_Key, _Tp, _Compare, _Allocator> &__x,
           const map<_Key, _Tp, _Compare, _Allocator> &__y)
{
        return !(__x == __y);
}
template <class _Key, class _Tp, class _Compare, class _Allocator>
inline bool
operator>(const map<_Key, _Tp, _Compare, _Allocator> &__x,
          const map<_Key, _Tp, _Compare, _Allocator> &__y)
{
        return __y < __x;
}
template <class _Key, class _Tp, class _Compare, class _Allocator>
inline bool
operator>=(const map<_Key, _Tp, _Compare, _Allocator> &__x,
           const map<_Key, _Tp, _Compare, _Allocator> &__y)
{
        return !(__x < __y);
}
template <class _Key, class _Tp, class _Compare, class _Allocator>
inline bool
operator<=(const map<_Key, _Tp, _Compare, _Allocator> &__x,
           const map<_Key, _Tp, _Compare, _Allocator> &__y)
{
        return !(__y < __x);
}
template <class _Key, class _Tp, class _Compare, class _Allocator>
inline void
swap(map<_Key, _Tp, _Compare, _Allocator> &__x,
     map<_Key, _Tp, _Compare, _Allocator> &__y)
{
        __x.swap(__y);
}
template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Allocator = allocator<pair<const _Key, _Tp>>>
class multimap
{
    public:
        typedef _Key key_type;
        typedef _Tp mapped_type;
        typedef pair<const key_type, mapped_type> value_type;
        typedef __type_identity_t<_Compare> key_compare;
        typedef __type_identity_t<_Allocator> allocator_type;
        typedef value_type &reference;
        typedef const value_type &const_reference;
        _Static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");
        class value_compare
            : public __binary_function<value_type, value_type, bool>
        {
            friend class multimap;

        protected:
            key_compare comp;

            value_compare(key_compare __c) : comp(__c) {}

        public:
            bool operator()(const value_type &__x, const value_type &__y) const
            {
                return comp(__x.first, __y.first);
            }
        };

    private:
        typedef std::__value_type<key_type, mapped_type> __value_type;
        typedef __map_value_compare<key_type, __value_type, key_compare> __vc;
        typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                               __value_type>::type __allocator_type;
        typedef __tree<__value_type, __vc, __allocator_type> __base;
        typedef typename __base::__node_traits __node_traits;
        typedef allocator_traits<allocator_type> __alloc_traits;
        __base __tree_;

    public:
        typedef typename __alloc_traits::pointer pointer;
        typedef typename __alloc_traits::const_pointer const_pointer;
        typedef typename __alloc_traits::size_type size_type;
        typedef typename __alloc_traits::difference_type difference_type;
        typedef __map_iterator<typename __base::iterator> iterator;
        typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
        typedef std::reverse_iterator<iterator> reverse_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
        template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
        friend class map;
        template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
        friend class multimap;

        multimap()
            : __tree_(__vc(key_compare())) {}

        explicit multimap(const key_compare &__comp)
            : __tree_(__vc(__comp)) {}

        explicit multimap(const key_compare &__comp, const allocator_type &__a)
            : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {}
        template <class _InputIterator>

        multimap(_InputIterator __f, _InputIterator __l,
                 const key_compare &__comp = key_compare())
            : __tree_(__vc(__comp))
        {
            insert(__f, __l);
        }
        template <class _InputIterator>

        multimap(_InputIterator __f, _InputIterator __l,
                 const key_compare &__comp, const allocator_type &__a)
            : __tree_(__vc(__comp), typename __base::allocator_type(__a))
        {
            insert(__f, __l);
        }

        multimap(const multimap &__m)
            : __tree_(__m.__tree_.value_comp(),
                      __alloc_traits::select_on_container_copy_construction(__m.__tree_.__alloc()))
        {
            insert(__m.begin(), __m.end());
        }

        multimap &operator=(const multimap &__m)
        {
            if (this != std::addressof(__m))
            {
                __tree_.clear();
                __tree_.value_comp() = __m.__tree_.value_comp();
                __tree_.__copy_assign_alloc(__m.__tree_);
                insert(__m.begin(), __m.end());
            }
            return *this;
        }

        explicit multimap(const allocator_type &__a)
            : __tree_(typename __base::allocator_type(__a))
        {
        }

        multimap(const multimap &__m, const allocator_type &__a)
            : __tree_(__m.__tree_.value_comp(), typename __base::allocator_type(__a))
        {
            insert(__m.begin(), __m.end());
        }

        ~multimap()
        {
            _Static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), "");
        }

        iterator begin() throw() { return __tree_.begin(); }

        const_iterator begin() const throw() { return __tree_.begin(); }

        iterator end() throw() { return __tree_.end(); }

        const_iterator end() const throw() { return __tree_.end(); }

        reverse_iterator rbegin() throw() { return reverse_iterator(end()); }

        const_reverse_iterator rbegin() const throw()
        {
            return const_reverse_iterator(end());
        }

        reverse_iterator rend() throw() { return reverse_iterator(begin()); }

        const_reverse_iterator rend() const throw()
        {
            return const_reverse_iterator(begin());
        }

        const_iterator cbegin() const throw() { return begin(); }

        const_iterator cend() const throw() { return end(); }

        const_reverse_iterator crbegin() const throw() { return rbegin(); }

        const_reverse_iterator crend() const throw() { return rend(); }

        bool empty() const throw() { return __tree_.size() == 0; }

        size_type size() const throw() { return __tree_.size(); }

        size_type max_size() const throw() { return __tree_.max_size(); }

        allocator_type get_allocator() const throw() { return allocator_type(__tree_.__alloc()); }

        key_compare key_comp() const { return __tree_.value_comp().key_comp(); }

        value_compare value_comp() const
        {
            return value_compare(__tree_.value_comp().key_comp());
        }

        iterator insert(const value_type &__v) { return __tree_.__insert_multi(__v); }

        iterator insert(const_iterator __p, const value_type &__v)
        {
            return __tree_.__insert_multi(__p.__i_, __v);
        }
        template <class _InputIterator>

        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                __tree_.__insert_multi(__e.__i_, *__f);
        }

        iterator erase(const_iterator __p) { return __tree_.erase(__p.__i_); }

        iterator erase(iterator __p) { return __tree_.erase(__p.__i_); }

        size_type erase(const key_type &__k) { return __tree_.__erase_multi(__k); }

        iterator erase(const_iterator __f, const_iterator __l)
        {
            return __tree_.erase(__f.__i_, __l.__i_);
        }

        void clear() throw() { __tree_.clear(); }

        void swap(multimap &__m)
        {
            __tree_.swap(__m.__tree_);
        }

        iterator find(const key_type &__k) { return __tree_.find(__k); }

        const_iterator find(const key_type &__k) const { return __tree_.find(__k); }

        size_type count(const key_type &__k) const
        {
            return __tree_.__count_multi(__k);
        }

        iterator lower_bound(const key_type &__k)
        {
            return __tree_.lower_bound(__k);
        }

        const_iterator lower_bound(const key_type &__k) const
        {
            return __tree_.lower_bound(__k);
        }

        iterator upper_bound(const key_type &__k)
        {
            return __tree_.upper_bound(__k);
        }

        const_iterator upper_bound(const key_type &__k) const
        {
            return __tree_.upper_bound(__k);
        }

        pair<iterator, iterator> equal_range(const key_type &__k)
        {
            return __tree_.__equal_range_multi(__k);
        }

        pair<const_iterator, const_iterator> equal_range(const key_type &__k) const
        {
            return __tree_.__equal_range_multi(__k);
        }

    private:
        typedef typename __base::__node __node;
        typedef typename __base::__node_allocator __node_allocator;
        typedef typename __base::__node_pointer __node_pointer;
        typedef __map_node_destructor<__node_allocator> _Dp;
        typedef unique_ptr<__node, _Dp> __node_holder;
};
template <class _Key, class _Tp, class _Compare, class _Allocator>
inline bool
operator==(const multimap<_Key, _Tp, _Compare, _Allocator> &__x,
           const multimap<_Key, _Tp, _Compare, _Allocator> &__y)
{
        return __x.size() == __y.size() && std::equal(__x.begin(), __x.end(), __y.begin());
}
template <class _Key, class _Tp, class _Compare, class _Allocator>
inline bool
operator<(const multimap<_Key, _Tp, _Compare, _Allocator> &__x,
          const multimap<_Key, _Tp, _Compare, _Allocator> &__y)
{
        return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}
template <class _Key, class _Tp, class _Compare, class _Allocator>
inline bool
operator!=(const multimap<_Key, _Tp, _Compare, _Allocator> &__x,
           const multimap<_Key, _Tp, _Compare, _Allocator> &__y)
{
        return !(__x == __y);
}
template <class _Key, class _Tp, class _Compare, class _Allocator>
inline bool
operator>(const multimap<_Key, _Tp, _Compare, _Allocator> &__x,
          const multimap<_Key, _Tp, _Compare, _Allocator> &__y)
{
        return __y < __x;
}
template <class _Key, class _Tp, class _Compare, class _Allocator>
inline bool
operator>=(const multimap<_Key, _Tp, _Compare, _Allocator> &__x,
           const multimap<_Key, _Tp, _Compare, _Allocator> &__y)
{
        return !(__x < __y);
}
template <class _Key, class _Tp, class _Compare, class _Allocator>
inline bool
operator<=(const multimap<_Key, _Tp, _Compare, _Allocator> &__x,
           const multimap<_Key, _Tp, _Compare, _Allocator> &__y)
{
        return !(__y < __x);
}
template <class _Key, class _Tp, class _Compare, class _Allocator>
inline void
swap(multimap<_Key, _Tp, _Compare, _Allocator> &__x,
     multimap<_Key, _Tp, _Compare, _Allocator> &__y)
{
        __x.swap(__y);
}
    }
}
namespace boost
{
    namespace date_time
    {
template <typename charT>
struct parse_match_result
{
        parse_match_result() : match_depth(0),
                               current_match(PARSE_ERROR)
        {
        }
        typedef std::basic_string<charT> string_type;
        string_type remaining() const
        {
            if (match_depth == cache.size())
            {
                return string_type();
            }
            if (current_match == PARSE_ERROR)
            {
                return cache;
            }
            return string_type(cache, match_depth);
        }
        charT last_char() const
        {
            return cache[cache.size() - 1];
        }
        bool has_remaining() const
        {
            return (cache.size() > match_depth);
        }
        string_type cache;
        unsigned short match_depth;
        short current_match;
        enum PARSE_STATE
        {
            PARSE_ERROR = -1
        };
};
template <typename charT>
std::basic_ostream<charT> &
operator<<(std::basic_ostream<charT> &os, parse_match_result<charT> &mr)
{
        os << "cm: " << mr.current_match
           << " C: '" << mr.cache
           << "' md: " << mr.match_depth
           << " R: " << mr.remaining();
        return os;
}
template <typename charT>
struct string_parse_tree
{
        typedef std::multimap<charT, string_parse_tree> ptree_coll;
        typedef typename ptree_coll::value_type value_type;
        typedef typename ptree_coll::iterator iterator;
        typedef typename ptree_coll::const_iterator const_iterator;
        typedef std::basic_string<charT> string_type;
        typedef std::vector<std::basic_string<charT>> collection_type;
        typedef parse_match_result<charT> parse_match_result_type;
        string_parse_tree(collection_type names, unsigned int starting_point = 0) : m_value(parse_match_result_type::PARSE_ERROR)
        {
            unsigned short index = 0;
            while (index != names.size())
            {
                string_type s = boost::algorithm::to_lower_copy(names[index]);
                insert(s, static_cast<unsigned short>(index + starting_point));
                index++;
            }
            index++;
        }
        string_parse_tree(short value = parse_match_result_type::PARSE_ERROR) : m_value(value)
        {
        }
        ptree_coll m_next_chars;
        short m_value;
        void insert(const string_type &s, unsigned short value)
        {
            unsigned int i = 0;
            iterator ti;
            while (i < s.size())
            {
                if (i == 0)
                {
                    if (i == (s.size() - 1))
                    {
                        ti = m_next_chars.insert(value_type(s[i],
                                                            string_parse_tree<charT>(value)));
                    }
                    else
                    {
                        ti = m_next_chars.insert(value_type(s[i],
                                                            string_parse_tree<charT>()));
                    }
                }
                else
                {
                    if (i == (s.size() - 1))
                    {
                        ti = ti->second.m_next_chars.insert(value_type(s[i],
                                                                       string_parse_tree<charT>(value)));
                    }
                    else
                    {
                        ti = ti->second.m_next_chars.insert(value_type(s[i],
                                                                       string_parse_tree<charT>()));
                    }
                }
                i++;
            }
        }
        short
        match(std::istreambuf_iterator<charT> &sitr,
              std::istreambuf_iterator<charT> &stream_end,
              parse_match_result_type &result,
              unsigned int &level) const
        {
            level++;
            charT c;
            bool adv_itr = true;
            if (level > result.cache.size())
            {
                if (sitr == stream_end)
                    return 0;
                c = static_cast<charT>(std::tolower(*sitr));
            }
            else
            {
                adv_itr = false;
                c = static_cast<charT>(std::tolower(result.cache[level - 1]));
            }
            const_iterator litr = m_next_chars.lower_bound(c);
            const_iterator uitr = m_next_chars.upper_bound(c);
            while (litr != uitr)
            {
                if (adv_itr)
                {
                    sitr++;
                    result.cache += c;
                }
                if (litr->second.m_value != -1)
                {
                    if (result.match_depth < level)
                    {
                        result.current_match = litr->second.m_value;
                        result.match_depth = static_cast<unsigned short>(level);
                    }
                    litr->second.match(sitr, stream_end,
                                       result, level);
                    level--;
                }
                else
                {
                    litr->second.match(sitr, stream_end,
                                       result, level);
                    level--;
                }
                if (level <= result.cache.size())
                {
                    adv_itr = false;
                }
                litr++;
            }
            return result.current_match;
        }
        parse_match_result_type
        match(std::istreambuf_iterator<charT> &sitr,
              std::istreambuf_iterator<charT> &stream_end) const
        {
            unsigned int level = 0;
            parse_match_result_type result;
            match(sitr, stream_end, result, level);
            return result;
        }
        void printme(std::ostream &os, int &level)
        {
            level++;
            iterator itr = m_next_chars.begin();
            iterator end = m_next_chars.end();
            while (itr != end)
            {
                os << "level:  " << level
                   << " node:  " << itr->first
                   << " value: " << itr->second.m_value
                   << std::endl;
                itr->second.printme(os, level);
                itr++;
            }
            level--;
        }
        void print(std::ostream &os)
        {
            int level = 0;
            printme(os, level);
        }
        void printmatch(std::ostream &os, charT c)
        {
            iterator litr = m_next_chars.lower_bound(c);
            iterator uitr = m_next_chars.upper_bound(c);
            os << "matches for: " << c << std::endl;
            while (litr != uitr)
            {
                os << " node:  " << litr->first
                   << " value: " << litr->second.m_value
                   << std::endl;
                litr++;
            }
        }
};
    }
}
namespace boost
{
    namespace date_time
    {
template <class InputT, class OutputT>
inline std::basic_string<OutputT> convert_string_type(const std::basic_string<InputT> &inp_str)
{
        typedef std::basic_string<OutputT> output_type;
        output_type result;
        result.insert(result.begin(), inp_str.begin(), inp_str.end());
        return result;
}
    }
}
namespace boost
{
    namespace date_time
    {
template <class date_type, typename CharT>
class period_parser
{
    public:
        typedef std::basic_string<CharT> string_type;
        typedef CharT char_type;
        typedef std::istreambuf_iterator<CharT> stream_itr_type;
        typedef string_parse_tree<CharT> parse_tree_type;
        typedef typename parse_tree_type::parse_match_result_type match_results;
        typedef std::vector<std::basic_string<CharT>> collection_type;
        static const char_type default_period_separator[2];
        static const char_type default_period_start_delimeter[2];
        static const char_type default_period_open_range_end_delimeter[2];
        static const char_type default_period_closed_range_end_delimeter[2];
        enum period_range_option
        {
            AS_OPEN_RANGE,
            AS_CLOSED_RANGE
        };
        period_parser(period_range_option range_opt = AS_CLOSED_RANGE,
                      const char_type *const period_separator = default_period_separator,
                      const char_type *const period_start_delimeter = default_period_start_delimeter,
                      const char_type *const period_open_range_end_delimeter = default_period_open_range_end_delimeter,
                      const char_type *const period_closed_range_end_delimeter = default_period_closed_range_end_delimeter)
            : m_range_option(range_opt)
        {
            delimiters.push_back(string_type(period_separator));
            delimiters.push_back(string_type(period_start_delimeter));
            delimiters.push_back(string_type(period_open_range_end_delimeter));
            delimiters.push_back(string_type(period_closed_range_end_delimeter));
        }
        period_range_option range_option() const
        {
            return m_range_option;
        }
        void range_option(period_range_option option)
        {
            m_range_option = option;
        }
        collection_type delimiter_strings() const
        {
            return delimiters;
        }
        void delimiter_strings(const string_type &separator,
                               const string_type &start_delim,
                               const string_type &open_end_delim,
                               const string_type &closed_end_delim)
        {
            delimiters.clear();
            delimiters.push_back(separator);
            delimiters.push_back(start_delim);
            delimiters.push_back(open_end_delim);
            delimiters.push_back(closed_end_delim);
        }
        template <class period_type, class duration_type, class facet_type>
        period_type get_period(stream_itr_type &sitr,
                               stream_itr_type &stream_end,
                               std::ios_base &a_ios,
                               const period_type &,
                               const duration_type &dur_unit,
                               const facet_type &facet) const
        {
            while (std::isspace(*sitr) && sitr != stream_end)
            {
                ++sitr;
            }
            typedef typename period_type::point_type point_type;
            point_type p1(not_a_date_time), p2(not_a_date_time);
            consume_delim(sitr, stream_end, delimiters[START]);
            facet.get(sitr, stream_end, a_ios, p1);
            consume_delim(sitr, stream_end, delimiters[SEPARATOR]);
            facet.get(sitr, stream_end, a_ios, p2);
            if (m_range_option == AS_CLOSED_RANGE)
            {
                consume_delim(sitr, stream_end, delimiters[CLOSED_END]);
                p2 += dur_unit;
            }
            else
            {
                consume_delim(sitr, stream_end, delimiters[OPEN_END]);
            }
            return period_type(p1, p2);
        }

    private:
        collection_type delimiters;
        period_range_option m_range_option;
        enum delim_ids
        {
            SEPARATOR,
            START,
            OPEN_END,
            CLOSED_END
        };
        void consume_delim(stream_itr_type &sitr,
                           stream_itr_type &stream_end,
                           const string_type &delim) const
        {
            string_type s;
            for (unsigned int i = 0; i < delim.length() && sitr != stream_end; ++i)
            {
                s += *sitr;
                ++sitr;
            }
            if (s != delim)
            {
                boost::throw_exception(std::ios_base::failure("Parse failed. Expected '" + convert_string_type<char_type, char>(delim) + "' but found '" + convert_string_type<char_type, char>(s) + "'"));
            }
        }
};
template <class date_type, class char_type>
const typename period_parser<date_type, char_type>::char_type
    period_parser<date_type, char_type>::default_period_separator[2] = {'/'};
template <class date_type, class char_type>
const typename period_parser<date_type, char_type>::char_type
    period_parser<date_type, char_type>::default_period_start_delimeter[2] = {'['};
template <class date_type, class char_type>
const typename period_parser<date_type, char_type>::char_type
    period_parser<date_type, char_type>::default_period_open_range_end_delimeter[2] = {')'};
template <class date_type, class char_type>
const typename period_parser<date_type, char_type>::char_type
    period_parser<date_type, char_type>::default_period_closed_range_end_delimeter[2] = {']'};
    }
}
namespace boost
{
    namespace date_time
    {
template <class date_type, class CharT, class OutItrT = std::ostreambuf_iterator<CharT, std::char_traits<CharT>>>
class date_generator_formatter
{
    public:
        typedef partial_date<date_type> partial_date_type;
        typedef nth_kday_of_month<date_type> nth_kday_type;
        typedef first_kday_of_month<date_type> first_kday_type;
        typedef last_kday_of_month<date_type> last_kday_type;
        typedef first_kday_after<date_type> kday_after_type;
        typedef first_kday_before<date_type> kday_before_type;
        typedef CharT char_type;
        typedef std::basic_string<char_type> string_type;
        typedef std::vector<string_type> collection_type;
        static const char_type first_string[6];
        static const char_type second_string[7];
        static const char_type third_string[6];
        static const char_type fourth_string[7];
        static const char_type fifth_string[6];
        static const char_type last_string[5];
        static const char_type before_string[8];
        static const char_type after_string[6];
        static const char_type of_string[3];
        enum phrase_elements
        {
            first = 0,
            second,
            third,
            fourth,
            fifth,
            last,
            before,
            after,
            of,
            number_of_phrase_elements
        };
        date_generator_formatter()
        {
            phrase_strings.reserve(number_of_phrase_elements);
            phrase_strings.push_back(string_type(first_string));
            phrase_strings.push_back(string_type(second_string));
            phrase_strings.push_back(string_type(third_string));
            phrase_strings.push_back(string_type(fourth_string));
            phrase_strings.push_back(string_type(fifth_string));
            phrase_strings.push_back(string_type(last_string));
            phrase_strings.push_back(string_type(before_string));
            phrase_strings.push_back(string_type(after_string));
            phrase_strings.push_back(string_type(of_string));
        }
        date_generator_formatter(const string_type &first_str,
                                 const string_type &second_str,
                                 const string_type &third_str,
                                 const string_type &fourth_str,
                                 const string_type &fifth_str,
                                 const string_type &last_str,
                                 const string_type &before_str,
                                 const string_type &after_str,
                                 const string_type &of_str)
        {
            phrase_strings.reserve(number_of_phrase_elements);
            phrase_strings.push_back(first_str);
            phrase_strings.push_back(second_str);
            phrase_strings.push_back(third_str);
            phrase_strings.push_back(fourth_str);
            phrase_strings.push_back(fifth_str);
            phrase_strings.push_back(last_str);
            phrase_strings.push_back(before_str);
            phrase_strings.push_back(after_str);
            phrase_strings.push_back(of_str);
        }
        void elements(const collection_type &new_strings,
                      phrase_elements beg_pos = first)
        {
            if (beg_pos < number_of_phrase_elements)
            {
                typename collection_type::iterator itr = phrase_strings.begin();
                itr += beg_pos;
                std::copy(new_strings.begin(), new_strings.end(),
                          itr);
            }
        }
        template <class facet_type>
        OutItrT put_partial_date(OutItrT next, std::ios_base &a_ios,
                                 CharT a_fill, const partial_date_type &pd,
                                 const facet_type &facet) const
        {
            facet.put(next, a_ios, a_fill, pd.day());
            next = a_fill;
            facet.put(next, a_ios, a_fill, pd.month());
            return next;
        }
        template <class facet_type>
        OutItrT put_nth_kday(OutItrT next, std::ios_base &a_ios,
                             CharT a_fill, const nth_kday_type &nkd,
                             const facet_type &facet) const
        {
            put_string(next, phrase_strings[nkd.nth_week() - 1]);
            next = a_fill;
            facet.put(next, a_ios, a_fill, nkd.day_of_week());
            next = a_fill;
            put_string(next, string_type(of_string));
            next = a_fill;
            facet.put(next, a_ios, a_fill, nkd.month());
            return next;
        }
        template <class facet_type>
        OutItrT put_first_kday(OutItrT next, std::ios_base &a_ios,
                               CharT a_fill, const first_kday_type &fkd,
                               const facet_type &facet) const
        {
            put_string(next, phrase_strings[first]);
            next = a_fill;
            facet.put(next, a_ios, a_fill, fkd.day_of_week());
            next = a_fill;
            put_string(next, string_type(of_string));
            next = a_fill;
            facet.put(next, a_ios, a_fill, fkd.month());
            return next;
        }
        template <class facet_type>
        OutItrT put_last_kday(OutItrT next, std::ios_base &a_ios,
                              CharT a_fill, const last_kday_type &lkd,
                              const facet_type &facet) const
        {
            put_string(next, phrase_strings[last]);
            next = a_fill;
            facet.put(next, a_ios, a_fill, lkd.day_of_week());
            next = a_fill;
            put_string(next, string_type(of_string));
            next = a_fill;
            facet.put(next, a_ios, a_fill, lkd.month());
            return next;
        }
        template <class facet_type>
        OutItrT put_kday_before(OutItrT next, std::ios_base &a_ios,
                                CharT a_fill, const kday_before_type &fkb,
                                const facet_type &facet) const
        {
            facet.put(next, a_ios, a_fill, fkb.day_of_week());
            next = a_fill;
            put_string(next, phrase_strings[before]);
            return next;
        }
        template <class facet_type>
        OutItrT put_kday_after(OutItrT next, std::ios_base &a_ios,
                               CharT a_fill, const kday_after_type &fka,
                               const facet_type &facet) const
        {
            facet.put(next, a_ios, a_fill, fka.day_of_week());
            next = a_fill;
            put_string(next, phrase_strings[after]);
            return next;
        }

    private:
        collection_type phrase_strings;
        OutItrT put_string(OutItrT next, const string_type &str) const
        {
            typename string_type::const_iterator itr = str.begin();
            while (itr != str.end())
            {
                *next = *itr;
                ++itr;
                ++next;
            }
            return next;
        }
};
template <class date_type, class CharT, class OutItrT>
const typename date_generator_formatter<date_type, CharT, OutItrT>::char_type
    date_generator_formatter<date_type, CharT, OutItrT>::first_string[6] =
        {'f', 'i', 'r', 's', 't'};
template <class date_type, class CharT, class OutItrT>
const typename date_generator_formatter<date_type, CharT, OutItrT>::char_type
    date_generator_formatter<date_type, CharT, OutItrT>::second_string[7] =
        {'s', 'e', 'c', 'o', 'n', 'd'};
template <class date_type, class CharT, class OutItrT>
const typename date_generator_formatter<date_type, CharT, OutItrT>::char_type
    date_generator_formatter<date_type, CharT, OutItrT>::third_string[6] =
        {'t', 'h', 'i', 'r', 'd'};
template <class date_type, class CharT, class OutItrT>
const typename date_generator_formatter<date_type, CharT, OutItrT>::char_type
    date_generator_formatter<date_type, CharT, OutItrT>::fourth_string[7] =
        {'f', 'o', 'u', 'r', 't', 'h'};
template <class date_type, class CharT, class OutItrT>
const typename date_generator_formatter<date_type, CharT, OutItrT>::char_type
    date_generator_formatter<date_type, CharT, OutItrT>::fifth_string[6] =
        {'f', 'i', 'f', 't', 'h'};
template <class date_type, class CharT, class OutItrT>
const typename date_generator_formatter<date_type, CharT, OutItrT>::char_type
    date_generator_formatter<date_type, CharT, OutItrT>::last_string[5] =
        {'l', 'a', 's', 't'};
template <class date_type, class CharT, class OutItrT>
const typename date_generator_formatter<date_type, CharT, OutItrT>::char_type
    date_generator_formatter<date_type, CharT, OutItrT>::before_string[8] =
        {'b', 'e', 'f', 'o', 'r', 'e'};
template <class date_type, class CharT, class OutItrT>
const typename date_generator_formatter<date_type, CharT, OutItrT>::char_type
    date_generator_formatter<date_type, CharT, OutItrT>::after_string[6] =
        {'a', 'f', 't', 'e', 'r'};
template <class date_type, class CharT, class OutItrT>
const typename date_generator_formatter<date_type, CharT, OutItrT>::char_type
    date_generator_formatter<date_type, CharT, OutItrT>::of_string[3] =
        {'o', 'f'};
    }
}
namespace boost
{
    class bad_lexical_cast : public std::bad_cast
    {
public:
bad_lexical_cast()
    : source(&typeid(void)), target(&typeid(void))
{
}
const char *what() const throw()
{
        return "bad lexical cast: "
               "source type value could not be interpreted as target";
}
~bad_lexical_cast() throw()
{
}

private:
typedef ::std::type_info type_info_t;

public:
bad_lexical_cast(
    const type_info_t &source_type_arg,
    const type_info_t &target_type_arg)
    : source(&source_type_arg), target(&target_type_arg)
{
}
const type_info_t &source_type() const
{
        return *source;
}
const type_info_t &target_type() const
{
        return *target;
}

private:
const type_info_t *source;
const type_info_t *target;
    };
    namespace conversion
    {
namespace detail
{
        template <class S, class T>
        inline void throw_bad_cast()
        {
            boost::throw_exception(bad_lexical_cast(typeid(S), typeid(T)));
        }
}
    }
}
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wuninitialized"
#pragma GCC diagnostic ignored "-Wsign-conversion"
namespace boost
{
    namespace detail
    {
template <typename T>
struct is_character
{
        typedef typename boost::integral_constant<
            bool,
            boost::is_same<T, char>::value ||
                boost::is_same<T, wchar_t>::value ||
                boost::is_same<T, unsigned char>::value ||
                boost::is_same<T, signed char>::value>
            type;
        static const bool value = (type::value);
};
    }
}
namespace boost
{
    template <class T>
    struct is_float : public is_floating_point<T>
    {
    };
}
namespace boost
{
    template <class T>
    struct remove_volatile
    {
typedef T type;
    };
    template <class T>
    struct remove_volatile<T volatile>
    {
typedef T type;
    };
    template <class T, std::size_t N>
    struct remove_volatile<T volatile [N]>
    { typedef T type[N]; };
    template <class T>
    struct remove_volatile<T volatile[]> { typedef T type[]; };
}

namespace boost
{
    template <class T>
    struct type
    {
    };
}
namespace boost
{
    namespace mpl
    {
template <typename SourceTag, typename TargetTag>
struct numeric_cast
{
        template <typename N>
        struct apply;
};
    }
}

namespace boost
{
    namespace mpl
    {
namespace aux
{
        template <typename T, typename fallback_ = boost::mpl::bool_<false>>
        struct has_tag
        {
            struct gcc_3_2_wknd
            {
                template <typename U>
                static boost::mpl::aux::yes_tag test(boost::mpl::aux::type_wrapper<U> const volatile *, boost::mpl::aux::type_wrapper<typename U::tag> * = 0);
                static boost::mpl::aux::no_tag test(...);
            };
            typedef boost::mpl::aux::type_wrapper<T> t_;
            static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_ *>(0))) == sizeof(boost::mpl::aux::yes_tag);
            typedef boost::mpl::bool_<value> type;
        };
}
    }
}
namespace boost
{
    namespace mpl
    {
namespace aux
{
        template <typename T>
        struct tag_impl
        {
            typedef typename T::tag type;
        };
}
template <typename T, typename Default = void_>
struct tag
    : if_<
          aux::has_tag<T>, aux::tag_impl<T>, Default>::type
{
};
    }
}

namespace boost
{
    namespace mpl
    {
namespace aux
{
        template <
            typename F, typename Tag1, typename Tag2>
        struct cast1st_impl
        {
            template <typename N1, typename N2>
            struct apply
                : apply_wrap2<
                      F, typename apply_wrap1<numeric_cast<Tag1, Tag2>, N1>::type, N2>
            {
            };
        };
        template <
            typename F, typename Tag1, typename Tag2>
        struct cast2nd_impl
        {
            template <typename N1, typename N2>
            struct apply
                : apply_wrap2<
                      F, N1, typename apply_wrap1<numeric_cast<Tag2, Tag1>, N2>::type>
            {
            };
        };
}
    }
}
namespace boost
{
    namespace mpl
    {
namespace aux
{
}
    }
}
namespace boost
{
    namespace mpl
    {
namespace aux
{
        template <typename T>
        struct msvc_eti_base
            : T
        {
            msvc_eti_base();
            typedef T type;
        };
        template <>
        struct msvc_eti_base<int>
        {
            typedef msvc_eti_base type;
            typedef msvc_eti_base first;
            typedef msvc_eti_base second;
            typedef msvc_eti_base tag;
            enum
            {
                value = 0
            };
        };
}
    }
}
namespace boost
{
    namespace mpl
    {
template <
    typename Tag1, typename Tag2>
struct equal_to_impl
    : if_c<
          (Tag1::value > Tag2::value), aux::cast2nd_impl<equal_to_impl<Tag1, Tag1>, Tag1, Tag2>, aux::cast1st_impl<equal_to_impl<Tag2, Tag2>, Tag1, Tag2>>::type
{
};
template <>
struct equal_to_impl<na, na>
{
        template <typename U1, typename U2>
        struct apply
        {
            typedef apply type;
            static const int value = 0;
        };
};
template <typename Tag>
struct equal_to_impl<na, Tag>
{
        template <typename U1, typename U2>
        struct apply
        {
            typedef apply type;
            static const int value = 0;
        };
};
template <typename Tag>
struct equal_to_impl<Tag, na>
{
        template <typename U1, typename U2>
        struct apply
        {
            typedef apply type;
            static const int value = 0;
        };
};
template <typename T>
struct equal_to_tag
{
        typedef typename T::tag type;
};
template <
    typename N1 = na, typename N2 = na>
struct equal_to
    : equal_to_impl<
          typename equal_to_tag<N1>::type, typename equal_to_tag<N2>::type>::template apply<N1, N2>::type
{
};
template <>
struct equal_to<na, na>
{
        template <typename T1, typename T2, typename T3 = na, typename T4 = na, typename T5 = na>
        struct apply : equal_to<T1, T2>
        {
        };
};
template <typename Tag>
struct lambda<equal_to<na, na>, Tag, int_<-1>>
{
        typedef false_ is_le;
        typedef equal_to<na, na> result_;
        typedef equal_to<na, na> type;
};
namespace aux
{
        template <typename T1, typename T2>
        struct template_arity<equal_to<T1, T2>> : int_<2>
        {
        };
        template <>
        struct template_arity<equal_to<na, na>> : int_<-1>
        {
        };
}
    }
}
namespace boost
{
    namespace mpl
    {
template <>
struct equal_to_impl<integral_c_tag, integral_c_tag>
{
        template <typename N1, typename N2>
        struct apply
            : bool_<(N1::value == N2::value)>
        {
        };
};
    }
}
namespace boost
{
    namespace numeric
    {
namespace convdetail
{
        template <class T1, class T2>
        struct equal_to
        {
            enum
            {
                x = (T1::value == T2::value)
            };
            static const bool value = x;
            typedef mpl::bool_<value> type;
        };
        template <class Value,
                  class Case0Val,
                  class Case1Val,
                  class Case2Val,
                  class Case0Type,
                  class Case1Type,
                  class Case2Type,
                  class DefaultType>
        struct ct_switch4
        {
            typedef mpl::identity<Case0Type> Case0TypeQ;
            typedef mpl::identity<Case1Type> Case1TypeQ;
            typedef equal_to<Value, Case0Val> is_case0;
            typedef equal_to<Value, Case1Val> is_case1;
            typedef equal_to<Value, Case2Val> is_case2;
            typedef mpl::if_<is_case2, Case2Type, DefaultType> choose_2_3Q;
            typedef mpl::eval_if<is_case1, Case1TypeQ, choose_2_3Q> choose_1_2_3Q;
            typedef typename mpl::eval_if<is_case0, Case0TypeQ, choose_1_2_3Q>::type
                type;
        };
        template <class expr0, class expr1, class TT, class TF, class FT, class FF>
        struct for_both
        {
            typedef mpl::identity<TF> TF_Q;
            typedef mpl::identity<TT> TT_Q;
            typedef typename mpl::not_<expr0>::type not_expr0;
            typedef typename mpl::not_<expr1>::type not_expr1;
            typedef typename mpl::and_<expr0, expr1>::type caseTT;
            typedef typename mpl::and_<expr0, not_expr1>::type caseTF;
            typedef typename mpl::and_<not_expr0, expr1>::type caseFT;
            typedef mpl::if_<caseFT, FT, FF> choose_FT_FF_Q;
            typedef mpl::eval_if<caseTF, TF_Q, choose_FT_FF_Q> choose_TF_FT_FF_Q;
            typedef typename mpl::eval_if<caseTT, TT_Q, choose_TF_FT_FF_Q>::type type;
        };
}
    }
}
namespace boost
{
    namespace numeric
    {
enum int_float_mixture_enum
{
    integral_to_integral,
    integral_to_float,
    float_to_integral,
    float_to_float
};
    }
}
namespace boost
{
    namespace numeric
    {
namespace convdetail
{
        typedef boost::integral_constant<int_float_mixture_enum, integral_to_integral> int2int_c;
        typedef boost::integral_constant<int_float_mixture_enum, integral_to_float> int2float_c;
        typedef boost::integral_constant<int_float_mixture_enum, float_to_integral> float2int_c;
        typedef boost::integral_constant<int_float_mixture_enum, float_to_float> float2float_c;
        template <class T, class S>
        struct get_int_float_mixture
        {
            typedef mpl::bool_<::std::numeric_limits<S>::is_integer> S_int;
            typedef mpl::bool_<::std::numeric_limits<T>::is_integer> T_int;
            typedef typename for_both<S_int, T_int, int2int_c, int2float_c, float2int_c, float2float_c>::type
                type;
        };
        template <class IntFloatMixture, class Int2Int, class Int2Float, class Float2Int, class Float2Float>
        struct for_int_float_mixture
        {
            typedef typename ct_switch4<IntFloatMixture, int2int_c, int2float_c, float2int_c, Int2Int, Int2Float, Float2Int, Float2Float>::type
                type;
        };
}
    }
}
namespace boost
{
    namespace numeric
    {
enum sign_mixture_enum
{
    unsigned_to_unsigned,
    signed_to_signed,
    signed_to_unsigned,
    unsigned_to_signed
};
    }
}
namespace boost
{
    namespace numeric
    {
namespace convdetail
{
        typedef boost::integral_constant<sign_mixture_enum, unsigned_to_unsigned> unsig2unsig_c;
        typedef boost::integral_constant<sign_mixture_enum, signed_to_signed> sig2sig_c;
        typedef boost::integral_constant<sign_mixture_enum, signed_to_unsigned> sig2unsig_c;
        typedef boost::integral_constant<sign_mixture_enum, unsigned_to_signed> unsig2sig_c;
        template <class T, class S>
        struct get_sign_mixture
        {
            typedef mpl::bool_<::std::numeric_limits<S>::is_signed> S_signed;
            typedef mpl::bool_<::std::numeric_limits<T>::is_signed> T_signed;
            typedef typename for_both<S_signed, T_signed, sig2sig_c, sig2unsig_c, unsig2sig_c, unsig2unsig_c>::type
                type;
        };
        template <class SignMixture, class Sig2Sig, class Sig2Unsig, class Unsig2Sig, class Unsig2Unsig>
        struct for_sign_mixture
        {
            typedef typename ct_switch4<SignMixture, sig2sig_c, sig2unsig_c, unsig2sig_c, Sig2Sig, Sig2Unsig, Unsig2Sig, Unsig2Unsig>::type
                type;
        };
}
    }
}
namespace boost
{
    namespace numeric
    {
enum udt_builtin_mixture_enum
{
    builtin_to_builtin,
    builtin_to_udt,
    udt_to_builtin,
    udt_to_udt
};
    }
}
namespace boost
{
    namespace numeric
    {
namespace convdetail
{
        typedef boost::integral_constant<udt_builtin_mixture_enum, builtin_to_builtin> builtin2builtin_c;
        typedef boost::integral_constant<udt_builtin_mixture_enum, builtin_to_udt> builtin2udt_c;
        typedef boost::integral_constant<udt_builtin_mixture_enum, udt_to_builtin> udt2builtin_c;
        typedef boost::integral_constant<udt_builtin_mixture_enum, udt_to_udt> udt2udt_c;
        template <class UdtMixture, class BuiltIn2BuiltIn, class BuiltIn2Udt, class Udt2BuiltIn, class Udt2Udt>
        struct for_udt_builtin_mixture
        {
            typedef typename ct_switch4<UdtMixture, builtin2builtin_c, builtin2udt_c, udt2builtin_c, BuiltIn2BuiltIn, BuiltIn2Udt, Udt2BuiltIn, Udt2Udt>::type
                type;
        };
        template <class T, class S>
        struct get_udt_builtin_mixture
        {
            typedef is_arithmetic<S> S_builtin;
            typedef is_arithmetic<T> T_builtin;
            typedef typename for_both<S_builtin, T_builtin, builtin2builtin_c, builtin2udt_c, udt2builtin_c, udt2udt_c>::type
                type;
        };
}
    }
}
namespace mpl_
{
    template <typename T, T N>
    struct integral_c;
}
namespace boost
{
    namespace mpl
    {
using ::mpl_::integral_c;
    }
}
namespace mpl_
{
    template <typename T, T N>
    struct integral_c
    {
static const T value = N;
typedef integral_c type;
typedef T value_type;
typedef integral_c_tag tag;
typedef integral_c<T, static_cast<T>((value + 1))> next;
typedef integral_c<T, static_cast<T>((value - 1))> prior;
operator T() const { return static_cast<T>(this->value); }
    };
    template <typename T, T N>
    T const integral_c<T, N>::value;
}
namespace mpl_
{
    template <bool C>
    struct integral_c<bool, C>
    {
static const bool value = C;
typedef integral_c_tag tag;
typedef integral_c type;
typedef bool value_type;
operator bool() const { return this->value; }
    };
}
namespace boost
{
    namespace mpl
    {
namespace aux
{
        template <typename T>
        struct integral_rank;
        template <>
        struct integral_rank<bool> : int_<1>
        {
        };
        template <>
        struct integral_rank<signed char> : int_<2>
        {
        };
        template <>
        struct integral_rank<char> : int_<3>
        {
        };
        template <>
        struct integral_rank<unsigned char> : int_<4>
        {
        };
        template <>
        struct integral_rank<wchar_t> : int_<5>
        {
        };
        template <>
        struct integral_rank<short> : int_<6>
        {
        };
        template <>
        struct integral_rank<unsigned short> : int_<7>
        {
        };
        template <>
        struct integral_rank<int> : int_<8>
        {
        };
        template <>
        struct integral_rank<unsigned int> : int_<9>
        {
        };
        template <>
        struct integral_rank<long> : int_<10>
        {
        };
        template <>
        struct integral_rank<unsigned long> : int_<11>
        {
        };
        template <>
        struct integral_rank<long_long_type> : int_<12>
        {
        };
        template <>
        struct integral_rank<ulong_long_type> : int_<13>
        {
        };
        template <typename T1, typename T2>
        struct largest_int
            : if_c<
                  (integral_rank<T1>::value >= integral_rank<T2>::value), T1, T2>
        {
        };
}
    }
}
namespace boost
{
    namespace mpl
    {
template <
    typename Tag1, typename Tag2>
struct times_impl
    : if_c<
          (Tag1::value > Tag2::value), aux::cast2nd_impl<times_impl<Tag1, Tag1>, Tag1, Tag2>, aux::cast1st_impl<times_impl<Tag2, Tag2>, Tag1, Tag2>>::type
{
};
template <>
struct times_impl<na, na>
{
        template <typename U1, typename U2>
        struct apply
        {
            typedef apply type;
            static const int value = 0;
        };
};
template <typename Tag>
struct times_impl<na, Tag>
{
        template <typename U1, typename U2>
        struct apply
        {
            typedef apply type;
            static const int value = 0;
        };
};
template <typename Tag>
struct times_impl<Tag, na>
{
        template <typename U1, typename U2>
        struct apply
        {
            typedef apply type;
            static const int value = 0;
        };
};
template <typename T>
struct times_tag
{
        typedef typename T::tag type;
};
template <
    typename N1 = na, typename N2 = na, typename N3 = na, typename N4 = na, typename N5 = na>
struct times
    : times<times<times<times<N1, N2>, N3>, N4>, N5>
{
};
template <
    typename N1, typename N2, typename N3, typename N4>
struct times<N1, N2, N3, N4, na>
    : times<times<times<N1, N2>, N3>, N4>
{
};
template <
    typename N1, typename N2, typename N3>
struct times<N1, N2, N3, na, na>
    : times<times<N1, N2>, N3>
{
};
template <
    typename N1, typename N2>
struct times<N1, N2, na, na, na>
    : times_impl<
          typename times_tag<N1>::type, typename times_tag<N2>::type>::template apply<N1, N2>::type
{
};
template <>
struct times<na, na>
{
        template <typename T1, typename T2, typename T3 = na, typename T4 = na, typename T5 = na>
        struct apply : times<T1, T2>
        {
        };
};
template <typename Tag>
struct lambda<times<na, na>, Tag, int_<-1>>
{
        typedef false_ is_le;
        typedef times<na, na> result_;
        typedef times<na, na> type;
};
namespace aux
{
        template <typename T1, typename T2, typename T3, typename T4, typename T5>
        struct template_arity<times<T1, T2, T3, T4, T5>> : int_<5>
        {
        };
        template <>
        struct template_arity<times<na, na>> : int_<-1>
        {
        };
}
    }
}
namespace boost
{
    namespace mpl
    {
template <>
struct times_impl<integral_c_tag, integral_c_tag>
{
        template <typename N1, typename N2>
        struct apply
            : integral_c<
                  typename aux::largest_int<
                      typename N1::value_type, typename N2::value_type>::type,
                  (N1::value * N2::value)>
        {
        };
};
    }
}
namespace boost
{
    namespace mpl
    {
template <
    typename N1 = na, typename N2 = na, typename N3 = na, typename N4 = na, typename N5 = na>
struct multiplies
    : times<N1, N2, N3, N4, N5>
{
};
template <>
struct multiplies<na, na, na, na, na>
{
        template <typename T1, typename T2, typename T3, typename T4, typename T5>
        struct apply : multiplies<T1, T2, T3, T4, T5>
        {
        };
};
template <typename Tag>
struct lambda<multiplies<na, na, na, na, na>, Tag, int_<-1>>
{
        typedef false_ is_le;
        typedef multiplies<na, na, na, na, na> result_;
        typedef multiplies<na, na, na, na, na> type;
};
namespace aux
{
        template <typename T1, typename T2, typename T3, typename T4, typename T5>
        struct template_arity<multiplies<T1, T2, T3, T4, T5>> : int_<5>
        {
        };
        template <>
        struct template_arity<multiplies<na, na, na, na, na>> : int_<-1>
        {
        };
}
    }
}
namespace boost
{
    namespace mpl
    {
template <
    typename Tag1, typename Tag2>
struct less_impl
    : if_c<
          (Tag1::value > Tag2::value), aux::cast2nd_impl<less_impl<Tag1, Tag1>, Tag1, Tag2>, aux::cast1st_impl<less_impl<Tag2, Tag2>, Tag1, Tag2>>::type
{
};
template <>
struct less_impl<na, na>
{
        template <typename U1, typename U2>
        struct apply
        {
            typedef apply type;
            static const int value = 0;
        };
};
template <typename Tag>
struct less_impl<na, Tag>
{
        template <typename U1, typename U2>
        struct apply
        {
            typedef apply type;
            static const int value = 0;
        };
};
template <typename Tag>
struct less_impl<Tag, na>
{
        template <typename U1, typename U2>
        struct apply
        {
            typedef apply type;
            static const int value = 0;
        };
};
template <typename T>
struct less_tag
{
        typedef typename T::tag type;
};
template <
    typename N1 = na, typename N2 = na>
struct less
    : less_impl<
          typename less_tag<N1>::type, typename less_tag<N2>::type>::template apply<N1, N2>::type
{
};
template <>
struct less<na, na>
{
        template <typename T1, typename T2, typename T3 = na, typename T4 = na, typename T5 = na>
        struct apply : less<T1, T2>
        {
        };
};
template <typename Tag>
struct lambda<less<na, na>, Tag, int_<-1>>
{
        typedef false_ is_le;
        typedef less<na, na> result_;
        typedef less<na, na> type;
};
namespace aux
{
        template <typename T1, typename T2>
        struct template_arity<less<T1, T2>> : int_<2>
        {
        };
        template <>
        struct template_arity<less<na, na>> : int_<-1>
        {
        };
}
    }
}
namespace boost
{
    namespace mpl
    {
template <>
struct less_impl<integral_c_tag, integral_c_tag>
{
        template <typename N1, typename N2>
        struct apply
            : bool_<(N2::value > N1::value)>
        {
        };
};
    }
}
namespace boost
{
    namespace numeric
    {
namespace convdetail
{
        template <class T, class S>
        struct subranged_Sig2Unsig
        {
            typedef mpl::true_ type;
        };
        template <class T, class S>
        struct subranged_Unsig2Sig
        {
            typedef mpl::int_<::std::numeric_limits<S>::digits> S_digits;
            typedef mpl::int_<::std::numeric_limits<T>::digits> T_digits;
            typedef typename T_digits::next u_T_digits;
            typedef mpl::int_<2> Two;
            typedef typename mpl::multiplies<S_digits, Two>::type S_digits_times_2;
            typedef typename mpl::less<u_T_digits, S_digits_times_2>::type type;
        };
        template <class T, class S>
        struct subranged_SameSign
        {
            typedef mpl::int_<::std::numeric_limits<S>::digits> S_digits;
            typedef mpl::int_<::std::numeric_limits<T>::digits> T_digits;
            typedef typename mpl::less<T_digits, S_digits>::type type;
        };
        template <class T, class S>
        struct subranged_Int2Float
        {
            typedef mpl::false_ type;
        };
        template <class T, class S>
        struct subranged_Float2Int
        {
            typedef mpl::true_ type;
        };
        template <class T, class S>
        struct subranged_Float2Float
        {
            typedef mpl::int_<::std::numeric_limits<S>::digits> S_mantisa;
            typedef mpl::int_<::std::numeric_limits<T>::digits> T_mantisa;
            typedef mpl::int_<::std::numeric_limits<S>::max_exponent> S_exponent;
            typedef mpl::int_<::std::numeric_limits<T>::max_exponent> T_exponent;
            typedef typename mpl::less<T_exponent, S_exponent>::type T_smaller_exponent;
            typedef typename mpl::equal_to<T_exponent, S_exponent>::type equal_exponents;
            typedef mpl::less<T_mantisa, S_mantisa> T_smaller_mantisa;
            typedef mpl::eval_if<equal_exponents, T_smaller_mantisa, mpl::false_> not_bigger_exponent_case;
            typedef typename mpl::eval_if<T_smaller_exponent, mpl::true_, not_bigger_exponent_case>::type
                type;
        };
        template <class T, class S>
        struct subranged_Udt2BuiltIn
        {
            typedef mpl::true_ type;
        };
        template <class T, class S>
        struct subranged_BuiltIn2Udt
        {
            typedef mpl::false_ type;
        };
        template <class T, class S>
        struct subranged_Udt2Udt
        {
            typedef mpl::false_ type;
        };
        template <class T, class S>
        struct get_subranged_Int2Int
        {
            typedef subranged_SameSign<T, S> Sig2Sig;
            typedef subranged_Sig2Unsig<T, S> Sig2Unsig;
            typedef subranged_Unsig2Sig<T, S> Unsig2Sig;
            typedef Sig2Sig Unsig2Unsig;
            typedef typename get_sign_mixture<T, S>::type sign_mixture;
            typedef typename for_sign_mixture<sign_mixture, Sig2Sig, Sig2Unsig, Unsig2Sig, Unsig2Unsig>::type
                type;
        };
        template <class T, class S>
        struct get_subranged_BuiltIn2BuiltIn
        {
            typedef get_subranged_Int2Int<T, S> Int2IntQ;
            typedef subranged_Int2Float<T, S> Int2Float;
            typedef subranged_Float2Int<T, S> Float2Int;
            typedef subranged_Float2Float<T, S> Float2Float;
            typedef mpl::identity<Int2Float> Int2FloatQ;
            typedef mpl::identity<Float2Int> Float2IntQ;
            typedef mpl::identity<Float2Float> Float2FloatQ;
            typedef typename get_int_float_mixture<T, S>::type int_float_mixture;
            typedef for_int_float_mixture<int_float_mixture, Int2IntQ, Int2FloatQ, Float2IntQ, Float2FloatQ> for_;
            typedef typename for_::type selected;
            typedef typename selected::type type;
        };
        template <class T, class S>
        struct get_subranged
        {
            typedef get_subranged_BuiltIn2BuiltIn<T, S> BuiltIn2BuiltInQ;
            typedef subranged_BuiltIn2Udt<T, S> BuiltIn2Udt;
            typedef subranged_Udt2BuiltIn<T, S> Udt2BuiltIn;
            typedef subranged_Udt2Udt<T, S> Udt2Udt;
            typedef mpl::identity<BuiltIn2Udt> BuiltIn2UdtQ;
            typedef mpl::identity<Udt2BuiltIn> Udt2BuiltInQ;
            typedef mpl::identity<Udt2Udt> Udt2UdtQ;
            typedef typename get_udt_builtin_mixture<T, S>::type udt_builtin_mixture;
            typedef typename for_udt_builtin_mixture<udt_builtin_mixture, BuiltIn2BuiltInQ, BuiltIn2UdtQ, Udt2BuiltInQ, Udt2UdtQ>::type
                selected;
            typedef typename selected::type selected2;
            typedef typename selected2::type type;
        };
        template <class T, class S>
        struct get_is_subranged
        {
            typedef get_subranged<T, S> non_trivial_case;
            typedef mpl::identity<mpl::false_> trivial_case;
            typedef is_same<T, S> is_trivial;
            typedef typename mpl::if_<is_trivial, trivial_case, non_trivial_case>::type selected;
            typedef typename selected::type type;
        };
}
    }
}

namespace boost
{
    namespace numeric
    {
namespace convdetail
{
        template <class T, class S>
        struct non_trivial_traits_impl
        {
            typedef typename get_int_float_mixture<T, S>::type int_float_mixture;
            typedef typename get_sign_mixture<T, S>::type sign_mixture;
            typedef typename get_udt_builtin_mixture<T, S>::type udt_builtin_mixture;
            typedef typename get_is_subranged<T, S>::type subranged;
            typedef mpl::false_ trivial;
            typedef T target_type;
            typedef S source_type;
            typedef T result_type;
            typedef typename mpl::if_<is_arithmetic<S>, S, S const &>::type argument_type;
            typedef typename mpl::if_<subranged, S, T>::type supertype;
            typedef typename mpl::if_<subranged, T, S>::type subtype;
        };
        template <class N>
        struct trivial_traits_impl
        {
            typedef typename get_int_float_mixture<N, N>::type int_float_mixture;
            typedef typename get_sign_mixture<N, N>::type sign_mixture;
            typedef typename get_udt_builtin_mixture<N, N>::type udt_builtin_mixture;
            typedef mpl::false_ subranged;
            typedef mpl::true_ trivial;
            typedef N target_type;
            typedef N source_type;
            typedef N const &result_type;
            typedef N const &argument_type;
            typedef N supertype;
            typedef N subtype;
        };
        template <class T, class S>
        struct get_conversion_traits
        {
            typedef typename remove_cv<T>::type target_type;
            typedef typename remove_cv<S>::type source_type;
            typedef typename is_same<target_type, source_type>::type is_trivial;
            typedef trivial_traits_impl<target_type> trivial_imp;
            typedef non_trivial_traits_impl<target_type, source_type> non_trivial_imp;
            typedef typename mpl::if_<is_trivial, trivial_imp, non_trivial_imp>::type type;
        };
}
    }
}
namespace boost
{
    namespace numeric
    {
template <class T, class S>
struct conversion_traits
    : convdetail::get_conversion_traits<T, S>::type
{
};
    }
}
namespace boost
{
    namespace numeric
    {
template <class S>
struct Trunc
{
        typedef S source_type;
        typedef typename mpl::if_<is_arithmetic<S>, S, S const &>::type argument_type;
        static source_type nearbyint(argument_type s)
        {
            using std::ceil;
            using std::floor;
            return s < static_cast<S>(0) ? ceil(s) : floor(s);
        }
        typedef mpl::integral_c<std::float_round_style, std::round_toward_zero> round_style;
};
template <class S>
struct Floor
{
        typedef S source_type;
        typedef typename mpl::if_<is_arithmetic<S>, S, S const &>::type argument_type;
        static source_type nearbyint(argument_type s)
        {
            using std::floor;
            return floor(s);
        }
        typedef mpl::integral_c<std::float_round_style, std::round_toward_neg_infinity> round_style;
};
template <class S>
struct Ceil
{
        typedef S source_type;
        typedef typename mpl::if_<is_arithmetic<S>, S, S const &>::type argument_type;
        static source_type nearbyint(argument_type s)
        {
            using std::ceil;
            return ceil(s);
        }
        typedef mpl::integral_c<std::float_round_style, std::round_toward_infinity> round_style;
};
template <class S>
struct RoundEven
{
        typedef S source_type;
        typedef typename mpl::if_<is_arithmetic<S>, S, S const &>::type argument_type;
        static source_type nearbyint(argument_type s)
        {
            using std::ceil;
            using std::floor;
            S prev = floor(s);
            S next = ceil(s);
            S rt = (s - prev) - (next - s);
            S const zero(0.0);
            S const two(2.0);
            if (rt < zero)
                return prev;
            else if (rt > zero)
                return next;
            else
            {
                bool is_prev_even = two * floor(prev / two) == prev;
                return (is_prev_even ? prev : next);
            }
        }
        typedef mpl::integral_c<std::float_round_style, std::round_to_nearest> round_style;
};
enum range_check_result
{
    cInRange = 0,
    cNegOverflow = 1,
    cPosOverflow = 2
};
class bad_numeric_cast : public std::bad_cast
{
    public:
        const char *what() const throw()
        {
            return "bad numeric conversion: overflow";
        }
};
class negative_overflow : public bad_numeric_cast
{
    public:
        const char *what() const throw()
        {
            return "bad numeric conversion: negative overflow";
        }
};
class positive_overflow : public bad_numeric_cast
{
    public:
        const char *what() const throw()
        {
            return "bad numeric conversion: positive overflow";
        }
};
struct def_overflow_handler
{
        void operator()(range_check_result r)
        {
            if (r == cNegOverflow)
                throw negative_overflow();
            else if (r == cPosOverflow)
                throw positive_overflow();
        }
};
struct silent_overflow_handler
{
        void operator()(range_check_result) {}
};
template <class Traits>
struct raw_converter
{
        typedef typename Traits::result_type result_type;
        typedef typename Traits::argument_type argument_type;
        static result_type low_level_convert(argument_type s) { return static_cast<result_type>(s); }
};
struct UseInternalRangeChecker
{
};
    }
}

namespace boost
{
    namespace numeric
    {
namespace boundsdetail
{
        template <class N>
        class Integral
        {
            typedef std::numeric_limits<N> limits;

        public:
            static N lowest() { return limits::min(); }
            static N highest() { return limits::max(); }
            static N smallest() { return static_cast<N>(1); }
        };
        template <class N>
        class Float
        {
            typedef std::numeric_limits<N> limits;

        public:
            static N lowest() { return static_cast<N>(-limits::max()); }
            static N highest() { return limits::max(); }
            static N smallest() { return limits::min(); }
        };
        template <class N>
        struct get_impl
        {
            typedef mpl::bool_<::std::numeric_limits<N>::is_integer> is_int;
            typedef Integral<N> impl_int;
            typedef Float<N> impl_float;
            typedef typename mpl::if_<is_int, impl_int, impl_float>::type type;
        };
}
    }
}

namespace boost
{
    namespace numeric
    {
template <class N>
struct bounds : boundsdetail::get_impl<N>::type
{
};
    }
}
namespace boost
{
    namespace numeric
    {
namespace convdetail
{
        typedef mpl::integral_c<std::float_round_style, std::round_toward_zero> round2zero_c;
        typedef mpl::integral_c<std::float_round_style, std::round_to_nearest> round2nearest_c;
        typedef mpl::integral_c<std::float_round_style, std::round_toward_infinity> round2inf_c;
        typedef mpl::integral_c<std::float_round_style, std::round_toward_neg_infinity> round2neg_inf_c;
        template <class RoundStyle, class RoundToZero, class RoundToNearest, class RoundToInf, class RoundToNegInf>
        struct for_round_style
        {
            typedef ct_switch4<RoundStyle, round2zero_c, round2nearest_c, round2inf_c, RoundToZero, RoundToNearest, RoundToInf, RoundToNegInf> selector;
            typedef typename selector::type type;
        };
        struct non_applicable
        {
            typedef mpl::false_ do_apply;
        };
        struct applicable
        {
            typedef mpl::true_ do_apply;
        };
        template <class Traits>
        struct LT_LoT : applicable
        {
            typedef typename Traits::target_type T;
            typedef typename Traits::source_type S;
            typedef typename Traits::argument_type argument_type;
            static range_check_result apply(argument_type s)
            {
                return s < static_cast<S>(bounds<T>::lowest()) ? cNegOverflow : cInRange;
            }
        };
        template <class Traits>
        struct LT_Zero : applicable
        {
            typedef typename Traits::source_type S;
            typedef typename Traits::argument_type argument_type;
            static range_check_result apply(argument_type s)
            {
                return s < static_cast<S>(0) ? cNegOverflow : cInRange;
            }
        };
        template <class Traits>
        struct LE_PrevLoT : applicable
        {
            typedef typename Traits::target_type T;
            typedef typename Traits::source_type S;
            typedef typename Traits::argument_type argument_type;
            static range_check_result apply(argument_type s)
            {
                return s <= static_cast<S>(bounds<T>::lowest()) - static_cast<S>(1.0)
                           ? cNegOverflow
                           : cInRange;
            }
        };
        template <class Traits>
        struct LT_HalfPrevLoT : applicable
        {
            typedef typename Traits::target_type T;
            typedef typename Traits::source_type S;
            typedef typename Traits::argument_type argument_type;
            static range_check_result apply(argument_type s)
            {
                return s < static_cast<S>(bounds<T>::lowest()) - static_cast<S>(0.5)
                           ? cNegOverflow
                           : cInRange;
            }
        };
        template <class Traits>
        struct GT_HiT : applicable
        {
            typedef typename Traits::target_type T;
            typedef typename Traits::source_type S;
            typedef typename Traits::argument_type argument_type;
            static range_check_result apply(argument_type s)
            {
                return s > static_cast<S>(bounds<T>::highest())
                           ? cPosOverflow
                           : cInRange;
            }
        };
        template <class Traits>
        struct GE_SuccHiT : applicable
        {
            typedef typename Traits::target_type T;
            typedef typename Traits::source_type S;
            typedef typename Traits::argument_type argument_type;
            static range_check_result apply(argument_type s)
            {
                return s >= static_cast<S>(bounds<T>::highest()) + static_cast<S>(1.0)
                           ? cPosOverflow
                           : cInRange;
            }
        };
        template <class Traits>
        struct GT_HalfSuccHiT : applicable
        {
            typedef typename Traits::target_type T;
            typedef typename Traits::source_type S;
            typedef typename Traits::argument_type argument_type;
            static range_check_result apply(argument_type s)
            {
                return s >= static_cast<S>(bounds<T>::highest()) + static_cast<S>(0.5)
                           ? cPosOverflow
                           : cInRange;
            }
        };
        template <class PredA, class PredB>
        struct applyBoth
        {
            typedef typename PredA::argument_type argument_type;
            static range_check_result apply(argument_type s)
            {
                range_check_result r = PredA::apply(s);
                if (r == cInRange)
                    r = PredB::apply(s);
                return r;
            }
        };
        template <class PredA, class PredB>
        struct combine
        {
            typedef applyBoth<PredA, PredB> Both;
            typedef void NNone;
            typedef typename PredA::do_apply do_applyA;
            typedef typename PredB::do_apply do_applyB;
            typedef typename for_both<do_applyA, do_applyB, Both, PredA, PredB, NNone>::type type;
        };
        template <class Traits>
        struct dummy_range_checker
        {
            typedef typename Traits::argument_type argument_type;
            static range_check_result out_of_range(argument_type) { return cInRange; }
            static void validate_range(argument_type) {}
        };
        template <class Traits, class IsNegOverflow, class IsPosOverflow, class OverflowHandler>
        struct generic_range_checker
        {
            typedef OverflowHandler overflow_handler;
            typedef typename Traits::argument_type argument_type;
            static range_check_result out_of_range(argument_type s)
            {
                typedef typename combine<IsNegOverflow, IsPosOverflow>::type Predicate;
                return Predicate::apply(s);
            }
            static void validate_range(argument_type s)
            {
                OverflowHandler()(out_of_range(s));
            }
        };
        template <class Traits, class OverflowHandler>
        struct GetRC_Sig2Sig_or_Unsig2Unsig
        {
            typedef dummy_range_checker<Traits> Dummy;
            typedef LT_LoT<Traits> Pred1;
            typedef GT_HiT<Traits> Pred2;
            typedef generic_range_checker<Traits, Pred1, Pred2, OverflowHandler> Normal;
            typedef typename Traits::subranged subranged;
            typedef typename mpl::if_<subranged, Normal, Dummy>::type type;
        };
        template <class Traits, class OverflowHandler>
        struct GetRC_Sig2Unsig
        {
            typedef LT_Zero<Traits> Pred1;
            typedef GT_HiT<Traits> Pred2;
            typedef generic_range_checker<Traits, Pred1, Pred2, OverflowHandler> ChoiceA;
            typedef generic_range_checker<Traits, Pred1, non_applicable, OverflowHandler> ChoiceB;
            typedef typename Traits::target_type T;
            typedef typename Traits::source_type S;
            typedef typename subranged_Unsig2Sig<S, T>::type oposite_subranged;
            typedef typename mpl::not_<oposite_subranged>::type positively_subranged;
            typedef typename mpl::if_<positively_subranged, ChoiceA, ChoiceB>::type type;
        };
        template <class Traits, class OverflowHandler>
        struct GetRC_Unsig2Sig
        {
            typedef GT_HiT<Traits> Pred1;
            typedef generic_range_checker<Traits, non_applicable, Pred1, OverflowHandler> type;
        };
        template <class Traits, class OverflowHandler>
        struct GetRC_Int2Int
        {
            typedef GetRC_Sig2Sig_or_Unsig2Unsig<Traits, OverflowHandler> Sig2SigQ;
            typedef GetRC_Sig2Unsig<Traits, OverflowHandler> Sig2UnsigQ;
            typedef GetRC_Unsig2Sig<Traits, OverflowHandler> Unsig2SigQ;
            typedef Sig2SigQ Unsig2UnsigQ;
            typedef typename Traits::sign_mixture sign_mixture;
            typedef typename for_sign_mixture<sign_mixture, Sig2SigQ, Sig2UnsigQ, Unsig2SigQ, Unsig2UnsigQ>::type
                selector;
            typedef typename selector::type type;
        };
        template <class Traits>
        struct GetRC_Int2Float
        {
            typedef dummy_range_checker<Traits> type;
        };
        template <class Traits, class OverflowHandler, class Float2IntRounder>
        struct GetRC_Float2Int
        {
            typedef LE_PrevLoT<Traits> Pred1;
            typedef GE_SuccHiT<Traits> Pred2;
            typedef LT_HalfPrevLoT<Traits> Pred3;
            typedef GT_HalfSuccHiT<Traits> Pred4;
            typedef GT_HiT<Traits> Pred5;
            typedef LT_LoT<Traits> Pred6;
            typedef generic_range_checker<Traits, Pred1, Pred2, OverflowHandler> ToZero;
            typedef generic_range_checker<Traits, Pred3, Pred4, OverflowHandler> ToNearest;
            typedef generic_range_checker<Traits, Pred1, Pred5, OverflowHandler> ToInf;
            typedef generic_range_checker<Traits, Pred6, Pred2, OverflowHandler> ToNegInf;
            typedef typename Float2IntRounder::round_style round_style;
            typedef typename for_round_style<round_style, ToZero, ToNearest, ToInf, ToNegInf>::type type;
        };
        template <class Traits, class OverflowHandler>
        struct GetRC_Float2Float
        {
            typedef dummy_range_checker<Traits> Dummy;
            typedef LT_LoT<Traits> Pred1;
            typedef GT_HiT<Traits> Pred2;
            typedef generic_range_checker<Traits, Pred1, Pred2, OverflowHandler> Normal;
            typedef typename Traits::subranged subranged;
            typedef typename mpl::if_<subranged, Normal, Dummy>::type type;
        };
        template <class Traits, class OverflowHandler, class Float2IntRounder>
        struct GetRC_BuiltIn2BuiltIn
        {
            typedef GetRC_Int2Int<Traits, OverflowHandler> Int2IntQ;
            typedef GetRC_Int2Float<Traits> Int2FloatQ;
            typedef GetRC_Float2Int<Traits, OverflowHandler, Float2IntRounder> Float2IntQ;
            typedef GetRC_Float2Float<Traits, OverflowHandler> Float2FloatQ;
            typedef typename Traits::int_float_mixture int_float_mixture;
            typedef typename for_int_float_mixture<int_float_mixture, Int2IntQ, Int2FloatQ, Float2IntQ, Float2FloatQ>::type selector;
            typedef typename selector::type type;
        };
        template <class Traits, class OverflowHandler, class Float2IntRounder>
        struct GetRC
        {
            typedef GetRC_BuiltIn2BuiltIn<Traits, OverflowHandler, Float2IntRounder> BuiltIn2BuiltInQ;
            typedef dummy_range_checker<Traits> Dummy;
            typedef mpl::identity<Dummy> DummyQ;
            typedef typename Traits::udt_builtin_mixture udt_builtin_mixture;
            typedef typename for_udt_builtin_mixture<udt_builtin_mixture, BuiltIn2BuiltInQ, DummyQ, DummyQ, DummyQ>::type selector;
            typedef typename selector::type type;
        };
        template <class Traits>
        struct trivial_converter_impl : public dummy_range_checker<Traits>
        {
            typedef Traits traits;
            typedef typename Traits::source_type source_type;
            typedef typename Traits::argument_type argument_type;
            typedef typename Traits::result_type result_type;
            static result_type low_level_convert(argument_type s) { return s; }
            static source_type nearbyint(argument_type s) { return s; }
            static result_type convert(argument_type s) { return s; }
        };
        template <class Traits, class RangeChecker, class RawConverter, class Float2IntRounder>
        struct rounding_converter : public RangeChecker, public Float2IntRounder, public RawConverter
        {
            typedef RangeChecker RangeCheckerBase;
            typedef Float2IntRounder Float2IntRounderBase;
            typedef RawConverter RawConverterBase;
            typedef Traits traits;
            typedef typename Traits::source_type source_type;
            typedef typename Traits::argument_type argument_type;
            typedef typename Traits::result_type result_type;
            static result_type convert(argument_type s)
            {
                RangeCheckerBase::validate_range(s);
                source_type s1 = Float2IntRounderBase::nearbyint(s);
                return RawConverterBase::low_level_convert(s1);
            }
        };
        template <class Traits, class RangeChecker, class RawConverter>
        struct non_rounding_converter : public RangeChecker, public RawConverter
        {
            typedef RangeChecker RangeCheckerBase;
            typedef RawConverter RawConverterBase;
            typedef Traits traits;
            typedef typename Traits::source_type source_type;
            typedef typename Traits::argument_type argument_type;
            typedef typename Traits::result_type result_type;
            static source_type nearbyint(argument_type s) { return s; }
            static result_type convert(argument_type s)
            {
                RangeCheckerBase::validate_range(s);
                return RawConverterBase::low_level_convert(s);
            }
        };
        template <class Traits, class OverflowHandler, class Float2IntRounder, class RawConverter, class UserRangeChecker>
        struct get_non_trivial_converter
        {
            typedef GetRC<Traits, OverflowHandler, Float2IntRounder> InternalRangeCheckerQ;
            typedef is_same<UserRangeChecker, UseInternalRangeChecker> use_internal_RC;
            typedef mpl::identity<UserRangeChecker> UserRangeCheckerQ;
            typedef typename mpl::eval_if<use_internal_RC, InternalRangeCheckerQ, UserRangeCheckerQ>::type
                RangeChecker;
            typedef non_rounding_converter<Traits, RangeChecker, RawConverter> NonRounding;
            typedef rounding_converter<Traits, RangeChecker, RawConverter, Float2IntRounder> Rounding;
            typedef mpl::identity<NonRounding> NonRoundingQ;
            typedef mpl::identity<Rounding> RoundingQ;
            typedef typename Traits::int_float_mixture int_float_mixture;
            typedef typename for_int_float_mixture<int_float_mixture, NonRoundingQ, NonRoundingQ, RoundingQ, NonRoundingQ>::type
                selector;
            typedef typename selector::type type;
        };
        template <class Traits, class OverflowHandler, class Float2IntRounder, class RawConverter, class UserRangeChecker>
        struct get_converter_impl
        {
            typedef trivial_converter_impl<Traits> Trivial;
            typedef mpl::identity<Trivial> TrivialQ;
            typedef get_non_trivial_converter<Traits, OverflowHandler, Float2IntRounder, RawConverter, UserRangeChecker> NonTrivialQ;
            typedef typename Traits::trivial trivial;
            typedef typename mpl::eval_if<trivial, TrivialQ, NonTrivialQ>::type type;
        };
}
    }
}

namespace boost
{
    namespace numeric
    {
template <class T,
          class S,
          class Traits = conversion_traits<T, S>,
          class OverflowHandler = def_overflow_handler,
          class Float2IntRounder = Trunc<typename Traits::source_type>,
          class RawConverter = raw_converter<Traits>,
          class UserRangeChecker = UseInternalRangeChecker>
struct converter : convdetail::get_converter_impl<Traits,
                                                  OverflowHandler,
                                                  Float2IntRounder,
                                                  RawConverter,
                                                  UserRangeChecker>::type
{
        typedef Traits traits;
        typedef typename Traits::argument_type argument_type;
        typedef typename Traits::result_type result_type;
        result_type operator()(argument_type s) const { return this->convert(s); }
};
template <class S,
          class OverflowHandler = def_overflow_handler,
          class Float2IntRounder = Trunc<S>,
          class UserRangeChecker = UseInternalRangeChecker>
struct make_converter_from
{
        template <class T,
                  class Traits = conversion_traits<T, S>,
                  class RawConverter = raw_converter<Traits>>
        struct to
        {
            typedef converter<T, S, Traits, OverflowHandler, Float2IntRounder, RawConverter, UserRangeChecker> type;
        };
};
    }
}
namespace boost
{
    namespace numeric
    {
template <typename Target, typename Source, typename EnableIf = void>
struct numeric_cast_traits
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<Source> rounding_policy;
};
    }
}
namespace boost
{
    namespace numeric
    {
template <>
struct numeric_cast_traits<
    char, char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    char, signed char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    char, unsigned char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    char, short>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
};
template <>
struct numeric_cast_traits<
    char, unsigned short>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
};
template <>
struct numeric_cast_traits<
    char, int>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
};
template <>
struct numeric_cast_traits<
    char, unsigned int>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
};
template <>
struct numeric_cast_traits<
    char, long>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
};
template <>
struct numeric_cast_traits<
    char, unsigned long>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
};
template <>
struct numeric_cast_traits<
    char, float>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
};
template <>
struct numeric_cast_traits<
    char, double>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
};
template <>
struct numeric_cast_traits<
    char, long double>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
};
template <>
struct numeric_cast_traits<
    signed char, char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    signed char, signed char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    signed char, unsigned char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    signed char, short>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
};
template <>
struct numeric_cast_traits<
    signed char, unsigned short>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
};
template <>
struct numeric_cast_traits<
    signed char, int>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
};
template <>
struct numeric_cast_traits<
    signed char, unsigned int>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
};
template <>
struct numeric_cast_traits<
    signed char, long>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
};
template <>
struct numeric_cast_traits<
    signed char, unsigned long>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
};
template <>
struct numeric_cast_traits<
    signed char, float>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
};
template <>
struct numeric_cast_traits<
    signed char, double>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
};
template <>
struct numeric_cast_traits<
    signed char, long double>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned char, char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned char, signed char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned char, unsigned char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned char, short>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned char, unsigned short>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned char, int>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned char, unsigned int>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned char, long>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned char, unsigned long>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned char, float>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned char, double>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned char, long double>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
};
template <>
struct numeric_cast_traits<
    short, char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    short, signed char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    short, unsigned char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    short, short>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
};
template <>
struct numeric_cast_traits<
    short, unsigned short>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
};
template <>
struct numeric_cast_traits<
    short, int>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
};
template <>
struct numeric_cast_traits<
    short, unsigned int>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
};
template <>
struct numeric_cast_traits<
    short, long>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
};
template <>
struct numeric_cast_traits<
    short, unsigned long>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
};
template <>
struct numeric_cast_traits<
    short, float>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
};
template <>
struct numeric_cast_traits<
    short, double>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
};
template <>
struct numeric_cast_traits<
    short, long double>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned short, char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned short, signed char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned short, unsigned char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned short, short>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned short, unsigned short>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned short, int>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned short, unsigned int>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned short, long>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned short, unsigned long>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned short, float>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned short, double>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned short, long double>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
};
template <>
struct numeric_cast_traits<
    int, char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    int, signed char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    int, unsigned char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    int, short>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
};
template <>
struct numeric_cast_traits<
    int, unsigned short>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
};
template <>
struct numeric_cast_traits<
    int, int>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
};
template <>
struct numeric_cast_traits<
    int, unsigned int>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
};
template <>
struct numeric_cast_traits<
    int, long>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
};
template <>
struct numeric_cast_traits<
    int, unsigned long>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
};
template <>
struct numeric_cast_traits<
    int, float>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
};
template <>
struct numeric_cast_traits<
    int, double>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
};
template <>
struct numeric_cast_traits<
    int, long double>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned int, char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned int, signed char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned int, unsigned char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned int, short>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned int, unsigned short>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned int, int>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned int, unsigned int>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned int, long>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned int, unsigned long>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned int, float>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned int, double>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned int, long double>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long, char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long, signed char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long, unsigned char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long, short>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long, unsigned short>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long, int>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long, unsigned int>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long, long>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long, unsigned long>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long, float>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long, double>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long, long double>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned long, char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned long, signed char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned long, unsigned char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned long, short>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned long, unsigned short>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned long, int>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned long, unsigned int>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned long, long>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned long, unsigned long>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned long, float>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned long, double>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned long, long double>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
};
template <>
struct numeric_cast_traits<
    float, char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    float, signed char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    float, unsigned char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    float, short>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
};
template <>
struct numeric_cast_traits<
    float, unsigned short>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
};
template <>
struct numeric_cast_traits<
    float, int>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
};
template <>
struct numeric_cast_traits<
    float, unsigned int>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
};
template <>
struct numeric_cast_traits<
    float, long>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
};
template <>
struct numeric_cast_traits<
    float, unsigned long>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
};
template <>
struct numeric_cast_traits<
    float, float>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
};
template <>
struct numeric_cast_traits<
    float, double>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
};
template <>
struct numeric_cast_traits<
    float, long double>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
};
template <>
struct numeric_cast_traits<
    double, char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    double, signed char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    double, unsigned char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    double, short>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
};
template <>
struct numeric_cast_traits<
    double, unsigned short>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
};
template <>
struct numeric_cast_traits<
    double, int>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
};
template <>
struct numeric_cast_traits<
    double, unsigned int>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
};
template <>
struct numeric_cast_traits<
    double, long>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
};
template <>
struct numeric_cast_traits<
    double, unsigned long>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
};
template <>
struct numeric_cast_traits<
    double, float>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
};
template <>
struct numeric_cast_traits<
    double, double>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
};
template <>
struct numeric_cast_traits<
    double, long double>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long double, char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long double, signed char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long double, unsigned char>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long double, short>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long double, unsigned short>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long double, int>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long double, unsigned int>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long double, long>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long double, unsigned long>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long double, float>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long double, double>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long double, long double>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
};
    }
}
namespace boost
{
    namespace numeric
    {
template <>
struct numeric_cast_traits<
    char, boost::long_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    char, boost::ulong_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    signed char, boost::long_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    signed char, boost::ulong_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned char, boost::long_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned char, boost::ulong_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    short, boost::long_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    short, boost::ulong_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned short, boost::long_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned short, boost::ulong_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    int, boost::long_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    int, boost::ulong_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned int, boost::long_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned int, boost::ulong_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long, boost::long_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long, boost::ulong_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned long, boost::long_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    unsigned long, boost::ulong_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    float, boost::long_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    float, boost::ulong_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    double, boost::long_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    double, boost::ulong_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long double, boost::long_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    long double, boost::ulong_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    boost::long_long_type, boost::long_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    boost::long_long_type, boost::ulong_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    boost::ulong_long_type, boost::long_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
};
template <>
struct numeric_cast_traits<
    boost::ulong_long_type, boost::ulong_long_type>
{
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
};
    }
}

namespace boost
{
    template <typename Target, typename Source>
    inline Target numeric_cast(Source arg)
    {
typedef numeric::conversion_traits<Target, Source> conv_traits;
typedef numeric::numeric_cast_traits<Target, Source> cast_traits;
typedef boost::numeric::converter<
    Target,
    Source,
    conv_traits,
    typename cast_traits::overflow_policy,
    typename cast_traits::rounding_policy,
    boost::numeric::raw_converter<conv_traits>,
    typename cast_traits::range_checking_policy>
    converter;
return converter::convert(arg);
    }
    using numeric::bad_numeric_cast;
}

namespace boost
{
    namespace detail
    {
template <class Source>
struct detect_precision_loss
{
        typedef Source source_type;
        typedef boost::numeric::Trunc<Source> Rounder;
        typedef typename conditional<
            boost::is_arithmetic<Source>::value, Source, Source const &>::type argument_type;
        static inline source_type nearbyint(argument_type s, bool &is_ok)
        {
            const source_type near_int = Rounder::nearbyint(s);
            if (near_int && is_ok)
            {
                const source_type orig_div_round = s / near_int;
                const source_type eps = std::numeric_limits<source_type>::epsilon();
                is_ok = !((orig_div_round > 1 ? orig_div_round - 1 : 1 - orig_div_round) > eps);
            }
            return s;
        }
        typedef typename Rounder::round_style round_style;
};
template <typename Base, class Source>
struct fake_precision_loss : public Base
{
        typedef Source source_type;
        typedef typename conditional<
            boost::is_arithmetic<Source>::value, Source, Source const &>::type argument_type;
        static inline source_type nearbyint(argument_type s, bool &)
        {
            return s;
        }
};
struct nothrow_overflow_handler
{
        inline bool operator()(boost::numeric::range_check_result r) const
        {
            return (r == boost::numeric::cInRange);
        }
};
template <typename Target, typename Source>
inline bool noexcept_numeric_convert(const Source &arg, Target &result)
{
        typedef boost::numeric::converter<
            Target,
            Source,
            boost::numeric::conversion_traits<Target, Source>,
            nothrow_overflow_handler,
            detect_precision_loss<Source>>
            converter_orig_t;
        typedef typename boost::conditional<
            boost::is_base_of<detect_precision_loss<Source>, converter_orig_t>::value,
            converter_orig_t,
            fake_precision_loss<converter_orig_t, Source>>::type converter_t;
        bool res = nothrow_overflow_handler()(converter_t::out_of_range(arg));
        if (res)
        {
            result = converter_t::low_level_convert(converter_t::nearbyint(arg, res));
        }
        return res;
}
template <typename Target, typename Source>
struct lexical_cast_dynamic_num_not_ignoring_minus
{
        static inline bool try_convert(const Source &arg, Target &result)
        {
            return noexcept_numeric_convert<Target, Source>(arg, result);
        }
};
template <typename Target, typename Source>
struct lexical_cast_dynamic_num_ignoring_minus
{
        static inline bool try_convert(const Source &arg, Target &result)
        {
            typedef typename boost::conditional<
                boost::is_float<Source>::value,
                boost::type_identity<Source>,
                boost::make_unsigned<Source>>::type usource_lazy_t;
            typedef typename usource_lazy_t::type usource_t;
            if (arg < 0)
            {
                const bool res = noexcept_numeric_convert<Target, usource_t>(0u - arg, result);
                result = static_cast<Target>(0u - result);
                return res;
            }
            else
            {
                return noexcept_numeric_convert<Target, usource_t>(arg, result);
            }
        }
};
template <typename Target, typename Source>
struct dynamic_num_converter_impl
{
        typedef typename boost::remove_volatile<Source>::type source_type;
        static inline bool try_convert(source_type arg, Target &result)
        {
            typedef typename boost::conditional<
                boost::is_unsigned<Target>::value &&
                    (boost::is_signed<source_type>::value || boost::is_float<source_type>::value) &&
                    !(boost::is_same<source_type, bool>::value) &&
                    !(boost::is_same<Target, bool>::value),
                lexical_cast_dynamic_num_ignoring_minus<Target, source_type>,
                lexical_cast_dynamic_num_not_ignoring_minus<Target, source_type>>::type caster_type;
            return caster_type::try_convert(arg, result);
        }
};
    }
}
namespace boost
{
    namespace detail
    {
namespace has_left_shift_impl
{
        template <typename T>
        T &make();
        struct no_operator
        {
        };
        struct any
        {
            template <class T>
            any(T const &);
        };
        no_operator operator<<(const any &, const any &);
        struct returns_void_t
        {
        };
        template <typename T>
        int operator,(const T &, returns_void_t);
        template <typename T>
        int operator,(const volatile T &, returns_void_t);
        template <typename Lhs, typename Rhs>
        struct operator_returns_void
        {
            static ::boost::type_traits::yes_type returns_void(returns_void_t);
            static ::boost::type_traits::no_type returns_void(int);
            static const bool value = (sizeof(::boost::type_traits::yes_type) == sizeof(returns_void((make<Lhs>() << make<Rhs>(), returns_void_t()))));
        };
        struct dont_care
        {
        };
        template <typename Lhs, typename Rhs, typename Ret, bool Returns_void>
        struct operator_returns_Ret;
        template <typename Lhs, typename Rhs>
        struct operator_returns_Ret<Lhs, Rhs, dont_care, true>
        {
            static const bool value = true;
        };
        template <typename Lhs, typename Rhs>
        struct operator_returns_Ret<Lhs, Rhs, dont_care, false>
        {
            static const bool value = true;
        };
        template <typename Lhs, typename Rhs>
        struct operator_returns_Ret<Lhs, Rhs, void, true>
        {
            static const bool value = true;
        };
        template <typename Lhs, typename Rhs>
        struct operator_returns_Ret<Lhs, Rhs, void, false>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Rhs, typename Ret>
        struct operator_returns_Ret<Lhs, Rhs, Ret, true>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Rhs, typename Ret>
        struct operator_returns_Ret<Lhs, Rhs, Ret, false>
        {
            static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
            static ::boost::type_traits::no_type is_convertible_to_Ret(...);
            static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() << make<Rhs>())) == sizeof(::boost::type_traits::yes_type));
        };
        struct has_operator
        {
        };
        no_operator operator,(no_operator, has_operator);
        template <typename Lhs, typename Rhs>
        struct operator_exists
        {
            static ::boost::type_traits::yes_type s_check(has_operator);
            static ::boost::type_traits::no_type s_check(no_operator);
            static const bool value = (sizeof(s_check(((make<Lhs>() << make<Rhs>()), make<has_operator>()))) == sizeof(::boost::type_traits::yes_type));
        };
        template <typename Lhs, typename Rhs, typename Ret, bool Forbidden_if>
        struct trait_impl1;
        template <typename Lhs, typename Rhs, typename Ret>
        struct trait_impl1<Lhs, Rhs, Ret, true>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Rhs, typename Ret>
        struct trait_impl1<Lhs, Rhs, Ret, false>
        {
            static const bool value = (operator_exists<Lhs, Rhs>::value && operator_returns_Ret<Lhs, Rhs, Ret, operator_returns_void<Lhs, Rhs>::value>::value);
        };
        template <typename Rhs, typename Ret>
        struct trait_impl1<void, Rhs, Ret, false>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Ret>
        struct trait_impl1<Lhs, void, Ret, false>
        {
            static const bool value = false;
        };
        template <typename Ret>
        struct trait_impl1<void, void, Ret, false>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Rhs, typename Ret>
        struct trait_impl
        {
            typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
            typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
            typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
            typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
            typedef typename ::boost::remove_cv<typename ::boost::remove_reference<typename ::boost::remove_pointer<Lhs_noref>::type>::type>::type Lhs_noptr;
            typedef typename ::boost::remove_cv<typename ::boost::remove_reference<typename ::boost::remove_pointer<Rhs_noref>::type>::type>::type Rhs_noptr;
            static const bool value = (trait_impl1<Lhs_noref, Rhs_noref, Ret, ((::boost::is_fundamental<Lhs_nocv>::value && ::boost::is_fundamental<Rhs_nocv>::value && ((!::boost::is_integral<Lhs_noref>::value) || (!::boost::is_integral<Rhs_noref>::value))) || (::boost::is_fundamental<Lhs_nocv>::value && ::boost::is_pointer<Rhs_noref>::value) || (::boost::is_fundamental<Rhs_nocv>::value && ::boost::is_pointer<Lhs_noref>::value) || (::boost::is_pointer<Lhs_noref>::value && ::boost::is_pointer<Rhs_noref>::value))>::value);
        };
}
    }
    template <class Lhs, class Rhs = Lhs, class Ret = ::boost::detail::has_left_shift_impl::dont_care>
    struct has_left_shift : public integral_constant<bool, (::boost::detail::has_left_shift_impl::trait_impl<Lhs, Rhs, Ret>::value)>
    {
    };
}
namespace boost
{
    namespace detail
    {
namespace has_right_shift_impl
{
        template <typename T>
        T &make();
        struct no_operator
        {
        };
        struct any
        {
            template <class T>
            any(T const &);
        };
        no_operator operator>>(const any &, const any &);
        struct returns_void_t
        {
        };
        template <typename T>
        int operator,(const T &, returns_void_t);
        template <typename T>
        int operator,(const volatile T &, returns_void_t);
        template <typename Lhs, typename Rhs>
        struct operator_returns_void
        {
            static ::boost::type_traits::yes_type returns_void(returns_void_t);
            static ::boost::type_traits::no_type returns_void(int);
            static const bool value = (sizeof(::boost::type_traits::yes_type) == sizeof(returns_void((make<Lhs>() >> make<Rhs>(), returns_void_t()))));
        };
        struct dont_care
        {
        };
        template <typename Lhs, typename Rhs, typename Ret, bool Returns_void>
        struct operator_returns_Ret;
        template <typename Lhs, typename Rhs>
        struct operator_returns_Ret<Lhs, Rhs, dont_care, true>
        {
            static const bool value = true;
        };
        template <typename Lhs, typename Rhs>
        struct operator_returns_Ret<Lhs, Rhs, dont_care, false>
        {
            static const bool value = true;
        };
        template <typename Lhs, typename Rhs>
        struct operator_returns_Ret<Lhs, Rhs, void, true>
        {
            static const bool value = true;
        };
        template <typename Lhs, typename Rhs>
        struct operator_returns_Ret<Lhs, Rhs, void, false>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Rhs, typename Ret>
        struct operator_returns_Ret<Lhs, Rhs, Ret, true>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Rhs, typename Ret>
        struct operator_returns_Ret<Lhs, Rhs, Ret, false>
        {
            static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
            static ::boost::type_traits::no_type is_convertible_to_Ret(...);
            static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() >> make<Rhs>())) == sizeof(::boost::type_traits::yes_type));
        };
        struct has_operator
        {
        };
        no_operator operator,(no_operator, has_operator);
        template <typename Lhs, typename Rhs>
        struct operator_exists
        {
            static ::boost::type_traits::yes_type s_check(has_operator);
            static ::boost::type_traits::no_type s_check(no_operator);
            static const bool value = (sizeof(s_check(((make<Lhs>() >> make<Rhs>()), make<has_operator>()))) == sizeof(::boost::type_traits::yes_type));
        };
        template <typename Lhs, typename Rhs, typename Ret, bool Forbidden_if>
        struct trait_impl1;
        template <typename Lhs, typename Rhs, typename Ret>
        struct trait_impl1<Lhs, Rhs, Ret, true>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Rhs, typename Ret>
        struct trait_impl1<Lhs, Rhs, Ret, false>
        {
            static const bool value = (operator_exists<Lhs, Rhs>::value && operator_returns_Ret<Lhs, Rhs, Ret, operator_returns_void<Lhs, Rhs>::value>::value);
        };
        template <typename Rhs, typename Ret>
        struct trait_impl1<void, Rhs, Ret, false>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Ret>
        struct trait_impl1<Lhs, void, Ret, false>
        {
            static const bool value = false;
        };
        template <typename Ret>
        struct trait_impl1<void, void, Ret, false>
        {
            static const bool value = false;
        };
        template <typename Lhs, typename Rhs, typename Ret>
        struct trait_impl
        {
            typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
            typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
            typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
            typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
            typedef typename ::boost::remove_cv<typename ::boost::remove_reference<typename ::boost::remove_pointer<Lhs_noref>::type>::type>::type Lhs_noptr;
            typedef typename ::boost::remove_cv<typename ::boost::remove_reference<typename ::boost::remove_pointer<Rhs_noref>::type>::type>::type Rhs_noptr;
            static const bool value = (trait_impl1<Lhs_noref, Rhs_noref, Ret, ((::boost::is_fundamental<Lhs_nocv>::value && ::boost::is_fundamental<Rhs_nocv>::value && ((!::boost::is_integral<Lhs_noref>::value) || (!::boost::is_integral<Rhs_noref>::value))) || (::boost::is_fundamental<Lhs_nocv>::value && ::boost::is_pointer<Rhs_noref>::value) || (::boost::is_fundamental<Rhs_nocv>::value && ::boost::is_pointer<Lhs_noref>::value) || (::boost::is_pointer<Lhs_noref>::value && ::boost::is_pointer<Rhs_noref>::value))>::value);
        };
}
    }
    template <class Lhs, class Rhs = Lhs, class Ret = ::boost::detail::has_right_shift_impl::dont_care>
    struct has_right_shift : public integral_constant<bool, (::boost::detail::has_right_shift_impl::trait_impl<Lhs, Rhs, Ret>::value)>
    {
    };
}

namespace boost
{
    template <class T>
    class integer_traits : public std::numeric_limits<T>
    {
public:
static const bool is_integral = false;
    };
    namespace detail
    {
template <class T, T min_val, T max_val>
class integer_traits_base
{
    public:
        static const bool is_integral = true;
        static const T const_min = min_val;
        static const T const_max = max_val;
};
template <class T, T min_val, T max_val>
const bool integer_traits_base<T, min_val, max_val>::is_integral;
template <class T, T min_val, T max_val>
const T integer_traits_base<T, min_val, max_val>::const_min;
template <class T, T min_val, T max_val>
const T integer_traits_base<T, min_val, max_val>::const_max;
    }
    template <>
    class integer_traits<bool>
        : public std::numeric_limits<bool>,
          public detail::integer_traits_base<bool, false, true>
    {
    };
    template <>
    class integer_traits<char>
        : public std::numeric_limits<char>,
          public detail::integer_traits_base<char, (-127 - 1), 127>
    {
    };
    template <>
    class integer_traits<signed char>
        : public std::numeric_limits<signed char>,
          public detail::integer_traits_base<signed char, (-127 - 1), 127>
    {
    };
    template <>
    class integer_traits<unsigned char>
        : public std::numeric_limits<unsigned char>,
          public detail::integer_traits_base<unsigned char, 0, (127 * 2 + 1)>
    {
    };
    template <>
    class integer_traits<wchar_t>
        : public std::numeric_limits<wchar_t>,
          public detail::integer_traits_base<wchar_t, (-2147483647 - 1), 2147483647>
    {
    };
    template <>
    class integer_traits<short>
        : public std::numeric_limits<short>,
          public detail::integer_traits_base<short, (-32767 - 1), 32767>
    {
    };
    template <>
    class integer_traits<unsigned short>
        : public std::numeric_limits<unsigned short>,
          public detail::integer_traits_base<unsigned short, 0, (32767 * 2 + 1)>
    {
    };
    template <>
    class integer_traits<int>
        : public std::numeric_limits<int>,
          public detail::integer_traits_base<int, (-2147483647 - 1), 2147483647>
    {
    };
    template <>
    class integer_traits<unsigned int>
        : public std::numeric_limits<unsigned int>,
          public detail::integer_traits_base<unsigned int, 0, (2147483647 * 2U + 1U)>
    {
    };
    template <>
    class integer_traits<long>
        : public std::numeric_limits<long>,
          public detail::integer_traits_base<long, (-9223372036854775807L - 1L), 9223372036854775807L>
    {
    };
    template <>
    class integer_traits<unsigned long>
        : public std::numeric_limits<unsigned long>,
          public detail::integer_traits_base<unsigned long, 0, (9223372036854775807L * 2UL + 1UL)>
    {
    };
    template <>
    class integer_traits<::boost::long_long_type>
        : public std::numeric_limits<::boost::long_long_type>,
          public detail::integer_traits_base<::boost::long_long_type, (-0x7fffffffffffffffLL - 1), 0x7fffffffffffffffLL>
    {
    };
    template <>
    class integer_traits<::boost::ulong_long_type>
        : public std::numeric_limits<::boost::ulong_long_type>,
          public detail::integer_traits_base<::boost::ulong_long_type, 0, 0xffffffffffffffffULL>
    {
    };
}
namespace boost
{
    namespace detail
    {
class lcast_abstract_stub
{
};
template <class T>
struct lcast_precision
{
        typedef typename boost::conditional<
            boost::is_abstract<T>::value, std::numeric_limits<lcast_abstract_stub>, std::numeric_limits<T>>::type limits;
        static const bool use_default_precision = !limits::is_specialized || limits::is_exact;
        static const bool is_specialized_bin = !use_default_precision && limits::radix == 2 && limits::digits > 0;
        static const bool is_specialized_dec = !use_default_precision && limits::radix == 10 && limits::digits10 > 0;
        static const std::streamsize streamsize_max = boost::integer_traits<std::streamsize>::const_max;
        static const unsigned int precision_dec = limits::digits10 + 1U;
        typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<((!is_specialized_dec || precision_dec <= streamsize_max + 0UL) != 0)>)> boost_static_assert_typedef_79;
        static const unsigned long precision_bin = 2UL + limits::digits * 30103UL / 100000UL;
        typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<((!is_specialized_bin || (limits::digits + 0UL < (9223372036854775807L * 2UL + 1UL) / 30103UL && precision_bin > limits::digits10 + 0UL && precision_bin <= streamsize_max + 0UL)) != 0)>)> boost_static_assert_typedef_89;
        static const std::streamsize value = is_specialized_bin ? precision_bin : is_specialized_dec ? precision_dec
                                                                                                     : 6;
};
template <class T>
inline std::streamsize lcast_get_precision(T * = 0)
{
        return lcast_precision<T>::value;
}
template <class T>
inline void lcast_set_precision(std::ios_base &stream, T *)
{
        stream.precision(lcast_get_precision<T>());
}
template <class Source, class Target>
inline void lcast_set_precision(std::ios_base &stream, Source *, Target *)
{
        std::streamsize const s = lcast_get_precision(static_cast<Source *>(0));
        std::streamsize const t = lcast_get_precision(static_cast<Target *>(0));
        stream.precision(s > t ? s : t);
}
    }
}

namespace boost
{
    namespace detail
    {
template <typename TargetChar, typename SourceChar>
struct widest_char
{
        typedef typename boost::conditional<
            (sizeof(TargetChar) > sizeof(SourceChar)), TargetChar, SourceChar>::type type;
};
    }
}
extern "C"
{
    void __assert_rtn(const char *, const char *, int, const char *);
}
namespace boost_swap_impl
{
    template <class T>
    struct is_const
    {
enum _vt
{
    value = 0
};
    };
    template <class T>
    struct is_const<T const>
    {
enum _vt
{
    value = 1
};
    };
    using namespace std;
    template <class T>
    void swap_impl(T &left, T &right)
    {
swap(left, right);
    }
    template <class T, std::size_t N>
    void swap_impl(T (&left)[N], T (&right)[N])
    {
for (std::size_t i = 0; i < N; ++i)
{
        ::boost_swap_impl::swap_impl(left[i], right[i]);
}
    }
}
namespace boost
{
    template <class T1, class T2>
    typename enable_if_c<!boost_swap_impl::is_const<T1>::value && !boost_swap_impl::is_const<T2>::value>::type
    swap(T1 &left, T2 &right)
    {
::boost_swap_impl::swap_impl(left, right);
    }
}
namespace boost
{
    template <class T, std::size_t N>
    class array
    {
public:
T elems[N];

public:
typedef T value_type;
typedef T *iterator;
typedef const T *const_iterator;
typedef T &reference;
typedef const T &const_reference;
typedef std::size_t size_type;
typedef std::ptrdiff_t difference_type;
iterator begin() { return elems; }
const_iterator begin() const { return elems; }
const_iterator cbegin() const { return elems; }
iterator end() { return elems + N; }
const_iterator end() const { return elems + N; }
const_iterator cend() const { return elems + N; }
typedef std::reverse_iterator<iterator> reverse_iterator;
typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
reverse_iterator rbegin() { return reverse_iterator(end()); }
const_reverse_iterator rbegin() const
{
        return const_reverse_iterator(end());
}
const_reverse_iterator crbegin() const
{
        return const_reverse_iterator(end());
}
reverse_iterator rend() { return reverse_iterator(begin()); }
const_reverse_iterator rend() const
{
        return const_reverse_iterator(begin());
}
const_reverse_iterator crend() const
{
        return const_reverse_iterator(begin());
}
reference operator[](size_type i)
{
        return (__builtin_expect(!((i < N) && ("out of range")), 0) ? __assert_rtn(__func__, "array.hpp", 117, "(i < N)&&(\"out of range\")") : (void)0), elems[i];
}
const_reference operator[](size_type i) const
{
        return (__builtin_expect(!((i < N) && ("out of range")), 0) ? __assert_rtn(__func__, "array.hpp", 122, "(i < N)&&(\"out of range\")") : (void)0), elems[i];
}
reference at(size_type i) { return rangecheck(i), elems[i]; }
const_reference at(size_type i) const { return rangecheck(i), elems[i]; }
reference front()
{
        return elems[0];
}
const_reference front() const
{
        return elems[0];
}
reference back()
{
        return elems[N - 1];
}
const_reference back() const
{
        return elems[N - 1];
}
static size_type size() { return N; }
static bool empty() { return false; }
static size_type max_size() { return N; }
enum
{
    static_size = N
};
void swap(array<T, N> &y)
{
        for (size_type i = 0; i < N; ++i)
            boost::swap(elems[i], y.elems[i]);
}
const T *data() const { return elems; }
T *data() { return elems; }
T *c_array() { return elems; }
template <typename T2>
array<T, N> &operator=(const array<T2, N> &rhs)
{
        std::copy(rhs.begin(), rhs.end(), begin());
        return *this;
}
void assign(const T &value) { fill(value); }
void fill(const T &value)
{
        std::fill_n(begin(), size(), value);
}
static bool rangecheck(size_type i)
{
        return i >= size() ? boost::throw_exception(std::out_of_range("array<>: index out of range")), true : true;
}
    };
    template <class T>
    class array<T, 0>
    {
public:
typedef T value_type;
typedef T *iterator;
typedef const T *const_iterator;
typedef T &reference;
typedef const T &const_reference;
typedef std::size_t size_type;
typedef std::ptrdiff_t difference_type;
iterator begin() { return iterator(reinterpret_cast<T *>(this)); }
const_iterator begin() const { return const_iterator(reinterpret_cast<const T *>(this)); }
const_iterator cbegin() const { return const_iterator(reinterpret_cast<const T *>(this)); }
iterator end() { return begin(); }
const_iterator end() const { return begin(); }
const_iterator cend() const { return cbegin(); }
typedef std::reverse_iterator<iterator> reverse_iterator;
typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
reverse_iterator rbegin() { return reverse_iterator(end()); }
const_reverse_iterator rbegin() const
{
        return const_reverse_iterator(end());
}
const_reverse_iterator crbegin() const
{
        return const_reverse_iterator(end());
}
reverse_iterator rend() { return reverse_iterator(begin()); }
const_reverse_iterator rend() const
{
        return const_reverse_iterator(begin());
}
const_reverse_iterator crend() const
{
        return const_reverse_iterator(begin());
}
reference operator[](size_type)
{
        return failed_rangecheck();
}
const_reference operator[](size_type) const
{
        return failed_rangecheck();
}
reference at(size_type) { return failed_rangecheck(); }
const_reference at(size_type) const { return failed_rangecheck(); }
reference front()
{
        return failed_rangecheck();
}
const_reference front() const
{
        return failed_rangecheck();
}
reference back()
{
        return failed_rangecheck();
}
const_reference back() const
{
        return failed_rangecheck();
}
static size_type size() { return 0; }
static bool empty() { return true; }
static size_type max_size() { return 0; }
enum
{
    static_size = 0
};
void swap(array<T, 0> &)
{
}
const T *data() const { return 0; }
T *data() { return 0; }
T *c_array() { return 0; }
template <typename T2>
array<T, 0> &operator=(const array<T2, 0> &)
{
        return *this;
}
void assign(const T &value) { fill(value); }
void fill(const T &) {}
static reference failed_rangecheck()
{
        std::out_of_range e("attempt to access element of an empty array");
        boost::throw_exception(e);
        static T placeholder;
        return placeholder;
}
    };
    template <class T, std::size_t N>
    bool operator==(const array<T, N> &x, const array<T, N> &y)
    {
return std::equal(x.begin(), x.end(), y.begin());
    }
    template <class T, std::size_t N>
    bool operator<(const array<T, N> &x, const array<T, N> &y)
    {
return std::lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
    }
    template <class T, std::size_t N>
    bool operator!=(const array<T, N> &x, const array<T, N> &y)
    {
return !(x == y);
    }
    template <class T, std::size_t N>
    bool operator>(const array<T, N> &x, const array<T, N> &y)
    {
return y < x;
    }
    template <class T, std::size_t N>
    bool operator<=(const array<T, N> &x, const array<T, N> &y)
    {
return !(y < x);
    }
    template <class T, std::size_t N>
    bool operator>=(const array<T, N> &x, const array<T, N> &y)
    {
return !(x < y);
    }
    template <class T, std::size_t N>
    inline void swap(array<T, N> &x, array<T, N> &y)
    {
x.swap(y);
    }
    template <typename T, std::size_t N>
    T (&get_c_array(boost::array<T, N> &arg))
    [N]
    {
return arg.elems;
    }
    template <typename T, std::size_t N>
    const T (&get_c_array(const boost::array<T, N> &arg))[N]
    {
return arg.elems;
    }
    template <class It>
    std::size_t hash_range(It, It);
    template <class T, std::size_t N>
    std::size_t hash_value(const array<T, N> &arr)
    {
return boost::hash_range(arr.begin(), arr.end());
    }
    template <size_t Idx, typename T, size_t N>
    T &get(boost::array<T, N> &arr)
    {
typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<((Idx < N) != 0)>)> boost_static_assert_typedef_423;
return arr[Idx];
    }
    template <size_t Idx, typename T, size_t N>
    const T &get(const boost::array<T, N> &arr)
    {
typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<((Idx < N) != 0)>)> boost_static_assert_typedef_429;
return arr[Idx];
    }
}
namespace std
{
    template <size_t Idx, typename T, size_t N>
    T &get(boost::array<T, N> &arr)
    {
typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<((Idx < N) != 0)>)> boost_static_assert_typedef_440;
return arr[Idx];
    }
    template <size_t Idx, typename T, size_t N>
    const T &get(const boost::array<T, N> &arr)
    {
typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<((Idx < N) != 0)>)> boost_static_assert_typedef_446;
return arr[Idx];
    }
}

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wc++11-extensions"
namespace std
{
    inline namespace __1
    {
template <class T>
class allocator;
template <class T>
struct less;
template <class T>
struct equal_to;
template <class T1, class T2>
struct pair;
template <class T>
struct char_traits;
struct input_iterator_tag;
struct forward_iterator_tag;
struct bidirectional_iterator_tag;
struct random_access_iterator_tag;
template <class Container>
class insert_iterator;
struct allocator_arg_t;
struct piecewise_construct_t;
template <class Ptr>
struct pointer_traits;
    }
}
#pragma GCC diagnostic pop
namespace boost
{
    namespace intrusive
    {
namespace detail
{
}
    }
}
namespace boost
{
    namespace container
    {
namespace dtl
{
        namespace bi = boost::intrusive;
        namespace bid = boost::intrusive::detail;
}
    }
}
namespace boost
{
    namespace container
    {
namespace pmr
{
        namespace bi = boost::intrusive;
        namespace bid = boost::intrusive::detail;
}
    }
}
namespace boost
{
    namespace container
    {
template <class T>
class new_allocator;
template <class T, class Allocator = void, class Options = void>
class vector;
template <class T, class Allocator = void>
class stable_vector;
template <class T, std::size_t Capacity, class Options = void>
class static_vector;
template <class T, class Allocator = void, class Options = void>
class small_vector_base;
template <class T, std::size_t N, class Allocator = void, class Options = void>
class small_vector;
template <class T, class Allocator = void, class Options = void>
class devector;
template <class T, class Allocator = void, class Options = void>
class deque;
template <class T, class Allocator = void>
class list;
template <class T, class Allocator = void>
class slist;
template <class Key, class Compare = std::less<Key>, class Allocator = void, class Options = void>
class set;
template <class Key, class Compare = std::less<Key>, class Allocator = void, class Options = void>
class multiset;
template <class Key, class T, class Compare = std::less<Key>, class Allocator = void, class Options = void>
class map;
template <class Key, class T, class Compare = std::less<Key>, class Allocator = void, class Options = void>
class multimap;
template <class Key, class Compare = std::less<Key>, class Allocator = void>
class flat_set;
template <class Key, class Compare = std::less<Key>, class Allocator = void>
class flat_multiset;
template <class Key, class T, class Compare = std::less<Key>, class Allocator = void>
class flat_map;
template <class Key, class T, class Compare = std::less<Key>, class Allocator = void>
class flat_multimap;
template <class Key, std::size_t N, class Compare = std::less<Key>, class SmallVectorAllocator = void, class SmallVectorOptions = void>
struct small_flat_set_of
{
        typedef flat_set<Key, Compare, small_vector<Key, N, SmallVectorAllocator, SmallVectorOptions>> type;
};
template <class Key, std::size_t N, class Compare = std::less<Key>, class SmallVectorAllocator = void, class SmallVectorOptions = void>
struct small_flat_multiset_of
{
        typedef flat_multiset<Key, Compare, small_vector<Key, N, SmallVectorAllocator, SmallVectorOptions>> type;
};
template <class Key, class T, std::size_t N, class Compare = std::less<Key>, class SmallVectorAllocator = void, class SmallVectorOptions = void>
struct small_flat_map_of
{
        typedef flat_map<Key, T, Compare, small_vector<std::pair<Key, T>, N, SmallVectorAllocator, SmallVectorOptions>> type;
};
template <class Key, class T, std::size_t N, class Compare = std::less<Key>, class SmallVectorAllocator = void, class SmallVectorOptions = void>
struct small_flat_multimap_of
{
        typedef flat_multimap<Key, T, Compare, small_vector<std::pair<Key, T>, N, SmallVectorAllocator, SmallVectorOptions>> type;
};
template <class CharT, class Traits = std::char_traits<CharT>, class Allocator = void>
class basic_string;
typedef basic_string<char> string;
typedef basic_string<wchar_t> wstring;
static const std::size_t ADP_nodes_per_block = 256u;
static const std::size_t ADP_max_free_blocks = 2u;
static const std::size_t ADP_overhead_percent = 1u;
static const std::size_t ADP_only_alignment = 0u;
template <class T, std::size_t NodesPerBlock = ADP_nodes_per_block, std::size_t MaxFreeBlocks = ADP_max_free_blocks, std::size_t OverheadPercent = ADP_overhead_percent, unsigned Version = 2>
class adaptive_pool;
template <class T, unsigned Version = 2, unsigned int AllocationDisableMask = 0>
class allocator;
static const std::size_t NodeAlloc_nodes_per_block = 256u;
template <class T, std::size_t NodesPerBlock = NodeAlloc_nodes_per_block, std::size_t Version = 2>
class node_allocator;
namespace pmr
{
        class memory_resource;
        template <class T>
        class polymorphic_allocator;
        class monotonic_buffer_resource;
        struct pool_options;
        template <class Allocator>
        class resource_adaptor_imp;
        class unsynchronized_pool_resource;
        class synchronized_pool_resource;
}
struct ordered_range_t
{
};
static const ordered_range_t ordered_range = ordered_range_t();
struct ordered_unique_range_t
    : public ordered_range_t
{
};
static const ordered_unique_range_t ordered_unique_range = ordered_unique_range_t();
struct default_init_t
{
};
static const default_init_t default_init = default_init_t();
struct value_init_t
{
};
static const value_init_t value_init = value_init_t();
namespace container_detail_really_deep_namespace
{
        struct dummy
        {
            dummy()
            {
                (void)ordered_range;
                (void)ordered_unique_range;
                (void)default_init;
            }
        };
}
typedef const std::piecewise_construct_t &piecewise_construct_t;
    }
}

namespace boost
{
    namespace core
    {
using ::snprintf;
using ::swprintf;
using ::vsnprintf;
using ::vswprintf;
    }
}
namespace boost
{
    namespace detail
    {
template <typename Char>
struct lcast_char_constants
{
        static const Char zero = static_cast<Char>('0');
        static const Char minus = static_cast<Char>('-');
        static const Char plus = static_cast<Char>('+');
        static const Char lowercase_e = static_cast<Char>('e');
        static const Char capital_e = static_cast<Char>('E');
        static const Char c_decimal_separator = static_cast<Char>('.');
};
    }
}
namespace boost
{
    namespace detail
    {
template <class T>
inline
    typename boost::make_unsigned<T>::type
    lcast_to_unsigned(const T value)
{
        typedef typename boost::make_unsigned<T>::type result_type;
        return value < 0
                   ? static_cast<result_type>(0u - static_cast<result_type>(value))
                   : static_cast<result_type>(value);
}
    }
    namespace detail
    {
template <class Traits, class T, class CharT>
class lcast_put_unsigned : boost::noncopyable
{
        typedef typename Traits::int_type int_type;
        typename boost::conditional<
            (sizeof(unsigned) > sizeof(T)), unsigned, T>::type m_value;
        CharT *m_finish;
        CharT const m_czero;
        int_type const m_zero;

    public:
        lcast_put_unsigned(const T n_param, CharT *finish)
            : m_value(n_param), m_finish(finish), m_czero(lcast_char_constants<CharT>::zero), m_zero(Traits::to_int_type(m_czero))
        {
            typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<((!std::numeric_limits<T>::is_signed) != 0)>)> boost_static_assert_typedef_89;
        }
        CharT *convert()
        {
            std::locale loc;
            if (loc == std::locale::classic())
            {
                return main_convert_loop();
            }
            typedef std::numpunct<CharT> numpunct;
            numpunct const &np = std::use_facet<numpunct>(loc);
            std::string const grouping = np.grouping();
            std::string::size_type const grouping_size = grouping.size();
            if (!grouping_size || grouping[0] <= 0)
            {
                return main_convert_loop();
            }
            typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<((std::numeric_limits<T>::digits10 < 127) != 0)>)> boost_static_assert_typedef_111;
            CharT const thousands_sep = np.thousands_sep();
            std::string::size_type group = 0;
            char last_grp_size = grouping[0];
            char left = last_grp_size;
            do
            {
                if (left == 0)
                {
                    ++group;
                    if (group < grouping_size)
                    {
                        char const grp_size = grouping[group];
                        last_grp_size = (grp_size <= 0 ? static_cast<char>(127) : grp_size);
                    }
                    left = last_grp_size;
                    --m_finish;
                    Traits::assign(*m_finish, thousands_sep);
                }
                --left;
            } while (main_convert_iteration());
            return m_finish;
        }

    private:
        inline bool main_convert_iteration()
        {
            --m_finish;
            int_type const digit = static_cast<int_type>(m_value % 10U);
            Traits::assign(*m_finish, Traits::to_char_type(m_zero + digit));
            m_value /= 10;
            return !!m_value;
        }
        inline CharT *main_convert_loop()
        {
            while (main_convert_iteration())
                ;
            return m_finish;
        }
};
    }
    namespace detail
    {
template <class Traits, class T, class CharT>
class lcast_ret_unsigned : boost::noncopyable
{
        bool m_multiplier_overflowed;
        T m_multiplier;
        T &m_value;
        const CharT *const m_begin;
        const CharT *m_end;

    public:
        lcast_ret_unsigned(T &value, const CharT *const begin, const CharT *end)
            : m_multiplier_overflowed(false), m_multiplier(1), m_value(value), m_begin(begin), m_end(end)
        {
            typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<((!std::numeric_limits<T>::is_signed) != 0)>)> boost_static_assert_typedef_171;
            typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<((std::numeric_limits<T>::is_specialized) != 0)>)> boost_static_assert_typedef_180;
        }
        inline bool convert()
        {
            CharT const czero = lcast_char_constants<CharT>::zero;
            --m_end;
            m_value = static_cast<T>(0);
            if (m_begin > m_end || *m_end < czero || *m_end >= czero + 10)
                return false;
            m_value = static_cast<T>(*m_end - czero);
            --m_end;
            std::locale loc;
            if (loc == std::locale::classic())
            {
                return main_convert_loop();
            }
            typedef std::numpunct<CharT> numpunct;
            numpunct const &np = std::use_facet<numpunct>(loc);
            std::string const &grouping = np.grouping();
            std::string::size_type const grouping_size = grouping.size();
            if (!grouping_size || grouping[0] <= 0)
            {
                return main_convert_loop();
            }
            unsigned char current_grouping = 0;
            CharT const thousands_sep = np.thousands_sep();
            char remained = static_cast<char>(grouping[current_grouping] - 1);
            for (; m_end >= m_begin; --m_end)
            {
                if (remained)
                {
                    if (!main_convert_iteration())
                    {
                        return false;
                    }
                    --remained;
                }
                else
                {
                    if (!Traits::eq(*m_end, thousands_sep))
                    {
                        return main_convert_loop();
                    }
                    else
                    {
                        if (m_begin == m_end)
                            return false;
                        if (current_grouping < grouping_size - 1)
                            ++current_grouping;
                        remained = grouping[current_grouping];
                    }
                }
            }
            return true;
        }

    private:
        inline bool main_convert_iteration()
        {
            CharT const czero = lcast_char_constants<CharT>::zero;
            T const maxv = (std::numeric_limits<T>::max)();
            m_multiplier_overflowed = m_multiplier_overflowed || (maxv / 10 < m_multiplier);
            m_multiplier = static_cast<T>(m_multiplier * 10);
            T const dig_value = static_cast<T>(*m_end - czero);
            T const new_sub_value = static_cast<T>(m_multiplier * dig_value);
            if (*m_end < czero || *m_end >= czero + 10 || (dig_value && (m_multiplier_overflowed || static_cast<T>(maxv / dig_value) < m_multiplier || static_cast<T>(maxv - new_sub_value) < m_value)))
                return false;
            m_value = static_cast<T>(m_value + new_sub_value);
            return true;
        }
        bool main_convert_loop()
        {
            for (; m_end >= m_begin; --m_end)
            {
                if (!main_convert_iteration())
                {
                    return false;
                }
            }
            return true;
        }
};
    }
}
namespace boost
{
    namespace core
    {
using std::fpclassify;
using std::isfinite;
using std::isinf;
using std::isnan;
using std::isnormal;
int const fp_zero = 3;
int const fp_subnormal = 5;
int const fp_normal = 4;
int const fp_infinite = 2;
int const fp_nan = 1;
using std::signbit;
namespace detail
{
        inline float copysign_impl(float x, float y)
        {
            return __builtin_copysignf(x, y);
        }
        inline double copysign_impl(double x, double y)
        {
            return __builtin_copysign(x, y);
        }
        inline long double copysign_impl(long double x, long double y)
        {
            return __builtin_copysignl(x, y);
        }
}
template <class T>
T copysign(T x, T y)
{
        return boost::core::detail::copysign_impl(x, y);
}
    }
}
namespace boost
{
    namespace detail
    {
template <class CharT>
bool lc_iequal(const CharT *val, const CharT *lcase, const CharT *ucase, unsigned int len)
{
        for (unsigned int i = 0; i < len; ++i)
        {
            if (val[i] != lcase[i] && val[i] != ucase[i])
                return false;
        }
        return true;
}
template <class CharT, class T>
inline bool parse_inf_nan_impl(const CharT *begin, const CharT *end, T &value, const CharT *lc_NAN, const CharT *lc_nan, const CharT *lc_INFINITY, const CharT *lc_infinity, const CharT opening_brace, const CharT closing_brace)
{
        if (begin == end)
            return false;
        const CharT minus = lcast_char_constants<CharT>::minus;
        const CharT plus = lcast_char_constants<CharT>::plus;
        const int inifinity_size = 8;
        bool const has_minus = (*begin == minus);
        if (has_minus || *begin == plus)
        {
            ++begin;
        }
        if (end - begin < 3)
            return false;
        if (lc_iequal(begin, lc_nan, lc_NAN, 3))
        {
            begin += 3;
            if (end != begin)
            {
                if (end - begin < 2)
                    return false;
                --end;
                if (*begin != opening_brace || *end != closing_brace)
                    return false;
            }
            if (!has_minus)
                value = std::numeric_limits<T>::quiet_NaN();
            else
                value = boost::core::copysign(std::numeric_limits<T>::quiet_NaN(), static_cast<T>(-1));
            return true;
        }
        else if (
            (
                end - begin == 3 && lc_iequal(begin, lc_infinity, lc_INFINITY, 3)) ||
            (end - begin == inifinity_size && lc_iequal(begin, lc_infinity, lc_INFINITY, inifinity_size)))
        {
            if (!has_minus)
                value = std::numeric_limits<T>::infinity();
            else
                value = -std::numeric_limits<T>::infinity();
            return true;
        }
        return false;
}
template <class CharT, class T>
bool put_inf_nan_impl(CharT *begin, CharT *&end, const T &value, const CharT *lc_nan, const CharT *lc_infinity)
{
        const CharT minus = lcast_char_constants<CharT>::minus;
        if (boost::core::isnan(value))
        {
            if (boost::core::signbit(value))
            {
                *begin = minus;
                ++begin;
            }
            std::memcpy(begin, lc_nan, 3 * sizeof(CharT));
            end = begin + 3;
            return true;
        }
        else if (boost::core::isinf(value))
        {
            if (boost::core::signbit(value))
            {
                *begin = minus;
                ++begin;
            }
            std::memcpy(begin, lc_infinity, 3 * sizeof(CharT));
            end = begin + 3;
            return true;
        }
        return false;
}
template <class T>
bool parse_inf_nan(const wchar_t *begin, const wchar_t *end, T &value)
{
        return parse_inf_nan_impl(begin, end, value, L"NAN", L"nan", L"INFINITY", L"infinity", L'(', L')');
}
template <class T>
bool put_inf_nan(wchar_t *begin, wchar_t *&end, const T &value)
{
        return put_inf_nan_impl(begin, end, value, L"nan", L"infinity");
}
template <class CharT, class T>
bool parse_inf_nan(const CharT *begin, const CharT *end, T &value)
{
        return parse_inf_nan_impl(begin, end, value, "NAN", "nan", "INFINITY", "infinity", '(', ')');
}
template <class CharT, class T>
bool put_inf_nan(CharT *begin, CharT *&end, const T &value)
{
        return put_inf_nan_impl(begin, end, value, "nan", "infinity");
}
    }
}
namespace boost
{
    typedef boost::uintmax_t static_min_max_unsigned_type;
    typedef boost::intmax_t static_min_max_signed_type;
    typedef boost::uintmax_t static_log2_argument_type;
    typedef int static_log2_result_type;
    template <class T>
    class integer_traits;
    template <>
    class integer_traits<bool>;
    template <>
    class integer_traits<char>;
    template <>
    class integer_traits<signed char>;
    template <>
    class integer_traits<unsigned char>;
    template <>
    class integer_traits<wchar_t>;
    template <>
    class integer_traits<short>;
    template <>
    class integer_traits<unsigned short>;
    template <>
    class integer_traits<int>;
    template <>
    class integer_traits<unsigned int>;
    template <>
    class integer_traits<long>;
    template <>
    class integer_traits<unsigned long>;
    template <>
    class integer_traits<::boost::long_long_type>;
    template <>
    class integer_traits<::boost::ulong_long_type>;
    template <typename LeastInt>
    struct int_fast_t;
    template <int Bits>
    struct int_t;
    template <int Bits>
    struct uint_t;
    template <boost::long_long_type MaxValue>
    struct int_max_value_t;
    template <boost::long_long_type MinValue>
    struct int_min_value_t;
    template <boost::ulong_long_type MaxValue>
    struct uint_value_t;
    template <std::size_t Bit>
    struct high_bit_mask_t;
    template <std::size_t Bits>
    struct low_bits_mask_t;
    template <>
    struct low_bits_mask_t<::std::numeric_limits<unsigned char>::digits>;
    template <static_log2_argument_type Value>
    struct static_log2;
    template <>
    struct static_log2<0u>;
    template <static_min_max_signed_type Value1, static_min_max_signed_type Value2>
    struct static_signed_min;
    template <static_min_max_signed_type Value1, static_min_max_signed_type Value2>
    struct static_signed_max;
    template <static_min_max_unsigned_type Value1, static_min_max_unsigned_type Value2>
    struct static_unsigned_min;
    template <static_min_max_unsigned_type Value1, static_min_max_unsigned_type Value2>
    struct static_unsigned_max;
    namespace integer
    {
typedef boost::uintmax_t static_gcd_type;
template <static_gcd_type Value1, static_gcd_type Value2>
struct static_gcd;
template <static_gcd_type Value1, static_gcd_type Value2>
struct static_lcm;
template <typename IntegerType>
class gcd_evaluator;
template <typename IntegerType>
class lcm_evaluator;
    }
}
namespace boost
{
    template <typename LeastInt>
    struct int_fast_t
    {
typedef LeastInt fast;
typedef fast type;
    };
    namespace detail
    {
template <int Category>
struct int_least_helper
{
};
template <int Category>
struct uint_least_helper
{
};
template <>
struct int_least_helper<1>
{
        typedef boost::long_long_type least;
};
template <>
struct int_least_helper<2>
{
        typedef long least;
};
template <>
struct int_least_helper<3>
{
        typedef int least;
};
template <>
struct int_least_helper<4>
{
        typedef short least;
};
template <>
struct int_least_helper<5>
{
        typedef signed char least;
};
template <>
struct uint_least_helper<1>
{
        typedef boost::ulong_long_type least;
};
template <>
struct uint_least_helper<2>
{
        typedef unsigned long least;
};
template <>
struct uint_least_helper<3>
{
        typedef unsigned int least;
};
template <>
struct uint_least_helper<4>
{
        typedef unsigned short least;
};
template <>
struct uint_least_helper<5>
{
        typedef unsigned char least;
};
template <int Bits>
struct exact_signed_base_helper
{
};
template <int Bits>
struct exact_unsigned_base_helper
{
};
template <>
struct exact_signed_base_helper<sizeof(signed char) * 8>
{
        typedef signed char exact;
};
template <>
struct exact_unsigned_base_helper<sizeof(unsigned char) * 8>
{
        typedef unsigned char exact;
};
template <>
struct exact_signed_base_helper<sizeof(short) * 8>
{
        typedef short exact;
};
template <>
struct exact_unsigned_base_helper<sizeof(unsigned short) * 8>
{
        typedef unsigned short exact;
};
template <>
struct exact_signed_base_helper<sizeof(int) * 8>
{
        typedef int exact;
};
template <>
struct exact_unsigned_base_helper<sizeof(unsigned int) * 8>
{
        typedef unsigned int exact;
};
template <>
struct exact_signed_base_helper<sizeof(long) * 8>
{
        typedef long exact;
};
template <>
struct exact_unsigned_base_helper<sizeof(unsigned long) * 8>
{
        typedef unsigned long exact;
};
    }
    template <int Bits>
    struct int_t : public boost::detail::exact_signed_base_helper<Bits>
    {
typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<((Bits <= (int)(sizeof(boost::intmax_t) * 8)) != 0)>)> boost_static_assert_typedef_118;
typedef typename boost::detail::int_least_helper<
    (Bits <= (int)(sizeof(boost::long_long_type) * 8)) +
    (Bits - 1 <= ::std::numeric_limits<long>::digits) +
    (Bits - 1 <= ::std::numeric_limits<int>::digits) +
    (Bits - 1 <= ::std::numeric_limits<short>::digits) +
    (Bits - 1 <= ::std::numeric_limits<signed char>::digits)>::least least;
typedef typename int_fast_t<least>::type fast;
    };
    template <int Bits>
    struct uint_t : public boost::detail::exact_unsigned_base_helper<Bits>
    {
typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<((Bits <= (int)(sizeof(boost::uintmax_t) * 8)) != 0)>)> boost_static_assert_typedef_139;
typedef typename boost::detail::uint_least_helper<
    (Bits <= (int)(sizeof(boost::long_long_type) * 8)) +
    (Bits <= ::std::numeric_limits<unsigned long>::digits) +
    (Bits <= ::std::numeric_limits<unsigned int>::digits) +
    (Bits <= ::std::numeric_limits<unsigned short>::digits) +
    (Bits <= ::std::numeric_limits<unsigned char>::digits)>::least least;
typedef typename int_fast_t<least>::type fast;
    };
    template <boost::long_long_type MaxValue>
    struct int_max_value_t
    {
typedef typename boost::detail::int_least_helper<
    (MaxValue <= ::boost::integer_traits<boost::long_long_type>::const_max) +
    (MaxValue <= ::boost::integer_traits<long>::const_max) +
    (MaxValue <= ::boost::integer_traits<int>::const_max) +
    (MaxValue <= ::boost::integer_traits<short>::const_max) +
    (MaxValue <= ::boost::integer_traits<signed char>::const_max)>::least least;
typedef typename int_fast_t<least>::type fast;
    };
    template <boost::long_long_type MinValue>
    struct int_min_value_t
    {
typedef typename boost::detail::int_least_helper<
    (MinValue >= ::boost::integer_traits<boost::long_long_type>::const_min) +
    (MinValue >= ::boost::integer_traits<long>::const_min) +
    (MinValue >= ::boost::integer_traits<int>::const_min) +
    (MinValue >= ::boost::integer_traits<short>::const_min) +
    (MinValue >= ::boost::integer_traits<signed char>::const_min)>::least least;
typedef typename int_fast_t<least>::type fast;
    };
    template <boost::ulong_long_type MaxValue>
    struct uint_value_t
    {
typedef typename boost::detail::uint_least_helper<
    (MaxValue <= ::boost::integer_traits<boost::ulong_long_type>::const_max) +
    (MaxValue <= ::boost::integer_traits<unsigned long>::const_max) +
    (MaxValue <= ::boost::integer_traits<unsigned int>::const_max) +
    (MaxValue <= ::boost::integer_traits<unsigned short>::const_max) +
    (MaxValue <= ::boost::integer_traits<unsigned char>::const_max)>::least least;
typedef typename int_fast_t<least>::type fast;
    };
}
namespace boost
{
    namespace detail
    {
template <class charT, class BufferT>
class basic_pointerbuf : public BufferT
{
    protected:
        typedef BufferT base_type;
        typedef basic_pointerbuf<charT, BufferT> this_type;
        typedef typename base_type::int_type int_type;
        typedef typename base_type::char_type char_type;
        typedef typename base_type::pos_type pos_type;
        typedef ::std::streamsize streamsize;
        typedef typename base_type::off_type off_type;

    public:
        basic_pointerbuf() : base_type() { this_type::setbuf(0, 0); }
        const charT *getnext() { return this->gptr(); }
        using base_type::pbase;
        using base_type::pptr;

    protected:
        inline base_type *setbuf(char_type *s, streamsize n);
        inline typename this_type::pos_type seekpos(pos_type sp, ::std::ios_base::openmode which);
        inline typename this_type::pos_type seekoff(off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which);

    private:
        basic_pointerbuf &operator=(const basic_pointerbuf &);
        basic_pointerbuf(const basic_pointerbuf &);
};
template <class charT, class BufferT>
BufferT *
basic_pointerbuf<charT, BufferT>::setbuf(char_type *s, streamsize n)
{
        this->setg(s, s, s + n);
        return this;
}
template <class charT, class BufferT>
typename basic_pointerbuf<charT, BufferT>::pos_type
basic_pointerbuf<charT, BufferT>::seekoff(off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which)
{
        typedef typename boost::int_t<sizeof(way) * 8>::least cast_type;
        if (which & ::std::ios_base::out)
            return pos_type(off_type(-1));
        std::ptrdiff_t size = this->egptr() - this->eback();
        std::ptrdiff_t pos = this->gptr() - this->eback();
        charT *g = this->eback();
        switch (static_cast<cast_type>(way))
        {
        case ::std::ios_base::beg:
            if ((off < 0) || (off > size))
                return pos_type(off_type(-1));
            else
                this->setg(g, g + off, g + size);
            break;
        case ::std::ios_base::end:
            if ((off < 0) || (off > size))
                return pos_type(off_type(-1));
            else
                this->setg(g, g + size - off, g + size);
            break;
        case ::std::ios_base::cur:
        {
            std::ptrdiff_t newpos = static_cast<std::ptrdiff_t>(pos + off);
            if ((newpos < 0) || (newpos > size))
                return pos_type(off_type(-1));
            else
                this->setg(g, g + newpos, g + size);
            break;
        }
        default:;
        }
        return static_cast<pos_type>(this->gptr() - this->eback());
}
template <class charT, class BufferT>
typename basic_pointerbuf<charT, BufferT>::pos_type
basic_pointerbuf<charT, BufferT>::seekpos(pos_type sp, ::std::ios_base::openmode which)
{
        if (which & ::std::ios_base::out)
            return pos_type(off_type(-1));
        off_type size = static_cast<off_type>(this->egptr() - this->eback());
        charT *g = this->eback();
        if (off_type(sp) <= size)
        {
            this->setg(g, g + off_type(sp), g + size);
        }
        return pos_type(off_type(-1));
}
    }
}
namespace boost
{
    namespace detail
    {
template <class BufferType, class CharT>
class basic_unlockedbuf : public basic_pointerbuf<CharT, BufferType>
{
    public:
        typedef basic_pointerbuf<CharT, BufferType> base_type;
        typedef typename base_type::streamsize streamsize;
        using base_type::pbase;
        using base_type::pptr;
        using base_type::setbuf;
};
    }
    namespace detail
    {
struct do_not_construct_out_buffer_t
{
};
struct do_not_construct_out_stream_t
{
        do_not_construct_out_stream_t(do_not_construct_out_buffer_t *) {}
};
template <class CharT, class Traits>
struct out_stream_helper_trait
{
        typedef std::basic_ostream<CharT, Traits> out_stream_t;
        typedef basic_unlockedbuf<std::basic_stringbuf<CharT, Traits>, CharT> stringbuffer_t;
        typedef basic_unlockedbuf<std::basic_streambuf<CharT, Traits>, CharT> buffer_t;
};
    }
    namespace detail
    {
template <class CharT, class Traits, bool RequiresStringbuffer, std::size_t CharacterBufferSize>
class lexical_istream_limited_src : boost::noncopyable
{
        typedef typename boost::conditional<
            RequiresStringbuffer,
            typename out_stream_helper_trait<CharT, Traits>::out_stream_t,
            do_not_construct_out_stream_t>::type deduced_out_stream_t;
        typedef typename boost::conditional<
            RequiresStringbuffer,
            typename out_stream_helper_trait<CharT, Traits>::stringbuffer_t,
            do_not_construct_out_buffer_t>::type deduced_out_buffer_t;
        deduced_out_buffer_t out_buffer;
        deduced_out_stream_t out_stream;
        CharT buffer[CharacterBufferSize];
        const CharT *start;
        const CharT *finish;

    public:
        lexical_istream_limited_src()
            : out_buffer(), out_stream(&out_buffer), start(buffer), finish(buffer + CharacterBufferSize)
        {
        }
        const CharT *cbegin() const
        {
            return start;
        }
        const CharT *cend() const
        {
            return finish;
        }

    private:
        bool shl_char(CharT ch)
        {
            Traits::assign(buffer[0], ch);
            finish = start + 1;
            return true;
        }
        template <class T>
        bool shl_char(T ch)
        {
            typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(((sizeof(T) <= sizeof(CharT))) != 0)>)> boost_static_assert_typedef_191;
            std::locale loc;
            CharT const w = std::use_facet<std::ctype<CharT>>(loc).widen(ch);
            Traits::assign(buffer[0], w);
            finish = start + 1;
            return true;
        }
        bool shl_char_array(CharT const *str_value)
        {
            start = str_value;
            finish = start + Traits::length(str_value);
            return true;
        }
        template <class T>
        bool shl_char_array(T const *str_value)
        {
            typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(((sizeof(T) <= sizeof(CharT))) != 0)>)> boost_static_assert_typedef_214;
            return shl_input_streamable(str_value);
        }
        bool shl_char_array_limited(CharT const *str, std::size_t max_size)
        {
            start = str;
            finish = std::find(start, start + max_size, Traits::to_char_type(0));
            return true;
        }
        template <typename InputStreamable>
        bool shl_input_streamable(InputStreamable &input)
        {
            out_stream.exceptions(std::ios::badbit);
            try
            {
                bool const result = !(out_stream << input).fail();
                const deduced_out_buffer_t *const p = static_cast<deduced_out_buffer_t *>(
                    out_stream.rdbuf());
                start = p->pbase();
                finish = p->pptr();
                return result;
            }
            catch (const ::std::ios_base::failure &)
            {
                return false;
            }
        }
        template <class T>
        inline bool shl_unsigned(const T n)
        {
            CharT *tmp_finish = buffer + CharacterBufferSize;
            start = lcast_put_unsigned<Traits, T, CharT>(n, tmp_finish).convert();
            finish = tmp_finish;
            return true;
        }
        template <class T>
        inline bool shl_signed(const T n)
        {
            CharT *tmp_finish = buffer + CharacterBufferSize;
            typedef typename boost::make_unsigned<T>::type utype;
            CharT *tmp_start = lcast_put_unsigned<Traits, utype, CharT>(lcast_to_unsigned(n), tmp_finish).convert();
            if (n < 0)
            {
                --tmp_start;
                CharT const minus = lcast_char_constants<CharT>::minus;
                Traits::assign(*tmp_start, minus);
            }
            start = tmp_start;
            finish = tmp_finish;
            return true;
        }
        template <class T, class SomeCharT>
        bool shl_real_type(const T &val, SomeCharT *)
        {
            lcast_set_precision(out_stream, &val);
            return shl_input_streamable(val);
        }
        bool shl_real_type(float val, char *begin)
        {
            using namespace std;
            const double val_as_double = val;
            finish = start +
                     boost::core::snprintf(begin, CharacterBufferSize,
                                           "%.*g", static_cast<int>(boost::detail::lcast_get_precision<float>()), val_as_double);
            return finish > start;
        }
        bool shl_real_type(double val, char *begin)
        {
            using namespace std;
            finish = start +
                     boost::core::snprintf(begin, CharacterBufferSize,
                                           "%.*g", static_cast<int>(boost::detail::lcast_get_precision<double>()), val);
            return finish > start;
        }
        bool shl_real_type(long double val, char *begin)
        {
            using namespace std;
            finish = start +
                     boost::core::snprintf(begin, CharacterBufferSize,
                                           "%.*Lg", static_cast<int>(boost::detail::lcast_get_precision<long double>()), val);
            return finish > start;
        }
        bool shl_real_type(float val, wchar_t *begin)
        {
            using namespace std;
            const double val_as_double = val;
            finish = start + swprintf(begin, CharacterBufferSize,
                                      L"%.*g",
                                      static_cast<int>(boost::detail::lcast_get_precision<float>()),
                                      val_as_double);
            return finish > start;
        }
        bool shl_real_type(double val, wchar_t *begin)
        {
            using namespace std;
            finish = start + swprintf(begin, CharacterBufferSize,
                                      L"%.*g", static_cast<int>(boost::detail::lcast_get_precision<double>()), val);
            return finish > start;
        }
        bool shl_real_type(long double val, wchar_t *begin)
        {
            using namespace std;
            finish = start + swprintf(begin, CharacterBufferSize,
                                      L"%.*Lg", static_cast<int>(boost::detail::lcast_get_precision<long double>()), val);
            return finish > start;
        }
        template <class T>
        bool shl_real(T val)
        {
            CharT *tmp_finish = buffer + CharacterBufferSize;
            if (put_inf_nan(buffer, tmp_finish, val))
            {
                finish = tmp_finish;
                return true;
            }
            return shl_real_type(val, static_cast<CharT *>(buffer));
        }

    public:
        template <class Alloc>
        bool operator<<(std::basic_string<CharT, Traits, Alloc> const &str)
        {
            start = str.data();
            finish = start + str.length();
            return true;
        }
        template <class Alloc>
        bool operator<<(boost::container::basic_string<CharT, Traits, Alloc> const &str)
        {
            start = str.data();
            finish = start + str.length();
            return true;
        }
        bool operator<<(bool value)
        {
            CharT const czero = lcast_char_constants<CharT>::zero;
            Traits::assign(buffer[0], Traits::to_char_type(czero + value));
            finish = start + 1;
            return true;
        }
        template <class C>
        typename boost::disable_if<boost::is_const<C>, bool>::type
        operator<<(const iterator_range<C *> &rng)
        {
            return (*this) << iterator_range<const C *>(rng.begin(), rng.end());
        }
        bool operator<<(const iterator_range<const CharT *> &rng)
        {
            start = rng.begin();
            finish = rng.end();
            return true;
        }
        bool operator<<(const iterator_range<const signed char *> &rng)
        {
            return (*this) << iterator_range<const char *>(
                       reinterpret_cast<const char *>(rng.begin()),
                       reinterpret_cast<const char *>(rng.end()));
        }
        bool operator<<(const iterator_range<const unsigned char *> &rng)
        {
            return (*this) << iterator_range<const char *>(
                       reinterpret_cast<const char *>(rng.begin()),
                       reinterpret_cast<const char *>(rng.end()));
        }
        bool operator<<(char ch) { return shl_char(ch); }
        bool operator<<(unsigned char ch) { return ((*this) << static_cast<char>(ch)); }
        bool operator<<(signed char ch) { return ((*this) << static_cast<char>(ch)); }
        bool operator<<(wchar_t const *str) { return shl_char_array(str); }
        bool operator<<(wchar_t *str) { return shl_char_array(str); }
        bool operator<<(wchar_t ch) { return shl_char(ch); }
        bool operator<<(unsigned char const *ch) { return ((*this) << reinterpret_cast<char const *>(ch)); }
        bool operator<<(unsigned char *ch) { return ((*this) << reinterpret_cast<char *>(ch)); }
        bool operator<<(signed char const *ch) { return ((*this) << reinterpret_cast<char const *>(ch)); }
        bool operator<<(signed char *ch) { return ((*this) << reinterpret_cast<char *>(ch)); }
        bool operator<<(char const *str_value) { return shl_char_array(str_value); }
        bool operator<<(char *str_value) { return shl_char_array(str_value); }
        bool operator<<(short n) { return shl_signed(n); }
        bool operator<<(int n) { return shl_signed(n); }
        bool operator<<(long n) { return shl_signed(n); }
        bool operator<<(unsigned short n) { return shl_unsigned(n); }
        bool operator<<(unsigned int n) { return shl_unsigned(n); }
        bool operator<<(unsigned long n) { return shl_unsigned(n); }
        bool operator<<(boost::ulong_long_type n) { return shl_unsigned(n); }
        bool operator<<(boost::long_long_type n) { return shl_signed(n); }
        bool operator<<(const boost::uint128_type &n) { return shl_unsigned(n); }
        bool operator<<(const boost::int128_type &n) { return shl_signed(n); }
        bool operator<<(float val) { return shl_real(val); }
        bool operator<<(double val) { return shl_real(val); }
        bool operator<<(long double val)
        {
            return shl_real(val);
        }
        template <class C, std::size_t N>
        typename boost::disable_if<boost::is_const<C>, bool>::type
        operator<<(boost::array<C, N> const &input)
        {
            typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(((sizeof(boost::array<const C, N>) == sizeof(boost::array<C, N>))) != 0)>)> boost_static_assert_typedef_454;
            return ((*this) << reinterpret_cast<boost::array<const C, N> const &>(input));
        }
        template <std::size_t N>
        bool operator<<(boost::array<const CharT, N> const &input)
        {
            return shl_char_array_limited(input.data(), N);
        }
        template <std::size_t N>
        bool operator<<(boost::array<const unsigned char, N> const &input)
        {
            return ((*this) << reinterpret_cast<boost::array<const char, N> const &>(input));
        }
        template <std::size_t N>
        bool operator<<(boost::array<const signed char, N> const &input)
        {
            return ((*this) << reinterpret_cast<boost::array<const char, N> const &>(input));
        }
        template <class C, std::size_t N>
        bool operator<<(std::array<C, N> const &input)
        {
            typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(((sizeof(std::array<C, N>) == sizeof(boost::array<C, N>))) != 0)>)> boost_static_assert_typedef_481;
            return ((*this) << reinterpret_cast<boost::array<C, N> const &>(input));
        }
        template <class InStreamable>
        bool operator<<(const InStreamable &input) { return shl_input_streamable(input); }
};
template <class CharT, class Traits>
class lexical_ostream_limited_src : boost::noncopyable
{
        const CharT *start;
        const CharT *const finish;

    public:
        lexical_ostream_limited_src(const CharT *begin, const CharT *end)
            : start(begin), finish(end)
        {
        }

    private:
        template <typename Type>
        bool shr_unsigned(Type &output)
        {
            if (start == finish)
                return false;
            CharT const minus = lcast_char_constants<CharT>::minus;
            CharT const plus = lcast_char_constants<CharT>::plus;
            bool const has_minus = Traits::eq(minus, *start);
            if (has_minus || Traits::eq(plus, *start))
            {
                ++start;
            }
            bool const succeed = lcast_ret_unsigned<Traits, Type, CharT>(output, start, finish).convert();
            if (has_minus)
            {
                output = static_cast<Type>(0u - output);
            }
            return succeed;
        }
        template <typename Type>
        bool shr_signed(Type &output)
        {
            if (start == finish)
                return false;
            CharT const minus = lcast_char_constants<CharT>::minus;
            CharT const plus = lcast_char_constants<CharT>::plus;
            typedef typename make_unsigned<Type>::type utype;
            utype out_tmp = 0;
            bool const has_minus = Traits::eq(minus, *start);
            if (has_minus || Traits::eq(plus, *start))
            {
                ++start;
            }
            bool succeed = lcast_ret_unsigned<Traits, utype, CharT>(out_tmp, start, finish).convert();
            if (has_minus)
            {
                utype const comp_val = (static_cast<utype>(1) << std::numeric_limits<Type>::digits);
                succeed = succeed && out_tmp <= comp_val;
                output = static_cast<Type>(0u - out_tmp);
            }
            else
            {
                utype const comp_val = static_cast<utype>((std::numeric_limits<Type>::max)());
                succeed = succeed && out_tmp <= comp_val;
                output = static_cast<Type>(out_tmp);
            }
            return succeed;
        }
        template <typename InputStreamable>
        bool shr_using_base_class(InputStreamable &output)
        {
            typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(((!boost::is_pointer<InputStreamable>::value)) != 0)>)> boost_static_assert_typedef_558;
            typedef typename out_stream_helper_trait<CharT, Traits>::buffer_t buffer_t;
            buffer_t buf;
            buf.setbuf(const_cast<CharT *>(start), static_cast<typename buffer_t::streamsize>(finish - start));
            std::basic_istream<CharT, Traits> stream(&buf);
            stream.exceptions(std::ios::badbit);
            try
            {
                stream.unsetf(std::ios::skipws);
                lcast_set_precision(stream, static_cast<InputStreamable *>(0));
                return (stream >> output) && (stream.get() == Traits::eof());
            }
            catch (const ::std::ios_base::failure &)
            {
                return false;
            }
        }
        template <class T>
        inline bool shr_xchar(T &output)
        {
            typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(((sizeof(CharT) == sizeof(T))) != 0)>)> boost_static_assert_typedef_603;
            bool const ok = (finish - start == 1);
            if (ok)
            {
                CharT out;
                Traits::assign(out, *start);
                output = static_cast<T>(out);
            }
            return ok;
        }
        template <std::size_t N, class ArrayT>
        bool shr_std_array(ArrayT &output)
        {
            using namespace std;
            const std::size_t size = static_cast<std::size_t>(finish - start);
            if (size > N - 1)
            {
                return false;
            }
            memcpy(&output[0], start, size * sizeof(CharT));
            output[size] = Traits::to_char_type(0);
            return true;
        }

    public:
        bool operator>>(unsigned short &output) { return shr_unsigned(output); }
        bool operator>>(unsigned int &output) { return shr_unsigned(output); }
        bool operator>>(unsigned long int &output) { return shr_unsigned(output); }
        bool operator>>(short &output) { return shr_signed(output); }
        bool operator>>(int &output) { return shr_signed(output); }
        bool operator>>(long int &output) { return shr_signed(output); }
        bool operator>>(boost::ulong_long_type &output) { return shr_unsigned(output); }
        bool operator>>(boost::long_long_type &output) { return shr_signed(output); }
        bool operator>>(boost::uint128_type &output) { return shr_unsigned(output); }
        bool operator>>(boost::int128_type &output) { return shr_signed(output); }
        bool operator>>(char &output) { return shr_xchar(output); }
        bool operator>>(unsigned char &output) { return shr_xchar(output); }
        bool operator>>(signed char &output) { return shr_xchar(output); }
        bool operator>>(wchar_t &output) { return shr_xchar(output); }
        template <class Alloc>
        bool operator>>(std::basic_string<CharT, Traits, Alloc> &str)
        {
            str.assign(start, finish);
            return true;
        }
        template <class Alloc>
        bool operator>>(boost::container::basic_string<CharT, Traits, Alloc> &str)
        {
            str.assign(start, finish);
            return true;
        }
        template <std::size_t N>
        bool operator>>(boost::array<CharT, N> &output)
        {
            return shr_std_array<N>(output);
        }
        template <std::size_t N>
        bool operator>>(boost::array<unsigned char, N> &output)
        {
            return ((*this) >> reinterpret_cast<boost::array<char, N> &>(output));
        }
        template <std::size_t N>
        bool operator>>(boost::array<signed char, N> &output)
        {
            return ((*this) >> reinterpret_cast<boost::array<char, N> &>(output));
        }
        template <class C, std::size_t N>
        bool operator>>(std::array<C, N> &output)
        {
            typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(((sizeof(std::array<C, N>) == sizeof(boost::array<C, N>))) != 0)>)> boost_static_assert_typedef_690;
            return ((*this) >> reinterpret_cast<boost::array<C, N> &>(output));
        }
        bool operator>>(bool &output)
        {
            output = false;
            if (start == finish)
                return false;
            CharT const zero = lcast_char_constants<CharT>::zero;
            CharT const plus = lcast_char_constants<CharT>::plus;
            CharT const minus = lcast_char_constants<CharT>::minus;
            const CharT *const dec_finish = finish - 1;
            output = Traits::eq(*dec_finish, zero + 1);
            if (!output && !Traits::eq(*dec_finish, zero))
            {
                return false;
            }
            if (start == dec_finish)
                return true;
            if (Traits::eq(plus, *start) || (Traits::eq(minus, *start) && !output))
            {
                ++start;
            }
            while (start != dec_finish)
            {
                if (!Traits::eq(zero, *start))
                {
                    return false;
                }
                ++start;
            }
            return true;
        }

    private:
        template <class T>
        bool float_types_converter_internal(T &output)
        {
            if (parse_inf_nan(start, finish, output))
                return true;
            bool const return_value = shr_using_base_class(output);
            CharT const minus = lcast_char_constants<CharT>::minus;
            CharT const plus = lcast_char_constants<CharT>::plus;
            CharT const capital_e = lcast_char_constants<CharT>::capital_e;
            CharT const lowercase_e = lcast_char_constants<CharT>::lowercase_e;
            if (return_value &&
                (Traits::eq(*(finish - 1), lowercase_e) || Traits::eq(*(finish - 1), capital_e) || Traits::eq(*(finish - 1), minus) || Traits::eq(*(finish - 1), plus)))
                return false;
            return return_value;
        }

    public:
        bool operator>>(float &output) { return float_types_converter_internal(output); }
        bool operator>>(double &output) { return float_types_converter_internal(output); }
        bool operator>>(long double &output) { return float_types_converter_internal(output); }
        template <typename InputStreamable>
        bool operator>>(InputStreamable &output)
        {
            return shr_using_base_class(output);
        }
};
    }
}

namespace boost
{
    namespace detail
    {
template <class Char>
struct normalize_single_byte_char
{
        typedef Char type;
};
template <>
struct normalize_single_byte_char<signed char>
{
        typedef char type;
};
template <>
struct normalize_single_byte_char<unsigned char>
{
        typedef char type;
};
    }
    namespace detail
    {
template <class T>
struct deduce_character_type_later
{
};
    }
    namespace detail
    {
template <typename Type>
struct stream_char_common : public boost::conditional<
                                boost::detail::is_character<Type>::value,
                                Type,
                                boost::detail::deduce_character_type_later<Type>>
{
};
template <typename Char>
struct stream_char_common<Char *> : public boost::conditional<
                                        boost::detail::is_character<Char>::value,
                                        Char,
                                        boost::detail::deduce_character_type_later<Char *>>
{
};
template <typename Char>
struct stream_char_common<const Char *> : public boost::conditional<
                                              boost::detail::is_character<Char>::value,
                                              Char,
                                              boost::detail::deduce_character_type_later<const Char *>>
{
};
template <typename Char>
struct stream_char_common<boost::iterator_range<Char *>> : public boost::conditional<
                                                               boost::detail::is_character<Char>::value,
                                                               Char,
                                                               boost::detail::deduce_character_type_later<boost::iterator_range<Char *>>>
{
};
template <typename Char>
struct stream_char_common<boost::iterator_range<const Char *>> : public boost::conditional<
                                                                     boost::detail::is_character<Char>::value,
                                                                     Char,
                                                                     boost::detail::deduce_character_type_later<boost::iterator_range<const Char *>>>
{
};
template <class Char, class Traits, class Alloc>
struct stream_char_common<std::basic_string<Char, Traits, Alloc>>
{
        typedef Char type;
};
template <class Char, class Traits, class Alloc>
struct stream_char_common<boost::container::basic_string<Char, Traits, Alloc>>
{
        typedef Char type;
};
template <typename Char, std::size_t N>
struct stream_char_common<boost::array<Char, N>> : public boost::conditional<
                                                       boost::detail::is_character<Char>::value,
                                                       Char,
                                                       boost::detail::deduce_character_type_later<boost::array<Char, N>>>
{
};
template <typename Char, std::size_t N>
struct stream_char_common<boost::array<const Char, N>> : public boost::conditional<
                                                             boost::detail::is_character<Char>::value,
                                                             Char,
                                                             boost::detail::deduce_character_type_later<boost::array<const Char, N>>>
{
};
template <typename Char, std::size_t N>
struct stream_char_common<std::array<Char, N>> : public boost::conditional<
                                                     boost::detail::is_character<Char>::value,
                                                     Char,
                                                     boost::detail::deduce_character_type_later<std::array<Char, N>>>
{
};
template <typename Char, std::size_t N>
struct stream_char_common<std::array<const Char, N>> : public boost::conditional<
                                                           boost::detail::is_character<Char>::value,
                                                           Char,
                                                           boost::detail::deduce_character_type_later<std::array<const Char, N>>>
{
};
template <>
struct stream_char_common<boost::int128_type> : public boost::type_identity<char>
{
};
template <>
struct stream_char_common<boost::uint128_type> : public boost::type_identity<char>
{
};
    }
    namespace detail
    {
template <class Char>
struct deduce_source_char_impl
{
        typedef typename boost::detail::normalize_single_byte_char<Char>::type type;
};
template <class T>
struct deduce_source_char_impl<deduce_character_type_later<T>>
{
        typedef boost::has_left_shift<std::basic_ostream<char>, T> result_t;
        typedef typename boost::conditional<
            result_t::value, char, wchar_t>::type type;
        typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(((result_t::value || boost::has_left_shift<std::basic_ostream<type>, T>::value)) != 0)>)> boost_static_assert_typedef_211;
};
    }
    namespace detail
    {
template <class Char>
struct deduce_target_char_impl
{
        typedef typename normalize_single_byte_char<Char>::type type;
};
template <class T>
struct deduce_target_char_impl<deduce_character_type_later<T>>
{
        typedef boost::has_right_shift<std::basic_istream<char>, T> result_t;
        typedef typename boost::conditional<
            result_t::value, char, wchar_t>::type type;
        typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(((result_t::value || boost::has_right_shift<std::basic_istream<wchar_t>, T>::value)) != 0)>)> boost_static_assert_typedef_244;
};
    }
    namespace detail
    {
template <class T>
struct deduce_target_char
{
        typedef typename stream_char_common<T>::type stage1_type;
        typedef typename deduce_target_char_impl<stage1_type>::type stage2_type;
        typedef stage2_type type;
};
template <class T>
struct deduce_source_char
{
        typedef typename stream_char_common<T>::type stage1_type;
        typedef typename deduce_source_char_impl<stage1_type>::type stage2_type;
        typedef stage2_type type;
};
    }
    namespace detail
    {
template <class Char, class T>
struct extract_char_traits
    : boost::false_type
{
        typedef std::char_traits<Char> trait_t;
};
template <class Char, class Traits, class Alloc>
struct extract_char_traits<Char, std::basic_string<Char, Traits, Alloc>>
    : boost::true_type
{
        typedef Traits trait_t;
};
template <class Char, class Traits, class Alloc>
struct extract_char_traits<Char, boost::container::basic_string<Char, Traits, Alloc>>
    : boost::true_type
{
        typedef Traits trait_t;
};
    }
    namespace detail
    {
template <class T>
struct array_to_pointer_decay
{
        typedef T type;
};
template <class T, std::size_t N>
struct array_to_pointer_decay<T[N]>
{
        typedef const T *type;
};
    }
    namespace detail
    {
template <class Source,
          class Enable = void>
struct lcast_src_length
{
        static const std::size_t value = 1;
};
template <class Source>
struct lcast_src_length<
    Source, typename boost::enable_if<boost::is_integral<Source>>::type>
{
        static const std::size_t value = std::numeric_limits<Source>::is_signed + std::numeric_limits<Source>::is_specialized + std::numeric_limits<Source>::digits10 * 2;
};
template <class Source>
struct lcast_src_length<
    Source, typename boost::enable_if<boost::is_float<Source>>::type>
{
        typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<((std::numeric_limits<Source>::max_exponent10 <= 999999L && std::numeric_limits<Source>::min_exponent10 >= -999999L) != 0)>)> boost_static_assert_typedef_387;
        static const std::size_t value = 5 + lcast_precision<Source>::value + 6;
};
    }
    namespace detail
    {
template <class Source, class Target>
struct lexical_cast_stream_traits
{
        typedef typename boost::detail::array_to_pointer_decay<Source>::type src;
        typedef typename boost::remove_cv<src>::type no_cv_src;
        typedef boost::detail::deduce_source_char<no_cv_src> deduce_src_char_metafunc;
        typedef typename deduce_src_char_metafunc::type src_char_t;
        typedef typename boost::detail::deduce_target_char<Target>::type target_char_t;
        typedef typename boost::detail::widest_char<
            target_char_t, src_char_t>::type char_type;
        typedef typename boost::conditional<
            boost::detail::extract_char_traits<char_type, Target>::value,
            typename boost::detail::extract_char_traits<char_type, Target>,
            typename boost::detail::extract_char_traits<char_type, no_cv_src>>::type::trait_t traits;
        typedef boost::integral_constant<
            bool,
            boost::is_same<char, src_char_t>::value &&
                (sizeof(char) != sizeof(target_char_t)) &&
                (!(boost::detail::is_character<no_cv_src>::value))>
            is_string_widening_required_t;
        typedef boost::integral_constant<
            bool,
            !(boost::is_integral<no_cv_src>::value ||
              boost::detail::is_character<
                  typename deduce_src_char_metafunc::stage1_type>::value)>
            is_source_input_not_optimized_t;
        static const bool requires_stringbuf = (is_string_widening_required_t::value || is_source_input_not_optimized_t::value);
        typedef boost::detail::lcast_src_length<no_cv_src> len_t;
};
    }
    namespace detail
    {
template <typename Target, typename Source>
struct lexical_converter_impl
{
        typedef lexical_cast_stream_traits<Source, Target> stream_trait;
        typedef detail::lexical_istream_limited_src<
            typename stream_trait::char_type,
            typename stream_trait::traits,
            stream_trait::requires_stringbuf,
            stream_trait::len_t::value + 1>
            i_interpreter_type;
        typedef detail::lexical_ostream_limited_src<
            typename stream_trait::char_type,
            typename stream_trait::traits>
            o_interpreter_type;
        static inline bool try_convert(const Source &arg, Target &result)
        {
            i_interpreter_type i_interpreter;
            if (!(i_interpreter.operator<<(arg)))
                return false;
            o_interpreter_type out(i_interpreter.cbegin(), i_interpreter.cend());
            if (!(out.operator>>(result)))
                return false;
            return true;
        }
};
    }
}
namespace boost
{
    namespace detail
    {
template <typename T>
struct is_stdstring
    : boost::false_type
{
};
template <typename CharT, typename Traits, typename Alloc>
struct is_stdstring<std::basic_string<CharT, Traits, Alloc>>
    : boost::true_type
{
};
template <typename T>
struct is_booststring
    : boost::false_type
{
};
template <typename CharT, typename Traits, typename Alloc>
struct is_booststring<boost::container::basic_string<CharT, Traits, Alloc>>
    : boost::true_type
{
};
template <typename Target, typename Source>
struct is_arithmetic_and_not_xchars
{
        typedef boost::integral_constant<
            bool,
            !(boost::detail::is_character<Target>::value) &&
                !(boost::detail::is_character<Source>::value) &&
                boost::is_arithmetic<Source>::value &&
                boost::is_arithmetic<Target>::value>
            type;
        static const bool value = (type::value);
};
template <typename Target, typename Source>
struct is_xchar_to_xchar
{
        typedef boost::integral_constant<
            bool,
            sizeof(Source) == sizeof(Target) &&
                sizeof(Source) == sizeof(char) &&
                boost::detail::is_character<Target>::value &&
                boost::detail::is_character<Source>::value>
            type;
        static const bool value = (type::value);
};
template <typename Target, typename Source>
struct is_char_array_to_stdstring
    : boost::false_type
{
};
template <typename CharT, typename Traits, typename Alloc>
struct is_char_array_to_stdstring<std::basic_string<CharT, Traits, Alloc>, CharT *>
    : boost::true_type
{
};
template <typename CharT, typename Traits, typename Alloc>
struct is_char_array_to_stdstring<std::basic_string<CharT, Traits, Alloc>, const CharT *>
    : boost::true_type
{
};
template <typename Target, typename Source>
struct is_char_array_to_booststring
    : boost::false_type
{
};
template <typename CharT, typename Traits, typename Alloc>
struct is_char_array_to_booststring<boost::container::basic_string<CharT, Traits, Alloc>, CharT *>
    : boost::true_type
{
};
template <typename CharT, typename Traits, typename Alloc>
struct is_char_array_to_booststring<boost::container::basic_string<CharT, Traits, Alloc>, const CharT *>
    : boost::true_type
{
};
template <typename Target, typename Source>
struct copy_converter_impl
{
        static inline bool try_convert(const Source &arg, Target &result)
        {
            result = arg;
            return true;
        }
};
    }
    namespace conversion
    {
namespace detail
{
        template <typename Target, typename Source>
        inline bool try_lexical_convert(const Source &arg, Target &result)
        {
            typedef typename boost::detail::array_to_pointer_decay<Source>::type src;
            typedef boost::integral_constant<
                bool,
                boost::detail::is_xchar_to_xchar<Target, src>::value ||
                    boost::detail::is_char_array_to_stdstring<Target, src>::value ||
                    boost::detail::is_char_array_to_booststring<Target, src>::value ||
                    (boost::is_same<Target, src>::value &&
                     (boost::detail::is_stdstring<Target>::value || boost::detail::is_booststring<Target>::value)) ||
                    (boost::is_same<Target, src>::value &&
                     boost::detail::is_character<Target>::value)>
                shall_we_copy_t;
            typedef boost::detail::is_arithmetic_and_not_xchars<Target, src>
                shall_we_copy_with_dynamic_check_t;
            typedef typename boost::conditional<
                shall_we_copy_t::value,
                boost::type_identity<boost::detail::copy_converter_impl<Target, src>>,
                boost::conditional<
                    shall_we_copy_with_dynamic_check_t::value,
                    boost::detail::dynamic_num_converter_impl<Target, src>,
                    boost::detail::lexical_converter_impl<Target, src>>>::type caster_type_lazy;
            typedef typename caster_type_lazy::type caster_type;
            return caster_type::try_convert(arg, result);
        }
        template <typename Target, typename CharacterT>
        inline bool try_lexical_convert(const CharacterT *chars, std::size_t count, Target &result)
        {
            typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<((boost::detail::is_character<CharacterT>::value) != 0)>)> boost_static_assert_typedef_210;
            return ::boost::conversion::detail::try_lexical_convert(
                ::boost::iterator_range<const CharacterT *>(chars, chars + count), result);
        }
}
    }
    namespace conversion
    {
using ::boost::conversion::detail::try_lexical_convert;
    }
}
#pragma GCC diagnostic pop

namespace boost
{
    template <typename Target, typename Source>
    inline Target lexical_cast(const Source &arg)
    {
Target result = Target();
if (!boost::conversion::detail::try_lexical_convert(arg, result))
{
        boost::conversion::detail::throw_bad_cast<Source, Target>();
}
return result;
    }
    template <typename Target>
    inline Target lexical_cast(const char *chars, std::size_t count)
    {
return ::boost::lexical_cast<Target>(
    ::boost::iterator_range<const char *>(chars, chars + count));
    }
    template <typename Target>
    inline Target lexical_cast(const unsigned char *chars, std::size_t count)
    {
return ::boost::lexical_cast<Target>(
    ::boost::iterator_range<const unsigned char *>(chars, chars + count));
    }
    template <typename Target>
    inline Target lexical_cast(const signed char *chars, std::size_t count)
    {
return ::boost::lexical_cast<Target>(
    ::boost::iterator_range<const signed char *>(chars, chars + count));
    }
    template <typename Target>
    inline Target lexical_cast(const wchar_t *chars, std::size_t count)
    {
return ::boost::lexical_cast<Target>(
    ::boost::iterator_range<const wchar_t *>(chars, chars + count));
    }
}

namespace boost
{
    namespace date_time
    {
template <typename charT>
std::vector<std::basic_string<charT>>
gather_month_strings(const std::locale &locale, bool short_strings = true)
{
        typedef std::basic_string<charT> string_type;
        typedef std::vector<string_type> collection_type;
        typedef std::ostreambuf_iterator<charT> ostream_iter_type;
        typedef std::basic_ostringstream<charT> stringstream_type;
        typedef std::time_put<charT> time_put_facet_type;
        charT short_fmt[3] = {'%', 'b'};
        charT long_fmt[3] = {'%', 'B'};
        collection_type months;
        string_type outfmt(short_fmt);
        if (!short_strings)
        {
            outfmt = long_fmt;
        }
        {
            const charT *p_outfmt = outfmt.c_str(), *p_outfmt_end = p_outfmt + outfmt.size();
            tm tm_value;
            std::memset(&tm_value, 0, sizeof(tm_value));
            for (int m = 0; m < 12; m++)
            {
                tm_value.tm_mon = m;
                stringstream_type ss;
                ostream_iter_type oitr(ss);
                std::use_facet<time_put_facet_type>(locale).put(oitr, ss, ss.fill(),
                                                                &tm_value,
                                                                p_outfmt,
                                                                p_outfmt_end);
                months.push_back(ss.str());
            }
        }
        return months;
}
template <typename charT>
std::vector<std::basic_string<charT>>
gather_weekday_strings(const std::locale &locale, bool short_strings = true)
{
        typedef std::basic_string<charT> string_type;
        typedef std::vector<string_type> collection_type;
        typedef std::ostreambuf_iterator<charT> ostream_iter_type;
        typedef std::basic_ostringstream<charT> stringstream_type;
        typedef std::time_put<charT> time_put_facet_type;
        charT short_fmt[3] = {'%', 'a'};
        charT long_fmt[3] = {'%', 'A'};
        collection_type weekdays;
        string_type outfmt(short_fmt);
        if (!short_strings)
        {
            outfmt = long_fmt;
        }
        {
            const charT *p_outfmt = outfmt.c_str(), *p_outfmt_end = p_outfmt + outfmt.size();
            tm tm_value;
            std::memset(&tm_value, 0, sizeof(tm_value));
            for (int i = 0; i < 7; i++)
            {
                tm_value.tm_wday = i;
                stringstream_type ss;
                ostream_iter_type oitr(ss);
                std::use_facet<time_put_facet_type>(locale).put(oitr, ss, ss.fill(),
                                                                &tm_value,
                                                                p_outfmt,
                                                                p_outfmt_end);
                weekdays.push_back(ss.str());
            }
        }
        return weekdays;
}
    }
}
namespace boost
{
    namespace date_time
    {
template <class date_type, typename charT>
class special_values_parser
{
    public:
        typedef std::basic_string<charT> string_type;
        typedef std::basic_stringstream<charT> stringstream_type;
        typedef std::istreambuf_iterator<charT> stream_itr_type;
        typedef typename date_type::duration_type duration_type;
        typedef string_parse_tree<charT> parse_tree_type;
        typedef typename parse_tree_type::parse_match_result_type match_results;
        typedef std::vector<std::basic_string<charT>> collection_type;
        typedef charT char_type;
        static const char_type nadt_string[16];
        static const char_type neg_inf_string[10];
        static const char_type pos_inf_string[10];
        static const char_type min_date_time_string[18];
        static const char_type max_date_time_string[18];
        special_values_parser()
        {
            sv_strings(string_type(nadt_string),
                       string_type(neg_inf_string),
                       string_type(pos_inf_string),
                       string_type(min_date_time_string),
                       string_type(max_date_time_string));
        }
        special_values_parser(const string_type &nadt_str,
                              const string_type &neg_inf_str,
                              const string_type &pos_inf_str,
                              const string_type &min_dt_str,
                              const string_type &max_dt_str)
        {
            sv_strings(nadt_str, neg_inf_str, pos_inf_str, min_dt_str, max_dt_str);
        }
        special_values_parser(typename collection_type::iterator beg, typename collection_type::iterator end)
        {
            collection_type phrases;
            std::copy(beg, end, std::back_inserter(phrases));
            m_sv_strings = parse_tree_type(phrases, static_cast<int>(not_a_date_time));
        }
        void sv_strings(const string_type &nadt_str,
                        const string_type &neg_inf_str,
                        const string_type &pos_inf_str,
                        const string_type &min_dt_str,
                        const string_type &max_dt_str)
        {
            collection_type phrases;
            phrases.push_back(nadt_str);
            phrases.push_back(neg_inf_str);
            phrases.push_back(pos_inf_str);
            phrases.push_back(min_dt_str);
            phrases.push_back(max_dt_str);
            m_sv_strings = parse_tree_type(phrases, static_cast<int>(not_a_date_time));
        }
        static bool should_call_match(const string_type &str)
        {
            if (!str.empty())
            {
                switch (str[0])
                {
                case '+':
                case '-':
                case 'n':
                case 'm':
                    return true;
                default:
                    break;
                }
            }
            return false;
        }
        bool match(stream_itr_type &sitr,
                   stream_itr_type &str_end,
                   match_results &mr) const
        {
            unsigned int level = 0;
            m_sv_strings.match(sitr, str_end, mr, level);
            return (mr.current_match != match_results::PARSE_ERROR);
        }

    private:
        parse_tree_type m_sv_strings;
};
template <class date_type, class CharT>
const typename special_values_parser<date_type, CharT>::char_type
    special_values_parser<date_type, CharT>::nadt_string[16] =
        {'n', 'o', 't', '-', 'a', '-', 'd', 'a', 't', 'e', '-', 't', 'i', 'm', 'e'};
template <class date_type, class CharT>
const typename special_values_parser<date_type, CharT>::char_type
    special_values_parser<date_type, CharT>::neg_inf_string[10] =
        {'-', 'i', 'n', 'f', 'i', 'n', 'i', 't', 'y'};
template <class date_type, class CharT>
const typename special_values_parser<date_type, CharT>::char_type
    special_values_parser<date_type, CharT>::pos_inf_string[10] =
        {'+', 'i', 'n', 'f', 'i', 'n', 'i', 't', 'y'};
template <class date_type, class CharT>
const typename special_values_parser<date_type, CharT>::char_type
    special_values_parser<date_type, CharT>::min_date_time_string[18] =
        {'m', 'i', 'n', 'i', 'm', 'u', 'm', '-', 'd', 'a', 't', 'e', '-', 't', 'i', 'm', 'e'};
template <class date_type, class CharT>
const typename special_values_parser<date_type, CharT>::char_type
    special_values_parser<date_type, CharT>::max_date_time_string[18] =
        {'m', 'a', 'x', 'i', 'm', 'u', 'm', '-', 'd', 'a', 't', 'e', '-', 't', 'i', 'm', 'e'};
    }
}
namespace boost
{
    namespace date_time
    {
template <typename int_type, typename charT>
inline int_type
fixed_string_to_int(std::istreambuf_iterator<charT> &itr,
                    std::istreambuf_iterator<charT> &stream_end,
                    parse_match_result<charT> &mr,
                    unsigned int length,
                    const charT &fill_char)
{
        unsigned int j = 0;
        while (j < length && itr != stream_end &&
               (std::isdigit(*itr) || *itr == fill_char))
        {
            if (*itr == fill_char)
            {
                mr.cache += ('0');
            }
            else
            {
                mr.cache += (*itr);
            }
            itr++;
            j++;
        }
        int_type i = static_cast<int_type>(-1);
        if (mr.cache.size() < length)
        {
            return i;
        }
        try
        {
            i = boost::lexical_cast<int_type>(mr.cache);
        }
        catch (bad_lexical_cast &)
        {
        }
        return i;
}
template <typename int_type, typename charT>
inline int_type
fixed_string_to_int(std::istreambuf_iterator<charT> &itr,
                    std::istreambuf_iterator<charT> &stream_end,
                    parse_match_result<charT> &mr,
                    unsigned int length)
{
        return fixed_string_to_int<int_type, charT>(itr, stream_end, mr, length, '0');
}
template <typename int_type, typename charT>
inline int_type
var_string_to_int(std::istreambuf_iterator<charT> &itr,
                  const std::istreambuf_iterator<charT> &stream_end,
                  unsigned int max_length)
{
        typedef std::basic_string<charT> string_type;
        unsigned int j = 0;
        string_type s;
        while (itr != stream_end && (j < max_length) && std::isdigit(*itr))
        {
            s += (*itr);
            ++itr;
            ++j;
        }
        int_type i = static_cast<int_type>(-1);
        if (!s.empty())
        {
            i = boost::lexical_cast<int_type>(s);
        }
        return i;
}
template <class date_type, typename charT>
class format_date_parser
{
    public:
        typedef std::basic_string<charT> string_type;
        typedef std::basic_istringstream<charT> stringstream_type;
        typedef std::istreambuf_iterator<charT> stream_itr_type;
        typedef typename string_type::const_iterator const_itr;
        typedef typename date_type::year_type year_type;
        typedef typename date_type::month_type month_type;
        typedef typename date_type::day_type day_type;
        typedef typename date_type::duration_type duration_type;
        typedef typename date_type::day_of_week_type day_of_week_type;
        typedef typename date_type::day_of_year_type day_of_year_type;
        typedef string_parse_tree<charT> parse_tree_type;
        typedef typename parse_tree_type::parse_match_result_type match_results;
        typedef std::vector<std::basic_string<charT>> input_collection_type;
        format_date_parser(const string_type &format_str,
                           const input_collection_type &month_short_names,
                           const input_collection_type &month_long_names,
                           const input_collection_type &weekday_short_names,
                           const input_collection_type &weekday_long_names) : m_format(format_str),
                                                                              m_month_short_names(month_short_names, 1),
                                                                              m_month_long_names(month_long_names, 1),
                                                                              m_weekday_short_names(weekday_short_names),
                                                                              m_weekday_long_names(weekday_long_names)
        {
        }
        format_date_parser(const string_type &format_str,
                           const std::locale &locale) : m_format(format_str),
                                                        m_month_short_names(gather_month_strings<charT>(locale), 1),
                                                        m_month_long_names(gather_month_strings<charT>(locale, false), 1),
                                                        m_weekday_short_names(gather_weekday_strings<charT>(locale)),
                                                        m_weekday_long_names(gather_weekday_strings<charT>(locale, false))
        {
        }
        format_date_parser(const format_date_parser<date_type, charT> &fdp)
        {
            this->m_format = fdp.m_format;
            this->m_month_short_names = fdp.m_month_short_names;
            this->m_month_long_names = fdp.m_month_long_names;
            this->m_weekday_short_names = fdp.m_weekday_short_names;
            this->m_weekday_long_names = fdp.m_weekday_long_names;
        }
        string_type format() const
        {
            return m_format;
        }
        void format(string_type format_str)
        {
            m_format = format_str;
        }
        void short_month_names(const input_collection_type &month_names)
        {
            m_month_short_names = parse_tree_type(month_names, 1);
        }
        void long_month_names(const input_collection_type &month_names)
        {
            m_month_long_names = parse_tree_type(month_names, 1);
        }
        void short_weekday_names(const input_collection_type &weekday_names)
        {
            m_weekday_short_names = parse_tree_type(weekday_names);
        }
        void long_weekday_names(const input_collection_type &weekday_names)
        {
            m_weekday_long_names = parse_tree_type(weekday_names);
        }
        date_type
        parse_date(const string_type &value,
                   const string_type &format_str,
                   const special_values_parser<date_type, charT> &sv_parser) const
        {
            stringstream_type ss(value);
            stream_itr_type sitr(ss);
            stream_itr_type stream_end;
            return parse_date(sitr, stream_end, format_str, sv_parser);
        }
        date_type
        parse_date(std::istreambuf_iterator<charT> &sitr,
                   std::istreambuf_iterator<charT> &stream_end,
                   const special_values_parser<date_type, charT> &sv_parser) const
        {
            return parse_date(sitr, stream_end, m_format, sv_parser);
        }
        date_type
        parse_date(std::istreambuf_iterator<charT> &sitr,
                   std::istreambuf_iterator<charT> &stream_end,
                   string_type format_str,
                   const special_values_parser<date_type, charT> &sv_parser) const
        {
            bool use_current_char = false;
            while (std::isspace(*sitr) && sitr != stream_end)
            {
                ++sitr;
            }
            short year(0), month(0), day(0), day_of_year(0);
            year_type t_year(1400);
            month_type t_month(1);
            day_type t_day(1);
            day_of_week_type wkday(0);
            const_itr itr(format_str.begin());
            while (itr != format_str.end() && (sitr != stream_end))
            {
                if (*itr == '%')
                {
                    if (++itr == format_str.end())
                        break;
                    if (*itr != '%')
                    {
                        switch (*itr)
                        {
                        case 'a':
                        {
                            match_results mr = m_weekday_short_names.match(sitr, stream_end);
                            if (mr.current_match == match_results::PARSE_ERROR)
                            {
                                if (sv_parser.match(sitr, stream_end, mr))
                                {
                                    return date_type(static_cast<special_values>(mr.current_match));
                                }
                            }
                            wkday = mr.current_match;
                            if (mr.has_remaining())
                            {
                                use_current_char = true;
                            }
                            break;
                        }
                        case 'A':
                        {
                            match_results mr = m_weekday_long_names.match(sitr, stream_end);
                            if (mr.current_match == match_results::PARSE_ERROR)
                            {
                                if (sv_parser.match(sitr, stream_end, mr))
                                {
                                    return date_type(static_cast<special_values>(mr.current_match));
                                }
                            }
                            wkday = mr.current_match;
                            if (mr.has_remaining())
                            {
                                use_current_char = true;
                            }
                            break;
                        }
                        case 'b':
                        {
                            match_results mr = m_month_short_names.match(sitr, stream_end);
                            if (mr.current_match == match_results::PARSE_ERROR)
                            {
                                if (sv_parser.match(sitr, stream_end, mr))
                                {
                                    return date_type(static_cast<special_values>(mr.current_match));
                                }
                            }
                            t_month = month_type(mr.current_match);
                            if (mr.has_remaining())
                            {
                                use_current_char = true;
                            }
                            break;
                        }
                        case 'B':
                        {
                            match_results mr = m_month_long_names.match(sitr, stream_end);
                            if (mr.current_match == match_results::PARSE_ERROR)
                            {
                                if (sv_parser.match(sitr, stream_end, mr))
                                {
                                    return date_type(static_cast<special_values>(mr.current_match));
                                }
                            }
                            t_month = month_type(mr.current_match);
                            if (mr.has_remaining())
                            {
                                use_current_char = true;
                            }
                            break;
                        }
                        case 'd':
                        {
                            match_results mr;
                            day = fixed_string_to_int<short, charT>(sitr, stream_end, mr, 2);
                            if (day == -1)
                            {
                                if (sv_parser.match(sitr, stream_end, mr))
                                {
                                    return date_type(static_cast<special_values>(mr.current_match));
                                }
                            }
                            t_day = day_type(day);
                            break;
                        }
                        case 'e':
                        {
                            match_results mr;
                            day = fixed_string_to_int<short, charT>(sitr, stream_end, mr, 2, ' ');
                            if (day == -1)
                            {
                                if (sv_parser.match(sitr, stream_end, mr))
                                {
                                    return date_type(static_cast<special_values>(mr.current_match));
                                }
                            }
                            t_day = day_type(day);
                            break;
                        }
                        case 'j':
                        {
                            match_results mr;
                            day_of_year = fixed_string_to_int<short, charT>(sitr, stream_end, mr, 3);
                            if (day_of_year == -1)
                            {
                                if (sv_parser.match(sitr, stream_end, mr))
                                {
                                    return date_type(static_cast<special_values>(mr.current_match));
                                }
                            }
                            day_of_year_type t_day_of_year(1);
                            t_day_of_year = day_of_year_type(day_of_year);
                            break;
                        }
                        case 'm':
                        {
                            match_results mr;
                            month = fixed_string_to_int<short, charT>(sitr, stream_end, mr, 2);
                            if (month == -1)
                            {
                                if (sv_parser.match(sitr, stream_end, mr))
                                {
                                    return date_type(static_cast<special_values>(mr.current_match));
                                }
                            }
                            t_month = month_type(month);
                            break;
                        }
                        case 'Y':
                        {
                            match_results mr;
                            year = fixed_string_to_int<short, charT>(sitr, stream_end, mr, 4);
                            if (year == -1)
                            {
                                if (sv_parser.match(sitr, stream_end, mr))
                                {
                                    return date_type(static_cast<special_values>(mr.current_match));
                                }
                            }
                            t_year = year_type(year);
                            break;
                        }
                        case 'y':
                        {
                            match_results mr;
                            year = fixed_string_to_int<short, charT>(sitr, stream_end, mr, 2);
                            if (year == -1)
                            {
                                if (sv_parser.match(sitr, stream_end, mr))
                                {
                                    return date_type(static_cast<special_values>(mr.current_match));
                                }
                            }
                            year += 2000;
                            t_year = year_type(year);
                            break;
                        }
                        default:
                        {
                        }
                        }
                    }
                    else
                    {
                        sitr++;
                    }
                    itr++;
                }
                else
                {
                    itr++;
                    if (use_current_char)
                    {
                        use_current_char = false;
                    }
                    else
                    {
                        sitr++;
                    }
                }
            }
            if (day_of_year > 0)
            {
                date_type d(static_cast<unsigned short>(year - 1), 12, 31);
                return d + duration_type(day_of_year);
            }
            return date_type(t_year, t_month, t_day);
        }
        month_type
        parse_month(std::istreambuf_iterator<charT> &sitr,
                    std::istreambuf_iterator<charT> &stream_end,
                    string_type format_str) const
        {
            match_results mr;
            return parse_month(sitr, stream_end, format_str, mr);
        }
        month_type
        parse_month(std::istreambuf_iterator<charT> &sitr,
                    std::istreambuf_iterator<charT> &stream_end,
                    string_type format_str,
                    match_results &mr) const
        {
            bool use_current_char = false;
            while (std::isspace(*sitr) && sitr != stream_end)
            {
                ++sitr;
            }
            short month(0);
            const_itr itr(format_str.begin());
            while (itr != format_str.end() && (sitr != stream_end))
            {
                if (*itr == '%')
                {
                    if (++itr == format_str.end())
                        break;
                    if (*itr != '%')
                    {
                        switch (*itr)
                        {
                        case 'b':
                        {
                            mr = m_month_short_names.match(sitr, stream_end);
                            month = mr.current_match;
                            if (mr.has_remaining())
                            {
                                use_current_char = true;
                            }
                            break;
                        }
                        case 'B':
                        {
                            mr = m_month_long_names.match(sitr, stream_end);
                            month = mr.current_match;
                            if (mr.has_remaining())
                            {
                                use_current_char = true;
                            }
                            break;
                        }
                        case 'm':
                        {
                            month = var_string_to_int<short, charT>(sitr, stream_end, 2);
                            break;
                        }
                        default:
                        {
                        }
                        }
                    }
                    else
                    {
                        sitr++;
                    }
                    itr++;
                }
                else
                {
                    itr++;
                    if (use_current_char)
                    {
                        use_current_char = false;
                    }
                    else
                    {
                        sitr++;
                    }
                }
            }
            return month_type(month);
        }
        day_type
        parse_var_day_of_month(std::istreambuf_iterator<charT> &sitr,
                               std::istreambuf_iterator<charT> &stream_end) const
        {
            while (std::isspace(*sitr) && sitr != stream_end)
            {
                ++sitr;
            }
            return day_type(var_string_to_int<short, charT>(sitr, stream_end, 2));
        }
        day_type
        parse_day_of_month(std::istreambuf_iterator<charT> &sitr,
                           std::istreambuf_iterator<charT> &stream_end) const
        {
            while (std::isspace(*sitr) && sitr != stream_end)
            {
                ++sitr;
            }
            match_results mr;
            return day_type(fixed_string_to_int<short, charT>(sitr, stream_end, mr, 2));
        }
        day_of_week_type
        parse_weekday(std::istreambuf_iterator<charT> &sitr,
                      std::istreambuf_iterator<charT> &stream_end,
                      string_type format_str) const
        {
            match_results mr;
            return parse_weekday(sitr, stream_end, format_str, mr);
        }
        day_of_week_type
        parse_weekday(std::istreambuf_iterator<charT> &sitr,
                      std::istreambuf_iterator<charT> &stream_end,
                      string_type format_str,
                      match_results &mr) const
        {
            bool use_current_char = false;
            while (std::isspace(*sitr) && sitr != stream_end)
            {
                ++sitr;
            }
            short wkday(0);
            const_itr itr(format_str.begin());
            while (itr != format_str.end() && (sitr != stream_end))
            {
                if (*itr == '%')
                {
                    if (++itr == format_str.end())
                        break;
                    if (*itr != '%')
                    {
                        switch (*itr)
                        {
                        case 'a':
                        {
                            mr = m_weekday_short_names.match(sitr, stream_end);
                            wkday = mr.current_match;
                            if (mr.has_remaining())
                            {
                                use_current_char = true;
                            }
                            break;
                        }
                        case 'A':
                        {
                            mr = m_weekday_long_names.match(sitr, stream_end);
                            wkday = mr.current_match;
                            if (mr.has_remaining())
                            {
                                use_current_char = true;
                            }
                            break;
                        }
                        case 'w':
                        {
                            wkday = var_string_to_int<short, charT>(sitr, stream_end, 2);
                            break;
                        }
                        default:
                        {
                        }
                        }
                    }
                    else
                    {
                        sitr++;
                    }
                    itr++;
                }
                else
                {
                    itr++;
                    if (use_current_char)
                    {
                        use_current_char = false;
                    }
                    else
                    {
                        sitr++;
                    }
                }
            }
            return day_of_week_type(wkday);
        }
        year_type
        parse_year(std::istreambuf_iterator<charT> &sitr,
                   std::istreambuf_iterator<charT> &stream_end,
                   string_type format_str) const
        {
            match_results mr;
            return parse_year(sitr, stream_end, format_str, mr);
        }
        year_type
        parse_year(std::istreambuf_iterator<charT> &sitr,
                   std::istreambuf_iterator<charT> &stream_end,
                   string_type format_str,
                   match_results &mr) const
        {
            while (std::isspace(*sitr) && sitr != stream_end)
            {
                ++sitr;
            }
            unsigned short year(0);
            const_itr itr(format_str.begin());
            while (itr != format_str.end() && (sitr != stream_end))
            {
                if (*itr == '%')
                {
                    if (++itr == format_str.end())
                        break;
                    if (*itr != '%')
                    {
                        switch (*itr)
                        {
                        case 'Y':
                        {
                            year = fixed_string_to_int<short, charT>(sitr, stream_end, mr, 4);
                            break;
                        }
                        case 'y':
                        {
                            year = fixed_string_to_int<short, charT>(sitr, stream_end, mr, 2);
                            year += 2000;
                            break;
                        }
                        default:
                        {
                        }
                        }
                    }
                    else
                    {
                        sitr++;
                    }
                    itr++;
                }
                else
                {
                    itr++;
                    sitr++;
                }
            }
            return year_type(year);
        }

    private:
        string_type m_format;
        parse_tree_type m_month_short_names;
        parse_tree_type m_month_long_names;
        parse_tree_type m_weekday_short_names;
        parse_tree_type m_weekday_long_names;
};
    }
}

namespace boost
{
    namespace date_time
    {
template <class date_type, typename charT>
class date_generator_parser
{
    public:
        typedef std::basic_string<charT> string_type;
        typedef std::istreambuf_iterator<charT> stream_itr_type;
        typedef typename date_type::month_type month_type;
        typedef typename date_type::day_of_week_type day_of_week_type;
        typedef typename date_type::day_type day_type;
        typedef string_parse_tree<charT> parse_tree_type;
        typedef typename parse_tree_type::parse_match_result_type match_results;
        typedef std::vector<std::basic_string<charT>> collection_type;
        typedef partial_date<date_type> partial_date_type;
        typedef nth_kday_of_month<date_type> nth_kday_type;
        typedef first_kday_of_month<date_type> first_kday_type;
        typedef last_kday_of_month<date_type> last_kday_type;
        typedef first_kday_after<date_type> kday_after_type;
        typedef first_kday_before<date_type> kday_before_type;
        typedef charT char_type;
        static const char_type first_string[6];
        static const char_type second_string[7];
        static const char_type third_string[6];
        static const char_type fourth_string[7];
        static const char_type fifth_string[6];
        static const char_type last_string[5];
        static const char_type before_string[8];
        static const char_type after_string[6];
        static const char_type of_string[3];
        enum phrase_elements
        {
            first = 0,
            second,
            third,
            fourth,
            fifth,
            last,
            before,
            after,
            of,
            number_of_phrase_elements
        };
        date_generator_parser()
        {
            element_strings(string_type(first_string),
                            string_type(second_string),
                            string_type(third_string),
                            string_type(fourth_string),
                            string_type(fifth_string),
                            string_type(last_string),
                            string_type(before_string),
                            string_type(after_string),
                            string_type(of_string));
        }
        date_generator_parser(const string_type &first_str,
                              const string_type &second_str,
                              const string_type &third_str,
                              const string_type &fourth_str,
                              const string_type &fifth_str,
                              const string_type &last_str,
                              const string_type &before_str,
                              const string_type &after_str,
                              const string_type &of_str)
        {
            element_strings(first_str, second_str, third_str, fourth_str, fifth_str,
                            last_str, before_str, after_str, of_str);
        }
        void element_strings(const string_type &first_str,
                             const string_type &second_str,
                             const string_type &third_str,
                             const string_type &fourth_str,
                             const string_type &fifth_str,
                             const string_type &last_str,
                             const string_type &before_str,
                             const string_type &after_str,
                             const string_type &of_str)
        {
            collection_type phrases;
            phrases.push_back(first_str);
            phrases.push_back(second_str);
            phrases.push_back(third_str);
            phrases.push_back(fourth_str);
            phrases.push_back(fifth_str);
            phrases.push_back(last_str);
            phrases.push_back(before_str);
            phrases.push_back(after_str);
            phrases.push_back(of_str);
            m_element_strings = parse_tree_type(phrases, this->first);
        }
        void element_strings(const collection_type &col)
        {
            m_element_strings = parse_tree_type(col, this->first);
        }
        template <class facet_type>
        partial_date_type
        get_partial_date_type(stream_itr_type &sitr,
                              stream_itr_type &stream_end,
                              std::ios_base &a_ios,
                              const facet_type &facet) const
        {
            while (std::isspace(*sitr) && sitr != stream_end)
            {
                ++sitr;
            }
            day_type d(1);
            month_type m(1);
            facet.get(sitr, stream_end, a_ios, d);
            facet.get(sitr, stream_end, a_ios, m);
            return partial_date_type(d, m);
        }
        template <class facet_type>
        nth_kday_type
        get_nth_kday_type(stream_itr_type &sitr,
                          stream_itr_type &stream_end,
                          std::ios_base &a_ios,
                          const facet_type &facet) const
        {
            while (std::isspace(*sitr) && sitr != stream_end)
            {
                ++sitr;
            }
            typename nth_kday_type::week_num wn;
            day_of_week_type wd(0);
            month_type m(1);
            match_results mr = m_element_strings.match(sitr, stream_end);
            switch (mr.current_match)
            {
            case first:
            {
                wn = nth_kday_type::first;
                break;
            }
            case second:
            {
                wn = nth_kday_type::second;
                break;
            }
            case third:
            {
                wn = nth_kday_type::third;
                break;
            }
            case fourth:
            {
                wn = nth_kday_type::fourth;
                break;
            }
            case fifth:
            {
                wn = nth_kday_type::fifth;
                break;
            }
            default:
            {
                boost::throw_exception(std::ios_base::failure("Parse failed. No match found for '" + mr.cache + "'"));
                std::abort();
            }
            }
            facet.get(sitr, stream_end, a_ios, wd);
            extract_element(sitr, stream_end, of);
            facet.get(sitr, stream_end, a_ios, m);
            return nth_kday_type(wn, wd, m);
        }
        template <class facet_type>
        first_kday_type
        get_first_kday_type(stream_itr_type &sitr,
                            stream_itr_type &stream_end,
                            std::ios_base &a_ios,
                            const facet_type &facet) const
        {
            while (std::isspace(*sitr) && sitr != stream_end)
            {
                ++sitr;
            }
            day_of_week_type wd(0);
            month_type m(1);
            extract_element(sitr, stream_end, first);
            facet.get(sitr, stream_end, a_ios, wd);
            extract_element(sitr, stream_end, of);
            facet.get(sitr, stream_end, a_ios, m);
            return first_kday_type(wd, m);
        }
        template <class facet_type>
        last_kday_type
        get_last_kday_type(stream_itr_type &sitr,
                           stream_itr_type &stream_end,
                           std::ios_base &a_ios,
                           const facet_type &facet) const
        {
            while (std::isspace(*sitr) && sitr != stream_end)
            {
                ++sitr;
            }
            day_of_week_type wd(0);
            month_type m(1);
            extract_element(sitr, stream_end, last);
            facet.get(sitr, stream_end, a_ios, wd);
            extract_element(sitr, stream_end, of);
            facet.get(sitr, stream_end, a_ios, m);
            return last_kday_type(wd, m);
        }
        template <class facet_type>
        kday_before_type
        get_kday_before_type(stream_itr_type &sitr,
                             stream_itr_type &stream_end,
                             std::ios_base &a_ios,
                             const facet_type &facet) const
        {
            while (std::isspace(*sitr) && sitr != stream_end)
            {
                ++sitr;
            }
            day_of_week_type wd(0);
            facet.get(sitr, stream_end, a_ios, wd);
            extract_element(sitr, stream_end, before);
            return kday_before_type(wd);
        }
        template <class facet_type>
        kday_after_type
        get_kday_after_type(stream_itr_type &sitr,
                            stream_itr_type &stream_end,
                            std::ios_base &a_ios,
                            const facet_type &facet) const
        {
            while (std::isspace(*sitr) && sitr != stream_end)
            {
                ++sitr;
            }
            day_of_week_type wd(0);
            facet.get(sitr, stream_end, a_ios, wd);
            extract_element(sitr, stream_end, after);
            return kday_after_type(wd);
        }

    private:
        parse_tree_type m_element_strings;
        void extract_element(stream_itr_type &sitr,
                             stream_itr_type &stream_end,
                             typename date_generator_parser::phrase_elements ele) const
        {
            while (std::isspace(*sitr) && sitr != stream_end)
            {
                ++sitr;
            }
            match_results mr = m_element_strings.match(sitr, stream_end);
            if (mr.current_match != ele)
            {
                boost::throw_exception(std::ios_base::failure("Parse failed. No match found for '" + mr.cache + "'"));
            }
        }
};
template <class date_type, class CharT>
const typename date_generator_parser<date_type, CharT>::char_type
    date_generator_parser<date_type, CharT>::first_string[6] =
        {'f', 'i', 'r', 's', 't'};
template <class date_type, class CharT>
const typename date_generator_parser<date_type, CharT>::char_type
    date_generator_parser<date_type, CharT>::second_string[7] =
        {'s', 'e', 'c', 'o', 'n', 'd'};
template <class date_type, class CharT>
const typename date_generator_parser<date_type, CharT>::char_type
    date_generator_parser<date_type, CharT>::third_string[6] =
        {'t', 'h', 'i', 'r', 'd'};
template <class date_type, class CharT>
const typename date_generator_parser<date_type, CharT>::char_type
    date_generator_parser<date_type, CharT>::fourth_string[7] =
        {'f', 'o', 'u', 'r', 't', 'h'};
template <class date_type, class CharT>
const typename date_generator_parser<date_type, CharT>::char_type
    date_generator_parser<date_type, CharT>::fifth_string[6] =
        {'f', 'i', 'f', 't', 'h'};
template <class date_type, class CharT>
const typename date_generator_parser<date_type, CharT>::char_type
    date_generator_parser<date_type, CharT>::last_string[5] =
        {'l', 'a', 's', 't'};
template <class date_type, class CharT>
const typename date_generator_parser<date_type, CharT>::char_type
    date_generator_parser<date_type, CharT>::before_string[8] =
        {'b', 'e', 'f', 'o', 'r', 'e'};
template <class date_type, class CharT>
const typename date_generator_parser<date_type, CharT>::char_type
    date_generator_parser<date_type, CharT>::after_string[6] =
        {'a', 'f', 't', 'e', 'r'};
template <class date_type, class CharT>
const typename date_generator_parser<date_type, CharT>::char_type
    date_generator_parser<date_type, CharT>::of_string[3] =
        {'o', 'f'};
    }
}
namespace boost
{
    namespace date_time
    {
template <class date_type,
          class CharT,
          class OutItrT = std::ostreambuf_iterator<CharT, std::char_traits<CharT>>>
class date_facet : public std::locale::facet
{
    public:
        typedef typename date_type::duration_type duration_type;
        typedef typename date_type::day_of_week_type day_of_week_type;
        typedef typename date_type::day_type day_type;
        typedef typename date_type::month_type month_type;
        typedef boost::date_time::period<date_type, duration_type> period_type;
        typedef std::basic_string<CharT> string_type;
        typedef CharT char_type;
        typedef boost::date_time::period_formatter<CharT> period_formatter_type;
        typedef boost::date_time::special_values_formatter<CharT> special_values_formatter_type;
        typedef std::vector<std::basic_string<CharT>> input_collection_type;
        typedef date_generator_formatter<date_type, CharT> date_gen_formatter_type;
        typedef partial_date<date_type> partial_date_type;
        typedef nth_kday_of_month<date_type> nth_kday_type;
        typedef first_kday_of_month<date_type> first_kday_type;
        typedef last_kday_of_month<date_type> last_kday_type;
        typedef first_kday_after<date_type> kday_after_type;
        typedef first_kday_before<date_type> kday_before_type;
        static const char_type long_weekday_format[3];
        static const char_type short_weekday_format[3];
        static const char_type long_month_format[3];
        static const char_type short_month_format[3];
        static const char_type default_period_separator[4];
        static const char_type standard_format_specifier[3];
        static const char_type iso_format_specifier[7];
        static const char_type iso_format_extended_specifier[9];
        static const char_type default_date_format[9];
        static std::locale::id id;
        explicit date_facet(::size_t a_ref = 0)
            : std::locale::facet(a_ref),
              m_format(default_date_format),
              m_month_format(short_month_format),
              m_weekday_format(short_weekday_format)
        {
        }
        explicit date_facet(const char_type *format_str,
                            const input_collection_type &short_names,
                            ::size_t ref_count = 0)
            : std::locale::facet(ref_count),
              m_format(format_str),
              m_month_format(short_month_format),
              m_weekday_format(short_weekday_format),
              m_month_short_names(short_names)
        {
        }
        explicit date_facet(const char_type *format_str,
                            period_formatter_type per_formatter = period_formatter_type(),
                            special_values_formatter_type sv_formatter = special_values_formatter_type(),
                            date_gen_formatter_type dg_formatter = date_gen_formatter_type(),
                            ::size_t ref_count = 0)
            : std::locale::facet(ref_count),
              m_format(format_str),
              m_month_format(short_month_format),
              m_weekday_format(short_weekday_format),
              m_period_formatter(per_formatter),
              m_date_gen_formatter(dg_formatter),
              m_special_values_formatter(sv_formatter)
        {
        }
        void format(const char_type *const format_str)
        {
            m_format = format_str;
        }
        virtual void set_iso_format()
        {
            m_format = iso_format_specifier;
        }
        virtual void set_iso_extended_format()
        {
            m_format = iso_format_extended_specifier;
        }
        void month_format(const char_type *const format_str)
        {
            m_month_format = format_str;
        }
        void weekday_format(const char_type *const format_str)
        {
            m_weekday_format = format_str;
        }
        void period_formatter(period_formatter_type per_formatter)
        {
            m_period_formatter = per_formatter;
        }
        void special_values_formatter(const special_values_formatter_type &svf)
        {
            m_special_values_formatter = svf;
        }
        void short_weekday_names(const input_collection_type &short_names)
        {
            m_weekday_short_names = short_names;
        }
        void long_weekday_names(const input_collection_type &long_names)
        {
            m_weekday_long_names = long_names;
        }
        void short_month_names(const input_collection_type &short_names)
        {
            m_month_short_names = short_names;
        }
        void long_month_names(const input_collection_type &long_names)
        {
            m_month_long_names = long_names;
        }
        void date_gen_phrase_strings(const input_collection_type &new_strings,
                                     typename date_gen_formatter_type::phrase_elements beg_pos = date_gen_formatter_type::first)
        {
            m_date_gen_formatter.elements(new_strings, beg_pos);
        }
        OutItrT put(OutItrT next,
                    std::ios_base &a_ios,
                    char_type fill_char,
                    const date_type &d) const
        {
            if (d.is_special())
            {
                return do_put_special(next, a_ios, fill_char, d.as_special());
            }
            return do_put_tm(next, a_ios, fill_char, to_tm(d), m_format);
        }
        OutItrT put(OutItrT next,
                    std::ios_base &a_ios,
                    char_type fill_char,
                    const duration_type &dd) const
        {
            if (dd.is_special())
            {
                return do_put_special(next, a_ios, fill_char, dd.get_rep().as_special());
            }
            typedef std::num_put<CharT, OutItrT> num_put;
            if (std::has_facet<num_put>(a_ios.getloc()))
            {
                return std::use_facet<num_put>(a_ios.getloc()).put(next, a_ios, fill_char, dd.get_rep().as_number());
            }
            else
            {
                num_put *f = new num_put();
                std::locale l = std::locale(a_ios.getloc(), f);
                a_ios.imbue(l);
                return f->put(next, a_ios, fill_char, dd.get_rep().as_number());
            }
        }
        OutItrT put(OutItrT next,
                    std::ios_base &a_ios,
                    char_type fill_char,
                    const month_type &m) const
        {
            std::tm dtm;
            std::memset(&dtm, 0, sizeof(dtm));
            dtm.tm_mon = m - 1;
            return do_put_tm(next, a_ios, fill_char, dtm, m_month_format);
        }
        OutItrT put(OutItrT next,
                    std::ios_base &a_ios,
                    char_type fill_char,
                    const day_type &day) const
        {
            std::tm dtm;
            std::memset(&dtm, 0, sizeof(dtm));
            dtm.tm_mday = day.as_number();
            char_type tmp[3] = {'%', 'd'};
            string_type temp_format(tmp);
            return do_put_tm(next, a_ios, fill_char, dtm, temp_format);
        }
        OutItrT put(OutItrT next,
                    std::ios_base &a_ios,
                    char_type fill_char,
                    const day_of_week_type &dow) const
        {
            std::tm dtm;
            std::memset(&dtm, 0, sizeof(dtm));
            dtm.tm_wday = dow;
            return do_put_tm(next, a_ios, fill_char, dtm, m_weekday_format);
        }
        OutItrT put(OutItrT next,
                    std::ios_base &a_ios,
                    char_type fill_char,
                    const period_type &p) const
        {
            return m_period_formatter.put_period(next, a_ios, fill_char, p, *this);
        }
        OutItrT put(OutItrT next,
                    std::ios_base &a_ios,
                    char_type fill_char,
                    const partial_date_type &pd) const
        {
            return m_date_gen_formatter.put_partial_date(next, a_ios, fill_char, pd, *this);
        }
        OutItrT put(OutItrT next,
                    std::ios_base &a_ios,
                    char_type fill_char,
                    const nth_kday_type &nkd) const
        {
            return m_date_gen_formatter.put_nth_kday(next, a_ios, fill_char, nkd, *this);
        }
        OutItrT put(OutItrT next,
                    std::ios_base &a_ios,
                    char_type fill_char,
                    const first_kday_type &fkd) const
        {
            return m_date_gen_formatter.put_first_kday(next, a_ios, fill_char, fkd, *this);
        }
        OutItrT put(OutItrT next,
                    std::ios_base &a_ios,
                    char_type fill_char,
                    const last_kday_type &lkd) const
        {
            return m_date_gen_formatter.put_last_kday(next, a_ios, fill_char, lkd, *this);
        }
        OutItrT put(OutItrT next,
                    std::ios_base &a_ios,
                    char_type fill_char,
                    const kday_before_type &fkb) const
        {
            return m_date_gen_formatter.put_kday_before(next, a_ios, fill_char, fkb, *this);
        }
        OutItrT put(OutItrT next,
                    std::ios_base &a_ios,
                    char_type fill_char,
                    const kday_after_type &fka) const
        {
            return m_date_gen_formatter.put_kday_after(next, a_ios, fill_char, fka, *this);
        }

    protected:
        virtual OutItrT do_put_special(OutItrT next,
                                       std::ios_base &,
                                       char_type,
                                       const boost::date_time::special_values sv) const
        {
            m_special_values_formatter.put_special(next, sv);
            return next;
        }
        virtual OutItrT do_put_tm(OutItrT next,
                                  std::ios_base &a_ios,
                                  char_type fill_char,
                                  const tm &tm_value,
                                  string_type a_format) const
        {
            if (!m_weekday_long_names.empty())
            {
                boost::algorithm::replace_all(a_format,
                                              long_weekday_format,
                                              m_weekday_long_names[tm_value.tm_wday]);
            }
            if (!m_weekday_short_names.empty())
            {
                boost::algorithm::replace_all(a_format,
                                              short_weekday_format,
                                              m_weekday_short_names[tm_value.tm_wday]);
            }
            if (!m_month_long_names.empty())
            {
                boost::algorithm::replace_all(a_format,
                                              long_month_format,
                                              m_month_long_names[tm_value.tm_mon]);
            }
            if (!m_month_short_names.empty())
            {
                boost::algorithm::replace_all(a_format,
                                              short_month_format,
                                              m_month_short_names[tm_value.tm_mon]);
            }
            const char_type *p_format = a_format.c_str();
            return std::use_facet<std::time_put<CharT>>(a_ios.getloc()).put(next, a_ios, fill_char, &tm_value, p_format, p_format + a_format.size());
        }

    protected:
        string_type m_format;
        string_type m_month_format;
        string_type m_weekday_format;
        period_formatter_type m_period_formatter;
        date_gen_formatter_type m_date_gen_formatter;
        special_values_formatter_type m_special_values_formatter;
        input_collection_type m_month_short_names;
        input_collection_type m_month_long_names;
        input_collection_type m_weekday_short_names;
        input_collection_type m_weekday_long_names;

    private:
};
template <class date_type, class CharT, class OutItrT>
std::locale::id date_facet<date_type, CharT, OutItrT>::id;
template <class date_type, class CharT, class OutItrT>
const typename date_facet<date_type, CharT, OutItrT>::char_type
    date_facet<date_type, CharT, OutItrT>::long_weekday_format[3] = {'%', 'A'};
template <class date_type, class CharT, class OutItrT>
const typename date_facet<date_type, CharT, OutItrT>::char_type
    date_facet<date_type, CharT, OutItrT>::short_weekday_format[3] = {'%', 'a'};
template <class date_type, class CharT, class OutItrT>
const typename date_facet<date_type, CharT, OutItrT>::char_type
    date_facet<date_type, CharT, OutItrT>::long_month_format[3] = {'%', 'B'};
template <class date_type, class CharT, class OutItrT>
const typename date_facet<date_type, CharT, OutItrT>::char_type
    date_facet<date_type, CharT, OutItrT>::short_month_format[3] = {'%', 'b'};
template <class date_type, class CharT, class OutItrT>
const typename date_facet<date_type, CharT, OutItrT>::char_type
    date_facet<date_type, CharT, OutItrT>::default_period_separator[4] = {' ', '/', ' '};
template <class date_type, class CharT, class OutItrT>
const typename date_facet<date_type, CharT, OutItrT>::char_type
    date_facet<date_type, CharT, OutItrT>::standard_format_specifier[3] =
        {'%', 'x'};
template <class date_type, class CharT, class OutItrT>
const typename date_facet<date_type, CharT, OutItrT>::char_type
    date_facet<date_type, CharT, OutItrT>::iso_format_specifier[7] =
        {'%', 'Y', '%', 'm', '%', 'd'};
template <class date_type, class CharT, class OutItrT>
const typename date_facet<date_type, CharT, OutItrT>::char_type
    date_facet<date_type, CharT, OutItrT>::iso_format_extended_specifier[9] =
        {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};
template <class date_type, class CharT, class OutItrT>
const typename date_facet<date_type, CharT, OutItrT>::char_type
    date_facet<date_type, CharT, OutItrT>::default_date_format[9] =
        {'%', 'Y', '-', '%', 'b', '-', '%', 'd'};
template <class date_type,
          class CharT,
          class InItrT = std::istreambuf_iterator<CharT, std::char_traits<CharT>>>
class date_input_facet : public std::locale::facet
{
    public:
        typedef typename date_type::duration_type duration_type;
        typedef typename date_type::day_of_week_type day_of_week_type;
        typedef typename date_type::day_type day_type;
        typedef typename date_type::month_type month_type;
        typedef typename date_type::year_type year_type;
        typedef boost::date_time::period<date_type, duration_type> period_type;
        typedef std::basic_string<CharT> string_type;
        typedef CharT char_type;
        typedef boost::date_time::period_parser<date_type, CharT> period_parser_type;
        typedef boost::date_time::special_values_parser<date_type, CharT> special_values_parser_type;
        typedef std::vector<std::basic_string<CharT>> input_collection_type;
        typedef format_date_parser<date_type, CharT> format_date_parser_type;
        typedef date_generator_parser<date_type, CharT> date_gen_parser_type;
        typedef partial_date<date_type> partial_date_type;
        typedef nth_kday_of_month<date_type> nth_kday_type;
        typedef first_kday_of_month<date_type> first_kday_type;
        typedef last_kday_of_month<date_type> last_kday_type;
        typedef first_kday_after<date_type> kday_after_type;
        typedef first_kday_before<date_type> kday_before_type;
        static const char_type long_weekday_format[3];
        static const char_type short_weekday_format[3];
        static const char_type long_month_format[3];
        static const char_type short_month_format[3];
        static const char_type four_digit_year_format[3];
        static const char_type two_digit_year_format[3];
        static const char_type default_period_separator[4];
        static const char_type standard_format_specifier[3];
        static const char_type iso_format_specifier[7];
        static const char_type iso_format_extended_specifier[9];
        static const char_type default_date_format[9];
        static std::locale::id id;
        explicit date_input_facet(::size_t a_ref = 0)
            : std::locale::facet(a_ref),
              m_format(default_date_format),
              m_month_format(short_month_format),
              m_weekday_format(short_weekday_format),
              m_year_format(four_digit_year_format),
              m_parser(m_format, std::locale::classic())
        {
        }
        explicit date_input_facet(const string_type &format_str,
                                  ::size_t a_ref = 0)
            : std::locale::facet(a_ref),
              m_format(format_str),
              m_month_format(short_month_format),
              m_weekday_format(short_weekday_format),
              m_year_format(four_digit_year_format),
              m_parser(m_format, std::locale::classic())
        {
        }
        explicit date_input_facet(const string_type &format_str,
                                  const format_date_parser_type &date_parser,
                                  const special_values_parser_type &sv_parser,
                                  const period_parser_type &per_parser,
                                  const date_gen_parser_type &date_gen_parser,
                                  ::size_t ref_count = 0)
            : std::locale::facet(ref_count),
              m_format(format_str),
              m_month_format(short_month_format),
              m_weekday_format(short_weekday_format),
              m_year_format(four_digit_year_format),
              m_parser(date_parser),
              m_date_gen_parser(date_gen_parser),
              m_period_parser(per_parser),
              m_sv_parser(sv_parser)
        {
        }
        void format(const char_type *const format_str)
        {
            m_format = format_str;
        }
        virtual void set_iso_format()
        {
            m_format = iso_format_specifier;
        }
        virtual void set_iso_extended_format()
        {
            m_format = iso_format_extended_specifier;
        }
        void month_format(const char_type *const format_str)
        {
            m_month_format = format_str;
        }
        void weekday_format(const char_type *const format_str)
        {
            m_weekday_format = format_str;
        }
        void year_format(const char_type *const format_str)
        {
            m_year_format = format_str;
        }
        void period_parser(period_parser_type per_parser)
        {
            m_period_parser = per_parser;
        }
        void short_weekday_names(const input_collection_type &weekday_names)
        {
            m_parser.short_weekday_names(weekday_names);
        }
        void long_weekday_names(const input_collection_type &weekday_names)
        {
            m_parser.long_weekday_names(weekday_names);
        }
        void short_month_names(const input_collection_type &month_names)
        {
            m_parser.short_month_names(month_names);
        }
        void long_month_names(const input_collection_type &month_names)
        {
            m_parser.long_month_names(month_names);
        }
        void date_gen_element_strings(const input_collection_type &col)
        {
            m_date_gen_parser.element_strings(col);
        }
        void date_gen_element_strings(const string_type &first,
                                      const string_type &second,
                                      const string_type &third,
                                      const string_type &fourth,
                                      const string_type &fifth,
                                      const string_type &last,
                                      const string_type &before,
                                      const string_type &after,
                                      const string_type &of)
        {
            m_date_gen_parser.element_strings(first, second, third, fourth, fifth, last, before, after, of);
        }
        void special_values_parser(special_values_parser_type sv_parser)
        {
            m_sv_parser = sv_parser;
        }
        InItrT get(InItrT &from,
                   InItrT &to,
                   std::ios_base &,
                   date_type &d) const
        {
            d = m_parser.parse_date(from, to, m_format, m_sv_parser);
            return from;
        }
        InItrT get(InItrT &from,
                   InItrT &to,
                   std::ios_base &,
                   month_type &m) const
        {
            m = m_parser.parse_month(from, to, m_month_format);
            return from;
        }
        InItrT get(InItrT &from,
                   InItrT &to,
                   std::ios_base &,
                   day_of_week_type &wd) const
        {
            wd = m_parser.parse_weekday(from, to, m_weekday_format);
            return from;
        }
        InItrT get(InItrT &from,
                   InItrT &to,
                   std::ios_base &,
                   day_type &d) const
        {
            d = m_parser.parse_var_day_of_month(from, to);
            return from;
        }
        InItrT get(InItrT &from,
                   InItrT &to,
                   std::ios_base &,
                   year_type &y) const
        {
            y = m_parser.parse_year(from, to, m_year_format);
            return from;
        }
        InItrT get(InItrT &from,
                   InItrT &to,
                   std::ios_base &a_ios,
                   duration_type &dd) const
        {
            while (std::isspace(*from) && from != to)
            {
                ++from;
            }
            char_type c = '\0';
            if (*from == '-' || *from == '+')
            {
                c = *from;
            }
            typedef std::num_get<CharT, InItrT> num_get;
            typename duration_type::duration_rep_type val = 0;
            std::ios_base::iostate err = std::ios_base::goodbit;
            if (std::has_facet<num_get>(a_ios.getloc()))
            {
                from = std::use_facet<num_get>(a_ios.getloc()).get(from, to, a_ios, err, val);
            }
            else
            {
                num_get *ng = new num_get();
                std::locale l = std::locale(a_ios.getloc(), ng);
                a_ios.imbue(l);
                from = ng->get(from, to, a_ios, err, val);
            }
            if (err & std::ios_base::failbit)
            {
                typedef typename special_values_parser_type::match_results match_results;
                match_results mr;
                if (c == '-' || c == '+')
                {
                    mr.cache += c;
                }
                m_sv_parser.match(from, to, mr);
                if (mr.current_match == match_results::PARSE_ERROR)
                {
                    boost::throw_exception(std::ios_base::failure("Parse failed. No match found for '" + mr.cache + "'"));
                    std::abort();
                }
                dd = duration_type(static_cast<special_values>(mr.current_match));
            }
            else
            {
                dd = duration_type(val);
            }
            return from;
        }
        InItrT get(InItrT &from,
                   InItrT &to,
                   std::ios_base &a_ios,
                   period_type &p) const
        {
            p = m_period_parser.get_period(from, to, a_ios, p, duration_type::unit(), *this);
            return from;
        }
        InItrT get(InItrT &from,
                   InItrT &to,
                   std::ios_base &a_ios,
                   nth_kday_type &nkd) const
        {
            nkd = m_date_gen_parser.get_nth_kday_type(from, to, a_ios, *this);
            return from;
        }
        InItrT get(InItrT &from,
                   InItrT &to,
                   std::ios_base &a_ios,
                   partial_date_type &pd) const
        {
            pd = m_date_gen_parser.get_partial_date_type(from, to, a_ios, *this);
            return from;
        }
        InItrT get(InItrT &from,
                   InItrT &to,
                   std::ios_base &a_ios,
                   first_kday_type &fkd) const
        {
            fkd = m_date_gen_parser.get_first_kday_type(from, to, a_ios, *this);
            return from;
        }
        InItrT get(InItrT &from,
                   InItrT &to,
                   std::ios_base &a_ios,
                   last_kday_type &lkd) const
        {
            lkd = m_date_gen_parser.get_last_kday_type(from, to, a_ios, *this);
            return from;
        }
        InItrT get(InItrT &from,
                   InItrT &to,
                   std::ios_base &a_ios,
                   kday_before_type &fkb) const
        {
            fkb = m_date_gen_parser.get_kday_before_type(from, to, a_ios, *this);
            return from;
        }
        InItrT get(InItrT &from,
                   InItrT &to,
                   std::ios_base &a_ios,
                   kday_after_type &fka) const
        {
            fka = m_date_gen_parser.get_kday_after_type(from, to, a_ios, *this);
            return from;
        }

    protected:
        string_type m_format;
        string_type m_month_format;
        string_type m_weekday_format;
        string_type m_year_format;
        format_date_parser_type m_parser;
        date_gen_parser_type m_date_gen_parser;
        period_parser_type m_period_parser;
        special_values_parser_type m_sv_parser;

    private:
};
template <class date_type, class CharT, class OutItrT>
std::locale::id date_input_facet<date_type, CharT, OutItrT>::id;
template <class date_type, class CharT, class OutItrT>
const typename date_input_facet<date_type, CharT, OutItrT>::char_type
    date_input_facet<date_type, CharT, OutItrT>::long_weekday_format[3] = {'%', 'A'};
template <class date_type, class CharT, class OutItrT>
const typename date_input_facet<date_type, CharT, OutItrT>::char_type
    date_input_facet<date_type, CharT, OutItrT>::short_weekday_format[3] = {'%', 'a'};
template <class date_type, class CharT, class OutItrT>
const typename date_input_facet<date_type, CharT, OutItrT>::char_type
    date_input_facet<date_type, CharT, OutItrT>::long_month_format[3] = {'%', 'B'};
template <class date_type, class CharT, class OutItrT>
const typename date_input_facet<date_type, CharT, OutItrT>::char_type
    date_input_facet<date_type, CharT, OutItrT>::short_month_format[3] = {'%', 'b'};
template <class date_type, class CharT, class OutItrT>
const typename date_input_facet<date_type, CharT, OutItrT>::char_type
    date_input_facet<date_type, CharT, OutItrT>::four_digit_year_format[3] = {'%', 'Y'};
template <class date_type, class CharT, class OutItrT>
const typename date_input_facet<date_type, CharT, OutItrT>::char_type
    date_input_facet<date_type, CharT, OutItrT>::two_digit_year_format[3] = {'%', 'y'};
template <class date_type, class CharT, class OutItrT>
const typename date_input_facet<date_type, CharT, OutItrT>::char_type
    date_input_facet<date_type, CharT, OutItrT>::default_period_separator[4] = {' ', '/', ' '};
template <class date_type, class CharT, class OutItrT>
const typename date_input_facet<date_type, CharT, OutItrT>::char_type
    date_input_facet<date_type, CharT, OutItrT>::standard_format_specifier[3] =
        {'%', 'x'};
template <class date_type, class CharT, class OutItrT>
const typename date_input_facet<date_type, CharT, OutItrT>::char_type
    date_input_facet<date_type, CharT, OutItrT>::iso_format_specifier[7] =
        {'%', 'Y', '%', 'm', '%', 'd'};
template <class date_type, class CharT, class OutItrT>
const typename date_input_facet<date_type, CharT, OutItrT>::char_type
    date_input_facet<date_type, CharT, OutItrT>::iso_format_extended_specifier[9] =
        {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};
template <class date_type, class CharT, class OutItrT>
const typename date_input_facet<date_type, CharT, OutItrT>::char_type
    date_input_facet<date_type, CharT, OutItrT>::default_date_format[9] =
        {'%', 'Y', '-', '%', 'b', '-', '%', 'd'};
    }
}
namespace boost
{
    namespace gregorian
    {
typedef boost::date_time::period_formatter<wchar_t> wperiod_formatter;
typedef boost::date_time::period_formatter<char> period_formatter;
typedef boost::date_time::date_facet<date, wchar_t> wdate_facet;
typedef boost::date_time::date_facet<date, char> date_facet;
typedef boost::date_time::period_parser<date, char> period_parser;
typedef boost::date_time::period_parser<date, wchar_t> wperiod_parser;
typedef boost::date_time::special_values_formatter<char> special_values_formatter;
typedef boost::date_time::special_values_formatter<wchar_t> wspecial_values_formatter;
typedef boost::date_time::special_values_parser<date, char> special_values_parser;
typedef boost::date_time::special_values_parser<date, wchar_t> wspecial_values_parser;
typedef boost::date_time::date_input_facet<date, char> date_input_facet;
typedef boost::date_time::date_input_facet<date, wchar_t> wdate_input_facet;
template <class CharT, class TraitsT>
inline std::basic_ostream<CharT, TraitsT> &
operator<<(std::basic_ostream<CharT, TraitsT> &os, const boost::gregorian::date &d)
{
        boost::io::ios_flags_saver iflags(os);
        typedef boost::date_time::date_facet<date, CharT> custom_date_facet;
        std::ostreambuf_iterator<CharT> output_itr(os);
        if (std::has_facet<custom_date_facet>(os.getloc()))
            std::use_facet<custom_date_facet>(os.getloc()).put(output_itr, os, os.fill(), d);
        else
        {
            custom_date_facet *f = new custom_date_facet();
            std::locale l = std::locale(os.getloc(), f);
            os.imbue(l);
            f->put(output_itr, os, os.fill(), d);
        }
        return os;
}
template <class CharT, class Traits>
inline std::basic_istream<CharT, Traits> &
operator>>(std::basic_istream<CharT, Traits> &is, date &d)
{
        boost::io::ios_flags_saver iflags(is);
        typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
        if (strm_sentry)
        {
            try
            {
                typedef typename date_time::date_input_facet<date, CharT> date_input_facet_local;
                std::istreambuf_iterator<CharT, Traits> sit(is), str_end;
                if (std::has_facet<date_input_facet_local>(is.getloc()))
                {
                    std::use_facet<date_input_facet_local>(is.getloc()).get(sit, str_end, is, d);
                }
                else
                {
                    date_input_facet_local *f = new date_input_facet_local();
                    std::locale l = std::locale(is.getloc(), f);
                    is.imbue(l);
                    f->get(sit, str_end, is, d);
                }
            }
            catch (...)
            {
                std::ios_base::iostate exception_mask = is.exceptions();
                if (std::ios_base::failbit & exception_mask)
                {
                    try
                    {
                        is.setstate(std::ios_base::failbit);
                    }
                    catch (std::ios_base::failure &)
                    {
                    }
                    throw;
                }
                else
                {
                    is.setstate(std::ios_base::failbit);
                }
            }
        }
        return is;
}
template <class CharT, class TraitsT>
inline std::basic_ostream<CharT, TraitsT> &
operator<<(std::basic_ostream<CharT, TraitsT> &os, const boost::gregorian::date_duration &dd)
{
        boost::io::ios_flags_saver iflags(os);
        typedef boost::date_time::date_facet<date, CharT> custom_date_facet;
        std::ostreambuf_iterator<CharT> output_itr(os);
        if (std::has_facet<custom_date_facet>(os.getloc()))
            std::use_facet<custom_date_facet>(os.getloc()).put(output_itr, os, os.fill(), dd);
        else
        {
            custom_date_facet *f = new custom_date_facet();
            std::locale l = std::locale(os.getloc(), f);
            os.imbue(l);
            f->put(output_itr, os, os.fill(), dd);
        }
        return os;
}
template <class CharT, class Traits>
inline std::basic_istream<CharT, Traits> &
operator>>(std::basic_istream<CharT, Traits> &is, date_duration &dd)
{
        boost::io::ios_flags_saver iflags(is);
        typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
        if (strm_sentry)
        {
            try
            {
                typedef typename date_time::date_input_facet<date, CharT> date_input_facet_local;
                std::istreambuf_iterator<CharT, Traits> sit(is), str_end;
                if (std::has_facet<date_input_facet_local>(is.getloc()))
                {
                    std::use_facet<date_input_facet_local>(is.getloc()).get(sit, str_end, is, dd);
                }
                else
                {
                    date_input_facet_local *f = new date_input_facet_local();
                    std::locale l = std::locale(is.getloc(), f);
                    is.imbue(l);
                    f->get(sit, str_end, is, dd);
                }
            }
            catch (...)
            {
                std::ios_base::iostate exception_mask = is.exceptions();
                if (std::ios_base::failbit & exception_mask)
                {
                    try
                    {
                        is.setstate(std::ios_base::failbit);
                    }
                    catch (std::ios_base::failure &)
                    {
                    }
                    throw;
                }
                else
                {
                    is.setstate(std::ios_base::failbit);
                }
            }
        }
        return is;
}
template <class CharT, class TraitsT>
inline std::basic_ostream<CharT, TraitsT> &
operator<<(std::basic_ostream<CharT, TraitsT> &os, const boost::gregorian::date_period &dp)
{
        boost::io::ios_flags_saver iflags(os);
        typedef boost::date_time::date_facet<date, CharT> custom_date_facet;
        std::ostreambuf_iterator<CharT> output_itr(os);
        if (std::has_facet<custom_date_facet>(os.getloc()))
            std::use_facet<custom_date_facet>(os.getloc()).put(output_itr, os, os.fill(), dp);
        else
        {
            custom_date_facet *f = new custom_date_facet();
            std::locale l = std::locale(os.getloc(), f);
            os.imbue(l);
            f->put(output_itr, os, os.fill(), dp);
        }
        return os;
}
template <class CharT, class Traits>
inline std::basic_istream<CharT, Traits> &
operator>>(std::basic_istream<CharT, Traits> &is, date_period &dp)
{
        boost::io::ios_flags_saver iflags(is);
        typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
        if (strm_sentry)
        {
            try
            {
                typedef typename date_time::date_input_facet<date, CharT> date_input_facet_local;
                std::istreambuf_iterator<CharT, Traits> sit(is), str_end;
                if (std::has_facet<date_input_facet_local>(is.getloc()))
                {
                    std::use_facet<date_input_facet_local>(is.getloc()).get(sit, str_end, is, dp);
                }
                else
                {
                    date_input_facet_local *f = new date_input_facet_local();
                    std::locale l = std::locale(is.getloc(), f);
                    is.imbue(l);
                    f->get(sit, str_end, is, dp);
                }
            }
            catch (...)
            {
                std::ios_base::iostate exception_mask = is.exceptions();
                if (std::ios_base::failbit & exception_mask)
                {
                    try
                    {
                        is.setstate(std::ios_base::failbit);
                    }
                    catch (std::ios_base::failure &)
                    {
                    }
                    throw;
                }
                else
                {
                    is.setstate(std::ios_base::failbit);
                }
            }
        }
        return is;
}
template <class CharT, class TraitsT>
inline std::basic_ostream<CharT, TraitsT> &
operator<<(std::basic_ostream<CharT, TraitsT> &os, const boost::gregorian::greg_month &gm)
{
        boost::io::ios_flags_saver iflags(os);
        typedef boost::date_time::date_facet<date, CharT> custom_date_facet;
        std::ostreambuf_iterator<CharT> output_itr(os);
        if (std::has_facet<custom_date_facet>(os.getloc()))
            std::use_facet<custom_date_facet>(os.getloc()).put(output_itr, os, os.fill(), gm);
        else
        {
            custom_date_facet *f = new custom_date_facet();
            std::locale l = std::locale(os.getloc(), f);
            os.imbue(l);
            f->put(output_itr, os, os.fill(), gm);
        }
        return os;
}
template <class CharT, class Traits>
inline std::basic_istream<CharT, Traits> &
operator>>(std::basic_istream<CharT, Traits> &is, greg_month &m)
{
        boost::io::ios_flags_saver iflags(is);
        typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
        if (strm_sentry)
        {
            try
            {
                typedef typename date_time::date_input_facet<date, CharT> date_input_facet_local;
                std::istreambuf_iterator<CharT, Traits> sit(is), str_end;
                if (std::has_facet<date_input_facet_local>(is.getloc()))
                {
                    std::use_facet<date_input_facet_local>(is.getloc()).get(sit, str_end, is, m);
                }
                else
                {
                    date_input_facet_local *f = new date_input_facet_local();
                    std::locale l = std::locale(is.getloc(), f);
                    is.imbue(l);
                    f->get(sit, str_end, is, m);
                }
            }
            catch (...)
            {
                std::ios_base::iostate exception_mask = is.exceptions();
                if (std::ios_base::failbit & exception_mask)
                {
                    try
                    {
                        is.setstate(std::ios_base::failbit);
                    }
                    catch (std::ios_base::failure &)
                    {
                    }
                    throw;
                }
                else
                {
                    is.setstate(std::ios_base::failbit);
                }
            }
        }
        return is;
}
template <class CharT, class TraitsT>
inline std::basic_ostream<CharT, TraitsT> &
operator<<(std::basic_ostream<CharT, TraitsT> &os, const boost::gregorian::greg_weekday &gw)
{
        boost::io::ios_flags_saver iflags(os);
        typedef boost::date_time::date_facet<date, CharT> custom_date_facet;
        std::ostreambuf_iterator<CharT> output_itr(os);
        if (std::has_facet<custom_date_facet>(os.getloc()))
            std::use_facet<custom_date_facet>(os.getloc()).put(output_itr, os, os.fill(), gw);
        else
        {
            custom_date_facet *f = new custom_date_facet();
            std::locale l = std::locale(os.getloc(), f);
            os.imbue(l);
            f->put(output_itr, os, os.fill(), gw);
        }
        return os;
}
template <class CharT, class Traits>
inline std::basic_istream<CharT, Traits> &
operator>>(std::basic_istream<CharT, Traits> &is, greg_weekday &wd)
{
        boost::io::ios_flags_saver iflags(is);
        typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
        if (strm_sentry)
        {
            try
            {
                typedef typename date_time::date_input_facet<date, CharT> date_input_facet_local;
                std::istreambuf_iterator<CharT, Traits> sit(is), str_end;
                if (std::has_facet<date_input_facet_local>(is.getloc()))
                {
                    std::use_facet<date_input_facet_local>(is.getloc()).get(sit, str_end, is, wd);
                }
                else
                {
                    date_input_facet_local *f = new date_input_facet_local();
                    std::locale l = std::locale(is.getloc(), f);
                    is.imbue(l);
                    f->get(sit, str_end, is, wd);
                }
            }
            catch (...)
            {
                std::ios_base::iostate exception_mask = is.exceptions();
                if (std::ios_base::failbit & exception_mask)
                {
                    try
                    {
                        is.setstate(std::ios_base::failbit);
                    }
                    catch (std::ios_base::failure &)
                    {
                    }
                    throw;
                }
                else
                {
                    is.setstate(std::ios_base::failbit);
                }
            }
        }
        return is;
}
template <class CharT, class Traits>
inline std::basic_istream<CharT, Traits> &
operator>>(std::basic_istream<CharT, Traits> &is, greg_day &gd)
{
        boost::io::ios_flags_saver iflags(is);
        typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
        if (strm_sentry)
        {
            try
            {
                typedef typename date_time::date_input_facet<date, CharT> date_input_facet_local;
                std::istreambuf_iterator<CharT, Traits> sit(is), str_end;
                if (std::has_facet<date_input_facet_local>(is.getloc()))
                {
                    std::use_facet<date_input_facet_local>(is.getloc()).get(sit, str_end, is, gd);
                }
                else
                {
                    date_input_facet_local *f = new date_input_facet_local();
                    std::locale l = std::locale(is.getloc(), f);
                    is.imbue(l);
                    f->get(sit, str_end, is, gd);
                }
            }
            catch (...)
            {
                std::ios_base::iostate exception_mask = is.exceptions();
                if (std::ios_base::failbit & exception_mask)
                {
                    try
                    {
                        is.setstate(std::ios_base::failbit);
                    }
                    catch (std::ios_base::failure &)
                    {
                    }
                    throw;
                }
                else
                {
                    is.setstate(std::ios_base::failbit);
                }
            }
        }
        return is;
}
template <class CharT, class Traits>
inline std::basic_istream<CharT, Traits> &
operator>>(std::basic_istream<CharT, Traits> &is, greg_year &gy)
{
        boost::io::ios_flags_saver iflags(is);
        typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
        if (strm_sentry)
        {
            try
            {
                typedef typename date_time::date_input_facet<date, CharT> date_input_facet_local;
                std::istreambuf_iterator<CharT, Traits> sit(is), str_end;
                if (std::has_facet<date_input_facet_local>(is.getloc()))
                {
                    std::use_facet<date_input_facet_local>(is.getloc()).get(sit, str_end, is, gy);
                }
                else
                {
                    date_input_facet_local *f = new date_input_facet_local();
                    std::locale l = std::locale(is.getloc(), f);
                    is.imbue(l);
                    f->get(sit, str_end, is, gy);
                }
            }
            catch (...)
            {
                std::ios_base::iostate exception_mask = is.exceptions();
                if (std::ios_base::failbit & exception_mask)
                {
                    try
                    {
                        is.setstate(std::ios_base::failbit);
                    }
                    catch (std::ios_base::failure &)
                    {
                    }
                    throw;
                }
                else
                {
                    is.setstate(std::ios_base::failbit);
                }
            }
        }
        return is;
}
template <class CharT, class TraitsT>
inline std::basic_ostream<CharT, TraitsT> &
operator<<(std::basic_ostream<CharT, TraitsT> &os, const boost::gregorian::partial_date &pd)
{
        boost::io::ios_flags_saver iflags(os);
        typedef boost::date_time::date_facet<date, CharT> custom_date_facet;
        std::ostreambuf_iterator<CharT> output_itr(os);
        if (std::has_facet<custom_date_facet>(os.getloc()))
            std::use_facet<custom_date_facet>(os.getloc()).put(output_itr, os, os.fill(), pd);
        else
        {
            custom_date_facet *f = new custom_date_facet();
            std::locale l = std::locale(os.getloc(), f);
            os.imbue(l);
            f->put(output_itr, os, os.fill(), pd);
        }
        return os;
}
template <class CharT, class Traits>
inline std::basic_istream<CharT, Traits> &
operator>>(std::basic_istream<CharT, Traits> &is, partial_date &pd)
{
        boost::io::ios_flags_saver iflags(is);
        typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
        if (strm_sentry)
        {
            try
            {
                typedef typename date_time::date_input_facet<date, CharT> date_input_facet_local;
                std::istreambuf_iterator<CharT, Traits> sit(is), str_end;
                if (std::has_facet<date_input_facet_local>(is.getloc()))
                {
                    std::use_facet<date_input_facet_local>(is.getloc()).get(sit, str_end, is, pd);
                }
                else
                {
                    date_input_facet_local *f = new date_input_facet_local();
                    std::locale l = std::locale(is.getloc(), f);
                    is.imbue(l);
                    f->get(sit, str_end, is, pd);
                }
            }
            catch (...)
            {
                std::ios_base::iostate exception_mask = is.exceptions();
                if (std::ios_base::failbit & exception_mask)
                {
                    try
                    {
                        is.setstate(std::ios_base::failbit);
                    }
                    catch (std::ios_base::failure &)
                    {
                    }
                    throw;
                }
                else
                {
                    is.setstate(std::ios_base::failbit);
                }
            }
        }
        return is;
}
template <class CharT, class TraitsT>
inline std::basic_ostream<CharT, TraitsT> &
operator<<(std::basic_ostream<CharT, TraitsT> &os, const boost::gregorian::nth_day_of_the_week_in_month &nkd)
{
        boost::io::ios_flags_saver iflags(os);
        typedef boost::date_time::date_facet<date, CharT> custom_date_facet;
        std::ostreambuf_iterator<CharT> output_itr(os);
        if (std::has_facet<custom_date_facet>(os.getloc()))
            std::use_facet<custom_date_facet>(os.getloc()).put(output_itr, os, os.fill(), nkd);
        else
        {
            custom_date_facet *f = new custom_date_facet();
            std::locale l = std::locale(os.getloc(), f);
            os.imbue(l);
            f->put(output_itr, os, os.fill(), nkd);
        }
        return os;
}
template <class CharT, class Traits>
inline std::basic_istream<CharT, Traits> &
operator>>(std::basic_istream<CharT, Traits> &is,
           nth_day_of_the_week_in_month &nday)
{
        boost::io::ios_flags_saver iflags(is);
        typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
        if (strm_sentry)
        {
            try
            {
                typedef typename date_time::date_input_facet<date, CharT> date_input_facet_local;
                std::istreambuf_iterator<CharT, Traits> sit(is), str_end;
                if (std::has_facet<date_input_facet_local>(is.getloc()))
                {
                    std::use_facet<date_input_facet_local>(is.getloc()).get(sit, str_end, is, nday);
                }
                else
                {
                    date_input_facet_local *f = new date_input_facet_local();
                    std::locale l = std::locale(is.getloc(), f);
                    is.imbue(l);
                    f->get(sit, str_end, is, nday);
                }
            }
            catch (...)
            {
                std::ios_base::iostate exception_mask = is.exceptions();
                if (std::ios_base::failbit & exception_mask)
                {
                    try
                    {
                        is.setstate(std::ios_base::failbit);
                    }
                    catch (std::ios_base::failure &)
                    {
                    }
                    throw;
                }
                else
                {
                    is.setstate(std::ios_base::failbit);
                }
            }
        }
        return is;
}
template <class CharT, class TraitsT>
inline std::basic_ostream<CharT, TraitsT> &
operator<<(std::basic_ostream<CharT, TraitsT> &os, const boost::gregorian::first_day_of_the_week_in_month &fkd)
{
        boost::io::ios_flags_saver iflags(os);
        typedef boost::date_time::date_facet<date, CharT> custom_date_facet;
        std::ostreambuf_iterator<CharT> output_itr(os);
        if (std::has_facet<custom_date_facet>(os.getloc()))
            std::use_facet<custom_date_facet>(os.getloc()).put(output_itr, os, os.fill(), fkd);
        else
        {
            custom_date_facet *f = new custom_date_facet();
            std::locale l = std::locale(os.getloc(), f);
            os.imbue(l);
            f->put(output_itr, os, os.fill(), fkd);
        }
        return os;
}
template <class CharT, class Traits>
inline std::basic_istream<CharT, Traits> &
operator>>(std::basic_istream<CharT, Traits> &is,
           first_day_of_the_week_in_month &fkd)
{
        boost::io::ios_flags_saver iflags(is);
        typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
        if (strm_sentry)
        {
            try
            {
                typedef typename date_time::date_input_facet<date, CharT> date_input_facet_local;
                std::istreambuf_iterator<CharT, Traits> sit(is), str_end;
                if (std::has_facet<date_input_facet_local>(is.getloc()))
                {
                    std::use_facet<date_input_facet_local>(is.getloc()).get(sit, str_end, is, fkd);
                }
                else
                {
                    date_input_facet_local *f = new date_input_facet_local();
                    std::locale l = std::locale(is.getloc(), f);
                    is.imbue(l);
                    f->get(sit, str_end, is, fkd);
                }
            }
            catch (...)
            {
                std::ios_base::iostate exception_mask = is.exceptions();
                if (std::ios_base::failbit & exception_mask)
                {
                    try
                    {
                        is.setstate(std::ios_base::failbit);
                    }
                    catch (std::ios_base::failure &)
                    {
                    }
                    throw;
                }
                else
                {
                    is.setstate(std::ios_base::failbit);
                }
            }
        }
        return is;
}
template <class CharT, class TraitsT>
inline std::basic_ostream<CharT, TraitsT> &
operator<<(std::basic_ostream<CharT, TraitsT> &os, const boost::gregorian::last_day_of_the_week_in_month &lkd)
{
        boost::io::ios_flags_saver iflags(os);
        typedef boost::date_time::date_facet<date, CharT> custom_date_facet;
        std::ostreambuf_iterator<CharT> output_itr(os);
        if (std::has_facet<custom_date_facet>(os.getloc()))
            std::use_facet<custom_date_facet>(os.getloc()).put(output_itr, os, os.fill(), lkd);
        else
        {
            custom_date_facet *f = new custom_date_facet();
            std::locale l = std::locale(os.getloc(), f);
            os.imbue(l);
            f->put(output_itr, os, os.fill(), lkd);
        }
        return os;
}
template <class CharT, class Traits>
inline std::basic_istream<CharT, Traits> &
operator>>(std::basic_istream<CharT, Traits> &is,
           last_day_of_the_week_in_month &lkd)
{
        boost::io::ios_flags_saver iflags(is);
        typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
        if (strm_sentry)
        {
            try
            {
                typedef typename date_time::date_input_facet<date, CharT> date_input_facet_local;
                std::istreambuf_iterator<CharT, Traits> sit(is), str_end;
                if (std::has_facet<date_input_facet_local>(is.getloc()))
                {
                    std::use_facet<date_input_facet_local>(is.getloc()).get(sit, str_end, is, lkd);
                }
                else
                {
                    date_input_facet_local *f = new date_input_facet_local();
                    std::locale l = std::locale(is.getloc(), f);
                    is.imbue(l);
                    f->get(sit, str_end, is, lkd);
                }
            }
            catch (...)
            {
                std::ios_base::iostate exception_mask = is.exceptions();
                if (std::ios_base::failbit & exception_mask)
                {
                    try
                    {
                        is.setstate(std::ios_base::failbit);
                    }
                    catch (std::ios_base::failure &)
                    {
                    }
                    throw;
                }
                else
                {
                    is.setstate(std::ios_base::failbit);
                }
            }
        }
        return is;
}
template <class CharT, class TraitsT>
inline std::basic_ostream<CharT, TraitsT> &
operator<<(std::basic_ostream<CharT, TraitsT> &os, const boost::gregorian::first_day_of_the_week_after &fda)
{
        boost::io::ios_flags_saver iflags(os);
        typedef boost::date_time::date_facet<date, CharT> custom_date_facet;
        std::ostreambuf_iterator<CharT> output_itr(os);
        if (std::has_facet<custom_date_facet>(os.getloc()))
        {
            std::use_facet<custom_date_facet>(os.getloc()).put(output_itr, os, os.fill(), fda);
        }
        else
        {
            custom_date_facet *f = new custom_date_facet();
            std::locale l = std::locale(os.getloc(), f);
            os.imbue(l);
            f->put(output_itr, os, os.fill(), fda);
        }
        return os;
}
template <class CharT, class Traits>
inline std::basic_istream<CharT, Traits> &
operator>>(std::basic_istream<CharT, Traits> &is,
           first_day_of_the_week_after &fka)
{
        boost::io::ios_flags_saver iflags(is);
        typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
        if (strm_sentry)
        {
            try
            {
                typedef typename date_time::date_input_facet<date, CharT> date_input_facet_local;
                std::istreambuf_iterator<CharT, Traits> sit(is), str_end;
                if (std::has_facet<date_input_facet_local>(is.getloc()))
                {
                    std::use_facet<date_input_facet_local>(is.getloc()).get(sit, str_end, is, fka);
                }
                else
                {
                    date_input_facet_local *f = new date_input_facet_local();
                    std::locale l = std::locale(is.getloc(), f);
                    is.imbue(l);
                    f->get(sit, str_end, is, fka);
                }
            }
            catch (...)
            {
                std::ios_base::iostate exception_mask = is.exceptions();
                if (std::ios_base::failbit & exception_mask)
                {
                    try
                    {
                        is.setstate(std::ios_base::failbit);
                    }
                    catch (std::ios_base::failure &)
                    {
                    }
                    throw;
                }
                else
                {
                    is.setstate(std::ios_base::failbit);
                }
            }
        }
        return is;
}
template <class CharT, class TraitsT>
inline std::basic_ostream<CharT, TraitsT> &
operator<<(std::basic_ostream<CharT, TraitsT> &os, const boost::gregorian::first_day_of_the_week_before &fdb)
{
        boost::io::ios_flags_saver iflags(os);
        typedef boost::date_time::date_facet<date, CharT> custom_date_facet;
        std::ostreambuf_iterator<CharT> output_itr(os);
        if (std::has_facet<custom_date_facet>(os.getloc()))
        {
            std::use_facet<custom_date_facet>(os.getloc()).put(output_itr, os, os.fill(), fdb);
        }
        else
        {
            custom_date_facet *f = new custom_date_facet();
            std::locale l = std::locale(os.getloc(), f);
            os.imbue(l);
            f->put(output_itr, os, os.fill(), fdb);
        }
        return os;
}
template <class CharT, class Traits>
inline std::basic_istream<CharT, Traits> &
operator>>(std::basic_istream<CharT, Traits> &is,
           first_day_of_the_week_before &fkb)
{
        boost::io::ios_flags_saver iflags(is);
        typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
        if (strm_sentry)
        {
            try
            {
                typedef typename date_time::date_input_facet<date, CharT> date_input_facet_local;
                std::istreambuf_iterator<CharT, Traits> sit(is), str_end;
                if (std::has_facet<date_input_facet_local>(is.getloc()))
                {
                    std::use_facet<date_input_facet_local>(is.getloc()).get(sit, str_end, is, fkb);
                }
                else
                {
                    date_input_facet_local *f = new date_input_facet_local();
                    std::locale l = std::locale(is.getloc(), f);
                    is.imbue(l);
                    f->get(sit, str_end, is, fkb);
                }
            }
            catch (...)
            {
                std::ios_base::iostate exception_mask = is.exceptions();
                if (std::ios_base::failbit & exception_mask)
                {
                    try
                    {
                        is.setstate(std::ios_base::failbit);
                    }
                    catch (std::ios_base::failure &)
                    {
                    }
                    throw;
                }
                else
                {
                    is.setstate(std::ios_base::failbit);
                }
            }
        }
        return is;
}
    }
}
extern "C"
{
    void __assert_rtn(const char *, const char *, int, const char *);
}

namespace boost
{
    namespace iterators
    {
namespace detail
{
        template <bool GreaterEqual, bool LessEqual>
        struct minimum_category_impl;
        template <class T1, class T2>
        struct error_not_related_by_convertibility;
        template <>
        struct minimum_category_impl<true, false>
        {
            template <class T1, class T2>
            struct apply
            {
                typedef T2 type;
            };
        };
        template <>
        struct minimum_category_impl<false, true>
        {
            template <class T1, class T2>
            struct apply
            {
                typedef T1 type;
            };
        };
        template <>
        struct minimum_category_impl<true, true>
        {
            template <class T1, class T2>
            struct apply
            {
                typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(((is_same<T1, T2>::value)) != 0)>)> boost_static_assert_typedef_47;
                typedef T1 type;
            };
        };
        template <>
        struct minimum_category_impl<false, false>
        {
            template <class T1, class T2>
            struct apply
                : error_not_related_by_convertibility<T1, T2>
            {
            };
        };
}
template <class T1 = mpl::_1, class T2 = mpl::_2>
struct minimum_category
{
        typedef boost::iterators::detail::minimum_category_impl<
            ::boost::is_convertible<T1, T2>::value, ::boost::is_convertible<T2, T1>::value>
            outer;
        typedef typename outer::template apply<T1, T2> inner;
        typedef typename inner::type type;
};
template <>
struct minimum_category<mpl::_1, mpl::_2>
{
        template <class T1, class T2>
        struct apply : minimum_category<T1, T2>
        {
        };
};
    }
}
extern "C"
{
    void __assert_rtn(const char *, const char *, int, const char *);
}
namespace boost
{
    struct escaped_list_error : public std::runtime_error
    {
escaped_list_error(const std::string &what_arg) : std::runtime_error(what_arg) {}
    };
    template <class Char,
              class Traits = typename std::basic_string<Char>::traits_type>
    class escaped_list_separator
    {
private:
typedef std::basic_string<Char, Traits> string_type;
struct char_eq
{
        Char e_;
        char_eq(Char e) : e_(e) {}
        bool operator()(Char c)
        {
            return Traits::eq(e_, c);
        }
};
string_type escape_;
string_type c_;
string_type quote_;
bool last_;
bool is_escape(Char e)
{
        char_eq f(e);
        return std::find_if(escape_.begin(), escape_.end(), f) != escape_.end();
}
bool is_c(Char e)
{
        char_eq f(e);
        return std::find_if(c_.begin(), c_.end(), f) != c_.end();
}
bool is_quote(Char e)
{
        char_eq f(e);
        return std::find_if(quote_.begin(), quote_.end(), f) != quote_.end();
}
template <typename iterator, typename Token>
void do_escape(iterator &next, iterator end, Token &tok)
{
        if (++next == end)
            ::boost::throw_exception(escaped_list_error(std::string("cannot end with escape")), ::boost::source_location(__builtin_FILE(), __builtin_LINE(), __builtin_FUNCTION(), __builtin_COLUMN()));
        if (Traits::eq(*next, 'n'))
        {
            tok += '\n';
            return;
        }
        else if (is_quote(*next))
        {
            tok += *next;
            return;
        }
        else if (is_c(*next))
        {
            tok += *next;
            return;
        }
        else if (is_escape(*next))
        {
            tok += *next;
            return;
        }
        else
            ::boost::throw_exception(escaped_list_error(std::string("unknown escape sequence")), ::boost::source_location(__builtin_FILE(), __builtin_LINE(), __builtin_FUNCTION(), __builtin_COLUMN()));
}

public:
explicit escaped_list_separator(Char e = '\\',
                                Char c = ',', Char q = '\"')
    : escape_(1, e), c_(1, c), quote_(1, q), last_(false) {}
escaped_list_separator(string_type e, string_type c, string_type q)
    : escape_(e), c_(c), quote_(q), last_(false) {}
void reset() { last_ = false; }
template <typename InputIterator, typename Token>
bool operator()(InputIterator &next, InputIterator end, Token &tok)
{
        bool bInQuote = false;
        tok = Token();
        if (next == end)
        {
            if (last_)
            {
                last_ = false;
                return true;
            }
            else
                return false;
        }
        last_ = false;
        for (; next != end; ++next)
        {
            if (is_escape(*next))
            {
                do_escape(next, end, tok);
            }
            else if (is_c(*next))
            {
                if (!bInQuote)
                {
                    ++next;
                    last_ = true;
                    return true;
                }
                else
                    tok += *next;
            }
            else if (is_quote(*next))
            {
                bInQuote = !bInQuote;
            }
            else
            {
                tok += *next;
            }
        }
        return true;
}
    };
    namespace tokenizer_detail
    {
template <typename traits, int N>
struct traits_extension_details : public traits
{
        typedef typename traits::char_type char_type;
        static bool isspace(char_type c)
        {
            return std::iswspace(c) != 0;
        }
        static bool ispunct(char_type c)
        {
            return std::iswpunct(c) != 0;
        }
};
template <typename traits>
struct traits_extension_details<traits, 1> : public traits
{
        typedef typename traits::char_type char_type;
        static bool isspace(char_type c)
        {
            return std::isspace(c) != 0;
        }
        static bool ispunct(char_type c)
        {
            return std::ispunct(c) != 0;
        }
};
template <typename traits>
struct traits_extension : public traits
{
        typedef typename traits::char_type char_type;
        static bool isspace(char_type c)
        {
            return traits_extension_details<traits, sizeof(char_type)>::isspace(c);
        }
        static bool ispunct(char_type c)
        {
            return traits_extension_details<traits, sizeof(char_type)>::ispunct(c);
        }
};
template <class IteratorTag>
struct assign_or_plus_equal
{
        template <class Iterator, class Token>
        static void assign(Iterator b, Iterator e, Token &t)
        {
            t.assign(b, e);
        }
        template <class Token, class Value>
        static void plus_equal(Token &, const Value &) {}
        template <class Token>
        static void clear(Token &) {}
};
template <>
struct assign_or_plus_equal<std::input_iterator_tag>
{
        template <class Iterator, class Token>
        static void assign(Iterator, Iterator, Token &) {}
        template <class Token, class Value>
        static void plus_equal(Token &t, const Value &v)
        {
            t += v;
        }
        template <class Token>
        static void clear(Token &t)
        {
            t = Token();
        }
};
template <class Iterator>
struct pointer_iterator_category
{
        typedef std::random_access_iterator_tag type;
};
template <class Iterator>
struct class_iterator_category
{
        typedef typename Iterator::iterator_category type;
};
template <class Iterator>
struct get_iterator_category
{
        typedef typename conditional<is_pointer<Iterator>::value,
                                     pointer_iterator_category<Iterator>,
                                     class_iterator_category<Iterator>>::type cat;
        typedef typename cat::type iterator_category;
};
    }
    class offset_separator
    {
private:
std::vector<int> offsets_;
unsigned int current_offset_;
bool wrap_offsets_;
bool return_partial_last_;

public:
template <typename Iter>
offset_separator(Iter begin, Iter end, bool wrap_offsets = true,
                 bool return_partial_last = true)
    : offsets_(begin, end), current_offset_(0),
      wrap_offsets_(wrap_offsets),
      return_partial_last_(return_partial_last) {}
offset_separator()
    : offsets_(1, 1), current_offset_(),
      wrap_offsets_(true), return_partial_last_(true) {}
void reset()
{
        current_offset_ = 0;
}
template <typename InputIterator, typename Token>
bool operator()(InputIterator &next, InputIterator end, Token &tok)
{
        typedef tokenizer_detail::assign_or_plus_equal<
            typename tokenizer_detail::get_iterator_category<
                InputIterator>::iterator_category>
            assigner;
        (__builtin_expect(!(!offsets_.empty()), 0) ? __assert_rtn(__func__, "token_functions.hpp", 376, "!offsets_.empty()") : (void)0);
        assigner::clear(tok);
        InputIterator start(next);
        if (next == end)
            return false;
        if (current_offset_ == offsets_.size())
        {
            if (wrap_offsets_)
                current_offset_ = 0;
            else
                return false;
        }
        int c = offsets_[current_offset_];
        int i = 0;
        for (; i < c; ++i)
        {
            if (next == end)
                break;
            assigner::plus_equal(tok, *next++);
        }
        assigner::assign(start, next, tok);
        if (!return_partial_last_)
            if (i < (c - 1))
                return false;
        ++current_offset_;
        return true;
}
    };
    enum empty_token_policy
    {
        drop_empty_tokens,
        keep_empty_tokens
    };
    template <typename Char,
              typename Tr = typename std::basic_string<Char>::traits_type>
    class char_separator
    {
typedef tokenizer_detail::traits_extension<Tr> Traits;
typedef std::basic_string<Char, Tr> string_type;

public:
explicit char_separator(const Char *dropped_delims,
                        const Char *kept_delims = 0,
                        empty_token_policy empty_tokens = drop_empty_tokens)
    : m_dropped_delims(dropped_delims),
      m_use_ispunct(false),
      m_use_isspace(false),
      m_empty_tokens(empty_tokens),
      m_output_done(false)
{
        if (kept_delims)
            m_kept_delims = kept_delims;
}
explicit char_separator()
    : m_use_ispunct(true),
      m_use_isspace(true),
      m_empty_tokens(drop_empty_tokens),
      m_output_done(false) {}
void reset() {}
template <typename InputIterator, typename Token>
bool operator()(InputIterator &next, InputIterator end, Token &tok)
{
        typedef tokenizer_detail::assign_or_plus_equal<
            typename tokenizer_detail::get_iterator_category<
                InputIterator>::iterator_category>
            assigner;
        assigner::clear(tok);
        if (m_empty_tokens == drop_empty_tokens)
            for (; next != end && is_dropped(*next); ++next)
            {
            }
        InputIterator start(next);
        if (m_empty_tokens == drop_empty_tokens)
        {
            if (next == end)
                return false;
            if (is_kept(*next))
            {
                assigner::plus_equal(tok, *next);
                ++next;
            }
            else
                for (; next != end && !is_dropped(*next) && !is_kept(*next); ++next)
                    assigner::plus_equal(tok, *next);
        }
        else
        {
            if (next == end)
            {
                if (m_output_done == false)
                {
                    m_output_done = true;
                    assigner::assign(start, next, tok);
                    return true;
                }
                else
                    return false;
            }
            if (is_kept(*next))
            {
                if (m_output_done == false)
                    m_output_done = true;
                else
                {
                    assigner::plus_equal(tok, *next);
                    ++next;
                    m_output_done = false;
                }
            }
            else if (m_output_done == false && is_dropped(*next))
            {
                m_output_done = true;
            }
            else
            {
                if (is_dropped(*next))
                    start = ++next;
                for (; next != end && !is_dropped(*next) && !is_kept(*next); ++next)
                    assigner::plus_equal(tok, *next);
                m_output_done = true;
            }
        }
        assigner::assign(start, next, tok);
        return true;
}

private:
string_type m_kept_delims;
string_type m_dropped_delims;
bool m_use_ispunct;
bool m_use_isspace;
empty_token_policy m_empty_tokens;
bool m_output_done;
bool is_kept(Char E) const
{
        if (m_kept_delims.length())
            return m_kept_delims.find(E) != string_type::npos;
        else if (m_use_ispunct)
        {
            return Traits::ispunct(E) != 0;
        }
        else
            return false;
}
bool is_dropped(Char E) const
{
        if (m_dropped_delims.length())
            return m_dropped_delims.find(E) != string_type::npos;
        else if (m_use_isspace)
        {
            return Traits::isspace(E) != 0;
        }
        else
            return false;
}
    };
    template <class Char,
              class Tr = typename std::basic_string<Char>::traits_type>
    class char_delimiters_separator
    {
private:
typedef tokenizer_detail::traits_extension<Tr> Traits;
typedef std::basic_string<Char, Tr> string_type;
string_type returnable_;
string_type nonreturnable_;
bool return_delims_;
bool no_ispunct_;
bool no_isspace_;
bool is_ret(Char E) const
{
        if (returnable_.length())
            return returnable_.find(E) != string_type::npos;
        else
        {
            if (no_ispunct_)
            {
                return false;
            }
            else
            {
                int r = Traits::ispunct(E);
                return r != 0;
            }
        }
}
bool is_nonret(Char E) const
{
        if (nonreturnable_.length())
            return nonreturnable_.find(E) != string_type::npos;
        else
        {
            if (no_isspace_)
            {
                return false;
            }
            else
            {
                int r = Traits::isspace(E);
                return r != 0;
            }
        }
}

public:
explicit char_delimiters_separator(bool return_delims = false,
                                   const Char *returnable = 0,
                                   const Char *nonreturnable = 0)
    : returnable_(returnable ? returnable : string_type().c_str()),
      nonreturnable_(nonreturnable ? nonreturnable : string_type().c_str()),
      return_delims_(return_delims), no_ispunct_(returnable != 0),
      no_isspace_(nonreturnable != 0) {}
void reset() {}

public:
template <typename InputIterator, typename Token>
bool operator()(InputIterator &next, InputIterator end, Token &tok)
{
        tok = Token();
        for (; next != end && (is_nonret(*next) || (is_ret(*next) && !return_delims_)); ++next)
        {
        }
        if (next == end)
        {
            return false;
        }
        if (is_ret(*next) && return_delims_)
        {
            tok += *next;
            ++next;
        }
        else
            for (; next != end && !is_nonret(*next) && !is_ret(*next); ++next)
                tok += *next;
        return true;
}
    };
}
namespace boost
{
    template <class TokenizerFunc, class Iterator, class Type>
    class token_iterator
        : public iterator_facade<
              token_iterator<TokenizerFunc, Iterator, Type>, Type, typename iterators::minimum_category<forward_traversal_tag, typename iterator_traversal<Iterator>::type>::type, const Type &>
    {
friend class iterator_core_access;
TokenizerFunc f_;
Iterator begin_;
Iterator end_;
bool valid_;
Type tok_;
void increment()
{
        (__builtin_expect(!(valid_), 0) ? __assert_rtn(__func__, "token_iterator.hpp", 54, "valid_") : (void)0);
        valid_ = f_(begin_, end_, tok_);
}
const Type &dereference() const
{
        (__builtin_expect(!(valid_), 0) ? __assert_rtn(__func__, "token_iterator.hpp", 59, "valid_") : (void)0);
        return tok_;
}
template <class Other>
bool equal(const Other &a) const
{
        return (a.valid_ && valid_)
                   ? ((a.begin_ == begin_) && (a.end_ == end_))
                   : (a.valid_ == valid_);
}
void initialize()
{
        if (valid_)
            return;
        f_.reset();
        valid_ = (begin_ != end_) ? f_(begin_, end_, tok_) : false;
}

public:
token_iterator() : begin_(), end_(), valid_(false), tok_() {}
token_iterator(TokenizerFunc f, Iterator begin, Iterator e = Iterator())
    : f_(f), begin_(begin), end_(e), valid_(false), tok_() { initialize(); }
token_iterator(Iterator begin, Iterator e = Iterator())
    : f_(), begin_(begin), end_(e), valid_(false), tok_() { initialize(); }
template <class OtherIter>
token_iterator(
    token_iterator<TokenizerFunc, OtherIter, Type> const &t, typename enable_if_convertible<OtherIter, Iterator>::type * = 0)
    : f_(t.tokenizer_function()), begin_(t.base()), end_(t.end()), valid_(!t.at_end()), tok_(t.current_token()) {}
Iterator base() const { return begin_; }
Iterator end() const { return end_; }
TokenizerFunc tokenizer_function() const { return f_; }
Type current_token() const { return tok_; }
bool at_end() const { return !valid_; }
    };
    template <
        class TokenizerFunc = char_delimiters_separator<char>,
        class Iterator = std::string::const_iterator,
        class Type = std::string>
    class token_iterator_generator
    {
private:
public:
typedef token_iterator<TokenizerFunc, Iterator, Type> type;
    };
    template <class Type, class Iterator, class TokenizerFunc>
    typename token_iterator_generator<TokenizerFunc, Iterator, Type>::type
    make_token_iterator(Iterator begin, Iterator end, const TokenizerFunc &fun)
    {
typedef typename token_iterator_generator<TokenizerFunc, Iterator, Type>::type ret_type;
return ret_type(fun, begin, end);
    }
}

namespace boost
{
    template <
        typename TokenizerFunc = char_delimiters_separator<char>,
        typename Iterator = std::string::const_iterator,
        typename Type = std::string>
    class tokenizer
    {
private:
typedef token_iterator_generator<TokenizerFunc, Iterator, Type> TGen;
typedef typename TGen::type iter;

public:
typedef iter iterator;
typedef iter const_iterator;
typedef Type value_type;
typedef value_type &reference;
typedef const value_type &const_reference;
typedef value_type *pointer;
typedef const pointer const_pointer;
typedef void size_type;
typedef void difference_type;
tokenizer(Iterator first, Iterator last,
          const TokenizerFunc &f = TokenizerFunc())
    : first_(first), last_(last), f_(f) {}
template <typename Container>
tokenizer(const Container &c)
    : first_(c.begin()), last_(c.end()), f_() {}
template <typename Container>
tokenizer(const Container &c, const TokenizerFunc &f)
    : first_(c.begin()), last_(c.end()), f_(f) {}
void assign(Iterator first, Iterator last)
{
        first_ = first;
        last_ = last;
}
void assign(Iterator first, Iterator last, const TokenizerFunc &f)
{
        assign(first, last);
        f_ = f;
}
template <typename Container>
void assign(const Container &c)
{
        assign(c.begin(), c.end());
}
template <typename Container>
void assign(const Container &c, const TokenizerFunc &f)
{
        assign(c.begin(), c.end(), f);
}
iter begin() const { return iter(f_, first_, last_); }
iter end() const { return iter(f_, last_, last_); }

private:
Iterator first_;
Iterator last_;
TokenizerFunc f_;
    };
}
namespace boost
{
    namespace date_time
    {
inline std::string
convert_to_lower(std::string inp)
{
        const std::locale loc(std::locale::classic());
        std::string::size_type i = 0, n = inp.length();
        for (; i < n; ++i)
        {
            inp[i] =
                std::tolower(inp[i], loc);
        }
        return inp;
}
template <class month_type>
inline unsigned short
month_str_to_ushort(std::string const &s)
{
        if ((s.at(0) >= '0') && (s.at(0) <= '9'))
        {
            return boost::lexical_cast<unsigned short>(s);
        }
        else
        {
            std::string str = convert_to_lower(s);
            static std::map<std::string, unsigned short> month_map;
            typedef std::map<std::string, unsigned short>::value_type vtype;
            if (month_map.empty())
            {
                month_map.insert(vtype("jan", static_cast<unsigned short>(1)));
                month_map.insert(vtype("january", static_cast<unsigned short>(1)));
                month_map.insert(vtype("feb", static_cast<unsigned short>(2)));
                month_map.insert(vtype("february", static_cast<unsigned short>(2)));
                month_map.insert(vtype("mar", static_cast<unsigned short>(3)));
                month_map.insert(vtype("march", static_cast<unsigned short>(3)));
                month_map.insert(vtype("apr", static_cast<unsigned short>(4)));
                month_map.insert(vtype("april", static_cast<unsigned short>(4)));
                month_map.insert(vtype("may", static_cast<unsigned short>(5)));
                month_map.insert(vtype("jun", static_cast<unsigned short>(6)));
                month_map.insert(vtype("june", static_cast<unsigned short>(6)));
                month_map.insert(vtype("jul", static_cast<unsigned short>(7)));
                month_map.insert(vtype("july", static_cast<unsigned short>(7)));
                month_map.insert(vtype("aug", static_cast<unsigned short>(8)));
                month_map.insert(vtype("august", static_cast<unsigned short>(8)));
                month_map.insert(vtype("sep", static_cast<unsigned short>(9)));
                month_map.insert(vtype("september", static_cast<unsigned short>(9)));
                month_map.insert(vtype("oct", static_cast<unsigned short>(10)));
                month_map.insert(vtype("october", static_cast<unsigned short>(10)));
                month_map.insert(vtype("nov", static_cast<unsigned short>(11)));
                month_map.insert(vtype("november", static_cast<unsigned short>(11)));
                month_map.insert(vtype("dec", static_cast<unsigned short>(12)));
                month_map.insert(vtype("december", static_cast<unsigned short>(12)));
            }
            std::map<std::string, unsigned short>::const_iterator mitr = month_map.find(str);
            if (mitr != month_map.end())
            {
                return mitr->second;
            }
        }
        return 13;
}
template <class date_type>
date_type
parse_date(const std::string &s, int order_spec = ymd_order_iso)
{
        std::string spec_str;
        if (order_spec == ymd_order_iso)
        {
            spec_str = "ymd";
        }
        else if (order_spec == ymd_order_dmy)
        {
            spec_str = "dmy";
        }
        else
        {
            spec_str = "mdy";
        }
        typedef typename date_type::month_type month_type;
        unsigned pos = 0;
        unsigned short year(0), month(0), day(0);
        typedef typename std::basic_string<char>::traits_type traits_type;
        typedef boost::char_separator<char, traits_type> char_separator_type;
        typedef boost::tokenizer<char_separator_type,
                                 std::basic_string<char>::const_iterator,
                                 std::basic_string<char>>
            tokenizer;
        typedef boost::tokenizer<char_separator_type,
                                 std::basic_string<char>::const_iterator,
                                 std::basic_string<char>>::iterator tokenizer_iterator;
        const char sep_char[] = {',', '-', '.', ' ', '/', '\0'};
        char_separator_type sep(sep_char);
        tokenizer tok(s, sep);
        for (tokenizer_iterator beg = tok.begin();
             beg != tok.end() && pos < spec_str.size();
             ++beg, ++pos)
        {
            switch (spec_str.at(pos))
            {
            case 'y':
            {
                year = boost::lexical_cast<unsigned short>(*beg);
                break;
            }
            case 'm':
            {
                month = month_str_to_ushort<month_type>(*beg);
                break;
            }
            case 'd':
            {
                day = boost::lexical_cast<unsigned short>(*beg);
                break;
            }
            default:
                break;
            }
        }
        return date_type(year, month, day);
}
template <class date_type>
date_type
parse_undelimited_date(const std::string &s)
{
        int offsets[] = {4, 2, 2};
        int pos = 0;
        unsigned short y = 0, m = 0, d = 0;
        boost::offset_separator osf(offsets, offsets + 3, false, false);
        typedef typename boost::tokenizer<boost::offset_separator,
                                          std::basic_string<char>::const_iterator,
                                          std::basic_string<char>>
            tokenizer_type;
        tokenizer_type tok(s, osf);
        for (typename tokenizer_type::iterator ti = tok.begin(); ti != tok.end(); ++ti)
        {
            unsigned short i = boost::lexical_cast<unsigned short>(*ti);
            switch (pos)
            {
            case 0:
                y = i;
                break;
            case 1:
                m = i;
                break;
            case 2:
                d = i;
                break;
            default:
                break;
            }
            pos++;
        }
        return date_type(y, m, d);
}
template <class date_type, class iterator_type>
inline date_type
from_stream_type(iterator_type &beg,
                 iterator_type const &end,
                 char)
{
        std::ostringstream ss;
        while (beg != end)
        {
            ss << *beg++;
        }
        return parse_date<date_type>(ss.str());
}
template <class date_type, class iterator_type>
inline date_type
from_stream_type(iterator_type &beg,
                 iterator_type const &,
                 std::string const &)
{
        return parse_date<date_type>(*beg);
}
template <class date_type, class iterator_type>
inline date_type from_stream_type(iterator_type &beg,
                                  iterator_type const &end,
                                  wchar_t)
{
        std::ostringstream ss;
        std::locale loc;
        std::ctype<wchar_t> const &fac = std::use_facet<std::ctype<wchar_t>>(loc);
        while (beg != end)
        {
            ss << fac.narrow(*beg++, 'X');
        }
        return parse_date<date_type>(ss.str());
}
template <class date_type, class iterator_type>
inline date_type
from_stream_type(iterator_type &beg,
                 iterator_type const &,
                 std::wstring const &)
{
        std::wstring ws = *beg;
        std::ostringstream ss;
        std::wstring::iterator wsb = ws.begin(), wse = ws.end();
        std::locale loc;
        std::ctype<wchar_t> const &fac = std::use_facet<std::ctype<wchar_t>>(loc);
        while (wsb != wse)
        {
            ss << fac.narrow(*wsb++, 'X');
        }
        return parse_date<date_type>(ss.str());
}
template <class date_type, class charT>
period<date_type, typename date_type::duration_type>
from_simple_string_type(const std::basic_string<charT> &s)
{
        typedef typename std::basic_string<charT>::traits_type traits_type;
        typedef typename boost::char_separator<charT, traits_type> char_separator;
        typedef typename boost::tokenizer<char_separator,
                                          typename std::basic_string<charT>::const_iterator,
                                          std::basic_string<charT>>
            tokenizer;
        const charT sep_list[4] = {'[', '/', ']', '\0'};
        char_separator sep(sep_list);
        tokenizer tokens(s, sep);
        typename tokenizer::iterator tok_it = tokens.begin();
        std::basic_string<charT> date_string = *tok_it;
        typename std::basic_string<charT>::iterator date_string_start = date_string.begin(),
                                                    date_string_end = date_string.end();
        typedef typename std::iterator_traits<typename std::basic_string<charT>::iterator>::value_type value_type;
        date_type d1 = from_stream_type<date_type>(date_string_start, date_string_end, value_type());
        date_string = *(++tok_it);
        date_string_start = date_string.begin(), date_string_end = date_string.end();
        date_type d2 = from_stream_type<date_type>(date_string_start, date_string_end, value_type());
        return period<date_type, typename date_type::duration_type>(d1, d2);
}
    }
}
namespace boost
{
    namespace date_time
    {
template <class charT>
short find_match(const charT *const *short_names,
                 const charT *const *long_names,
                 short size,
                 const std::basic_string<charT> &s)
{
        for (short i = 0; i < size; ++i)
        {
            if (short_names[i] == s || long_names[i] == s)
            {
                return i;
            }
        }
        return size;
}
    }
}
namespace boost
{
    namespace gregorian
    {
inline date_time::special_values
special_value_from_string(const std::string &s)
{
        static const char *const special_value_names[date_time::NumSpecialValues] = {"not-a-date-time", "-infinity", "+infinity", "min_date_time",
                                                                                     "max_date_time", "not_special"};
        short i = date_time::find_match(special_value_names,
                                        special_value_names,
                                        date_time::NumSpecialValues,
                                        s);
        if (i >= date_time::NumSpecialValues)
        {
            return date_time::not_special;
        }
        else
        {
            return static_cast<date_time::special_values>(i);
        }
}
inline date from_string(const std::string &s)
{
        return date_time::parse_date<date>(s);
}
inline date from_simple_string(const std::string &s)
{
        return date_time::parse_date<date>(s, date_time::ymd_order_iso);
}
inline date from_us_string(const std::string &s)
{
        return date_time::parse_date<date>(s, date_time::ymd_order_us);
}
inline date from_uk_string(const std::string &s)
{
        return date_time::parse_date<date>(s, date_time::ymd_order_dmy);
}
inline date from_undelimited_string(const std::string &s)
{
        return date_time::parse_undelimited_date<date>(s);
}
inline date date_from_iso_string(const std::string &s)
{
        return date_time::parse_undelimited_date<date>(s);
}
template <class iterator_type>
inline date from_stream(iterator_type beg, iterator_type end)
{
        if (beg == end)
        {
            return date(not_a_date_time);
        }
        typedef typename std::iterator_traits<iterator_type>::value_type value_type;
        return date_time::from_stream_type<date>(beg, end, value_type());
}
inline date_period date_period_from_string(const std::string &s)
{
        return date_time::from_simple_string_type<date, char>(s);
}
inline date_period date_period_from_wstring(const std::wstring &s)
{
        return date_time::from_simple_string_type<date, wchar_t>(s);
}
    }
}
extern "C"
{
    void __assert_rtn(const char *, const char *, int, const char *);
}
using namespace boost::gregorian;
using std::cout;
using std::endl;
int main()
{
    {
date d1;
date d2(2010, 1, 1);
date d3(2000, Jan, 1);
date d4(d2);
(__builtin_expect(!(d1 == date(not_a_date_time)), 0) ? __assert_rtn(__func__, "date_time.cpp", 22, "d1 == date(not_a_date_time)") : (void)0);
(__builtin_expect(!(d2 == d4), 0) ? __assert_rtn(__func__, "date_time.cpp", 23, "d2 == d4") : (void)0);
(__builtin_expect(!(d3 < d2), 0) ? __assert_rtn(__func__, "date_time.cpp", 24, "d3 < d2") : (void)0);
    }
    {
date d1 = from_string("1999-12-31");
date d2(from_string("2015/1/1"));
date d3 = from_undelimited_string("20111118");
    }
    return 0;
}
